<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-01T04:59:02.304Z" title="2024/1/1 12:59:02">2024-01-01</time>发表</span><span class="level-item"><time dateTime="2024-01-01T05:08:27.983Z" title="2024/1/1 13:08:27">2024-01-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="level-item">2 分钟读完 (大约262个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/01/UNICODE%20%E5%8F%8C%E5%90%91%E7%AE%97%E6%B3%95/">UNICODE 双向算法</a></p><div class="content"><p>前段时间看到群友聊天，使用特殊的昵称能够让文字的顺序发生变化。我把昵称复制到 IDEA 里面，发现包含一个显示为 RLI 的字符。在网上查询之后，发现是 Unicode 为显示双向文本提供的一个特殊字符，功能是将之后的文本视为独立的从右到左的顺序。还有其他特殊的格式化字符，以及用于解析这些字符并正确显示文本顺序的 Unicode 双向算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;⁧;(&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的文本在浏览器中会显示为 <code>print(&quot;&quot;);</code>，因为在第一个引号之后有一个 RLI 字符。如果在之后添加文字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;⁧;(&quot;</span>Hello World!</span><br></pre></td></tr></table></figure>
<p>则会显示为 <code>print(&quot;!Hello World&quot;);</code>，具体的显示方式和双向算法的实现有关。介绍 Unicode 双向算法的两个网站：<a target="_blank" rel="noopener" href="https://unicode.org/reports/tr9/">UNICODE BIDIRECTIONAL ALGORITHM</a>，<a target="_blank" rel="noopener" href="https://www.w3.org/International/articles/inline-bidi-markup/uba-basics">Unicode Bidirectional Algorithm basics</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-31T16:00:00.000Z" title="2024/1/1 00:00:00">2024-01-01</time>发表</span><span class="level-item"><time dateTime="2025-06-09T14:33:09.688Z" title="2025/6/9 22:33:09">2025-06-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Go/">Go</a></span><span class="level-item">1 小时读完 (大约13350个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/01/Go%20%E5%9F%BA%E7%A1%80/">Go 基础</a></p><div class="content"><p>参考<a target="_blank" rel="noopener" href="https://go.dev/">官方网站</a>，<a target="_blank" rel="noopener" href="https://www.gopl.io/">GOPL</a>，<a target="_blank" rel="noopener" href="https://pkg.go.dev/std">STD</a>，<a target="_blank" rel="noopener" href="https://github.com/golang/go">源代码</a>，<a target="_blank" rel="noopener" href="https://draven.co/golang/">Go 语言设计与实现</a>。</p>
<h2 id="Tutorial">Tutorial</h2>
<h3 id="Hello-World">Hello, World</h3>
<p>使用 <code>go run</code> 编译运行程序，<code>go build</code> 编译程序，<code>go doc</code> 查看文档。</p>
<p>某些标记之后的换行符会被转换为分号，因此换行符的位置对于正确解析 Go 代码至关重要。例如，函数的左括号 <code>&#123;</code> 必须与函数声明的结尾在同一行，否则会报错 <code>unexpected semicolon or newline before &#123;</code>。而在表达式 <code>x + y</code> 中，可以在 <code>+</code> 运算符之后换行，但不能在之前换行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Command-Line-Arguments">Command-Line Arguments</h3>
<p>可以使用 <code>os.Args</code> 变量获取命令行参数，该变量是一个字符串切片。<code>os.Args[0]</code> 是命令本身，剩余元素是程序启动时用户传递的参数。使用 <code>var</code> 声明语句定义变量，变量可以在声明时进行初始化。如果未显式初始化，则隐式初始化为该类型的零值（zero value），数值类型为 <code>0</code>，字符串类型为空串 <code>&quot;&quot;</code>。</p>
<p><code>for</code> 语句是 Go 中唯一的循环语句，可以充当其他语言中常规的 <code>for</code>、<code>while</code> 循环以及无限循环。Go 语言不允许未使用的局部变量，否则会报错 <code>declared and not used</code>。使用 <code>+=</code> 在循环中拼接字符串的开销较大，每次都会生成新字符串，而旧字符串则不再使用等待 GC，可以使用 <code>strings.Join</code> 方法提升性能，一次性拼接所有字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下几种声明变量的方式都是等价的。第一种简洁但只能在函数中使用，而不能用于包级变量，第二种使用默认初始化，第三种形式仅在声明多个变量时使用，第四种仅在声明类型和初始值类型不同时使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;&quot;</span><br><span class="line">var s string</span><br><span class="line">var s = &quot;&quot;</span><br><span class="line">var s string = &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Finding-Duplicate-Lines">Finding Duplicate Lines</h3>
<p><code>input.Scan()</code> 读取下一行数据并移除行尾的换行符，可以调用 <code>input.Text()</code> 方法获取结果。<code>map</code> 的迭代顺序未明确指定，但在实际操作中是随机的，这种设计是有意为之，防止程序依赖特定的顺序。<code>map</code> 是一个由 <code>make</code> 创建的数据结构的引用（reference），当将 <code>map</code> 作为参数传递时，函数会收到引用的副本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	files := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">		countLines(os.Stdin, counts)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">			f, err := os.Open(arg)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">&quot;dup2: %v\n&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			countLines(f, counts)</span><br><span class="line">			f.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	input := bufio.NewScanner(f)</span><br><span class="line">	<span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">		counts[input.Text()]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Animated-GIFs">Animated GIFs</h3>
<p><code>const</code> 常量的值必须是数字、字符串或者布尔值。以下程序使用 <code>web</code> 方式可以正常显示图像，但是如果使用 <code>./main &gt; out.gif</code> 重定向输出的方式，则在 Windows 中不能正常显示。因为 Windows 标准输出默认以文本模式处理数据，会修改输出的数据从而导致图像损坏。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	whiteIndex = <span class="number">0</span> <span class="comment">// first color in palette</span></span><br><span class="line">	blackIndex = <span class="number">1</span> <span class="comment">// next color in palette</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//!-main</span></span><br><span class="line">	<span class="comment">// The sequence of images is deterministic unless we seed</span></span><br><span class="line">	<span class="comment">// the pseudo-random number generator using the current time.</span></span><br><span class="line">	<span class="comment">// Thanks to Randall McPherson for pointing out the omission.</span></span><br><span class="line">	rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">		<span class="comment">//!+http</span></span><br><span class="line">		handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			lissajous(w)</span><br><span class="line">		&#125;</span><br><span class="line">		http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">		<span class="comment">//!-http</span></span><br><span class="line">		log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//!+main</span></span><br><span class="line">	lissajous(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		cycles  = <span class="number">5</span>     <span class="comment">// number of complete x oscillator revolutions</span></span><br><span class="line">		res     = <span class="number">0.001</span> <span class="comment">// angular resolution</span></span><br><span class="line">		size    = <span class="number">100</span>   <span class="comment">// image canvas covers [-size..+size]</span></span><br><span class="line">		nframes = <span class="number">64</span>    <span class="comment">// number of animation frames</span></span><br><span class="line">		delay   = <span class="number">8</span>     <span class="comment">// delay between frames in 10ms units</span></span><br><span class="line">	)</span><br><span class="line">	freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// relative frequency of y oscillator</span></span><br><span class="line">	anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">	phase := <span class="number">0.0</span> <span class="comment">// phase difference</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">		rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">		img := image.NewPaletted(rect, palette)</span><br><span class="line">		<span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">			x := math.Sin(t)</span><br><span class="line">			y := math.Sin(t*freq + phase)</span><br><span class="line">			img.SetColorIndex(size+<span class="type">int</span>(x*size+<span class="number">0.5</span>), size+<span class="type">int</span>(y*size+<span class="number">0.5</span>),</span><br><span class="line">				blackIndex)</span><br><span class="line">		&#125;</span><br><span class="line">		phase += <span class="number">0.1</span></span><br><span class="line">		anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">		anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">	&#125;</span><br><span class="line">	gif.EncodeAll(out, &amp;anim) <span class="comment">// <span class="doctag">NOTE:</span> ignoring encoding errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fet-ching-URLs-Concurrently">Fet ching URLs Concurrently</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">go</span> fetch(url, ch) <span class="comment">// start a goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		fmt.Println(&lt;-ch) <span class="comment">// receive from channel ch</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprint(err) <span class="comment">// send to channel ch</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nbytes, err := io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">	resp.Body.Close() <span class="comment">// don&#x27;t leak resources</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprintf(<span class="string">&quot;while reading %s: %v&quot;</span>, url, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	secs := time.Since(start).Seconds()</span><br><span class="line">	ch &lt;- fmt.Sprintf(<span class="string">&quot;%.2fs  %7d  %s&quot;</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="A-Web-Server">A Web Server</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+handler</span></span><br><span class="line"><span class="comment">// handler echoes the HTTP request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Host = %q\n&quot;</span>, r.Host)</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)</span><br><span class="line">	<span class="keyword">if</span> err := r.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Form[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Loose-Ends">Loose Ends</h3>
<p><code>switch</code> 语句的 <code>case</code> 不需要显式使用 <code>break</code>，默认不会 <code>fallthrough</code> 到下一个 <code>case</code>。可以省略 <code>switch</code> 之后的操作数，此时等价于 <code>switch true</code>。和 <code>for</code> 和 <code>if</code> 一样，在 <code>switch</code> 之后可以跟一个简单语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Signum</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> x &lt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Program-Structure">Program Structure</h2>
<h3 id="Names">Names</h3>
<p>名称以字母（Unicode 字母）或下划线开头，可以包含任意数量的字母、数字和下划线，大小写敏感。关键字（keywords）不可作为名称被使用，而预声明（predeclared）的名称（内置常量、类型和函数）可以重新声明，但是存在混淆的风险。在函数内声明的实体仅在函数内可见，在函数外声明的实体包可见，名称的首字母大写则在包外可见。包名总是小写的，实体命名使用驼峰命名法。</p>
<h3 id="Declarations">Declarations</h3>
<p>声明（declaration）命名一个程序实体，有四种主要的声明类型，<code>var</code>、<code>const</code>、<code>type</code> 和 <code>func</code>。Go 程序存储在以 <code>.go</code> 为后缀的文件中，每个文件开头都有包声明，之后是导入声明，然后是以任意顺序排列的包级（package-level）的类型、变量、常量和函数声明。函数的返回值列表是可选的（多个返回值构成列表），如果不返回任何值则可以省略。</p>
<h3 id="Variables">Variables</h3>
<p>变量声明的通用形式为 <code>var name type = expression</code>。如果省略 <code>type</code> 则类型由表达式推断，如果省略 <code>= expression</code> 则必须显式指定类型，初始值为该类型的零值。数值类型为 <code>0</code>，字符串类型为空串 <code>&quot;&quot;</code>，布尔类型为 <code>false</code>，接口和引用类型（切片、指针、哈希表、通道和函数）为 <code>nil</code>。像数组或者结构体聚合类型的元素或字段的零值就是自身的零值。</p>
<p>零值机制确保变量始终有其类型所定义的明确值，Go 语言中不存在未初始化变量的概念。可以同时声明一组变量，如果省略类型则可以同时声明不同类型的变量。包级变量会在 <code>main</code> 函数开始之前初始化，局部变量在声明时初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span> <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span> <span class="comment">// bool, float64, string</span></span><br><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open returns a file and an error</span></span><br></pre></td></tr></table></figure>
<h4 id="Short-Variable-Declarations">Short Variable Declarations</h4>
<p>在函数中可以使用简短变量声明（short variable declaration）的形式声明和初始化局部变量，形式为 <code>name := expression</code>。简短变量声明常用于声明和初始化大多数局部变量，而 <code>var</code> 声明常用于变量类型和表达式类型不同、或者稍后赋值且初始值不重要的局部变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">100</span> <span class="comment">// an int</span></span><br><span class="line"><span class="keyword">var</span> boiling <span class="type">float64</span> = <span class="number">100</span> <span class="comment">// a float64</span></span><br><span class="line">i, j = j, i <span class="comment">// swap values of i and j</span></span><br></pre></td></tr></table></figure>
<p>区分 <code>:=</code> 是声明而 <code>=</code> 是赋值。需要注意，如果简短变量声明中的变量已经在相同词法块（lexical block）中被声明过，那么该声明相当于对该变量赋值。而且简短变量声明必须至少声明一个新变量，否则代码将无法通过编译。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure>
<h4 id="Pointers">Pointers</h4>
<p>指针（pointer）是变量的地址（address），可以通过指针间接地读写变量的值，而无需知晓变量的名称。指针的零值是 <code>nil</code>，如果指针指向某个变量则其值必然不为 <code>nil</code>。两个指针相等仅当它们指向相同的变量或者都为 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数返回局部变量的地址是安全的，即使函数调用返回该局部变量 <code>v</code> 仍会存在。由编译器逃逸分析确定，该变量会在堆上分配。根据静态分析知识，为保证安全性，分析肯定是偏向误报（Sound）而不是漏报（Complete）。每次调用函数 <code>f</code> 返回的值都不同。每次获取变量的地址或者复制指针时，都会为该变量创建新的别名（aliases），<code>*p</code> 是 <code>v</code> 的别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    v := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Print(strings.Join(flag.Args(), *sep))</span><br><span class="line">	<span class="keyword">if</span> !*n &#123;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="The-new-Function">The new Function</h4>
<p>另一种创建变量的方式是使用内置函数 <code>new</code>，表达式 <code>new(T)</code> 创建类型为 <code>T</code> 的未命名变量，将其初始化为类型 <code>T</code> 的零值，返回类型为 <code>*T</code> 的地址值。使用 <code>new</code> 创建的变量和普通局部变量没有区别，只是后者需要显式获取地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dummy <span class="type">int</span></span><br><span class="line">	<span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常每次调用 <code>new</code> 都会返回具有唯一地址的不同变量，例外情况是，如果两个变量的类型不携带任何信息且大小为零（例如 <code>struct&#123;&#125;</code> 或 <code>[0]int</code>），则根据实现的不同可能会具有相同的地址（实测得到的是不同地址）。由于 <code>new</code> 是内置函数而不是关键字，所以可以被重新定义为其他东西，不过此时不能在 <code>delta</code> 中使用内置的 <code>new</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">new</span> - old &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lifetime-of-Variables">Lifetime of Variables</h4>
<p>变量的声明周期是指其在程序执行过程中的存活时间。包级变量在整个程序执行过程中存活，局部变量在声明时创建，在不被引用时回收（GC 可达性分析）。因为变量的生命周期取决于可达性，所以局部变量在函数返回之后仍有可能存活。编译器会决定将变量分配到堆中还是栈中，这一决定并非取决于使用 <code>var</code> 还是 <code>new</code> 来声明变量（Pointers 小节中提到过的逃逸分析）。例如，下面示例中 <code>x</code> 必须在堆上分配，而 <code>y</code> 可以在栈上分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	x = <span class="number">1</span></span><br><span class="line">	global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">	y := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">	*y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Assignments">Assignments</h3>
<p>Go 语言中仅有后置 <code>x++</code> 和 <code>x--</code> 而没有前置写法，而且该操作被视为语句而不是表达式，所以不能将其赋值给变量或者参与运算。</p>
<h4 id="Tuple-Assignment">Tuple Assignment</h4>
<p>元组赋值（tuple assignment）允许一次为多个变量赋值，在对任何变量更新之前，所有右侧表达式都会被计算出来。如果函数具有多个返回值，则赋值语句左侧必须包含相同数量的变量，可以使用 <code>_</code> 忽略不需要的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line">_, err = io.Copy(dst, src) <span class="comment">// discard byte count</span></span><br></pre></td></tr></table></figure>
<h4 id="Assignability">Assignability</h4>
<p>当值能够赋值给变量的类型时，该赋值操作才是合法的，不同类型有不同的赋值规则。只有当两个变量可以相互赋值时，它们才能够使用 <code>==</code> 和 <code>!=</code> 进行比较。（Java 中引用类型之间总是可以使用该运算符相互比较）</p>
<h3 id="Type-Declarations">Type Declarations</h3>
<p>类型声明形如 <code>type name underlying-type</code>，用于定义一个新的具有某个底层类型（underlying type）的命名类型（named type）。即使两个类型具有相同的底层类型，它们也是不同的类型，不能直接比较或组合，而需要使用 <code>T(x)</code> 进行显式类型转换。命名类型将底层类型的不同使用方式区分开来，避免不同使用方式之间混淆。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">	FreezingC     Celsius = <span class="number">0</span></span><br><span class="line">	BoilingC      Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Packages-and-Files">Packages and Files</h3>
<p>在 Go 语言中，包的作用与其他语言中的库或模块相同，支持模块化、封装、独立编译和代码复用。一个包的源代码在一个或多个 <code>.go</code> 文件中，通常这些文件位于一个目录中，该目录的名称以导入路径结尾。例如 <code>gopl.io/ch1/helloworld</code> 包的文件存储在 <code>$GOPATH/src/gopl.io/ch1/helloworld</code> 目录中。</p>
<h4 id="Imports">Imports</h4>
<p>每个包都由其导入路径标唯一标识，包名要求和导入路径的最后一部分相同，例如 <code>gopl.io/ch2/tempconv</code> 导入路径的包名是 <code>tempconv</code>。不同导入路径的包名可能冲突，可以在导入时指定别名来避免冲突。</p>
<h4 id="Package-Initialization">Package Initialization</h4>
<p>包初始化首先会按照声明顺序初始化包级变量，如果包中有多个 <code>.go</code> 文件，<code>go</code> 工具会对按照文件名对文件进行排序，然后调用编译器，文件按照传入编译器的顺序进行初始化。如果变量之间存在依赖关系，则会优先按照依赖关系初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a initialized third, to 3</span></span><br><span class="line"><span class="keyword">var</span> b = f() <span class="comment">// b initialized second, to 2, by calling f</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> <span class="comment">// c initialized first, to 1</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>init</code> 函数来初始化包级变量，每个文件都可以包含任意数量的 <code>init</code> 函数，按照声明顺序执行。包按照导入顺序依次初始化，如果包之间存在依赖关系，则会优先按照依赖关系初始化。<code>main</code> 包最后被初始化，从而保证 <code>main</code> 函数开始之前所有包都完成初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">		pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopCount returns the population count (number of set bits) of x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BitCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// Hacker&#x27;s Delight, Figure 5-2.</span></span><br><span class="line">	x = x - ((x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>)</span><br><span class="line">	x = (x &amp; <span class="number">0x3333333333333333</span>) + ((x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>)</span><br><span class="line">	x = (x + (x &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span></span><br><span class="line">	x = x + (x &gt;&gt; <span class="number">8</span>)</span><br><span class="line">	x = x + (x &gt;&gt; <span class="number">16</span>)</span><br><span class="line">	x = x + (x &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(x &amp; <span class="number">0x7f</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCountByClearing</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">		x = x &amp; (x - <span class="number">1</span>) <span class="comment">// clear rightmost non-zero bit</span></span><br><span class="line">		n++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCountByShifting</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">0</span>); i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> x&amp;(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">			n++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go 1.6, 2.67GHz Xeon</span></span><br><span class="line"><span class="comment">// $ go test -cpu=4 -bench=. gopl.io/ch2/popcount</span></span><br><span class="line"><span class="comment">// BenchmarkPopCount-4                  200000000         6.30 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkBitCount-4                  300000000         4.15 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByClearing-4        30000000         45.2 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByShifting-4        10000000        153 ns/op</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Go 1.6, 2.5GHz Intel Core i5</span></span><br><span class="line"><span class="comment">// $ go test -cpu=4 -bench=. gopl.io/ch2/popcount</span></span><br><span class="line"><span class="comment">// BenchmarkPopCount-4                  200000000         7.52 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkBitCount-4                  500000000         3.36 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByClearing-4        50000000         34.3 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByShifting-4        20000000        108 ns/op</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Go 1.7, 3.5GHz Xeon</span></span><br><span class="line"><span class="comment">// $ go test -cpu=4 -bench=. gopl.io/ch2/popcount</span></span><br><span class="line"><span class="comment">// BenchmarkPopCount-12                 2000000000        0.28 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkBitCount-12                 2000000000        0.27 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByClearing-12       100000000        18.5 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByShifting-12       20000000         70.1 ns/op</span></span><br></pre></td></tr></table></figure>
<h3 id="Scope">Scope</h3>
<p>区分作用域（Scope）和生命周期（lifetime），声明的作用域是指程序文本中的一个区域，是编译时的属性。而变量的生命周期是指程序执行期间，其他部分可以引用该变量的时间范围，是运行时的属性。</p>
<p>语法块（syntactic block）是指由花括号包围的语句块，词法块（lexical block）是对语法块概念的泛化，以涵盖未明确使用花括号包围的其它声明组合。整个源代码也是词法块，被称为宇宙块（universe block）。程序可以包含多个同名的声明，只要声明在不同词法块中。当编译器遇到对某个名称的引用，它会从最内层的词法块开始向外找，直到宇宙块为止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x := f(); x == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y := g(x); x == y &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(x, y) <span class="comment">// compile error: x and y are not visible here</span></span><br></pre></td></tr></table></figure>
<h2 id="Basic-Data-Types">Basic Data Types</h2>
<p>Go 语言的类型分为四类：基本类型、聚合类型、引用类型和接口类型。基本类型包括数值类型、字符串和布尔类型，聚合类型包括数组和结构体，引用类型包括指针、切片、哈希表、函数和通道。</p>
<h3 id="Integers">Integers</h3>
<p>数值类型包括整数、浮点数和复数。Go 提供有符号和无符号整数运算，它们分别有四种不同大小的类型，<code>int8, int16, int32, int64</code> 和  <code>uint8, uint16, uint32, uint64</code>。还有 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 类型，通常为 32 位或 64 位，具体位数由编译器决定。</p>
<p><code>rune</code> 和 <code>int32</code> 等价，通常用于表示 Unicode 码点。<code>byte</code> 和 <code>uint8</code> 等价，通常用于表示字节数据。在 Go 语言中，<code>%</code> 运算符得到的余数符号总是和被除数相同。没有 <code>~x</code> 按位取反，而是使用 <code>^x</code> 执行按位取反。对于有符号数而言，<code>&gt;&gt;</code> 会使用符号位填充。</p>
<h3 id="Floating-Point-Numbers">Floating-Point Numbers</h3>
<p>浮点类型有 <code>float32</code> 和 <code>float64</code> 两种，遵循 IEEE 754 标准。32 位浮点数的小数精度大约是 6 位，64 位浮点数的精度大约是 15 位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="type">float64</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z) <span class="comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Complex-Numbers">Complex Numbers</h3>
<p>有两种复数类型 <code>complex64</code> 和 <code>complex128</code>，它们的元素分别是 <code>float32</code> 和 <code>float64</code> 类型。可以使用内置函数 <code>complex</code>、<code>real</code> 和 <code>imag</code> 处理复数，可以直接使用 <code>i</code> 来声明复数的虚部。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y) <span class="comment">// &quot;(-5+10i)&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y)) <span class="comment">// &quot;-5&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Strings">Strings</h3>
<p>字符串是不可变的字节序列，内置函数 <code>len</code> 返回字符串的字节数量，而不是字符数量，索引操作 <code>s[i]</code> 获取字符串 <code>s</code> 的第 <code>i</code> 个字节。字符串的第 <code>i</code> 个字节不一定就是第 <code>i</code> 个字符，因为非 ASCII 码点的 UTF-8 编码需要多个字节。使用 <code>s[i:j]</code> 可以获取子字符串，该子字符串是一个新的字符串，不过和原串共享底层字节数组。由于可以共享底层内存，所以字符串的复制和子串操作的开销很低。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>]) <span class="comment">// &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749296835958.png" alt=""></p>
<p>可以在字符串中插入转义序列，特别地，有十六进制转义 <code>\xhh</code> 和八进制转义 <code>\ooo</code>，其中 <code>hh</code> 和 <code>ooo</code> 表示十六进制和八进制数字，八进制数不超过 <code>\377</code> 对应十进制 255。原始字符串字面量（raw string literal）使用的是反引号而不是单引号，输出时不会处理原始字符串字面量中的转义序列。 例外情况是，当原始字符串字面量跨多行编写时，会删除回车符 <code>\r</code>，从而使字符串在所有平台上保持一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GoUsage = <span class="string">`Go is a tool for managing Go source code.</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">go command [arguments]</span></span><br><span class="line"><span class="string">...`</span></span><br></pre></td></tr></table></figure>
<h4 id="Unicode">Unicode</h4>
<p>Unicode 是字符编码标准，每个字符对应一个 Unicode 码点，在 Go 中使用 <code>rune</code> 表示（<code>int32</code> 的同义词），即使用 UTF-32 编码方式定长存储 Unicode 码点，但是这样空间开销较大。</p>
<h4 id="UTF-8">UTF-8</h4>
<p>UTF-8 变长编码（由 Go 语言开发者发明）使用 1 到 4 字节表示 <code>rune</code>，第一个字节的高位指示当前 <code>rune</code> 使用多少字节表示。变长编码无法直接通过索引访问字符串中的第 <code>n</code> 个字符，但这种编码方式空间有诸多优点。空间占用小，和 ASCII 兼容，自同步（可以通过后退不超过 3 个字节找到字符的开头），从左向右解码不会有歧义。任何字符的编码都不是其他一个或多个字符编码的子串，因此可以通过查找字节来查找字符，而无需担心前面的上下文。字典序和 Unicode 码点顺序相同，不存在嵌入的 NUL 字节（零字节），对于使用 NUL 终止字符串的语言来说非常方便。</p>
<p><img src="/img/Go.assets/1749298903599.png" alt=""></p>
<p>Go 的源文件始终使用 UTF-8 编码方式，UTF-8 是 Go 程序处理文本字符串的首选编码方式。可以在字符串中使用 <code>\uhhhh</code> 表示 16 位码点，使用 <code>\Uhhhhhhhh</code> 表示 32 位码点，其中 <code>h</code> 是十六进制数字，每种形式都表示码点的 UTF-8 编码。例如，以下字符串字面量都表示相同的 6 字节字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;世界&quot;</span></span><br><span class="line"><span class="string">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span></span><br><span class="line"><span class="string">&quot;\u4e16\u754c&quot;</span></span><br><span class="line"><span class="string">&quot;\U00004e16\U0000754c&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>rune</code> 字面量中也可以使用 Unicode 转义字符，下面三种字面量是等价的。对于值小于 256 的 <code>rune</code> 可以使用单个十六进制转义字符表示，例如 <code>'\x41'</code> 表示 <code>'A'</code>。但是更大的值必须使用 <code>\u</code> 或 <code>\U</code> 转义，<code>'\xe4\xb8\x96'</code> 不是合法的 <code>rune</code> 字面量，即使这三个字节是单个码点的 UTF-8 编码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;世&#x27;</span> <span class="string">&#x27;\u4e16&#x27;</span> <span class="string">&#x27;\U00004e16&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于 UTF-8 的特性，许多字符串操作都无需解码。可以使用以下方法检验一个字符串是否是另一个字符串的前缀。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串 <code>s</code> 占用 13 个字节，包含 9 个码点/字符/<code>rune</code>，要处理字符可以使用 UTF-8 解码器 <code>DecodeRuneInString</code>。不过 Go 的 <code>range</code> 循环在应用于字符串时会自动进行 UTF-8 解码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// &quot;13&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) <span class="comment">// &quot;9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%c\n&quot;</span>, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749301168174.png" alt=""></p>
<p>如果 UTF-8 解码遇到非法字节，则会生成特殊的 Unicode 替换字符 <code>\uFFFD</code>，显示为白色问号周围环绕黑色六边形或菱形图案。将 UTF-8 编码的字符串转换为 <code>[]rune</code> 之后，会得到 Unicode 码点序列，反之亦然。将整数转换为字符串会将其解释为单个 <code>rune</code> 值，然后将其转换为 UTF-8 表示形式，如果对应的 <code>rune</code> 是无效的，则会使用替换字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;program&quot; in Japanese katakana</span></span><br><span class="line">s := <span class="string">&quot;プログラム&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;% x\n&quot;</span>, s) <span class="comment">// &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;</span></span><br><span class="line">r := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, r) <span class="comment">// &quot;[30d7 30ed 30b0 30e9 30e0]&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Strings-and-Byte-Slices">Strings and Byte Slices</h4>
<p>字符串 <code>s</code> 可以使用 <code>[]byte(s)</code> 转换为字节切片，然后使用 <code>string(b)</code> 转换回来。两个操作通常都会进行复制操作，以确保 <code>b</code> 的可变性和 <code>s2</code> 的不可变性。<code>bytes</code> 包提供 <code>Buffer</code> 类型，类似 Java 中的 <code>StringBuilder</code>，该类型无需初始化，其零值可以直接使用，因为之后调用的方法中会判断底层切片 <code>buf</code> 是否为 <code>nil</code>，然后为其分配内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s)</span><br><span class="line">s2 := <span class="type">string</span>(b)</span><br></pre></td></tr></table></figure>
<h4 id="Conversions-between-Strings-and-Numbers">Conversions between Strings and Numbers</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">123</span></span><br><span class="line">y := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">fmt.Println(y, strconv.Itoa(x)) <span class="comment">// &quot;123 123&quot;</span></span><br><span class="line"></span><br><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>) <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br></pre></td></tr></table></figure>
<h3 id="Constants">Constants</h3>
<p><code>const</code> 常量的底层类型必须是基本类型（和 Java 中的 <code>final</code> 很不一样）。当常量作为一个组声明时，除该组的第一个元素外，剩余元素的右侧表达式可以省略，此时默认会使用之前元素的表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) <span class="comment">// &quot;1 1 2 2&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="The-Constant-Generator-iota">The Constant Generator iota</h4>
<p>可以使用常量生成器 <code>iota</code> 创建枚举常量组，<code>iota</code> 的值从 0 开始，每次递增 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags <span class="type">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FlagUp           Flags = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// is up</span></span><br><span class="line">    FlagBroadcast                      <span class="comment">// supports broadcast access capability</span></span><br><span class="line">    FlagLoopback                       <span class="comment">// is a loopback interface</span></span><br><span class="line">    FlagPointToPoint                   <span class="comment">// belongs to a point-to-point link</span></span><br><span class="line">    FlagMulticast                      <span class="comment">// supports multicast access capability</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="Untyped-Constants">Untyped Constants</h4>
<p>没有指定类型的常量是无类型（untyped）常量，编译器会以比基本类型更高的数值精度来表示无类型常量，并且在其上执行高精度运算而不是机器运算（受限于 CPU 的位数），至少可以假设其具有 256 位精度。例如 <code>ZiB</code> 和 <code>YiB</code> 无法存储在任何整型变量中，但是可以在下面的表达式中使用。有六种无类型常量：untyped boolean、untyped integer、untyped rune、untyped floating-point、untyped complex 和 untyped string。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _   = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    KiB <span class="comment">// 1024</span></span><br><span class="line">    MiB <span class="comment">// 1048576</span></span><br><span class="line">    GiB <span class="comment">// 1073741824</span></span><br><span class="line">    TiB <span class="comment">// 1099511627776 (exceeds 1 &lt;&lt; 32)</span></span><br><span class="line">    PiB <span class="comment">// 1125899906842624</span></span><br><span class="line">    EiB <span class="comment">// 1152921504606846976</span></span><br><span class="line">    ZiB <span class="comment">// 1180591620717411303424 (exceeds 1 &lt;&lt; 64)</span></span><br><span class="line">    YiB <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(YiB/ZiB) <span class="comment">// &quot;1024&quot;</span></span><br></pre></td></tr></table></figure>
<p>浮点型常量 <code>math.Pi</code> 可以在需要浮点或复数的情况下使用，但是如果为其指定类型 <code>float64</code>，则精度会降低，而且在需要使用 <code>float32</code> 或 <code>complex128</code> 类型的值时需要显式类型转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi64 <span class="type">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = <span class="type">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = <span class="type">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure>
<p>只有常量可以不指定类型，当将无类型常量赋值给变量时，该常量会隐式转换为变量的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">&#x27;a&#x27;</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure>
<p>无论隐式还是显式转换，在转换时目标类型必须能够表示原始值，对于实数和复数的浮点数，允许四舍五入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    deadbeef = <span class="number">0xdeadbeef</span>        <span class="comment">// untyped int with value 3735928559</span></span><br><span class="line">    a        = <span class="type">uint32</span>(deadbeef)  <span class="comment">// uint32 with value 3735928559</span></span><br><span class="line">    b        = <span class="type">float32</span>(deadbeef) <span class="comment">// float32 with value 3735928576 (rounded up)</span></span><br><span class="line">    c        = <span class="type">float64</span>(deadbeef) <span class="comment">// float64 with value 3735928559 (exact)</span></span><br><span class="line">    d        = <span class="type">int32</span>(deadbeef)   <span class="comment">// compile error: constant overflows int32</span></span><br><span class="line">    e        = <span class="type">float64</span>(<span class="number">1e309</span>)    <span class="comment">// compile error: constant overflows float64</span></span><br><span class="line">    f        = <span class="type">uint</span>(<span class="number">-1</span>)          <span class="comment">// compile error: constant underflows uint</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在未显式指定类型的变量声明中，无类型常量的特性会决定变量的默认类型。无类型整型默认转换为 <code>int</code> 类型，无类型浮点数和复数默认转换为 <code>float64</code> 和 <code>complex128</code>。如果要使用其他类型，需要显示类型转换，或者在变量声明中指定类型。在将无类型常量转换为接口值时，默认值非常重要，因为它们会决定接口的动态类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span>      <span class="comment">// untyped integer; implicit int(0)</span></span><br><span class="line">r := <span class="string">&#x27;\000&#x27;</span> <span class="comment">// untyped rune; implicit rune(&#x27;\000&#x27;)</span></span><br><span class="line">f := <span class="number">0.0</span>    <span class="comment">// untyped floating-point; implicit float64(0.0)</span></span><br><span class="line">c := <span class="number">0i</span>     <span class="comment">// untyped complex; implicit complex128(0i)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0</span>)      <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0.0</span>)    <span class="comment">// &quot;float64&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0i</span>)     <span class="comment">// &quot;complex128&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="string">&#x27;\000&#x27;</span>) <span class="comment">// &quot;int32&quot; (rune)</span></span><br></pre></td></tr></table></figure>
<h2 id="Composite-Types">Composite Types</h2>
<h3 id="Arrays">Arrays</h3>
<p>数组元素默认初始化为元素类型的零值，可以使用数组字面量（array literal）来初始化数组。在数组字面量中，如果使用省略号 <code>...</code> 代替数组长度，则数组长度就是列表中元素的数量。数组大小属于类型的一部分，<code>[3]int</code> 和 <code>[4]int</code> 是不同的类型。大小必须是一个常量表达式，在编译时能够确定值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span> <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>]) <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, q) <span class="comment">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>
<p>除指定值列表外，还可以指定索引和值构成的列表，索引可以按任意顺序排列，不需要列出所有索引，未指定值的索引默认取零值。下面的数组 <code>r</code> 包含 100 个元素，其中最后一个元素的值为 -1。如果数组元素是可比较的，那么相同数组类型之间也可以相互比较，只有当所有对应元素都相等时，两个数组才相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>将数组作为参数传递时，传递的是数组的副本，如果函数想要修改原数组，需要传递指向数组的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	*ptr = [<span class="number">32</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slices">Slices</h3>
<p>切片是可变长的序列，由指针、长度和容量组成。指针指向该切片能够访问的底层数组的第一个元素，该元素不一定是底层数组的第一个元素。长度是切片包含的元素数量，容量是切片起始位置到底层数组末尾之间的元素数量，长度不会超过容量。多个切片可以共享相同的底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">Q2 := months[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(Q2) <span class="comment">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749365784634.png" alt=""></p>
<p>超出切片容量 <code>cap(s)</code> 会导致 <code>panic</code>，超出长度 <code>len(s)</code> 会扩展切片长度。由于切片包含指向底层数组的指针，所以将其作为参数传递不会复制数组元素，参数和切片共享底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// extend a slice (within capacity)</span></span><br><span class="line">fmt.Println(endlessSummer) <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure>
<p>切片字面量和数组字面量类似，只是未给出大小，它会先创建具有正确大小的数组，然后将该数组作为切片的底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>和数组不同，切片无法进行比较，不能使用 <code>==</code> 判断两个切片是否相等。标准库提供对 <code>[]byte</code> 切片的比较函数 <code>bytes.Equal</code>，对于其他类型的切片，需要自己实现比较逻辑。例外情况是，切片可以和 <code>nil</code> 进行比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> summer == <span class="literal">nil</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>切片的零值是 <code>nil</code>，<code>nil</code> 切片的长度和容量都是零。不过长度和容量为零的切片不一定是 <code>nil</code> 切片，例如 <code>[]int&#123;&#125;</code> 或 <code>make([]int, 3)[3:]</code>。除和 <code>nil</code> 进行相等性比较之外，<code>nil</code> 切片和任何其他长度为零的切片具有相同的行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="type">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="type">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>
<p>内置函数 <code>make</code> 用于创建切片，如果省略容量参数，则容量默认和长度相等。内部实现上，<code>make</code> 会创建未命名的数组变量，然后返回该数组的一个切片，该数组只能通过切片访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>
<h4 id="The-append-Function">The append Function</h4>
<p>内置函数 <code>append</code> 将元素添加到切片。如果容量足够则扩展切片长度，这会返回一个更大的新切片，和原切片共享底层数组。如果容量不足，则需要创建新数组，将旧数组的元素复制到新数组，此时和原切片的底层数组不同。下面是一个简易实现示例，内置函数 <code>append</code> 可能更加复杂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="type">int</span>, y <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> z []<span class="type">int</span></span><br><span class="line">	zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">		<span class="comment">// There is room to grow.  Extend the slice.</span></span><br><span class="line">		z = x[:zlen]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// There is insufficient space.  Allocate a new array.</span></span><br><span class="line">		<span class="comment">// Grow by doubling, for amortized linear complexity.</span></span><br><span class="line">		zcap := zlen</span><br><span class="line">		<span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">			zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">		z = <span class="built_in">make</span>([]<span class="type">int</span>, zlen, zcap)</span><br><span class="line">		<span class="built_in">copy</span>(z, x) <span class="comment">// a built-in function; see text</span></span><br><span class="line">	&#125;</span><br><span class="line">	z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749368591004.png" alt=""></p>
<p><img src="/img/Go.assets/1749368654320.png" alt=""></p>
<p>内置的 <code>append</code> 函数允许添加多个元素或切片，省略号 <code>...int</code> 表示函数具有可变参数，在切片之后添加省略号表示将其展开为参数列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="type">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, x...) <span class="comment">// append the slice x</span></span><br><span class="line">fmt.Println(x)      <span class="comment">// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Maps">Maps</h3>
<p><code>map</code> 是对哈希表的引用，表示为 <code>map[K]V</code>，其中 <code>K</code> 和 <code>V</code> 分别是键值的类型。键类型必须能够使用 <code>==</code> 比较，不建议使用浮点数作为键，因为浮点数可以是 <code>NaN</code>。可以使用内置函数 <code>make</code> 或哈希表字面量（map literal）创建 <code>map</code>，使用内置函数 <code>delete</code> 删除键。如果键不在哈希表中，则会返回值类型对应的零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">&quot;alice&quot;</span>]) <span class="comment">// &quot;32&quot;</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;alice&quot;</span>) <span class="comment">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>map</code> 元素不是变量，无法获取其地址，原因之一是扩容会导致地址失效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">&quot;bob&quot;</span>] <span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>
<p>可以使用基于范围的 <code>for</code> 循环遍历哈希表。<code>map</code> 的迭代顺序不是确定性的，实际实现为随机顺序，如果要按照顺序遍历，需要对键进行排序。由于已知 <code>names</code> 的最终大小，所以预分配指定容量的数组会更高效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">names := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ages))</span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code> 类型的零值是 <code>nil</code>，表示没有引用哈希表。对 <code>nil</code> 映射执行 <code>[]</code>、<code>delete</code>、<code>len</code> 和 <code>range</code> 都是安全的，其行为和空映射 <code>map[string]int&#123;&#125;</code> 类似。但是不允许向其中存储数据，会导致程序崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(ages == <span class="literal">nil</span>)    <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ages) == <span class="number">0</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">ages[<span class="string">&quot;carol&quot;</span>] = <span class="number">21</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>
<p>可以使用以下形式判断 <code>map</code> 中是否存在指定的键，以和默认零值区分开来。和切片类似，<code>map</code> 之间不能相互比较，只允许其和 <code>nil</code> 进行比较。如果想要将切片作为键，由于切片是不可比较的，所以可以将切片转换为字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;bob&quot;</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Structs">Structs</h3>
<p>使用 <code>type xxx struct</code> 形式声明结构体，指向结构体的指针可以直接通过 <code>.</code> 访问其字段（不像 C++ 需要使用 <code>-&gt;</code>），该写法等价于显式解引用之后再使用 <code>.</code>。字段通常一行写一个，不过相同类型的连续字段可以合并书写。字段顺序对于类型标识至关重要，不同字段顺序定义得到的是不同的类型。如果字段名称以大写开头，则该字段会被导出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            <span class="type">int</span></span><br><span class="line">    Name, Address <span class="type">string</span></span><br><span class="line">    DoB           time.Time</span><br><span class="line">    Position      <span class="type">string</span></span><br><span class="line">    Salary        <span class="type">int</span></span><br><span class="line">    ManagerID     <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class="line">employeeOfTheMonth.Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br><span class="line">(*employeeOfTheMonth).Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br></pre></td></tr></table></figure>
<p>具有名称 <code>S</code> 的结构体不能声明类型为 <code>S</code> 的字段，即不能包含自身类型的字段，但是可以包含指向自身类型的指针。结构体的零值由其每个字段的零值组合而成。没有字段的结构体 <code>struct&#123;&#125;</code> 被称为空结构体，其大小为零，可以用作 <code>map[string]struct&#123;&#125;&#123;&#125;</code> 表示集合类型。</p>
<h4 id="Struct-Literals">Struct Literals</h4>
<p>可以使用结构体字面量（struct literal）初始化结构体，如果不指定类型，需要按照字段声明顺序，给所有字段指定初始值。如果指定类型，则可以随意指定某些字段的初始值，剩余字段默认初始化为零值。结构体作为参数传递使用的是值传递，可以仅传递指针来提高效率。两种形式不能在相同字面量中混合使用。</p>
<h4 id="Comparing-Structs">Comparing Structs</h4>
<p>如果结构体的所有字段都是可比较的，那么该结构体就是可比较的，因此可以使用 <code>==</code> 或 <code>!=</code> 进行比较。和其他可比较类型类似，可比较的结构体也可以作为 <code>map</code> 的键。</p>
<h4 id="Struct-Embedding-and-Anonymous-Fields">Struct Embedding and Anonymous Fields</h4>
<p>可以使用结构体嵌入（struct embedding）将一个结构体作为另一个结构体的匿名字段，从而允许将形如 <code>x.d.e.f</code> 的字段链简化为 <code>x.f</code>。Go 中使用组合而不是继承复用代码，结构体嵌入可以简化组合产生的过长字段链。由于匿名字段实际上有隐含的名称，所有不能有两个相同类型的匿名字段，因为它们会相互冲突。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>      <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span>      <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span> <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON">JSON</h3>
<p>将 Go 数据结构序列化为 JSON 字符串，可以使用 <code>json.Marshal</code> 函数。序列化会将 Go 结构体字段名称用作 JSON 对象的字段名称，只有导出的字段才会被序列化。通过定义适当的数据结构，在反序列化时可以获取指定的数据，其余数据将被忽略。可以使用字段标签（field tags）替换 JSON 中默认的字段名称，使用 <code>key:&quot;value&quot;</code> 形式声明字段标签。字段标签通常用于将 Go 字段的驼峰命名转换为 JSON 字段的下划线命名，可以使用 <code>omitempty</code> 表示字段为零值或者为空时不生成对应的 JSON 输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title  <span class="type">string</span></span><br><span class="line">	Year   <span class="type">int</span>  <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">	Color  <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">	Actors []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">	&#123;Title: <span class="string">&quot;Casablanca&quot;</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">		Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Humphrey Bogart&quot;</span>, <span class="string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class="line">	&#123;Title: <span class="string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">		Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class="line">	&#123;Title: <span class="string">&quot;Bullitt&quot;</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">		Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Steve McQueen&quot;</span>, <span class="string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//!+Marshal</span></span><br><span class="line">		data, err := json.Marshal(movies)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line">		<span class="comment">//!-Marshal</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//!+MarshalIndent</span></span><br><span class="line">		data, err := json.MarshalIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line">		<span class="comment">//!-MarshalIndent</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//!+Unmarshal</span></span><br><span class="line">		<span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="type">string</span> &#125;</span><br><span class="line">		<span class="keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(titles) <span class="comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br><span class="line">		<span class="comment">//!-Unmarshal</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions">Functions</h2>
<h3 id="Function-Declarations">Function Declarations</h3>
<p>函数声明包含名称、参数列表、返回值列表以及函数体。如果函数值返回单个未命名返回值或者没有返回值，则可以省略返回值列表的括号。可以给返回值命名，此时默认会为每个名称声明对应的局部变量，初始化为其类型的零值。有返回值列表的函数必须以 <code>return</code> 语句结束，除非程序不会到达函数末尾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span></span> (result-list) &#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同类型的参数可以分为一组，仅编写一次类型。空标识 <code>_</code> 表示参数未被使用。函数的类型有时被称为其签名（signature），如果两个函数具有相同的参数类型和返回值类型，那么它们就具有相同的签名。参数和返回值的名称不会影响签名，签名也不受分组形式声明的影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123; z = x - y; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="type">int</span>, _ <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, sub) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, first) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, zero) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数总是值传递的，函数会接受参数的副本，对副本进行修改不会影响调用者。当参数是引用类型时，函数可以修改该参数间接引用的变量。如果发现某个函数没有函数体，则说明该函数是使用其他语言编写的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> <span class="comment">// implemented in assembly language</span></span><br></pre></td></tr></table></figure>
<h3 id="Recursion">Recursion</h3>
<p>许多编程语言使用固定大小的函数栈，通常为 64KB 到 2MB之间。固定大小的函数栈会限制递归调用的深度，需要小心避免栈溢出。Go 使用可变大小的栈，初始较小然后根据需要增大，直至达到大约 1GB 的上限。</p>
<h3 id="Multiple-Return-Values">Multiple Return Values</h3>
<p>Go 语言的垃圾回收机制会回收未使用的内存，但它不会自动释放未使用的操作系统资源，比如打开的文件和网络连接，这些资源应当显式的关闭。具有命名返回值的函数可以省略 <code>return</code> 语句的操作数，这被称为裸返回（bare return）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(rect image.Rectangle)</span></span> (width, height <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(path <span class="type">string</span>)</span></span> (dir, file <span class="type">string</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HourMinSec</span><span class="params">(t time.Time)</span></span> (hour, minute, second <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Errors">Errors</h3>
<p>对于失败（failure）是预期行为的函数，通常会有额外的返回值。如果失败的原因只有一个，那么额外返回布尔类型，否则应该返回 <code>error</code> 类型。内置类型 <code>error</code> 是接口类型，为 <code>nil</code> 时表示成功，反之则表示失败。和其他使用异常机制的语言不同，Go 语言使用 <code>panic</code> 表示非预期的错误，预期错误则使用 <code>if</code> 和 <code>return</code> 控制流机制实现错误处理。</p>
<h4 id="Error-Handling-Strategies">Error-Handling Strategies</h4>
<p>当函数调用出现错误时，调用方有责任检查并采取相应措施。最常见的处理方式是传播错误，也可以为错误添加额外信息。因为错误通常是链式的，所以消息字符串不应该大小，也不应该使用换行符。通常函数 <code>f(x)</code> 负责报告所执行的操作 <code>f</code> 以及与错误相关的参数 <code>x</code>，而调用者负责补充 <code>f(x)</code> 没有的其它信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种错误处理方式是重试，需要设置重试次数和重试前的等待时间。如果无法取得进展，调用者可以打印错误信息并终止程序，但这种处理方式仅用于程序的主要模块中。库函数通常应该将错误信息传递给调用者，除非该错误是 BUG。在某些情况下，可以仅记录错误信息并继续运行。极少数情况下，可以完全忽略某个错误。</p>
<h4 id="End-of-File-EOF">End of File (EOF)</h4>
<p>文件结束条件会产生 <code>io.EOF</code> 错误，需要特殊处理该错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...use r...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function-Values">Function Values</h3>
<p>在 Go 语言中，函数是一等公民（first-class values），像其他值一样，函数值也有类型，也可以作为参数传递给函数或从函数返回。函数类型的零值是 <code>nil</code>，调用 <code>nil</code> 函数会导致 <code>panic</code>，函数值之间是不可比较的，只能和 <code>nil</code> 比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span>     &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span>   &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> m * n &#125;</span><br><span class="line"></span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// &quot;9&quot;</span></span><br><span class="line"></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>))     <span class="comment">// &quot;-3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(int) int&quot;</span></span><br><span class="line"></span><br><span class="line">f = product           <span class="comment">// compile error: can&#x27;t assign f(int, int) int to f(int) int</span></span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Functions">Anonymous Functions</h3>
<p>命名函数只能在包级进行声明，而匿名函数可以在任意表达式中使用。每次调用 <code>squares</code> 都会创建一个局部变量 <code>x</code>，并返回一个类型为 <code>func() int</code> 的匿名函数。此时，匿名函数可以访问和修改外层函数的局部变量 <code>x</code>。这些隐含的变量就是将函数视为引用类型，以及函数值之间无法比较的原因。这类函数值使用闭包（closures）技术实现。就像之前提到的返回局部变量的地址的例子，闭包示例也说明变量的生命周期不是由作用域决定，而是由可达性决定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// squares returns a function that returns</span></span><br><span class="line"><span class="comment">// the next square number each time it is called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		x++</span><br><span class="line">		<span class="keyword">return</span> x * x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := squares()</span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;4&quot;</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;9&quot;</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当匿名函数需要递归时，必须先声明一个变量，然后将匿名函数赋值给该变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visitAll := <span class="function"><span class="keyword">func</span><span class="params">(items []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visitAll(m[item]) <span class="comment">// compile error: undefined: visitAll</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Caveat-Capturing-Iteration-Variables">Caveat: Capturing Iteration Variables</h4>
<p>在迭代中使用匿名函数时，需要避免捕获迭代变量的陷阱，正确的做法是声明一个同名的局部变量覆盖迭代变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">dirs := tempDirs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dirs); i++ &#123;</span><br><span class="line">    os.MkdirAll(dirs[i], <span class="number">0755</span>) <span class="comment">// OK</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dirs[i]) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Variadic-Functions">Variadic Functions</h3>
<p>可变参函数的最后一个参数类型前面使用省略号 <code>...</code>，表示可以接收任意数量的该类型参数。实际上，调用者会创建一个数组，将参数赋值到其中，然后将数组的切片传递给函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">		total += val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>...int</code> 参数的行为类似切片，但是可变参函数的类型和带有切片参数函数的类型并不相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(...<span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">([]<span class="type">int</span>)</span></span>  &#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(...int)&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, g) <span class="comment">// &quot;func([]int)&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Deferred-Function-Calls">Deferred Function Calls</h3>
<p><code>defer</code> 关键字之后跟函数调用，表示延迟执行该调用。函数和参数表达式在执行该语句时就会被计算，而实际调用则会推迟到包含该 <code>defer</code> 语句的函数执行完毕时，无论函数是正常/异常结束。可以有任意数量的调用被延迟执行，它们会以执行 <code>defer</code> 语句相反的顺序依次执行（类似栈 LIFO）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在单个 <code>defer</code> 语句中，对函数的入口和出口进行检测。下面的 <code>trace</code> 函数会立即被调用，而其返回的函数在 <code>bigSlowOperation</code> 函数结束时被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigSlowOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> trace(<span class="string">&quot;bigSlowOperation&quot;</span>)() <span class="comment">// don&#x27;t forget the extra parentheses</span></span><br><span class="line">	<span class="comment">// ...lots of work...</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second) <span class="comment">// simulate slow operation by sleeping</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	log.Printf(<span class="string">&quot;enter %s&quot;</span>, msg)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; log.Printf(<span class="string">&quot;exit %s (%s)&quot;</span>, msg, time.Since(start)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟执行的函数在 <code>return</code> 语句更新完返回值变量之后执行，可以在其中修改返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">	<span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Panic">Panic</h3>
<p>当 Go 运行时检测到严重的错误时，会产生 <code>panic</code>，正常执行会停止，从函数栈顶到 <code>main</code> 函数的所有延迟函数调用会依次执行，然后程序会崩溃并记录日志。可以显示调用内置的 <code>painc</code> 函数。对于函数的前置条件进行确认是良好的做法，但是除非能够提供更详细的错误信息或更早地检测到错误，否则没有必要去确认在运行时会自动检查的条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reset</span><span class="params">(x *Buffer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;x is nil&quot;</span>) <span class="comment">// unnecessary!</span></span><br><span class="line">	&#125;</span><br><span class="line">	x.elements = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Recover">Recover</h3>
<p>如果在延迟函数中调用内置的 <code>recover</code> 函数，且包含该 <code>defer</code> 语句的函数发生 <code>panic</code>，那么 <code>recover</code> 会终止当前的 <code>panic</code> 状态并返回 <code>panic</code> 的值。发生 <code>panic</code> 的函数不会继续执行，而是直接返回。在没有发生 <code>panic</code> 时调用 <code>recover</code> 函数不会有任何效果，仅仅返回 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="type">string</span>)</span></span> (s *Syntax, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Methods">Methods</h2>
<h3 id="Method-Declarations">Method Declarations</h3>
<p>方法声明就是在函数名之前添加额外的参数，该参数将函数和该参数的类型绑定。额外的参数 <code>p</code> 被称作该方法的接收者（receiver），在 Go 语言中，没有使用 <code>this</code> 或 <code>self</code> 表示接收者，而是像对待普通参数一样选择接收者的名称，通常使用类型的首字母作为其名称。以下两个函数声明不会相互冲突，一个是包级函数，另一个是 <code>Point</code> 类型的方法。</p>
<p>在 Go 语言中，字段和方法不能同名（和 Java 不同）。和其他面向对象语言不同，Go 中可以为大多数类型定义方法，而不仅仅是结构体类型。例外情况是：① 不能直接为基本类型定义方法，而必须使用 <code>type</code> 创建命名类型；② 不能为指针和接口类型定义方法，但是接收者可以是指向非指针类型的指针。另外，类型和方法必须定义在相同的包中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Methods-with-a-Pointer-Receiver">Methods with a Pointer Receiver</h3>
<p>如果方法使用 <code>(p Point)</code> 声明，则和普通参数一样会复制该变量，如果想要在方法中修改相关变量，则应该使用 <code>(p *Point)</code> 指针类型接收变量的地址。在调用时也需要通过指针调用该方法，不过语法上允许直接通过 <code>Point</code> 变量而不是 <code>*Point</code> 调用 <code>ScaleBy</code> 方法，编译器会对其隐式地执行 <code>&amp;</code> 取址操作。对于临时值由于还没有为其分配地址，所以不能使用简写形式。同样可以通过 <code>*Point</code> 变量调用 <code>Distance</code> 方法，编译器会隐式地执行 <code>*</code> 解引用操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">	p.X *= factor</span><br><span class="line">	p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>) <span class="comment">// compile error: can&#x27;t take address of Point literal</span></span><br></pre></td></tr></table></figure>
<h4 id="Nil-Is-a-Valid-Receiver-Value">Nil Is a Valid Receiver Value</h4>
<p>正如函数允许将 <code>nil</code> 指针作为参数，接收者也可以为 <code>nil</code>，当 <code>nil</code> 是该类型有意义的零值时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntList is a linked list of integers.</span></span><br><span class="line"><span class="comment">// A nil *IntList represents the empty list.</span></span><br><span class="line"><span class="keyword">type</span> IntList <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Tail  *IntList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum returns the sum of the list elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *IntList)</span></span> Sum() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.Value + list.Tail.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Composing-Types-by-Struct-Embedding">Composing Types by Struct Embedding</h3>
<p>结构体嵌入会将内部组合结构体的方法提升到外部结构体中。这种组合方式和继承不同，两种类型并不是父子关系，不具有多态性。实际上，编译器会生成包装方法，其内部会调用字段的对应方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point</span><br><span class="line">	Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>&#125;</span><br><span class="line">blue := color.RGBA&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line"><span class="keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">q.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ColoredPoint)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Point.Distance(q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ColoredPoint)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">	p.Point.ScaleBy(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Method-Values-and-Expressions">Method Values and Expressions</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distanceFromP := p.Distance        <span class="comment">// method value</span></span><br><span class="line">fmt.Println(distanceFromP(q))      <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="keyword">var</span> origin Point                   <span class="comment">// &#123;0, 0&#125;</span></span><br><span class="line">fmt.Println(distanceFromP(origin)) <span class="comment">// &quot;2.23606797749979&quot;, ;5</span></span><br><span class="line"></span><br><span class="line">scaleP := p.ScaleBy                <span class="comment">// method value</span></span><br><span class="line">scaleP(<span class="number">2</span>)                          <span class="comment">// p becomes (2, 4)</span></span><br><span class="line">scaleP(<span class="number">3</span>)                          <span class="comment">// then (6, 12)</span></span><br><span class="line">scaleP(<span class="number">10</span>)                         <span class="comment">// then (60, 120)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// method expression</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// &quot;5&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance) <span class="comment">// &quot;func(Point, Point) float64&quot;</span></span><br><span class="line"></span><br><span class="line">scale := (*Point).ScaleBy</span><br><span class="line">scale(&amp;p, <span class="number">2</span>)</span><br><span class="line">fmt.Println(p)            <span class="comment">// &quot;&#123;2 4&#125;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, scale) <span class="comment">// &quot;func(*Point, float64)&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Interfaces">Interfaces</h2>
<h3 id="Interface-Satisfaction">Interface Satisfaction</h3>
<p>接口类型是抽象类型，其定义一组方法，只要具体类型有这些方法，就可以被视为该接口的实例（隐式实现接口）。接口类型之间也可以嵌入，使得当前接口具有另一个接口的方法，而不需要显示的全部定义出来。只要具体类型或接口类型有某个接口类型的所有方法，就可以将其赋值给该接口类型。可以将任何值赋值给空接口类型 <code>interface&#123;&#125;</code>。可以使用以下方式，在编译时断言 <code>bytes.Buffer</code> 类型满足 <code>io.Writer</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer must satisfy io.Writer</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Interface-Values">Interface Values</h3>
<p>接口类型的值（interface value）包含两个组成部分，即具体类型以及该类型的值，它们被称为动态类型（dynamic type）和动态值（dynamic value）。动态类型由类型描述符（type descriptor）表示，其提供类型的字段和方法信息。接口的零值，其类型和值的组成部分都被设置为 <code>nil</code>。如果接口的类型部分是 <code>nil</code>，则该接口值就是 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;&lt;nil&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">w = os.Stdout</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*os.File&quot;</span></span><br><span class="line"></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*bytes.Buffer&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749473744332.png" alt=""></p>
<p><img src="/img/Go.assets/1749474247823.png" alt=""></p>
<p><img src="/img/Go.assets/1749474389546.png" alt=""></p>
<p>可以使用 <code>==</code> 和 <code>!=</code> 比较接口值，如果两个接口值均为 <code>nil</code>，或者它们的动态类型和动态值都相同，则这两个接口值相同。如果两个接口值的动态类型相同，但是它们的动态类型不支持比较操作，则会引发 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(x == x) <span class="comment">// panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure>
<h4 id="Caveat-An-Interface-Containing-a-Nil-Pointer-Is-Non-Nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</h4>
<p>当 <code>debug = false</code> 时，下面的代码会引发 <code>panic</code>，因为接口值的动态类型不是 <code>nil</code>，而动态值是 <code>nil</code>，在调用 <code>(*bytes.Buffer).Write</code> 方法时会出问题。解决方案是，将 <code>buf</code> 声明为 <code>var buf io.Writer</code>，避免将无效值（<code>bytes.Buffer</code> 类型的 <code>nil</code> 指针）赋值给接口类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">	&#125;</span><br><span class="line">	f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		<span class="comment">// ...use buf...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...do something...</span></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">		out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749475099821.png" alt=""></p>
<h3 id="Type-Assertions">Type Assertions</h3>
<p>类型断言（type assertion）是对接口值执行的操作，形如 <code>x.(T)</code>，其中 <code>x</code> 是接口类型的表达式，<code>T</code> 是断言类型。如果 <code>T</code> 是具体类型，那么类型断言会检查 <code>x</code> 的动态类型是否和 <code>T</code> 相同，如果相同则返回 <code>x</code> 的动态值，否则引发 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)      <span class="comment">// success: f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic: interface holds *os.File, not *bytes.Buffer</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>T</code> 是接口类型，那么类型断言会检查 <code>x</code> 的动态类型是否满足 <code>T</code>，如果满足则返回类型为 <code>T</code> 的接口值，该接口值和 <code>x</code> 具有相同的动态类型和动态值。不论 <code>T</code> 是什么类型，如果 <code>x</code> 是 <code>nil</code>，则断言会失败。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// success: *os.File has both Read and Write</span></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) <span class="comment">// panic: *ByteCounter has no Read method</span></span><br></pre></td></tr></table></figure>
<p>如果使用以下类型断言方式，则断言失败不会引发 <code>panic</code>，而是额外返回 <code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File) <span class="comment">// success: ok, f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer) <span class="comment">// failure: !ok, b == nil</span></span><br></pre></td></tr></table></figure>
<h3 id="Type-Switches">Type Switches</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>:</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x) <span class="comment">// x has type interface&#123;&#125; here.</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">		<span class="keyword">if</span> x &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		<span class="keyword">return</span> sqlQuoteString(x) <span class="comment">// (not shown)</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-31T15:57:09.852Z" title="2023/12/31 23:57:09">2023-12-31</time>发表</span><span class="level-item"><time dateTime="2024-02-10T10:34:33.751Z" title="2024/2/10 18:34:33">2024-02-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="level-item">3 分钟读完 (大约433个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/31/%E5%86%8D%E8%A7%81%202023/">再见 2023</a></p><div class="content"><p>时间过得好快！今年大概有 5 个月的时间都在搞算法，然后其他时间基本上每周都会打比赛，虽然对面试来说不应该花费这么多时间，但是我喜欢算法给我带来的反馈，以及比赛时能够高度集中注意力的状态。特别是绞尽脑汁然后 AC 的感觉，真的很棒。即使不会做，赛后也可以通过题解来学习。</p>
<p><img src="/img/Summary.assets/1704031883662.png" alt=""></p>
<p>力扣基本上可以稳定三题，上 2300 分之后就有点没状态，排名波动有点大。在打 CF 之前就听说，力扣分减 700 大概就是 CF 分，结果还真是这样。CF 思维题较多，前四题基本上不会使用很复杂的数据结构，如果能稳定四题就能到 1900 分吧。AtCoder 题目有点水，对我来说，基本上从 D 题开始才算正式进入比赛，但是经常简单题也没做出来。令人印象深刻的是，获得两次群主发的进步奖。</p>
<p><img src="/img/Summary.assets/1704033219234.png" alt=""></p>
<p>5 月份阅读完《OSTEP》，9、11 月份学习完课程 CMU 15-445，并且做完四个相关的项目，感觉还不错。12 月份阅读《DDIA》25%，然后摸鱼。6-8 月份，高数、线代、Linux、Java 虚拟机、Spring、设计模式雨露均沾，基本上没有特别深入的，当时有点急躁。总的来说，确实有做不少事，但是效率不高，目的不明确，缺乏实践，要做的事还有很多。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/17/">上一页</a></div><div class="pagination-next"><a href="/page/19/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/17/">17</a></li><li><a class="pagination-link is-current" href="/page/18/">18</a></li><li><a class="pagination-link" href="/page/19/">19</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/51/">51</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">152</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-26T00:11:50.404Z">2025-04-26</time></p><p class="title"><a href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> / <a href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-18T10:01:46.499Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-17T16:42:59.185Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/CMU%2015-445645%20%E2%80%94%20Fall%202024%20Projects/">CMU 15-445/645 — Fall 2024 Projects</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-26T13:03:18.733Z">2025-03-26</time></p><p class="title"><a href="/2025/03/26/Kafka/">Kafka 4.0（草稿）</a></p><p class="categories"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a> / <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/">Kafka</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">42</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">99</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>