<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-07-08T16:00:00.000Z" title="2025/7/9 00:00:00">2025-07-09</time>发表</span><span class="level-item"><time dateTime="2025-10-05T11:48:25.938Z" title="2025/10/5 19:48:25">2025-10-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/">协调服务</a><span> / </span><a class="link-muted" href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/ZooKeeper/">ZooKeeper</a></span><span class="level-item">1 分钟读完 (大约160个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/07/09/%E4%BD%BF%E7%94%A8%20ZooKeeper%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">使用 ZooKeeper 实现分布式锁</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://zookeeper.apache.org/">Apache ZooKeeper</a>，<a target="_blank" rel="noopener" href="https://hub.docker.com/_/zookeeper">DockerHub</a>，<a target="_blank" rel="noopener" href="https://curator.apache.org/docs/about">Apache Curator</a>，<a href="https://ligh0x74.github.io/2024/02/05/ZooKeeper%20Wait-free%20coordination%20for%20Internet-scale%20systems/#%E6%97%A0%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94%E7%9A%84%E7%AE%80%E5%8D%95%E9%94%81">无羊群效应的简单锁</a>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-zookeeper --restart always -p 2181:2181 -d zookeeper</span><br><span class="line">docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper</span><br><span class="line">docker rm -f some-zookeeper</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help, ls -s /, create /zk_test my_data, get /zk_test, set /zk_test junk, delete /zk_test, quit</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(</span><br><span class="line">        <span class="string">&quot;192.168.2.9:2181&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line">    )) &#123;</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.acquire();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-05-14T12:42:16.492Z" title="2025/5/14 20:42:16">2025-05-14</time>发表</span><span class="level-item"><time dateTime="2025-05-16T13:55:35.531Z" title="2025/5/16 21:55:35">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><span> / </span><a class="link-muted" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></span><span class="level-item">20 分钟读完 (大约2975个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://github.com/ashishps1/awesome-system-design-resources">GitHub Awesome System Design</a>。</p>
<h2 id="短链系统"><a target="_blank" rel="noopener" href="https://blog.algomaster.io/p/design-a-url-shortener">短链系统</a></h2>
<h3 id="我的想法">我的想法</h3>
<p>核心功能就是长链转短链，可以从使用算法和存储方式两个方面思考。算法首先想到的是哈希函数，可以将长链转为一个短链整数（需要处理哈希冲突），然后使用 Base62 编码为包含 <code>[0-9a-zA-z]</code> 的短链字符串。存储时可以存储长链和短链整数/字符串，不同存储格式主要是时间和空间的权衡，然后需要分别在两个字段上建立唯一/前缀索引来加速查询。</p>
<p>实际上可以将数据库的主键 ID 作为短链整数，这样空间占用更小，也不存在哈希冲突。查询短链到长链的映射可以直接利用主键索引，只需给长链建立索引来加速反向查询。虽然每次查询都要将短链整数编码为短链字符串，不过时间开销不算大，长度为 7 的字符串就可以表示 \(62^7\approx3\times 10^{12}\) 个不同的短链，而且可以使用缓存提升查询性能。</p>
<h3 id="文章内容">文章内容</h3>
<p>需求分析可以分为功能性需求和非功能性需求，功能性需求主要是业务需求，非功能性需求包括高性能、高可用、可扩展性和安全性。然后可以假设流量特征来估算系统的吞吐量、磁盘/内存空间以及带宽需求。流量特征可以从每日缩短 URL 的请求数量、读写比例、峰值流量和平均 URL 长度等方面思考。最后根据估算结果来估计需要的基础设施。</p>
<p>假设每天 100 万个缩短 URL 的请求，读写比例 <code>100 : 1</code>，峰值流量是平均负载的 10 倍，平均 URL 长度为 100 个字符。计算吞吐量，平均写吞吐量 \(\frac{\times 10^{6}}{24\times3600}\approx 12\) WPS，平均读吞吐量 \(100\times 12=1200\) RPS。假设每个 URL 占用 127 字节的存储空间，由短链 7 字节、长链 100 字节、创建时间 8 字节、到期时间 8 字节和点击次数 4 字节组成，那么每年就需要 \(127\times 10^{6}\times 365\approx 46.4\) GB 的磁盘存储空间。假设读取返回的 HTTP 301 重定向大小为 500 字节，每天读取带宽为 \(500\times 10^{6}\times 100= 50\) GB/day，每秒峰值读取带宽为 \(500\times RPS\times 10= 6\) MB/s。</p>
<p><img src="/img/Design.assets/1747210911179.png" alt=""></p>
<p>系统负载是读多写少的，假设负载符合二八定律（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pareto_principle">Pareto principle</a>），即 20% 的 URL 产生 80% 的读取流量。假设每天缓存 20% 的 URL，则需要 \(127\times 10^{6}\times 0.2=25.4\) MB 的内存作为缓存。假设缓存命中率为 90%，则到达数据库的平均请求数量为 \(1200\times0.1=120\) RPS。最后根据以上估算结果，估计使用 4-6 个服务器，每个服务器能够处理 200~300 RPS，10~20 个分布式数据库节点，3~4 个分布式缓存节点。</p>
<p><img src="/img/Design.assets/1747211754704.png" alt=""></p>
<p>由于需要存储数十亿条记录，而且数据库操作大多是简单的键值查找，不需要执行复杂的表连接，所以选择使用 DynamoDB 或 Cassandra 等 NoSQL 数据库，因为它们能够高效处理数十亿次简单键值的查找，而且提供高可扩展性和高可用性。</p>
<p>可以对长链使用哈希函数（MD5、SHA-256）得到哈希值，然后取哈希值的前缀转十进制，再使用 Base64 编码得到短链。要处理哈希冲突，可以使用不同的种子重新哈希或者取哈希值的其它位生成短链，也可以将增量后缀附加到短链。另一种生成短链的方式是使用分布式 ID（数据库自增 ID、Redis 生成 ID、雪花算法），从安全性角度思考，增量 ID 是可预测的，有人可以通过使用短链服务推断系统的 URL 总数或者猜测其他用户生成的 URL，混淆（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Obfuscation">Obfuscation</a>）增量 ID 可以缓解该问题。</p>
<p>额外功能：① 用户自定义短链，需要进行格式校验以及唯一性检查，如果和已有的短链发生冲突，服务器可以返回错误或者建议的替换方案。服务器还可以保留部分短链，以供内部使用。② 设置短链的过期时间，由用户指定或者使用默认的过期时间，可以使用定时任务或者在请求时检测短链是否过期，然后（逻辑）删除过期短链。③ 可以使用消息队列记录短链的访问日志，然后批量处理日志将其聚合存储在数据仓库中，以实现分析服务。</p>
<p>其他问题：① 使用负载均衡、基于范围/哈希的分片、缓存保证可扩展性。② 使用复制、自动故障转移、跨多个地理区域部署服务保证可用性。③ 处理边界条件，例如对于过期短链服务器返回 HTTP 401 状态码，不存在的短链返回 404 状态码，在生成短链时检测冲突。④ 限流防止滥用，输入校验确保用户提供的短链不包含恶意内容，使用 HTTPS 防止窃听和中间人攻击，对异常活动模式进行监控和报警。</p>
<h3 id="遗漏的点">遗漏的点</h3>
<p>功能性需求没有想到重定向和过期时间的设计，以及允许用户自定义短链、数据分析等额外功能。重定向可以使用 301/302 状态码（永久/临时重定向），临时重定向每次请求都会经过短链服务，从而可以统计短链的使用次数。没有特别思考非功能性需求，基本上是从单服务器的角度思考问题。对哈希函数有点误解，误认为哈希的结果都是整数，像是 MD5、SHA 生成的哈希值都是可以包含字母的。我之前都是默认使用 MySQL + Redis 的组合，没有想到使用其他 NoSQL 数据库。使用哈希函数索引实现长链快速判重，使用布隆过滤器过滤请求。</p>
<h3 id="一些疑问">一些疑问</h3>
<p>Q：为什么估计使用 4-6 个服务器，10~20 个分布式数据库节点，3~4 个分布式缓存节点？</p>
<p>Q：文章描述的系统似乎只会检测短链冲突，而没有检测重复的长链？</p>
<p>Q：<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html">DynamoDB</a> 和 <a target="_blank" rel="noopener" href="https://cassandra.apache.org/doc/latest/">Cassandra</a> 数据库有什么特点？</p>
<h2 id="排行榜系统"><a target="_blank" rel="noopener" href="https://systemdesign.one/leaderboard-system-design/">排行榜系统</a></h2>
<h3 id="我的想法-2">我的想法</h3>
<p>排行榜主要是按照分数对用户进行排序，功能性需求主要是显示排名和更新排名。像是游戏打完排位会显示排名上升多少，然后排行榜只会显示 TopK 用户，每隔固定时间才更新榜单。像是算法比赛的排行榜会显示所有用户，榜单也是实时更新的。对于 TopK 榜单一般会使用小顶堆来实现，当新分数大于堆顶元素时，就弹出堆顶元素然后将当前元素入堆。</p>
<p>那么其他用户如何在分数变化之后计算排名呢？简单的想法就是直接更新 MySQL 数据库中的分数，然后获取所有小于该分数的用户数量。对于游戏这种分数频繁变化的场景，更新、查询数据库的磁盘 I/O 开销较大。如果能够将所有用户的分数信息缓存到 Redis 中，则可以直接使用跳表维护排行榜，然后使用消息队列异步更新数据库（类似后写<a target="_blank" rel="noopener" href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/">缓存策略</a>）。</p>
<p>像是算法比赛这种结束之后排名就不会变化的场景，数据库中也可以存储排名信息（而不只是分数）。如果内存中存不下所有用户的分数信息，可以对数据分片使用多个 Redis 节点维护排行榜，获取排名就需要对所有节点数据做聚合。应该也可以使用统计数据估算排名，返回给前端的是估算排名而不是真正的排名，然后后台使用定时任务去修正排名。</p>
<h3 id="文章内容-2">文章内容</h3>
<p>排行榜分为绝对排行榜和相对排行榜，绝对排行榜显示 TopK 用户，相对排行榜显示指定用户周围的用户。HTTP 响应可以设置 <code>cache-control: private, no-cache, must-revalidate, max-age=5</code> 使用缓存，状态码 202 表示异步处理请求、401 表示身份未认证、403 表示没有权限，使用 HEAD 请求查看服务的健康状况。</p>
<p>功能性需求：绝对和相对排行榜，可以查看指定用户的排名，排行榜可以划分为全球、区域和朋友圈，可以查看历史比赛的排行榜，可以根据每天/周/月的游戏情况进行排名，客户端以分布式的方式在全球范围内更新排行榜。流量特征：每天 5000 万个写入请求，读写比例为 <code>5 : 1</code>，用户分布在全球各地，排行榜需实时显示。</p>
<p><img src="/img/Design.assets/1747384011378.png" alt=""></p>
<p><img src="/img/Design.assets/1747384154716.png" alt=""></p>
<p><img src="/img/Design.assets/1747399028301.png" alt=""></p>
<p>客户端使用 WebSocket 协议和负载均衡器建立连接，保证排行榜的实时性（允许服务器主动推送数据）。依然使用 DynamoDB 实现可扩展性，将玩家 ID 作为分区键、玩家得分作为排序键。<em><strong>东西有点多，看得有点懵，先实现再说。</strong></em></p>
<h3 id="遗漏的点-2">遗漏的点</h3>
<p>单个用户的分数变化会导致其他用户的排名也发生变化（导致缓存失效），所以使用 MySQL 数据库获取排名的方式需要全表扫描更新所有用户的排名，或者延迟更新每个用户的排名，磁盘 I/O 开销会比我之前想的更大。更新 MySQL 分数之后应该主动更新缓存而不是删除缓存（从 Cache Aside 变为类似 Write Through），确保所有用户都在 Redis 的排行榜中（所以也不能设置过期时间），避免重建整个排行榜。不过主动更新缓存可能导致不一致，例如网络原因导致缓存更新失败、并发更新的顺序交错导致旧数据覆盖新数据，可以使用消息队列排队、重试请求保证正确性。</p>
<h3 id="一些疑问-2">一些疑问</h3>
<p>Q：既然游戏和用户的关系是一对多，即不同游戏的用户不会共享，那么完全没有必要将不同游戏的数据耦合到一个数据库中。而且 Redis 维护的排行榜数据以 <code>leaderboard_id</code> 作为键是有问题的，这可是 <code>Leaderboards</code> 表的主键。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-26T00:11:50.404Z" title="2025/4/26 08:11:50">2025-04-26</time>发表</span><span class="level-item"><time dateTime="2025-05-07T02:27:15.451Z" title="2025/5/7 10:27:15">2025-05-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span> / </span><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></span><span class="level-item">43 分钟读完 (大约6438个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://skyzh.github.io/mini-lsm/">mini-lsm</a>，<a target="_blank" rel="noopener" href="https://discord.com/channels/1197355762297610260/1197435686370947112">Discord</a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/">Rust Documentation</a>，<a target="_blank" rel="noopener" href="https://tourofrust.com/">Tour of Rust</a>。</p>
<h2 id="Week-1-Overview-Mini-LSM">Week 1 Overview: Mini-LSM</h2>
<h3 id="Memtables">Memtables</h3>
<p>如果要在内存中存储键值对，可以简单的使用哈希表，但是如果要支持顺序遍历以及范围查询，要使用特殊的数据结构，例如跳表、B/B+ 树、红黑树、AVL树等。<strong>为什么 LSM 实现使用跳表（<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam-skiplist/latest/crossbeam_skiplist/">crossbeam_skiplist</a>）作为内存表的数据结构？</strong> B/B+ 树主要是针对磁盘 I/O 做优化，插入/删除会涉及页分裂和合并，在纯内存的场景下不太适用。红黑树是近似平衡的，AVL 树是严格平衡的，所以红黑树的插入/删除效率更好，而 AVL 树的查找效率更好。跳表的实现更加简单，而且并发友好，只需要锁定局部数据。不过跳表是基于链表实现的，数据局部性可能较差，而且概率数据结构稳定性也会差点。</p>
<p><strong>为什么内存表在 delete 时只是将值置为空，而不是删除整个键值对？</strong> 因为如果当前内存表找不到指定的 Key，那么会继续在已经冻结的内存表中找，如果删除整个键值对，则会丢失该删除操作。<strong>为什么要有多个内存表呢？</strong> 当前内存表执行 get/put 操作的同时，可以基于冻结的内存表构建 SST，然后刷到磁盘中，而不会 STW 阻塞整个 LSM。</p>
<p><strong>何时使用 <code>state</code> 读写锁和 <code>state_lock</code> 独占锁？</strong> 由于使用的跳表是支持无锁并发的，读写跳表只需要加 <code>state</code> 读锁，但是判断是否冻结以及整个冻结操作都需要加 <code>state_lock</code> 独占锁来保证原子性，可以使用双重检查加锁来优化性能。然后冻结操作内会加 <code>state</code> 写锁，将当前内存表加入冻结列表，然后创建一个新的内存表。<strong>在内存表超出限制大小需要冻结时，将 <code>state</code> 读锁释放再加写锁，与直接将读锁升级为写锁有什么区别？</strong> 在释放读锁之后，依然允许其他线程执行 get/put 操作，此时当前冻结线程可以执行昂贵的磁盘 I/O 而不会影响整体的性能。</p>
<p><img src="/img/DB.assets/1745494765832.png" alt=""></p>
<h3 id="Merge-Iterator">Merge Iterator</h3>
<p>可以构建迭代器来遍历内存表，像是 Java 中的迭代器通常会有 <code>hasNext()</code> 和 <code>next()</code> 方法来判断迭代器的有效性以及获取下一个元素。<code>StorageIterator</code> 迭代器的设计有点不同，<code>next()</code> 只会移动内部的跳表迭代器而不会返回元素，获取元素是通过 <code>key()</code> 和 <code>value()</code> 方法实现的。<strong>为什么 <code>StorageIterator</code> 迭代器的设计和 Rust 风格的迭代器不同？为什么 <code>MemTableIterator</code> 需要自引用？</strong> 因为 <code>StorageIterator</code> 迭代器可能需要多次获取当前 Key 而不移动到下一个元素，所以将移动操作和取值操作分离是比较好的选择。使用自引用结构的目的是避免编写 Rust 的生命周期代码的复杂性。</p>
<p>实现单个内存表迭代器之后，因为除当前内存表外还有多个冻结内存表，所以需要一个合并迭代器，将所有内存表迭代器合并，从而实现顺序遍历。如果有多个内存表包含相同的键，需要返回该键的最新值，以及跳过其他包含旧值的键。可以使用堆来对多个迭代器排序，首先按照键的大小排序，然后按照内存表的新旧编号排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter1: b-&gt;del, c-&gt;4, d-&gt;5</span><br><span class="line">iter2: a-&gt;1, b-&gt;2, c-&gt;3</span><br><span class="line">iter3: e-&gt;4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;1, b-&gt;del, c-&gt;4, d-&gt;5, e-&gt;4</span><br></pre></td></tr></table></figure>
<p>Rust 的 <code>BinaryHeap</code> 在修改堆中元素之后，会自动排序保证堆的有效性。如果在修改之后迭代器报错，不能直接返回错误信息，而要首先从堆中移除失效的迭代器，从而避免访问失效的迭代器（会调用其方法获取 Key）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let Some(mut inner_iter) = self.iters.peek_mut() &#123;</span><br><span class="line">    inner_iter.next()?; // &lt;- will cause problem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现合并迭代器 <code>MergeIterator</code> 之后，外部还有一个 <code>LsmIterator</code> 做包装，用来过滤被逻辑删除的键，也就是在遍历时会自动跳过值为空的键。然后 <code>LsmIterator</code> 外部又有一个 <code>FusedIterator</code> 做包装，在底层迭代器报错之后，会避免再次访问底层迭代器。<strong>为什么不直接在 <code>MemTableIterator</code> 中过滤被逻辑删除的键？</strong> 在合并迭代器时需要知道该键在新内存表被删除避免读取到旧内存表的值。</p>
<h3 id="Block">Block</h3>
<p>当内存表数量超过系统限制时，会将内存表作为 SST 刷新到磁盘，一个 SST 由多个块组成，单个块的大小通常是 4KB。编码方式如下：键值对是变长编码，作为 Entry 存储在 Data Section，同时维护每个 Entry 的偏移量来支持二分查找，最后存储总的 Entry 数量从而支持定位 Offset Section 的起始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">|             Data Section             |              Offset Section             |      Extra      |</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">| Entry #1 | Entry #2 | ... | Entry #N | Offset #1 | Offset #2 | ... | Offset #N | num_of_elements |</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------</span><br><span class="line">|                           Entry #1                            | ... |</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">| key_len (2B) | key (keylen) | value_len (2B) | value (varlen) | ... |</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="Sorted-String-Table-SST">Sorted String Table (SST)</h3>
<p>SST 由存储在磁盘上的数据块和索引块组成，数据块是按需加载的，只有在用户请求时才会加载到内存中。索引块也可以按需加载，但在本项目中假设所有 SST 索引块（元数据块）都能装入内存。<strong>一个 SST 文件的大小通常是 256MB，在构建 SST 时最好预分配 <code>Vec</code> 的空间，避免频繁动态扩容的开销。</strong> 如果单个数据块的大小超出限制，会自动创建一个新块存储数据。SST 的元数据包括，每个数据块的第一个和最后一个键以及该数据块的偏移量。最后存储元数据的偏移量从而支持定位元数据的起始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">|         Block Section         |          Meta Section         |          Extra          |</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">| data block | ... | data block |            metadata           | meta block offset (u32) |</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>在实现 <code>SsTableIterator</code> 的 <code>seek_to_key</code> 方法时（找到第一个 <code>? &gt;= x</code> 的键），可以根据数据块的第一个键使用二分查找来快速定位目标数据块。需要注意的是，如果目标 Key 是 <code>x</code>，要找的是最后一个满足 <code>first_key &lt;= x</code> 的数据块，而且在调用该 <code>BlockIterator</code> 的 <code>seek_to_key</code> 方法之后，还要额外判断该 <code>BlockIterator</code> 是否失效。例如，查找 <code>b</code> 会定位到第一个数据块（正确），而查找 <code>d</code> 也会定位到第一个数据块（错误），然后在 <code>BlockIterator</code> 上调用 <code>seek_to_key</code> 会导致迭代器失效，此时需要跳到下一个块上，也就是说第二个数据块才是目标块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------</span><br><span class="line">| block 1 | block 2 |   block meta   |</span><br><span class="line">--------------------------------------</span><br><span class="line">| a, b, c | e, f, g | 1: a/c, 2: e/g |</span><br><span class="line">--------------------------------------</span><br></pre></td></tr></table></figure>
<p>可以使用缓存来加速数据块的访问，项目使用 <a target="_blank" rel="noopener" href="https://github.com/moka-rs/moka">moka-rs</a> 作为缓存库来实现块缓存，块由 <code>(sst_id, block_id)</code> 唯一标识。</p>
<h3 id="Read-Path-Write-Path">Read Path &amp; Write Path</h3>
<p>实现完成内存表和 SST 结构之后，可以实现 <code>TwoMergeIterator</code> 来合并两者的迭代器，理论上可以直接使用之前实现的 <code>MergeIterator</code>，不过这里只有两个迭代器需要合并，所以这里使用一个更简单的实现。然后可以修改 <code>LsmStorageInner</code> 的 <code>scan</code> 和 <code>get</code> 方法的实现，将 SST 添加到读取路径中。由于创建 SST 的迭代器会比较耗时（涉及磁盘 I/O），所以不要在整个过程持有 <code>state</code> 读锁，而是创建一个 <code>state</code> 快照，然后基于快照创建迭代器来访问数据。</p>
<p>创建 SST 的合并迭代器需要加载所有底层 SST 的第一个块，优化方式是并行创建迭代器。在 <code>LsmStorageInner::scan</code> 方法中，实际上可以利用参数 <code>lower</code> 和 <code>upper</code>，以及 SST 的 <code>first_key</code> 和 <code>last_key</code> 来过滤 SST，避免不必要的磁盘 I/O。当内存表的数量达到上限时，需要将最旧的冻结内存表以 SST 文件的形式刷到磁盘，刷新工作主要由后台线程负责。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">snapshot</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">read</span>();</span><br><span class="line">    Arc::<span class="title function_ invoke__">clone</span>(&amp;guard)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Snack-Time-SST-Optimizations">Snack Time: SST Optimizations</h3>
<p>可以在读取路径上集成<a target="_blank" rel="noopener" href="https://samwho.dev/bloom-filters/">布隆过滤器</a>来过滤 SST，布隆过滤器基于 SST 包含的数据创建，每个 SST 都包含一个持久化的布隆过滤器数据。由于数据块中的键是有序存储的，可以对键进行前缀压缩。<strong>根据相邻键进行键前缀压缩而不是根据块中的第一个键进行压缩有哪些优点/缺点？</strong> 项目中是根据数据块的 <code>first_key</code> 的前缀进行压缩，这样可以在查找时快速复原当前 Key。如果是根据相邻键压缩，那么压缩比例会更高，但是压缩和复原最坏需要遍历所有前缀数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">|         Block Section         |                            Meta Section                           |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">| data block | ... | data block | metadata | meta block offset | bloom filter | bloom filter offset |</span><br><span class="line">|                               |  varlen  |         u32       |    varlen    |        u32          |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_overlap_len (u16) | rest_key_len (u16) | key (rest_key_len)</span><br></pre></td></tr></table></figure>
<h2 id="Week-2-Overview-Compaction-and-Persistence">Week 2 Overview: Compaction and Persistence</h2>
<h3 id="Compaction-Implementation">Compaction Implementation</h3>
<p>可以对 L0 SST 文件进行压缩，避免读放大，由于各个 SST 之间的键范围存在重叠。最简单的方式是进行 Full Compaction，将所有键按顺序排序存储到一组新的 SST 中（被称为 sorted run）。压缩时允许并行执行读写操作，所以不持有 <code>state</code> 的读写锁，依然复制状态快照（不会复制 SST，只是复制状态），然后基于快照创建 L0 和 L1（之前压缩的 L1 需要和 L0 再次整合）的合并迭代器。</p>
<p>使用 <code>SsTableBuilder</code> 构建 SST，如果超出大小限制则拆分文件，在迭代时过滤已经被删除的键，重复的键已经在合并迭代器内部过滤。替换状态时只需要持有 <code>state_lock</code> 独占锁，<code>state</code> 读写锁依然只在复制状态快照时持有，允许并行执行读写内存表的操作。替换状态不会丢失内存表的修改，因为状态只包含内存表的指针。</p>
<p>由于在压缩时也会产生 L0 SST 文件，所以在替换状态时只删除被压缩的 L0 SST 文件、以及所有 L1 SST 文件。<strong>在 macOS/Linux 操作系统上，直接删除文件不会有问题，即使可能存在并行读取，因为操作系统只有在没有文件句柄被持有时才会真正删除该文件。在 Windows 上似乎会直接报错。</strong> 删除文件操作在解锁 <code>state_lock</code> 之后执行。</p>
<p><img src="/img/DB.assets/1745716942378.png" alt=""></p>
<h3 id="Simple-Compaction-Strategy">Simple Compaction Strategy</h3>
<p>实现 Simple Leveled Compaction 策略，基本想法是指定一个最大层数 <code>max_levels</code>（不包括 L0），然后在 L0 SST 文件数量达到阈值，或者下层文件数量和上层（&gt;= L1）文件数量的比值小于阈值时执行相邻层级之间的压缩。<strong>是否可以像 Full Compaction 一样直接过滤已经被删除的键？</strong> 只有当压缩 Level 是最底层时，才能过滤掉已经被删除的键，否则可能读取到下层 Level 的旧值。<strong>主动选择旧 Level 进行压缩，即使其没有达到指定阈值，是否是一个好主意？</strong> 参考 <a target="_blank" rel="noopener" href="https://disc-projects.bu.edu/lethe/">Lethe</a> 文章，定期压缩可以减少无效键导致的空间放大、压缩无效键导致的写放大、无效键占用布隆过滤器导致误报率提升。</p>
<h3 id="Tiered-Compaction-Strategy">Tiered Compaction Strategy</h3>
<p>实现 Tiered Compaction 策略（RocksDB 的 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/universal-compaction">Universal Compaction</a>），该压缩不会使用 L0，所有 SST 都直接存放到 <code>levels</code> 中，压缩过程中生成的 SST 总是会占据一个 tier，tier 的编号就是该 tier 包含的第一个 SST ID。</p>
<p>首先，只有当 tier 的数量超过阈值才会触发压缩。当估计的空间放大率 <code>all levels except last level size / last level size</code> 超过阈值会触发 Full Compaction，或者 <code>this tier size / sum of all previous tiers size</code> 超过阈值会触发前缀压缩。如果没有触发上述压缩，则会直接触发前缀压缩，压缩的最大层数由参数限制。由于压缩过程中也会生成 SST，所以修改状态时替换的是 <code>levels</code> 的中间部分而不一定是前缀。</p>
<h3 id="Leveled-Compaction-Strategy">Leveled Compaction Strategy</h3>
<p>实现 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">Leveled Compaction</a> 策略，相当于对 Simple Leveled Compaction 的优化。之前的策略会在相邻层级之间压缩数据，初始时会反复地将上层数据压缩到下面的空层中，更好的策略是跳过中间的空层，直接和有数据的低层进行压缩。在数据量不是很大的时候，没有必要分层压缩产生读放大，所以给最底层设置一个阈值 <code>base_level_size_mb</code>，在最底层的文件大小超过该阈值之前总是将数据压缩到最底层。</p>
<p>然后使用 <code>level_size_multiplier</code> 来确定各个层级的 <code>target size</code>，只允许有一个小于 <code>base_level_size_mb</code> 的正 <code>target size</code>，该层记作 <code>base level</code>。每次压缩 L0 的数据都直接压缩到 <code>base level</code>，这样可以确保在数据量比较小时使用较少的层级（后缀层级），避免较多层级产生读放大、以及反复压缩相邻空层产生写放大。</p>
<p>优先将满足 <code>current_size / target_size &gt; 1.0</code> 的比值最大的层级压缩到下层中，尽量减少空间放大。之前的策略总是将上层所有 SST 和下层做压缩，这样压缩过程中的空间放大会比较多。可以实现部分压缩，从上层选择最旧的 SST，然后和下层键范围重叠的 SST 做压缩。对于 L0 可以计算整个 L0 的最小最大键，然后和下层范围重叠的 SST 做压缩。<strong>需要考虑没有重叠的情况，此时压缩结果需要放在 Level 的开头或者末尾，比较简单的实现方式就是根据 SST 的 <code>first_key</code> 排序。</strong></p>
<h3 id="Manifest">Manifest</h3>
<p>可以持久化 LSM 存储引擎的状态，从而允许重启时恢复。简单的方法是，在状态被修改时将所有状态持久化，但是这样磁盘 I/O 开销较大，特别是修改操作比较频繁时。该项目使用 Manifest 文件维护 SST Flush 和 Compaction 操作记录，SST Flush 操作记录该 SST 的 <code>sst_id</code>，Compaction 操作记录压缩任务 <code>task</code> 和压缩结果 <code>output</code>。在不持有 <code>state</code> 读写锁时追加 Manifest 文件，允许并行读写内存表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| JSON record | JSON record | JSON record | JSON record |</span><br></pre></td></tr></table></figure>
<p>由于记录的信息有限，在重启恢复时只能先构建 <code>L0</code> 和 <code>levels</code> 元数据，然后根据这些元数据读取磁盘上的 SST 来构建 <code>sstables</code> 哈希表。如果在压缩过程中使用到 <code>sstables</code> 中 SST 的 <code>first_key</code> 排序，那么在恢复时需要特殊处理。不能在应用记录的过程中构建 <code>sstables</code>，因为记录中的 SST 可能已经被压缩，从而对应的文件已经从磁盘删除。</p>
<p><strong>为保证磁盘中 SST 和 Manifest 文件的一致性，需要在追加 Manifest 文件之前 Sync 整个存储目录，或者可以在修改文件之后总是执行 Sync。</strong> 在关闭 LSM 之前，需要将所有内存表刷新到 SST 中。在恢复时需要维护最大的 <code>max_sst_id</code>，恢复完成之后需要根据 <code>max_sst_id + 1</code> 创建当前的内存表。由于 Manifest 文件会记录所有操作，所以需要定时创建快照来截断日志（例如 Raft 中状态机快照），来减少空间占用以及加快恢复速度。</p>
<h3 id="Write-Ahead-Log-WAL">Write-Ahead Log (WAL)</h3>
<p>Manifest 文件可以保证正常关闭时，LSM 状态的持久性，但是如果发生崩溃，就需要依靠 WAL 来保证持久性。每个内存表对应一个 WAL 文件，如果冻结内存表被刷新到 SST 文件中，则可以将 WAL 文件删除，前提是该 SST 文件已经被 Sync 到磁盘中（默认在创建 SST 时就会 Sync）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len | key | value_len | value |</span><br></pre></td></tr></table></figure>
<p>为了能够在重启时恢复内存表，需要在 Manifest 文件中维护 NewMemtable 记录，该记录存储内存表的 ID。为减少磁盘 I/O 以及系统调用开销，可以在将当前内存表转移到冻结内存表时刷新 WAL 到磁盘，而不是在每次修改内存表时刷新，不过如果宕机则会丢失当前内存表的数据。创建 WAL 文件应该在追加 Manifest 记录之前，这样可以保证恢复时的一致性。在重启恢复时，依然不能在应用记录的过程中读取 WAL，因为记录中的 WAL 可能已经被删除，由于该内存表已经被刷新到 SST 中。</p>
<h3 id="Snack-Time-Batch-Write-and-Checksums">Snack Time: Batch Write and Checksums</h3>
<p>实现批量写入接口，允许用户提供一组 <code>put</code> 和 <code>delete</code> 操作批量执行。给 Block、SST Meta（Block Meta、Bloom Filter）、WAL 以及 Manifest 文件添加校验和，从而允许检查数据是否损坏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">|                   Block Section                     |                            Meta Section                           |</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">| data block | checksum | ... | data block | checksum | metadata | meta block offset | bloom filter | bloom filter offset |</span><br><span class="line">|   varlen   |    u32   |     |   varlen   |    u32   |  varlen  |         u32       |    varlen    |        u32          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">|                                                Meta Section                                            |</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">| no. of block | metadata | checksum | meta block offset | bloom filter | checksum | bloom filter offset |</span><br><span class="line">|     u32      |  varlen  |    u32   |        u32        |    varlen    |    u32   |        u32          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len | key | value_len | value | checksum |</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| len | JSON record | checksum | len | JSON record | checksum | len | JSON record | checksum |</span><br></pre></td></tr></table></figure>
<h2 id="Week-3-Overview-Multi-Version-Concurrency-Control">Week 3 Overview: Multi-Version Concurrency Control</h2>
<h3 id="Timestamp-Key-Encoding-Refactor">Timestamp Key Encoding + Refactor</h3>
<h3 id="Snapshot-Read-Memtables-and-Timestamps">Snapshot Read - Memtables and Timestamps</h3>
<h3 id="Snapshot-Read-Engine-Read-Path-and-Transaction-API">Snapshot Read - Engine Read Path and Transaction API</h3>
<p>为实现 MVCC 需要重构代码，首先替换 Key 的表示以包含时间戳字段，按照 <code>user_key</code> 升序 <code>ts</code> 降序排序，这样可以优先读到新版本的数据。然后修改内存表、Block、SST、WAL 以支持时间戳字段，在重启恢复 LSM 状态时需要根据 SST 和内存表中使用的最大时间戳来确定当前时间戳。在整个 <code>write_batch</code> 中需要持有 MVCC 的 <code>write_lock</code>，从而确保按照时间戳递增的顺序执行写入操作（只有写入操作会递增时间戳）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alternative key representation: | user_key (varlen) | ts (8 bytes) | in a single slice</span><br><span class="line">Our key representation: | user_key slice | ts (u64) |</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_overlap_len (u16) | remaining_key_len (u16) | key (remaining_key_len) | timestamp (u64)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len (exclude ts len) (u16) | key | ts (u64) | value_len (u16) | value | checksum (u32) |</span><br></pre></td></tr></table></figure>
<p>在压缩过程中，暂时忽略 <code>compact_to_bottom_level</code> 保留所有版本的数据（不执行实际的删除操作）。确保不同时间戳的相同 <code>user_key</code> 在同一个的 SST 中，即使超出 SST 的大小限制，从而简化其他功能的开发。个人认为主要是 Leveled Compaction 会从上层部分压缩到下层，如果多个版本不在一个 SST 中，会存在旧版本的键值对在上层而新版本的键值对被压缩到下层的情况。修改 <code>LsmIterator</code> 包含时间戳字段，只迭代 <code>&lt;=</code> 当前时间戳的最新数据，如果键被删除就跳过该键的所有旧版本。应该首先判断版本再判断删除，因为删除操作可能是在快照之后的版本执行的。</p>
<p>在 <code>get</code> 读取路径中，只需要根据当前时间戳创建事务，读取快照内可见的数据即可。不过由于内存表会包含多个版本的数据，所以只能使用范围查询来查找该 <code>user_key</code> 的最新可见版本。在 <code>scan</code> 读取路径中，如果 <code>lower</code> 和 <code>upper</code> 是 <code>Bound::Included</code>，则对应的时间戳是 <code>ts</code> 和 <code>TS_RANGE_END</code>。如果是 <code>Bound::Excluded</code>，则对应的时间戳是 <code>TS_RANGE_END</code> 和 <code>ts | TS_RANGE_BEGIN</code>。因为对于 <code>lower</code> 而言，必须定位到对应 <code>user_key_begin</code> 的最旧版本，才能确保迭代器跳过该 <code>user_key_begin</code>。对于 <code>upper</code> 而言，必须定位到 <code>ts</code> 及更新的版本才能确保迭代器跳过该 <code>user_key_end</code>。</p>
<h3 id="Watermark-and-Garbage-Collection">Watermark and Garbage Collection</h3>
<p>Watermark 是维护系统中 <code>lowest_read_ts</code> 的结构，可以在创建/终止事务时，使用 <code>BTreeMap</code> 维护各个时间戳的引用计数来实现。然后压缩操作保留所有键的最新快照以及所有 <code>&gt;= lowest_read_ts</code> 的快照，例外情况是如果当前压缩到 <code>compact_to_bottom_level</code>，且键的最新快照是删除操作，且该快照 <code>&lt;= lowest_read_ts</code>，则不保留该键值对到新 SST 中。</p>
<h3 id="Transaction-and-Optimistic-Concurrency-Control">Transaction and Optimistic Concurrency Control</h3>
<p>事务内执行的修改操作都存储到事务的 <code>local_storage</code> 本地内存表中，该表不包含时间戳信息。读取操作会先读取本地内存表，再读取公共内存表及 SST 文件。本地内存表迭代器 <code>TxnLocalIterator</code> 和之前没有时间戳的公共内存表实现相同，而 <code>TxnIterator</code> 会使用 <code>TwoMergeIterator</code> 合并本地和公共数据，不过需要跳过被删除的键，由于之前只有 <code>LsmIterator</code> 会执行该逻辑。</p>
<p>提交事务会将当前事务的状态设置为已提交，然后将本地内存表的数据通过 <code>LsmStorageInner::write_batch</code> 批量提交到公共内存表中。如果在写入公共内存表的过程中崩溃，恢复时的 WAL 无法区分事务之间的边界，从而不能保证事务的原子性。可以实现批量 WAL，将事务内的写入操作批量提交给 WAL，然后添加 Header 和 Footer 来区分事务边界。而且要保证批量写入操作都存储到相同的内存表中，从而使得事务内的批量操作只存储在一个 WAL 文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   HEADER   |                          BODY                                      |  FOOTER  |</span><br><span class="line">|     u32    |   u16   | var | u64 |    u16    |  var  |           ...            |    u32   |</span><br><span class="line">| batch_size | key_len | key | ts  | value_len | value | more key-value pairs ... | checksum |</span><br></pre></td></tr></table></figure>
<h3 id="A-Partial-Serializable-Snapshot-Isolation">(A Partial) Serializable Snapshot Isolation</h3>
<p>在事务内执行读写操作时维护读写集，然后在提交时验证当前事务是否和已提交事务冲突（OCC），从而实现可串行化快照隔离。首先，需要确保验证、提交操作的原子性，所以在 <code>commit</code> 方法开始时持有 MVCC 的 <code>commit_lock</code> 锁。然后遍历在 <code>(read_ts, expected_commit_ts)</code> 范围内提交的事务，判断当前事务的读集是否和这些事务的写集重叠。如果重叠则说明当前事务和已提交事务冲突，直接返回错误信息。例外情况是，如果当前事务是只读的，则不需要验证冲突。基本想法是，写操作会基于读操作的结果执行，而只读则不会修改公共数据。</p>
<p>在本项目中，对于 <code>scan</code> 操作只将扫描到的键加入读集而不是扫描范围，这样实现简单但是无法真正保证可串行化快照隔离（依然存在 write skew 异常）。在读写集中存储的是键的哈希值，这样可以减少内存空间占用、加快验证速度，但是会存在哈希冲突导致误报。在提交事务时可以将提交时间戳小于 <code>lowest_read_ts</code> 的已提交事务数据移除，然后将当前事务数据加入已提交事务集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txn1: len(scan(..)) = 2</span><br><span class="line">txn2: len(scan(..)) = 2</span><br><span class="line">txn1: put key1 = 2, commit, read set = &#123;a, b&#125;, write set = &#123;key1&#125;</span><br><span class="line">txn2: put key2 = 2, commit, read set = &#123;a, b&#125;, write set = &#123;key2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Snack-Time-Compaction-Filters">Snack Time: Compaction Filters</h3>
<p>如果需要删除以某个字符串为前缀的所有键，正常调用删除方法不但不会减少空间占用，反而会为每个键新增一个删除版本，只有压缩到最底层才会真正删除。可以使用压缩过滤器，添加前缀匹配规则到压缩过滤器，然后在压缩过程中不保留匹配的键值对到 SST 中。不过保证正确的前提是，所有事务都不会读取相关的键。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/55/">55</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">164</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">38</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">协调服务</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/ZooKeeper/"><span class="level-start"><span class="level-item">ZooKeeper</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-13T14:21:30.428Z">2025-10-13</time></p><p class="title"><a href="/2025/10/13/Linux%20Page%20Cache/">Linux Page Cache（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-21T10:49:47.130Z">2025-09-21</time></p><p class="title"><a href="/2025/09/21/%E5%A4%8D%E7%8E%B0%20Apache%20Shiro%201.2.4%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">复现 Apache Shiro 1.2.4 反序列化漏洞</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-31T16:00:00.000Z">2025-08-01</time></p><p class="title"><a href="/2025/08/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-08T16:00:00.000Z">2025-07-09</time></p><p class="title"><a href="/2025/07/09/%E4%BD%BF%E7%94%A8%20ZooKeeper%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">使用 ZooKeeper 实现分布式锁</a></p><p class="categories"><a href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/">协调服务</a> / <a href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/ZooKeeper/">ZooKeeper</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">102</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">clist</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://csdiy.wiki/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdiy</span></span><span class="level-right"><span class="level-item tag">csdiy.wiki</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>