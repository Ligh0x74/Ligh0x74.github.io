<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-31T16:00:00.000Z" title="2023/1/1 00:00:00">2023-01-01</time>发表</span><span class="level-item"><time dateTime="2025-04-19T07:29:59.040Z" title="2025/4/19 15:29:59">2025-04-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></span><span class="level-item">1 小时读完 (大约11877个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/01/Java%20%E5%9F%BA%E7%A1%80/">Java 基础</a></p><div class="content"><h2 id="基本类型">基本类型</h2>
<h3 id="整数类型">整数类型</h3>
<p>整数进行除法运算，商向零取整。</p>
<p>整数被 0 除将会产生一个异常，而浮点数被 0 除将会得到无穷大或 NaN。</p>
<p><strong>思考：进行取模运算时，数值的正负对结果有什么影响？</strong></p>
<p>取模的定义：<code>(a / b) * b + a % b = a</code>。根据定义算就行，或者记住取模的结果和左边的数（被除数）符号相同，但是结果本质上依赖于除法的舍入规则，所以最好还是按定义算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span> % <span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">3</span> % <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span> % -<span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">3</span> % -<span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%d %d %d %d&quot;</span>,a, b, c, d);</span><br></pre></td></tr></table></figure>
<h3 id="浮点类型">浮点类型</h3>
<p><strong>思考：double 类型的取值范围和精度是多少？（float 类型同理）</strong></p>
<p>double 类型的表示使用 IEEE 754 标准，以 \(V=(-1)^{s}\times M\times 2^{E}\) 的形式来表示浮点数。其中，\(s,M,E\) 分别表示符号、尾数和阶码，分别使用 1、11 和 52 位进行编码。根据标准定义，能够表示的最大/最小规格化值是 \(\pm (1+1-2^{-52})\times2^{(2^{11}-2-1023)}\approx\pm 1.79769313486231570e+308\)。</p>
<p>通常，会说 double 的精度是 15，计算方式为 \(\log{2^{-52}}\) 或者 \(\log{2^{-53}}\)（由于隐含的 \(1\)）。但是，这里所说的精度都是仅从尾数层面计算的，而没有涉及阶码（或者部分涉及）。在十进制表示中，由于阶码的影响（以及科学记数法表示），说精度是 15 没有什么意义。而在二进制表示中，直接说精度是 52 比较合理。</p>
<p><strong>思考：为什么浮点运算可能产生误差？是否所有浮点运算都会产生误差？BigDecimal 是如何避免误差的？</strong></p>
<p>声明：这里所讨论的误差是指运算过程中的舍入误差，不包括由于不能准确表示而产生的舍入误差，例如浮点数 0.1 只是实数 0.1 的近似，也不包括输出产生的舍入误差，例如虽然浮点数能够精确表示 <code>Double.MAX_VALUE</code>，但是输出会得到近似值 1.7976931348623157E308。</p>
<p>（1）发生误差的根本原因是，IEEE 754 标准不能准确表示所有小数（由于范围和精度限制），所以浮点运算只能近似地表示实数运算。标准定义了四种不同的舍入（rounding）方式，默认是将计算结果向偶数舍入（round-to-even）。向偶数舍入是指，将非中间值向最接近的数舍入，将中间值向偶数舍入。</p>
<p><img src="/img/Java.assets/1739349047502.png" alt=""></p>
<p>为什么选择向偶数舍入？如果计算一组数的平均数：向上/下舍入会使结果偏大/小；向零舍入在统计数据都是正/负数时，会使结果偏小/大；而向偶数舍入大概率可以避免这种统计偏差，因为此时向上和向下舍入的概率各占一半。</p>
<p>（2）并非所有浮点运算都会产生误差。首先，<code>0.5 + 0.25</code> 不会产生误差。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 01111111110 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.5</span>)));</span><br><span class="line"><span class="comment">// 0 01111111101 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.25</span>)));</span><br><span class="line">System.out.println(<span class="number">0.5</span> + <span class="number">0.25</span> == <span class="number">0.75</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么，是否可以猜测，能够被 IEEE 754 标准精确表示的数，浮点运算就不会产生误差？然而不是，只要运算结果超出浮点数能够表示的范围或者精度，那么运算就会产生误差。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 01111111111 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">1.0</span>)));</span><br><span class="line"><span class="comment">// 0 10000110100 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">9007199254740992.0</span>)));</span><br><span class="line">System.out.println(<span class="number">1.0</span> + <span class="number">9007199254740992.0</span>); <span class="comment">// 9.007199254740992E15</span></span><br></pre></td></tr></table></figure>
<p>那么，不能被 IEEE 754 标准精确表示的数，浮点运算是否总会产生误差？也不是，例如 <code>0.1 + 0.1</code> 就没有误差，而 <code>0.1 + 0.2</code> 就会有误差，可以使用这个<a target="_blank" rel="noopener" href="https://numeral-systems.com/ieee-754-add/">网站</a>查看计算过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 01111111011 1001100110011001100110011001100110011001100110011010</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.1</span>)));</span><br><span class="line"><span class="comment">// 0 01111111100 1001100110011001100110011001100110011001100110011010</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.2</span>)));</span><br><span class="line"><span class="comment">// 0 01111111101 0011001100110011001100110011001100110011001100110011</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.3</span>)));</span><br><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">0.2</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>（3）BigDecimal 表示不可变的任意精度的小数，可以将其视为由任意精度的未缩放值 \(x\)，以及 32 位的缩放值 \(k\) 组成，最终表示的数就是 \(x\times 10^{-k}\)。如果未缩放值 \(x\) 非常大，则会使用 BigInteger 来表示。BigInteger 表示不可变的任意精度的整数，内部使用 int 类型的数组存储整数的补码表示的各个部分。例如，\(9\times 10^{9}\) 会被存储为 \([2,410065408]\)，对应补码表示 \(01000011000011100010001101000000000\) 的 \(010\) 和 \(00011000011100010001101000000000\) 两部分。</p>
<p><strong>思考：double 类型不能准确表示的最小正整数是多少？（CSAPP 练习题 2.49）</strong></p>
<p>假设阶码位数足够大，对于有 \(n\) 位尾数的浮点数，不能准确表示的最小正整数是 \(2^{n+1}+1\)。所以，double 类型不能准确表示的最小正整数是 \(2^{53}+1=9007199254740993\)。示例如下，最低位的 1 被舍掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9007199254740993.</span>); <span class="comment">// 9.007199254740992E15</span></span><br></pre></td></tr></table></figure>
<p>需要注意，不能根据上述结论推断出，能够准确表示的最大正整数是 \(2^{n+1}\)。反例是，\(2^{n+1}+2\) 可以被准确表示，更简单的反例是 \(2^{n+2}\)。总的来说，能转换为 \((-1)^{s}\times M\times 2^{E}\) 形式的数都可以被准确表示。</p>
<p><strong>思考：将三个 int 类型的整数转换为 double 类型（假设为 \(x,y,z\)），问 \((xy)z=x(yz)\) 是否总是成立？如果不是，反例是什么？（<a target="_blank" rel="noopener" href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/">CSAPP 2.89 D</a>）</strong></p>
<p>反例如下，简单来说乘法可能存在舍入误差，不同的结合方式可能会有不同的舍入形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">23</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + <span class="number">1</span>;</span><br><span class="line">System.out.println((x * y) * z == x * (y * z)); <span class="comment">// false</span></span><br><span class="line">z = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line">System.out.println((x * y) * z == x * (y * z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可以根据乘法结果能否转换为标准定义的浮点形式，来判断是否存在舍入误差。首先 \((2^{30}+1)\times(2^{23}+1)=(1+2^{-23}+2^{-30}+2^{-53})\times 2^{53}\)，由于尾数能表示的最小值是 \(2^{-52}\)，所以最后 \(1\) 位会被舍掉，得到 \(xy=(1+2^{-23}+2^{-30})\times 2^{53}\)。然后 \((1+2^{-23}+2^{-30})\times 2^{53}\times(2^{24}+1)=(1+2^{-23}+2^{-30}+2^{-24}+2^{-47}+2^{-54})\times 2^{77}\)，所以最后 \(2\) 位会被舍掉，得到 \((xy)z=(1+2^{-23}+2^{-30}+2^{-24}+2^{-47})\times 2^{77}=151115754614164973158400\)。</p>
<h3 id="字符类型">字符类型</h3>
<p>Java 的 char 类型占用两个字节，使用 Unicode 字符集，并且采用 UTF-16 编码方式。</p>
<p>一个 Unicode 字符在 UTF-16 编码中由 1 ~ 2 个代码单元组成，一个 char 值表示 UTF-16 编码中的一个代码单元。</p>
<p>char 类型可以使用转义序列 \u 表示，例如 \u0061 表示字符 a。\u 转义序列与其他转义序列不同，它可以出现在加引号的字符常量或字符串之外。如下所示，第一行代码中的 \u005B 和 \u005D 分别是 [ 和 ] 的编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String\u005B\u005D args)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是 Unicode 转义序列会在解析代码前进行处理。例如，下面的代码看上去是没有问题，但是有两个语法错误，因为 \u000A 会被替换为一个换行符，而 \user 会被视为非法的 Unicode 转义，因为 \u 后面没有跟着 4 个十六进制数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u000A is a newline</span></span><br><span class="line"><span class="comment">// look inside c:\user</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\u0022+\u0022&quot;</span>; <span class="comment">// 表示一个空串</span></span><br></pre></td></tr></table></figure>
<p><strong>思考：能否使用 <code>Character.isDigit</code> 方法判断字符是 0~9？能否使用 <code>Character.isLetter</code> 方法判断字符是 a~z 或 A~Z？</strong></p>
<p>在 Unicode 字符集中，数字和字母的范围更大。例如，\u0669 表示 Arabic-Indic 数字中的 9，但是不能将其和字符 9 等同，字符 9 的 Unicode 表示为 \u0039。同理，\u03c0 表示希腊字母 π，<code>Character.isLetter</code> 也会返回 <code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u0669&#x27;</span>;</span><br><span class="line">System.out.println(c); <span class="comment">// ٩</span></span><br><span class="line">System.out.println(Character.getNumericValue(c)); <span class="comment">// 9</span></span><br><span class="line">System.out.println(Character.isDigit(c)); <span class="comment">// true</span></span><br><span class="line">System.out.println(c == <span class="string">&#x27;9&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换">类型转换</h3>
<p><strong>思考：自动类型转换是否可能损失精度？什么情况下需要强制类型转换？</strong></p>
<p>（1）自动类型转换可能损失精度，例如之前提到 double 不能准确表示的最小正整数是 9007199254740993。支持的自动类型转换如下（图片参考《Java 核心技术 卷一》），损失精度一般都涉及到浮点数。</p>
<p><img src="/img/Java.assets/1665313955255.png" alt=""></p>
<p>（2）简单来说，将大范围类型转换为小范围类型，需要强制类型转换，反之则不需要。或者按照书中的表述，可能损失信息的转换，需要强制类型转换。</p>
<p><strong>思考：以下代码会发生几次类型转换？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>; x += y;</span><br></pre></td></tr></table></figure>
<p>使用 <code>javap -v</code> 反编译字节码，部分输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: lconst_1</span><br><span class="line">1: lstore_1</span><br><span class="line">2: dconst_1</span><br><span class="line">3: dstore_3</span><br><span class="line">4: lload_1</span><br><span class="line">5: l2d</span><br><span class="line">6: dload_3</span><br><span class="line">7: dadd</span><br><span class="line">8: d2l</span><br><span class="line">9: lstore_1</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure>
<p>可以发现，字面量 1 直接使用 lconst_1 和 dconst_1 获取，不会发生类型转换。而 <code>x += y</code> 相当于 <code>x = (long) (x + y)</code>，所以发生两次类型转换。</p>
<h2 id="类与接口">类与接口</h2>
<h3 id="包">包</h3>
<p>通常使用逆序的因特网域名作为包名，然后对不同工程使用不同的子包，以防止相同名字的类产生冲突。可以使用<strong>完全限定名</strong>访问其他包中的类，也可以使用 import 语句（位于 package 语句的后面）导入其他包中的类，然后就可以直接使用类名。当导入的包存在命名冲突时，仍然需要使用完全限定名。编译器将 java 文件编译为 class 文件后，class 文件中的字节码使用的都是完全限定名。</p>
<p>使用星号可以导入其他包中的所有类，但是不能使用星号导入多个包，例如 <code>import java.*</code> 或 <code>import java.*.*</code> 是不允许的。嵌套的包之间没有任何关系，每一个包都是独立的类集合。用星号导入某个包中的所有类后，使用其子包仍然需要显示导入。使用 import static 可以导入静态方法/静态字段。</p>
<h3 id="访问修饰符">访问修饰符</h3>
<p>常规类（非内部类）可以被 public 修饰或者无修饰符，字段和方法可以被所有修饰符修饰或者无修饰符。不同修饰符的访问级别如下（图片源自 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">Controlling Access to Members of a Class</a>）。</p>
<p><img src="/img/Java.assets/1739514664938.png" alt=""></p>
<ul>
<li>public：被修饰的类/字段/方法可以被任意类访问。特别的，一个源文件只能有一个 public 类，并且文件名必须和该类名相同。</li>
<li>protected：被修饰的字段/方法可以被所有子类和相同包中的类访问。需要注意，在不同包中，子类可以访问的是自身继承的 protected 字段/方法，而不能访问父类对象的（或者其他子类继承的） protected 字段/方法。（避免滥用保护机制，不能通过派生子类来访问父类对象的 protected 字段/方法）</li>
<li><em>no modifier</em>：无修饰符，类/字段/方法可以被相同包中的类访问。</li>
<li>private：被修饰的字段/方法可以被所属的类访问。</li>
</ul>
<p><strong>思考：private 字段一定不会被其他类访问到吗？（不使用反射）</strong></p>
<p>虽然 private 字段不能通过 <code>obj.field</code> 形式访问，但是如果 private 字段从某个方法暴露出去，则会被其他类访问到。</p>
<h3 id="对象与对象变量">对象与对象变量</h3>
<p>以下代码使用 new 关键字构造 Date 类型的对象，然后将该对象的引用（地址）赋值给 <code>deadline</code>，这个 <code>deadline</code> 就是对象变量（可以看作指针）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">deadline</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<h3 id="字段的初始化顺序">字段的初始化顺序</h3>
<p>静态字段：在类加载时，按照类中出现的顺序执行显式初始化和静态初始化块。</p>
<p>实例字段：首先执行默认初始化，然后按照类中出现的顺序执行显式初始化和初始化块，最后执行构造器代码。</p>
<p>父类字段：父类静态字段的初始化在子类静态字段之前，父类实例字段的初始化在子类实例字段之前。</p>
<h3 id="方法的重载和重写">方法的重载和重写</h3>
<p>重载方法是指在相同类中，方法名相同但参数类型不同的方法（返回值类型不重要）。方法名 + 参数类型被称为方法的签名。在进行方法调用时，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个匹配的方法，编译器就会报错。</p>
<p>重写方法是指子类重写（覆盖）父类的方法，重写方法通常会加上 @Override 注解。方法重写遵循以下规则：</p>
<ul>
<li>重写方法的可见性不能低于原方法。</li>
<li>重写方法的返回值类型可以改为原返回类型的子类型。</li>
<li>重写方法声明的异常不能比原方法声明的异常更通用。</li>
<li>父类的 static 方法不能被子类重写，但是可以被子类中相同签名的 static 方法隐藏。</li>
<li>参数数量可变的形参换成数组类型构成重写。</li>
</ul>
<p>如果重写方法的返回值类型是原返回类型的子类型，此时编译器会在子类中生成一个桥方法，该桥方法的返回值类型和原方法相同，并且桥方法会调用重写的方法。</p>
<p><strong>思考：方法参数是值传递还是引用传递？</strong></p>
<p>方法参数总是值传递，即方法得到的是参数的副本。对于基本类型，肯定是值传递。对于引用类型，只要明白对象和对象变量的区别，就可以知道引用类型也是值传递，因为对象变量（指针）的值就是对象的引用（地址）。</p>
<h3 id="继承和多态（向上转型）">继承和多态（向上转型）</h3>
<p>在 Java 中，类之间只支持单继承，而接口之间支持多继承。在子类的构造器中，可以使用 super 语句调用父类的构造器，该语句必须是子类构造器的第一条语句。如果子类的构造器没有显式地调用父类的构造器，将自动地调用父类的无参数构造器。如果父类没有无参数构造器，并且在子类的构造器中又没有显式地调用父类的其他构造器，Java 编译器就会报错。</p>
<p>一个对象变量可以指示多种实际类型的现象称为多态，在运行时能够自动地选择适当的方法，称为动态绑定。在将父类强制类型转换成子类之前，应该使用 instanceof 进行检查。否则，如果类型不符，将会产生类型转换异常。</p>
<p><strong>思考：方法调用的原理？解析和分派？字段没有多态性？（详细分析见《深入理解 Java 虚拟机》第 8 章）</strong></p>
<p>所有方法调用的目标方法在 Class 文件中都是一个常量池中的符号引用。在类加载的解析阶段就可以将符号引用解析为直接引用的方法被称为非虚方法，包括静态方法、私有方法、实例构造器、父类方法以及 final 方法。这类方法的调用被称为解析。</p>
<p>虚方法是指除非虚方法以外的方法，需要通过分派确定调用目标。重载方法是静态分派（重载解析）的，依据对象的外观类型（Apparent Type）来选择调用的方法。重写方法是动态分派的，依据对象的运行时类型（Runtime Type）来选择调用的方法。</p>
<p>字段没有多态性，访问字段依据的是当前方法所属的类或者外观类型。</p>
<h3 id="接口">接口</h3>
<ul>
<li>方法默认被 public abstract 修饰，字段默认且必须被 public static final 修饰。</li>
<li>可以使用 default 修饰符声明默认方法（必须是非静态的）。</li>
<li>在 Java 8 中，可以声明静态方法，静态方法只能通过接口调用，不能通过实现类及其对象调用。</li>
<li>在 Java 9 中，可以声明私有方法（用作其他方法的辅助方法），私有方法可以是静态方法或实例方法。</li>
</ul>
<p>在继承关系中，接口的默认方法有时会和其他类/接口的方法冲突，解决规则如下：</p>
<ul>
<li><strong>父类与接口冲突，父类优先。</strong> 如果父类的方法和接口的默认方法有相同签名，则接口中的默认方法会被忽略。</li>
<li><strong>接口与接口冲突，覆盖方法。</strong> 如果两个接口有相同签名的方法，并且其中一个接口的方法是默认方法，则必须覆盖这个方法来解决冲突。</li>
</ul>
<p>如果想要在实现类中显示调用接口中的默认方法，可以使用 <code>interfaceName.super.methodName(xxx)</code>。</p>
<h2 id="常用关键字">常用关键字</h2>
<h3 id="this">this</h3>
<p>每个实例方法都会有一个隐含的参数 this，表示当前对象的引用。在字节码中，实例方法的 args_size 至少是 1，就是因为 this 作为隐含的参数。</p>
<p>可以使用 this 调用当前对象的构造器、字段/方法。特别的，可以在内部类中使用 <code>OuterClass.this</code> 表示外部类的引用；在 lambda 表达式中，this 表示创建这个表达式的对象的引用（类似事实最终变量）。</p>
<h3 id="super">super</h3>
<ul>
<li>调用父类的构造器/方法，获取父类的字段。</li>
<li>调用接口的默认方法，<code>interfaceName.super.xxx()</code>。</li>
</ul>
<p>与 this 不同，super 不是对象的引用，不能将 super 赋给另一个对象变量。</p>
<h3 id="final">final</h3>
<ul>
<li>修饰类时，类不能被继承。</li>
<li>修饰方法时，方法不能被重写。</li>
<li>修饰字段/变量时，字段/变量必须被初始化。</li>
</ul>
<h3 id="static">static</h3>
<p>可以修饰字段/方法/初始化块/内部类，它们在类加载时被创建。当 static 修饰方法时，该方法不能访问实例字段、不能使用 this 和 super 关键字。import static 表示静态导入。</p>
<h3 id="abstract">abstract</h3>
<p>可以使用 abstract 关键字来声明抽象类/方法。abstract 不能修饰私有/静态方法，以及 final 方法/类。包含抽象方法的类必须被声明为抽象类，但是抽象类可以不包含抽象方法。</p>
<h2 id="常用类与接口">常用类与接口</h2>
<h3 id="Object">Object</h3>
<p>Object 类是 Java 中所有类的父类，可以使用 Object 类型的变量引用任何类型的对象。在 Java 中，只有基本类型不是对象，基本类型由于自动装箱可以赋值给 Object 类型的变量。数组类型没有重写 equals、hashcode 和 toString 方法，通常会借助 Arrays 工具类来执行这些操作。</p>
<h4 id="equals-方法">equals 方法</h4>
<p>Object 类中的 equals 方法比较两个对象的引用是否相等，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要比较两个对象的内容是否相等，需要覆盖 equals 方法，通用的实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断对象的引用是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断 otherObject 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断 this 与 otherObject 的类型是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将 otherObject 强制类型转换为相应的类型</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.使用 == 比较基本类型</span></span><br><span class="line">        <span class="comment">// 使用 Object.equals 比较除数组之外的引用类型</span></span><br><span class="line">        <span class="comment">// 使用 Arrays.equals 比较数组类型</span></span><br><span class="line">        <span class="comment">// 不使用 name.equals(other.name) 比较是为了避免空指针异常</span></span><br><span class="line">        <span class="comment">// 如果当前类的直接父类不是 Object，还需要调用 super.equals(other) 比较父类中的字段</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">                &amp;&amp; salary == other.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashCode-方法">hashCode 方法</h4>
<p>Object 类中的 hashCode 方法是本地方法，它根据对象的存储地址计算得出散列码。如果重新定义 equals 方法，那么就要为可能插入散列表的对象重新定义 hashCode 方法。且 equals 与 hashCode 的定义必须相容：如果 <code>x.equals(y)</code> 返回 true，那么 <code>x.hashCode()</code> 就必须与 <code>y.hashCode()</code> 相等。</p>
<h4 id="clone-方法">clone 方法</h4>
<p>Object 类中的 clone 方法为 protected 修饰的本地方法，执行的是浅拷贝。如果要使用 clone 方法，需要在类上实现 Cloneable 标记接口，同时指定 public 修饰符。</p>
<h3 id="String">String</h3>
<p>String 类对象是不可变的，我们只能改变 String 类型的对象变量的值（指针的指向），而不能改变对象本身。</p>
<p>字符串字面量是共享的，存储在常量池中。拼接两个非 final 的 String 对象变量以及执行 <code>substring</code> 操作得到的字符串不是共享的（存储在堆中）。拼接两个 final 的 String 对象变量，编译器会执行常量折叠优化，直接从常量池中获取字符串对象。</p>
<p><strong>思考：为什么说 String 类对象是不可变的？</strong></p>
<p>因为 String 类被 final 修饰不可继承，String 类的 <code>value</code> 字段被 private final 修饰且没有逸出，也没有提供修改该字段的方法（不论方法被什么访问修饰符修饰），String 类对象的 this 引用不会在构造器中逸出。</p>
<p><strong>思考：字符串拼接会有什么性能问题？编译器是如何优化字符串拼接 <code>+</code> 操作的？</strong></p>
<p>如果不优化，每次拼接都会创建一个新的 String 对象。在拼接多次的场景下，拼接产生的中间对象在拼接之后就不会使用，这会浪费创建对象的时间和空间。例如，在循环中拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;7&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s += s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果优化，很容想到使用 StringBuilder 类，在 Java 8 中编译器也是这么做的。但是，不推荐在循环中使用 <code>+</code> 拼接，因为编译器会在循环中创建 StringBuilder 对象。而在 Java 9 之后编译器会使用 invokedynamic 指令，优点是可以动态地选择拼接策略。（或许可以看下这篇<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-string-concatenation-invoke-dynamic">文章</a>）</p>
<h3 id="包装类">包装类</h3>
<p>所有的基本类型都有一个对应的包装类（不可变的）。在使用包装类时，可以直接当作基本类型操作，编译器在编译时会自动地插入装箱和拆箱指令。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y = <span class="number">2</span>, z = x + y;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1</span><br><span class="line">1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">4: astore_1</span><br><span class="line">5: iconst_2</span><br><span class="line">6: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">9: astore_2</span><br><span class="line">10: aload_1</span><br><span class="line">11: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">14: aload_2</span><br><span class="line">15: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">18: iadd</span><br><span class="line">19: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">22: astore_3</span><br><span class="line">23: return</span><br></pre></td></tr></table></figure>
<p>可以看到，编译器会调用 <code>Integer.valueOf</code> 装箱，调用 <code>obj.intValue()</code> 拆箱。似乎对包装类进行运算总是会拆箱转换为基本类型，然后将运算结果装箱，所以效率不是很高。为了提高性能，包装类会在静态初始化块中创建常用对象缓存池，缓存对象的范围如下：Boolean（true 和 false）、Byte | Short | Int | Long（-128 ~ 127）、Character（0 ~ 127），Float 和 Long 类不会缓存对象。</p>
<h3 id="比较器">比较器</h3>
<h4 id="Comparable-接口">Comparable 接口</h4>
<p>实现 Comparable 接口的类可以进行自然排序，该接口在 java.lang 包下。所谓自然排序，就是指排序时，默认会使用 Comparable 接口的 compareTo 方法排序，而定制排序需要在排序时需要显示传入实现 Comparator 接口的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>compareTo</code> 方法较当前对象与指定对象的大小关系，当前对象小于/等于/大于指定对象时，返回负整数/零/正整数。注意，返回值是 int 类型的整数。</p>
<p>文档建议 <code>CompareTo</code> 方法应当与 <code>equals</code> 方法兼容，即当 <code>x.equals(y) == true</code> 时，<code>x.compareTo(y)  ==  0</code>。特别的，BigDecimal 类不遵循该建议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.compareTo(y)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="Comparator-接口">Comparator 接口</h4>
<p>如果类的自然排序与需求不匹配，可以定义Comparator 接口的实现类，然后将类对象作为参数传入排序方法中，执行定制排序。Comparator 接口在 java.util 包下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类">枚举类</h3>
<p>可以使用 enum 关键字创建枚举类，枚举类的构造器默认且必须是私有的，所以在比较时可以直接使用 <code>==</code> 运算符。枚举类实例的定义必须在字段/方法的定义之前。枚举类默认是 Enum 类的子类，所以枚举类型不能显示继承其他类。源代码和反编译得到的字节码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Size</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Size&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size SMALL;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size MEDIUM;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size LARGE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size EXTRA_LARGE;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String abbreviation;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Size[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Size <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String <span class="title function_">getAbbreviation</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常">异常</h2>
<p>异常层次结构如下，异常被分为检查型异常和非检查型异常。非检查型异常：派生于 Error 类或 RuntimeException 类的所有异常。检查型异常：除非检查型异常以外的所有异常。</p>
<p><img src="/img/Java.assets/1665803216018.png" alt=""></p>
<p>一个方法必须声明（throws）或捕获（catch）所有可能抛出的检查型异常，而非检查型异常要么在控制之外（Error），要么从一开始就应该避免（RuntimeException），所以不应该声明。</p>
<p>处理异常的一般经验是，捕获知道如何处理的异常，而继续传播（throw）不知道怎样处理的异常。</p>
<h3 id="try-catch-finally">try-catch-finally</h3>
<p>使用规则：</p>
<ul>
<li>当 catch 捕获多个异常时，异常变量隐含为 final 变量。</li>
<li>可以在 catch 中使用 initCause 方法将原异常设置为新异常的原因，当捕获到新异常时，可以使用 getCause 方法获取原异常。</li>
<li>不论是否有异常被捕获，finally 中的代码都会在方法返回之前执行执行。</li>
<li>finally 用于清理资源，不要把改变控制流的语句（return，throw， break，continue）放在 finally 中。如果在 finally 中包含 return 语句，则 finally 中的 return 会在 try/catch 中的 return 或者 throw 之前执行，有可能会丢失异常。</li>
</ul>
<p><strong>思考：以下代码在未发生异常和发生异常情况下的返回值分别是多少？（示例源自《深入理解 Java 虚拟机》第 6 章）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果未发生异常，由于 try 在 finally 之前执行，所以返回值已经确定是 1。如果在 try 中发生 Exception 及其子类的异常，由于 catch 也在 finally 之前执行，所以返回值已经确定是 2。如果在 try 中发生其他异常，或者在 catch/finally 中发生任意异常，则方法非正常退出，没有返回值。</p>
<h3 id="try-with-resources">try-with-resources</h3>
<p>在 Java 7 中，如果资源实现了 AutoCloseable 接口，就可以使用 try-with-resources 语句处理资源。当 try 块退出时，会自动调用资源的 close 方法关闭资源。</p>
<p>使用规则：</p>
<ul>
<li>catch 和 finally 在资源关闭之后执行。</li>
<li>在 Java 9 中，允许在 try 首部中使用之前声明的 final 或 effective final 变量。</li>
<li>如果 try 和 close 都抛出异常，则 close 方法抛出的异常会被抑制，并由 addSuppressed 方法添加到 try 的抛出的异常对象中。如果想查看被抑制的异常，可以使用 getSuppressed 方法获取被抑制的异常数组。</li>
</ul>
<h2 id="泛型">泛型</h2>
<h3 id="基本概念">基本概念</h3>
<p>使用泛型的目的是什么？如果不使用泛型，可以向集合类中添加任何类型的对象，并且读取时需要类型判断和强制类型转换。所以，使用泛型的目的是允许编译器进行类型检查，以及避免频繁地强制类型转换。</p>
<p>定义泛型类 <code>class C&lt;T&gt;</code>，定义泛型方法 <code>public static &lt;T&gt; void m(T x)</code>。</p>
<p>Java 库使用参数 E 表示集合的元素类型，K 和 V 分别表示表的键和值的类型，T（或者 U 和 S）表示任意类型。</p>
<p>可以使用 extends 关键字对类型参数进行限定 <code>&lt;T extends BoundingType&gt;</code>，表示 T 是限定类型（bounding type）的子类型（subtype），T 和限定类型可以是类或接口。</p>
<p>一个类型参数或通配符可以有多个限定，限定类型用 &amp; 分隔，而类型参数用逗号分隔。如果有一个类作为限定，它必须是限定列表中的第一个限定。</p>
<h3 id="类型擦除">类型擦除</h3>
<p>在虚拟机中没有泛型类型，所有对象都属于普通类。无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，这个原始类型的名字就是去掉类型参数后的泛型类型名。类型参数会在编译时被擦除，替换为第一个限定类型，对于无限定的类型参数则替换为 Object 类型。</p>
<p>需要注意，如果将限定 &lt;T extends Comparable &amp; Serializable&gt; 换为 &lt;T extends Serializable &amp; Comparable&gt;，会用 Serializable 替换 T，而这会导致在调用 compareTo 方法时进行额外的强制类型转换。为了提高效率，应该将标记接口放在限定列表的末尾。</p>
<p>（1）当调用的泛型方法的返回类型被擦除，编译器会插入强制类型转换（checkcast 指令）。</p>
<p>（2）编译器会生成桥方法，来避免类型擦除和多态之间的冲突。假设泛型类 <code>Class A&lt;T&gt;</code> 有个方法 <code>public void m(T x)</code>，那么它的子类在继承时指定 <code>Class B extends A&lt;Integer&gt;</code>，对应的重写方法是 <code>public void m(Integer x)</code>。类型擦除之后，两个方法的签名不同不构成重写，所以编译器会在子类中生成 <code>public void m(Object x)</code> 方法作为代理（构成重写），从而解决冲突。</p>
<h3 id="泛型的限制和继承规则">泛型的限制和继承规则</h3>
<p>使用限制：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html">Restrictions on Generics</a>。</p>
<p>继承规则：无论 S 与 T 有什么关系，通常 <code>Pair&lt;S&gt;</code> 与 <code>Pair&lt;T&gt;</code> 都没有任何关系（偏序）。</p>
<p><img src="/img/Java.assets/1665996674774.png" alt=""></p>
<h3 id="通配符的限定">通配符的限定</h3>
<p>子类限定 <code>&lt;? extends Type&gt;</code>，将泛型对象的类型参数限制为 Type 类型或其子类型。此时，如果类型参数作为方法参数，只能传入 null，因为不知道该传入具体哪个子类。如果类型参数作为返回值，只能将返回值赋值给 Type 类型或其父类型的变量（向上转型）。</p>
<p>父类限定 <code>&lt;? super Type&gt;</code>，将泛型对象的类型参数限制为 Type 类型或其父类型。此时，如果类型参数作为方法参数，只能传入 Type 类型或其子类型的变量（向上转型）。如果类型参数作为返回值，只能将返回值赋值给 Object 类型的变量，因为只有 Object 必定是该类型参数的父类。</p>
<p>无限定 <code>&lt;?&gt;</code>，不限制泛型对象的类型参数。此时，如果类型参数作为方法参数，只能传入 null，因为不知道该传入具体哪个类。如果类型参数作为返回值，只能将返回值赋值给 Object 类型的变量，因为只有 Object 必定是该类型参数的父类。</p>
<p>PECS（Producer Extends，Consumer Super）原则：读取数据使用子类限定，写入数据使用父类限定。</p>
<p>自限定的类型 <code>class SelfBound&lt;T extends SelfBound&lt;T&gt;&gt;</code>，SelfBound 的类型参数 T 限定为 <code>SelfBound&lt;T&gt;</code> 的子类。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;A&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;A&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;B&gt; &#123;...&#125; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，A 继承 <code>SelfBound&lt;A&gt;</code> ，使得 A 可以作为 SelfBound 的类型参数。而 B 没有继承 <code>SelfBound&lt;B&gt;</code>，所以不能将 B 作为 SelfBound 的类型参数。使用自限定的类型，目的是保证 SelfBound 类的类型参数为当前定义的类（例如 A）。虽然 B 继承的 SelfBound 类的类型参数是 A 而不是当前定义的 B，但是一般情况下并不会这样使用。</p>
<p>如果看不懂，可以考虑没有自限定类型的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfBound</span>&lt;T&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;Any-Type&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果 SelfBound 没有自限定，A 类在继承 SelfBound 时，类型参数可以是任意类型。</p>
<h2 id="反射">反射</h2>
<p>反射是 Java 中的一项功能，允许程序在运行时分析类，并且操纵其内部属性。（<a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/javareflection.html">Using Java Reflection</a>）</p>
<p>一个 Class 对象表示一个类型，包括类类型（包括数组类型）、接口类型、基本类型和 void。每个类型的 Class 对象是唯一的，所以可以直接使用 <code>==</code> 运算符比较。</p>
<p>获取 Class 对象的方式如下：使用 <code>obj.getClass()</code> 方法获取对象运行时类型的 Class 对象，使用 <code>Class.forName(xxx)</code> 方法获取指定类的 Class 对象。如果 T 是任意的 Java 类型或 void 关键字，<code>T.class</code> 将代表对应的 Class 对象。特别的，使用 <code>.class</code> 获取 Class 对象的引用时，不会初始化该 Class 对象表示的类，而前两种方式会进行初始化。（类加载的过程：加载、链接和初始化）</p>
<h2 id="注解">注解</h2>
<p>可以使用注解（也被称为元数据）在代码中提供额外的信息，然后这些信息可以在编译时解析或运行时利用反射获取。</p>
<h3 id="定义注解">定义注解</h3>
<p>注解的定义类似接口，区别在于需要再 interface 关键字之前加上 @ 符号。声明元素需要在元素名之后加上 <code>()</code>，可以使用 default 关键字为元素指定默认值。注解元素的类型限制：基本类型、String、Class、枚举类型、注解类型，以及由这些类型组成的一维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Demo &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的注解都隐式的继承自 java.lang.annotation.Annotation 接口。如果反编译上述注解的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，注解就是接口，默认继承自 Annotation 接口。而且在其中定义的元素实际上是接口中的抽象方法，只是可以使用 default 指定默认值。</p>
<h3 id="使用注解">使用注解</h3>
<p>在定义注解时，如果没有为元素指定默认值，则在使用时需要显示的赋值；否则，可以不显示赋值，自动使用默认值。注解元素的值必须是编译期常量，并且不能设置为 null。如果元素值是一个数组，那么要将它的值用 <code>&#123;&#125;</code> 括起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationName(elementName1 = value1, elementName2 = value2, ...)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标记注解：如果注解没有任何元素或者所有元素都提供了默认值，则在使用注解时可以不需要括号。</li>
<li>单值注解：如果注解只有一个名为 <code>value</code> 的元素，则在指定该元素的值时，可以忽略元素名以及赋值运算符。</li>
</ul>
<h3 id="内置注解">内置注解</h3>
<h4 id="元注解">元注解</h4>
<p>@Target：指定注解适用的上下文。@Retention：指示注解的保留时长，默认的保留策略为 <code>CLASS</code>。SOURCE 注解将被编译器丢弃。CLASS 注解将由编译器记录在类文件中，但会被 VM 丢弃。RUNTIME 注解将在运行时由 VM 保留，可以使用反射机制读取注解信息。</p>
<p>@Documented：指示将注解包含在 Java 文档中。@Inherited：允许子类继承父类中的注解，当被修饰的注解作用于类时，该元注解才有效。@repeatable：指示注解可以在同一上下文重复使用。</p>
<ul>
<li>字段和方法上的注解只要没有被覆盖，就会被继承（前提是字段和方法会被继承）。</li>
<li>接口上的注解永远都不会被继承，类上的注解只有在使用 @Inherited 时才会被继承。</li>
</ul>
<h4 id="标准注解">标准注解</h4>
<p>@Overried：指示当前方法将覆盖父类中的方法或实现接口中的方法。@Deprecated：指示目标被弃用。@SuppressWarnings：抑制目标中给定类型的编译器警告。@SafeVarargs：指示将会安全地操作可变参数。@FunctionalInterface：指示接口为函数式接口。</p>
<h2 id="I-O-流">I/O 流</h2>
<h3 id="字节流">字节流</h3>
<p>所有字节流都继承自 InputStream/OutputStream 抽象类，FileInputStream/FileOutputStream 是基本的字节流。FilterInputStream/FilterOutputStream 内部使用其他字节流对象作为数据来源，没有提供额外的功能，但是其子类会通过重写方法来提供额外的功能。</p>
<p>BufferedInputStream/BufferedOutputStream 对流使用缓冲区技术，每次向流读取/写入时，不必每次都进行实际的物理读取/写入操作。DataInputStream/DataOutputStream 允许从流读取/写入基本数据类型。PrintStream 支持格式化输出。</p>
<p><img src="/img/Java.assets/1666426524566.png" alt=""></p>
<p><img src="/img/Java.assets/1666426696517.png" alt=""></p>
<p>ByteArrayInputStream/ByteArrayOutputStream 对字节数组进行读取/写入，由于没有使用到文件，所以不需要对该流执行关闭操作。ObjectInputStream/ObjectOutputStream 见序列化。</p>
<h3 id="字符流">字符流</h3>
<p>所有字符流都继承自 Reader/Writer 抽象类，字符流内部都是基于字节流的。在使用字符流时，注意保证字符的编码和解码方式的一致性。InputStreamReader/OutputStreamWriter 是字节流和字符流之间的桥梁。FileReader/FileWriter 内部使用 FileInputStream，是使用 InputStreamReader/OutputStreamWriter 的快捷方式。</p>
<p><img src="/img/Java.assets/1666427056449.png" alt=""></p>
<p>BufferedReader/BufferedWriter 对流使用缓冲区技术，每次向流读取/写入时，不必每次都进行实际的物理读取/写入操作。PrintWriter 是使用 BufferedWriter 的快捷方式，并且支持格式化输出。</p>
<h3 id="标准-I-O-和-NIO">标准 I/O 和 NIO</h3>
<p><a target="_blank" rel="noopener" href="http://System.in">System.in</a> 的类型是 InputStream，System.out 和 System.err 的类型是 PrintStream。可以使用 System 中的 setIn、setOut 和 setErr，对标准 I/O 进行重定向。</p>
<h3 id="对象序列化">对象序列化</h3>
<p>序列化就是将对象转换为字节序列的形式，在通过网络传输对象或者将对象存储到磁盘时会进行序列化操作，反序列化同理。需要实现 Serializable 接口以支持对象序列化，可以使用 transient 关键字关闭某个字段的序列化。</p>
<p>在序列化时，会生成对象的序列号（单个序列化流中使用）和类的序列化版本号（serialVersionUID）。如果在相同序列化流中将一个对象序列化两次，那么反序列化将得到两个相同的对象。生成的序列化版本号是类的指纹，使用 SHA 计算结果的前 8 个字节表示。在反序列化时，会比较存储的指纹和当前指纹，如果不匹配就说明对象所属类的定义在序列化该对象后修改过，从而会产生 InvalidClassException 异常。此时，如果想要反序列化成功，就需要在类的定义中添加旧版本类的指纹，以此表明它对旧版本兼容。</p>
<p>使用 ObjectOutputStream 的 writeObject 方法将对象序列化，ObjectInputStream 的 readObject 方法将对象反序列化。反序列化时，要保证序列化对象所属的类在类路径中，否则在类型转换时会抛出 ClassNotFoundException 异常。</p>
<p>可以实现 Externalizable 接口对序列化的过程进行控制，该接口继承自 Serializable 接口。</p>
<ul>
<li>Serializable：将对象完全序列化，并且反序列化时不会调用构造器。</li>
<li>Externalizable：序列化时调用 writeExternal 方法序列化字段，反序列化时首先调用公共的无参构造器，然后调用 readExternal 方法反序列化字段。</li>
</ul>
<p>如果不想实现 Externalizable 接口，还可以在类中定义 writeObject/readObject 方法，方法会在序列化/反序列化时自动调用。方法需要按照如下格式定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果想在 writeObject/readObject 方法中使用默认的序列化/反序列化机制，可以在其中调用 ObjectOutputStream/ObjectInputStream 的 defaultWriteObject/defaultReadObject 方法。</p>
<p><strong>思考：序列化单例有什么问题？如何解决？</strong></p>
<p>如果将单例序列化，在反序列化时将得到不同的对象。解决方案是，在 readResolve 方法中返回单例对象，该方法会在反序列化时被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器">容器</h2>
<p>集合类会以内部类的形式实现 Iterator 接口。Collection 接口继承自 Iterable 接口，所以可以使用 Iterable 接口中的 iterator 方法获取 Iterator 对象来遍历集合。Map 接口的 entrySet 方法会返回 Collection 类型的对象，所以也支持迭代器遍历。</p>
<p><img src="/img/Java.assets/1666684482708.png" alt=""></p>
<p><img src="/img/Java.assets/1666684780700.png" alt=""></p>
<h3 id="Collection">Collection</h3>
<h4 id="List">List</h4>
<p>List 表示有序集合，可以存储重复的元素。</p>
<h5 id="ArrayList">ArrayList</h5>
<p>ArrayList 是支持动态扩容的数组，它的底层是一个 Object 类型的数组，所以可以存放任何类型的元素。</p>
<p>虽然底层数组的默认初始容量是 10，但是如果在创建时没有指定容量，并不会立即创建容量为 10 的数组，而是将创建数组的操作延迟到添加元素时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 transient 关键字修饰数组字段，表示不自动序列化，而是在 writeObject 方法中自定义序列化方式。因为数组元素数量小于等于数组容量，只序列化有效元素可以减少空间占用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
<h5 id="LinkedList">LinkedList</h5>
<p>LinkedList 的底层是一个双向链表，实现自 List 和 Deque 接口。</p>
<p>使用 get 方法获取指定索引的值时，会根据索引是否小于链表长度的一半，来决定正序或倒序遍历。如果使用默认序列化，则会丢失头节点和尾节点之间的所有节点，所以使用 transient 修饰相关字段，然后手动序列化链表元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h4 id="Set">Set</h4>
<p>Set 表示没有重复元素的集合。HashSet 的底层是 HashMap，只是所有的 value 都是相同的单例对象。LinkedHashSet 的底层是 LinkedHashMap，TreeSet 的底层是 TreeMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Map">Map</h3>
<h4 id="HashMap">HashMap</h4>
<p>HashMap 的底层是数组 + 链表/红黑树，不能保证迭代的顺序，遍历的时间与哈希表的容量和元素数量成正比。</p>
<p>默认容量是 16，负载因子是 0.75。在构造器中，不会创建底层数组，只会将负载因子和阈值初始化，数组的创建延迟到添加元素时。在源代码中，threshold 不只是存储阈值，在构造器中还会临时存储容量，该值会在初始扩容时使用。</p>
<p>当桶中的节点数量大于等于 8 时，如果哈希表的容量小于 64，会执行扩容操作，否则会将链表转为红黑树（树化）。当桶中的节点数量小于等于 6 时，会将红黑树转为链表（取消树化）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>计算哈希值时会将高位和低位异或，因为哈希表的容量总是 2 的幂，计算索引值时高位变化不会引起索引变化，从而会产生严重的哈希冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当元素数量大于扩容阈值时（容量和负载因子的乘积），会将容量扩容为原来的 2 倍。由于容量是 2 倍的关系，所以元素的索引值要么不变，要么加上旧容量的大小，取决于 <code>e.hash &amp; oldCap</code> 的值。</p>
<h4 id="LinkedHashMap">LinkedHashMap</h4>
<p>LinkedHashMap 具有确定的迭代顺序，默认是按插入顺序遍历。底层是哈希表 + 双向链表，遍历的时间只与元素数量成正比（通过双向链表遍历）。双向链表使用尾插法，头节点表示最早插入/访问的节点，尾节点表示最近插入/访问的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表的元素排列方式</span></span><br><span class="line"><span class="comment">// false 按插入顺序排列（默认）</span></span><br><span class="line"><span class="comment">// true 按访问顺序排列（实现 LRU 算法）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap 添加元素的方法继承自 HashMap，但是以下方法被重写，用于实现双向链表的排列和淘汰策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是按访问顺序排列，则将访问的结点移动到链表尾部</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在插入元素后调用，内部调用 removeEldestEntry 方法，用于实现淘汰策略</span></span><br><span class="line"><span class="comment">// removeEldestEntry 方法默认返回 false，即不会进行淘汰</span></span><br><span class="line"><span class="comment">// 可以重写该方法结合 accessOrder = true，来实现 LRU 淘汰策略</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-31T16:00:00.000Z" title="2023/1/1 00:00:00">2023-01-01</time>发表</span><span class="level-item"><time dateTime="2025-02-24T13:26:12.566Z" title="2025/2/24 21:26:12">2025-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></span><span class="level-item">35 分钟读完 (大约5219个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/01/Java%20%E5%B9%B6%E5%8F%91%20&amp;%20%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java 并发 &amp; 虚拟机</a></p><div class="content"><h2 id="基本概念">基本概念</h2>
<p>并发和并行：关于并发和并行的含义其实存在一些争议，但无非是定义不同。比较常见的说法，并发是指多个任务在单核 CPU 上分时执行，并行是指多个任务在多核 CPU 上同时执行。另一种说法，并发是指多个任务的执行在时间上重叠，在单核 CPU 上表现为分时执行，在多核 CPU 上表现为并行执行，并行是并发的子集。（当然还有其他说法，挺无聊的）另外，在单线程中也可以做到并发，例如 I/O 多路复用。</p>
<p>同步和异步：同步方法在方法执行完成之后才返回，异步方法可以在方法执行完成之前返回。异步方法只意味着非阻塞调用，并不一定是在另一个线程中执行。例如 C# 的 async 方法是在当前线程中执行，在遇到 await 时会将方法的剩余部分注册为<em>延续</em>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuation">continuation</a>），然后将控制权返回到方法的调用者，同时返回一个 Task 类型的对象，此时方法的调用者可以执行其他不依赖于方法结果的操作，从而避免阻塞。在 await 任务完成之后，延续会在线程池线程或者原始线程中执行。（参考 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model">Task asynchronous programming model</a>）</p>
<p>以上关于单线程中并发和异步的示例，在基于事件的系统中都有体现。事件循环在单个线程中接收和处理事件，通常使用 I/O 多路复用接收事件，使用异步 I/O 实现非阻塞。可以使用轮询判断异步 I/O 是否完成，更好的做法是使用 UNIX 信号在异步 I/O 完成时通知应用程序。如果要在异步 I/O 完成之后执行某些操作，通常会使用一种称为<em>延续</em>的数据结构，记录完成该事件需要的信息。（推荐阅读《OSTEP》第 33 章 基于事件的并发）</p>
<p><strong>思考：什么是死锁？产生条件？如何预防（Prevention）、避免（Avoidance）和检测死锁？</strong></p>
<p>死锁简单来说就是 ABBA 问题，即持有资源 A 的线程要获取资源 B，而持有资源 B 的线程也要获取资源 A。产生死锁的条件：互斥，持有并等待，非抢占，循环等待。死锁避免要求知道全局信息，根据信息来判断分配资源是否会发生死锁，例如银行家算法。死锁检测可以通过构建等待图，然后判断图中是否有环来实现。</p>
<p>死锁预防：① 消除循环等待：使用一致的加锁顺序（全序/偏序），例如根据锁的地址获取锁，或者根据对象的哈希值获取锁。② 消除持有并等待：在执行操作之前原子地获取所有锁，但是很难做到且会有性能问题。③ 消除非抢占：使用 tryLock + unlock 的方式获取锁，但是会有活锁问题（可以通过随机化等待时间来避免），以及需要回滚中间执行的操作。④ 消除互斥：使用非阻塞算法（利用 CAS 原子指令）。</p>
<h2 id="并发包">并发包</h2>
<h3 id="同步器">同步器</h3>
<p>AbstractQueuedSynchronizer（AQS）为实现依赖 FIFO 等待队列（以链表形式实现）的同步器提供框架。AQS 使用 int 类型的整数表示状态，使用获取（acquire）和释放（release）操作修改状态。状态以及获取和释放的含义由同步器决定：在 ReentrantLock 中表示重入次数；在 Semaphore 中表示剩余的许可数量；在 ReentrantReadWriteLock 中，高 16 位表示读锁计数，低 16 位表示写锁计数。AQS 内部使用 LockSupport 实现线程的阻塞和唤醒，内部使用类似信号量的许可机制（最多一个许可），即使在 unpark 之后调用 park 也不会导致阻塞。</p>
<p>相比 synchronized 关键字，ReentrantLock 提供可中断锁、定时锁和公平锁，以及支持等待多个条件，但是需要在 finally 中显示地执行解锁操作。公平锁和非公平锁的区别是能否插队，当有其他线程在队列中等待时，公平锁总是会将当前加锁线程入队，而非公平锁会尝试加锁，从而避免更多的上下文切换。</p>
<p>Semaphore 提供指定数量的许可，允许多个线程访问资源。ReentrantReadWriteLock 提供可重入的读写锁，允许在持有写锁的情况下获取读锁，从而实现锁降级（写锁降级为读锁），不支持锁升级（读锁升级为写锁），适用于读多写少的场景。不支持锁升级是因为，如果两个读线程同时进行升级（由于读锁是共享锁），则会发生死锁。</p>
<p>CountDownLatch 允许一个或多个线程等待，直到一组操作完成，计数不能被重置。CyclicBarrier 允许一组线程等待彼此到达屏障，当所有线程到达屏障之后，会执行设置的 barrierAction 动作，然后唤醒所有线程，重置计数器。以上提到的同步器只有 CyclicBarrier 基于 ReentrantLock 实现，其他都是直接基于 AQS 实现的。</p>
<h3 id="线程池">线程池</h3>
<p>创建线程的方式有三种：继承 Thread 类 + 重写 run 方法；实现 Runnable 接口；实现 Callable 接口，然后构造 FutureTask 对象，FutureTask 实现自 RunnableFuture 接口，所以也可以看作 Runnable 对象。</p>
<p>使用线程池的目的是复用线程，避免创建/销毁线程的开销，以及控制线程的数量。过多的线程会占用大量内存，而且不一定能提高系统的性能，因为 CPU 核心数有限（对于 CPU 密集型负载来说）。Executors 工具类提供创建线程池的工厂方法，可以创建固定/动态大小（ThreadPoolExecutor）、支持计划任务（ScheduledThreadPoolExecutor）、支持工作窃取和分解任务（ForkJoinPool）的线程池。</p>
<p>线程池通常会使用队列存放任务（Runnable 类型），队列可以分为同步队列、有界队列和无界队列。当线程池的线程数量达到设置的最大值，且队列已满（不是无界队列），则会执行拒绝策略。JDK 内置的拒绝策略有：抛出异常、丢弃当前任务、丢弃最早的任务、在当前线程执行该任务。</p>
<p>当线程池的线程数量超过 corePoolSize 时，空闲线程在超时之后被销毁。如果使用 ExecutorService 的 submit 提交任务，需要注意异常会被捕获到返回的 Future 对象中。如果没有任务，在 corePoolSize 范围内的线程会在获取任务时被阻塞队列阻塞。如果要终止线程，可以调用 shutdown 方法，然后可以调用 awaitTermination 等待。</p>
<h3 id="并发容器">并发容器</h3>
<p>可以使用 <code>Collections.synchronizedxxx()</code> 方法获取线程安全的容器，但是获取的容器只是简单地对所有方法使用 synchronized 关键字来实现线程安全。CopyOnWriteArrayList 读操作不需要加锁，写操作加锁且不会修改原数组，而是执行写时复制（COW）。ConcurrentLinkedQueue 是非阻塞的无界队列，没有使用锁而是只用 CAS 实现线程安全。</p>
<p>ArrayBlockingQueue 是有界阻塞队列，使用单个的 ReentrantLock 实现线程安全，使用两个 Condition（notEmpty 和 notFull）实现阻塞等待，不过也可以调用非阻塞的方法（在队列满/空时直接返回 false/null）。LinkedBlockingQueue 是无界阻塞队列，使用两个 ReentrantLock（putLock 和 takeLock）实现线程安全，同样使用两个 Condition 实现阻塞等待。</p>
<p>可以使用 Unsafe 或者 VarHandle 实现 CAS 操作。AtomicInteger 使用 CAS 保证原子性，AtomicStampedReference 使用版本号解决 CAS 的 ABA 问题，AtomicIntegerArray 提供原子修改数组的方法，AtomicIntegerFieldUpdater 使用反射和 Unsafe 提供对 volatile 字段原子更新的方法。</p>
<p>如果要设计线程安全的哈希表，最简单的方式是使用 synchronized 关键字修饰所有方法，但是并发性很差。首先，可以想到减少锁的粒度，将单个独占锁分解为每个桶一个锁（结合 CAS 提高性能）。但是，计数操作会修改共享变量，如果使用独占锁将成为性能瓶颈。如果使用原子变量进行计数，在高并发下性能不会更好，由于缓存失效以及频繁的重试。解决方案依然是减少锁的粒度，可以使用类似 LongAdder 的做法。接下来可以思考扩容问题，多个线程辅助扩容可以加快速度，基本上 ConcurrentHashMap 就是这样设计的。</p>
<h2 id="锁优化">锁优化</h2>
<p><strong>思考：减少锁竞争的方式有哪些？</strong></p>
<p>减小锁的范围，减小锁的粒度，读写锁/读写分离，线程私有。</p>
<p>ThreadLocal 的构造函数是空的，所以创建的对象没有和线程绑定，只有当调用 get/set 方法之后才会绑定。实际上，Thread 类有一个 ThreadLocalMap 类型的实例字段，set 方法会获取当前 ThreadLocal 对象的哈希值，使用 WeakReference 类型的数组存储 key/value（类似 WeakHashMap），key 就是 ThreadLocal 对象，value 就是 set 的参数。（该哈希表使用的是开放寻址法处理冲突）</p>
<p>通常所说的 ThreadLocal 存在内存泄露问题是指，当不再使用设置的 value 时（假设是很大的对象），如果存在该 ThreadLocal 的强引用，或者即使该 ThreadLocal 对象已经被回收，但是之后没有对 ThreadLocalMap 做操作，依然无法回收 value 对象。因为 ThreadLocalMap 的 Entry 对 value 有强引用，而只有在执行下一次 set/remove 操作时，该 Entry 以及 Entry 的 value 才会变为不可达的，所以最好在不使用时显式地执行 remove 操作。</p>
<p><strong>思考：HotSpot 虚拟机对 synchronized 的优化有哪些？（详见《深入理解 Java 虚拟机》第 13 章）</strong></p>
<p>自适应的自旋：动态调整自旋的时间，尽量避免重量级锁（互斥锁）的上下文切换开销，以及避免自旋过久占用 CPU 资源的开销。</p>
<p>锁消除：虚拟机在即时编译时，对不可能发生竞争的锁进行消除（依赖逃逸分析）。</p>
<p>锁粗化：如果连续地对相同对象加锁再解锁，会导致不必要的性能损耗，此时虚拟机会加大锁的范围（合并锁）。</p>
<p>轻量级锁：当目标对象没有被锁定，虚拟机会使用 CAS 获取对象的轻量级锁，目的是避免重量级锁的上下文切换开销。如果目标对象被轻量级锁定，那么自旋一段时间，超时之后升级为重量级锁。或者，如果有两个线程在等待获取轻量级锁，那么将锁升级为重量级锁。（轻量级锁本质上是复制对象的 Mark Word 到当前线程的栈帧中，然后使用 CAS 修改该对象的 Mark Word）</p>
<p>偏向锁：对象锁会偏向第一个加锁的线程，目的是减少无竞争情况下轻量级锁的 CAS 开销。即如果线程 A 对某个对象加锁（使用 CAS 修改 Mark Word），且该对象是第一次被加锁，那么线程 A 之后再次获取该对象锁时就不需要执行实际的加锁操作。但是，只要有其他线程尝试获取该对象的锁，那么偏向锁就会被撤销，变为未锁定或者轻量级锁定状态。（简单来说是这样，当然还有重偏向，以及如果调用过未重写的 <code>Object::hashCode()</code> 方法就不能偏向，之类的东西）</p>
<p><img src="/img/Java.assets/1739791027609.png" alt=""></p>
<p><img src="/img/Java.assets/1739791097135.png" alt=""></p>
<p><strong>思考：轻量级锁和偏向锁优化什么情况下可以提升性能？什么情况下会降低性能？</strong></p>
<p>轻量级锁和偏向锁都假设锁竞争发生的概率很小，如果真的发生（激烈的）锁竞争，那么轻量级锁和偏向锁很快就会升级为重量级锁，“优化”反而会额外增加轻量级锁 CAS 操作的开销以及撤销偏向的开销。</p>
<p>在 Java 15 中，偏向锁已弃用，详见 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/374">JEP 374: Deprecate and Disable Biased Locking</a>。主要原因是偏向锁的实现代码复杂且具有侵入性，妨碍 HotSpot 虚拟机中同步系统设计的更改，以及在当前环境下偏向锁的适用范围有限。</p>
<h2 id="内存区域">内存区域</h2>
<p>简单来说：程序计数器存储当前执行的字节码指令的地址；栈存储方法级别的数据，方法调用会创建栈帧，存储局部变量、返回地址等数据，有虚拟机栈和本地方法栈两种；堆存储对象数据；方法区也被称为类区，存储类级别的数据，包括类的字节码、静态变量和常量（在运行时常量池中）等数据。</p>
<p><img src="/img/Java.assets/1739842236364.png" alt=""></p>
<p><strong>思考：HotSpot 虚拟机使用 new 关键字创建对象的过程？对象在堆中的内存布局？</strong></p>
<p>检查 new 指令的参数是否在运行时常量池中有对应的符号引用，然后检查该符号引用代表的类是否执行过类加载（区分类加载和加载，类加载包括加载、链接和初始化）。如果类加载完成，则为对象分配内存（使用 CAS + 重试保证原子性，或者使用线程私有内存），然后设置对象头。最后调用构造器执行初始化。</p>
<p>对象存储在堆中，由对象头、实例数据和对齐填充组成。对象头存储运行时数据（Mark Word）和指向类型元数据的指针。实例数据存储字段值，包括继承的字段，默认相同宽度的字段会被存放在一起，在该前提下父类字段会在子类之前。对齐填充的作用是内存对齐，HotSpot 虚拟机使用的是 8 字节对齐。</p>
<h2 id="垃圾收集">垃圾收集</h2>
<h3 id="基本概念-2">基本概念</h3>
<p>由于程序计数器、虚拟机栈和本地方法栈是线程私有的，占用的内存随方法返回或者线程结束而回收，所以不是垃圾收集器关注的重点。而堆和方法区是线程共享的，占用的内存何时回收是动态的，垃圾收集器会通过可达性分析判断什么对象可以回收。</p>
<p>最简单的想法是使用引用计数判断对象是否可以被回收，但是无法处理循环引用的问题。所以，通常是通过图的可达性分析来判断对象是否可以被回收，实际上就是维护一个可达的 GC Roots 的对象集，如果某个对象从 GC Roots 不可达，那么该对象就可以被回收。</p>
<p>引用类型：强引用、软引用、弱引用和虚引用。除强引用外的其他引用都对应一个继承自 Reference 抽象类的类，可以存储对其他对象的引用（称为 referent）。简单来说，强可达的对象不会被回收，软可达的对象会在内存溢出之前被回收，弱可达的对象会在下次垃圾收集时被回收，虚可达的对象已经是 finalized 的，不可达的对象可以被回收。（参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ref/package-summary.html">java.lang.ref</a> 文档）</p>
<p><strong>思考：什么是 finalization 机制？finalize 方法为什么被弃用？</strong></p>
<p>当对象不可达时，如果对象没有重写 finalize 方法，则对象可以直接被回收。如果对象已重写 finalize 方法且该方法没有被调用过，则对象是 finalizable 的。虚拟机的 Finalizer 线程会将该对象加入队列排队，等待调用其 finalize 方法，调用之后对象是 finalized 的。如果对象是 finalized 且依然不可达，那么对象就会被回收变为 reclaimed。</p>
<p>垃圾收集器至少需要两个周期才能回收 finalizable 对象，并且被该对象引用的所有不可达对象会被保留，直到该对象被回收。此外，JVM 不保证会调用所有 finalizable 对象的 finalize 方法。（推荐阅读 <a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/javase/finalization.html">How to Handle Java Finalization’s Memory-Retention Issues</a>）</p>
<p>finalization 机制存在问题，会导致性能问题、死锁和挂起。finalizer 的错误可能导致资源泄露；没有办法取消 finalization；不同对象的 finalize 方法调用之间没有指定的顺序。此外，无法保证 finalization 的完成时间。finalize 方法只能在 finalizable 对象上经过不确定的延迟之后调用。（参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()">finalize</a> 文档）</p>
<h3 id="回收算法">回收算法</h3>
<p>分代收集理论：假设对象存活概率随对象年龄（经历垃圾收集的次数）的增加而增加，且跨代引用很少发生，则可以根据对象年龄，将堆划分成不同的区域（例如，新生代和老年代），然后使用不同的频率进行回收。相对于扫描所有对象而言，能够有效减少时间开销。</p>
<h2 id="类加载机制">类加载机制</h2>
<p>类的生命周期有 7 个阶段，各个阶段通常是交叉混合执行的，解析阶段可能在初始化之后开始。通常所说的类加载是指加载、连接和初始化。简单来说，加载阶段将类加载到方法区，验证阶段验证字节码是否符合规范，准备阶段执行静态字段的默认初始化（有例外情况），解析阶段将常量池的符号引用替换为直接引用。初始化阶段执行编译器生成的类构造器 <code>&lt;clint&gt;()</code> 方法（不是对象构造器），包括静态字段的显示初始化和静态初始化块。</p>
<p><img src="/img/Java.assets/1740399269595.png" alt=""></p>
<p>类加载器用于实现加载阶段的“通过类的全限定名获取该类的二进制字节流”动作。在虚拟机中，类由类加载器和类的全限定名唯一确定。如果相同的类被不同类加载器加载，那么 instanceof 的判断结果就是 false。双亲委派机制是指，类加载器总是会将加载请求委派给父类加载器（父子类加载器是组合关系而不是继承关系），只有当父类加载器无法完成该加载请求时，子类加载器才会尝试加载，从而确保核心类（例如 Object）的唯一性。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-31T16:00:00.000Z" title="2023/1/1 00:00:00">2023-01-01</time>发表</span><span class="level-item"><time dateTime="2025-04-08T08:30:48.701Z" title="2025/4/8 16:30:48">2025-04-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a></span><span class="level-item">37 分钟读完 (大约5548个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/01/MySQL/">MySQL</a></p><div class="content"><p>参考《高性能 MySQL》和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/">官方文档</a>。使用 MySQL 的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/index-other.html">Sakila</a> 示例数据库，使用 MySQL 版本 8.0.41 + InnoDB 存储引擎。各种术语的官方定义可以看 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/glossary.html">MySQL 术语表</a>，锁相关的内容可以看 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html">InnoDB Locking</a>，更多数据库概念可以看 <a target="_blank" rel="noopener" href="http://localhost:4000/2023/11/15/CUM%2015-445%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">CUM 15-445 课程总结</a>。任何描述都是简化的，不会涵盖所有情况，更多细节只能看文档。或者说没有必要去记细节，任何细节都取决于实现，而实现会随着版本更新而变化，需要学习的是整体的策略。</p>
<h2 id="基本概念">基本概念</h2>
<p>快照（<strong>snapshot</strong>）：数据在特定时间的表示。<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-consistent-read.html">一致性读</a>（<strong>consistent read</strong>）：根据快照显示查询结果，也被称为一致性非锁定读。在读已提交和可重复读<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-transaction-isolation-levels.html">隔离级别</a>下执行 SELECT 语句的默认模式是一致性读，也就是说会使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-multi-versioning.html">多版本并发控制</a>（<strong>MVCC</strong>）读取数据。读已提交在每次执行一致性读时都会重置快照，而可重复读只在第一次一致性读时建立快照。<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locking-reads.html">锁定读</a>（<strong>locking read</strong>）：使用 <code>SELECT ... FOR SHARE</code> 或者 <code>SELECT ... FOR UPDATE</code> 读取数据，会加读锁或者写锁，在事务提交或者回滚时释放（2PL）。</p>
<p>MVCC 是使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-undo-logs.html">撤销日志</a>（<strong>Undo Log</strong>）和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/dev/mysql-server/latest/classReadView.html">读取视图</a>（<strong>Read View</strong>）实现的。事务在修改记录之后会记录撤销日志，事务的回滚指针会指向该日志。读取视图包含一致性读不可见的事务 ID（事务 ID 不会在启动事务之后立即分配），读取记录时会比较记录的事务 ID 和读取视图，如果该记录对当前事务不可见，则执行撤销日志直到达到可见状态。删除操作被视为修改操作，通过修改删除标志位实现，只有当该版本记录对所有事务不可见时，才会被真正删除。撤销日志也会被记录到<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-redo-log.html">重做日志</a>（<strong>Redo Log</strong>）中，实现崩溃恢复。</p>
<p><img src="/img/MySQL.assets/1740576843875.png" alt=""></p>
<p>关于幻读的问题：DML 语句可以破坏快照，从而在可重复读隔离级别会出现幻读。（参考一致性读文档）如果将快照读和当前读混用，也会出现幻读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(c1) FROM t1 WHERE c1 = &#x27;xyz&#x27;;</span><br><span class="line">-- Returns 0: no rows match.</span><br><span class="line">DELETE FROM t1 WHERE c1 = &#x27;xyz&#x27;;</span><br><span class="line">-- Deletes several rows recently committed by other transaction.</span><br><span class="line"></span><br><span class="line">SELECT COUNT(c2) FROM t1 WHERE c2 = &#x27;abc&#x27;;</span><br><span class="line">-- Returns 0: no rows match.</span><br><span class="line">UPDATE t1 SET c2 = &#x27;cba&#x27; WHERE c2 = &#x27;abc&#x27;;</span><br><span class="line">-- Affects 10 rows: another txn just committed 10 rows with &#x27;abc&#x27; values.</span><br><span class="line">SELECT COUNT(c2) FROM t1 WHERE c2 = &#x27;cba&#x27;;</span><br><span class="line">-- Returns 10: this txn can now see the rows it just updated.</span><br></pre></td></tr></table></figure>
<h2 id="常用命令">常用命令</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SHOW FULL PROCESSLIST;</span><br><span class="line">SHOW ENGINE INNODB STATUS;</span><br><span class="line">SELECT * FROM performance_schema.data_locks\G</span><br><span class="line">SHOW STATUS LIKE &#x27;Last_query_cost&#x27;;</span><br><span class="line">SHOW [GLOBAL | SESSION] VARIABLES [LIKE &#x27;pattern&#x27; | WHERE expr];</span><br><span class="line">START TRANSACTION; BEGIN; COMMIT; ROLLBACK;</span><br><span class="line">[CREATE | ALTER | DROP | OPTIMIZE | ANALYZE | CHECK | REPAIR ] TABLE tbl_name;</span><br><span class="line">SHOW TABLE STATUS [LIKE &#x27;pattern&#x27; | WHERE expr];</span><br><span class="line">SHOW INDEX FROM tbl_name;</span><br><span class="line">EXPLAIN [FORMAT=TREE | ANALYZE] select_statement; SHOW WARNINGS;</span><br></pre></td></tr></table></figure>
<h2 id="前缀索引">前缀索引</h2>
<p>使用前缀索引可以减少索引的空间开销，内部节点的字符串比较会更高效，但是选择性会更低，那么匹配的主键会更多，从而需要更多次回表。所以需要选择合适的前缀长度，尽可能提高索引的选择性。索引的选择性是指不重复的索引值（基数，cardinality）和数据表的记录总数的比值。无法利用前缀索引执行分组、排序和覆盖索引扫描。</p>
<p>执行如下语句，city_demo 最终有 19200 条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE city_demo(city VARCHAR(50) NOT NULL);</span><br><span class="line">INSERT INTO city_demo(city) SELECT city FROM city;</span><br><span class="line">INSERT INTO city_demo(city) SELECT city FROM city_demo; -- 重复执行 5 次</span><br><span class="line">UPDATE city_demo SET city = (SELECT city FROM city ORDER BY RAND() LIMIT 1); -- 随机化数据</span><br></pre></td></tr></table></figure>
<p>查询出现次数最多的前 10 个城市，然后使用各种前缀测试索引的选择性。前缀长度为 7 比较合适，因为统计数量的偏差不算很大。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) AS c, city</span><br><span class="line">FROM city_demo GROUP BY city ORDER BY c DESC LIMIT 10;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| c  | city            |</span><br><span class="line">+----+-----------------+</span><br><span class="line">| 54 | Ondo            |</span><br><span class="line">| 51 | London          |</span><br><span class="line">| 49 | Olomouc         |</span><br><span class="line">| 49 | Pontianak       |</span><br><span class="line">| 47 | Kurgan          |</span><br><span class="line">| 46 | Almirante Brown |</span><br><span class="line">| 46 | Changzhou       |</span><br><span class="line">| 46 | Funafuti        |</span><br><span class="line">| 46 | Jodhpur         |</span><br><span class="line">| 45 | Plock           |</span><br><span class="line">+----+-----------------+</span><br><span class="line">SELECT COUNT(*) AS c, LEFT(city, 3) AS pref</span><br><span class="line">FROM city_demo GROUP BY pref ORDER BY c DESC LIMIT 10;</span><br><span class="line">+-----+------+</span><br><span class="line">| c   | pref |</span><br><span class="line">+-----+------+</span><br><span class="line">| 477 | San  |</span><br><span class="line">| 197 | Cha  |</span><br><span class="line">| 171 | Tan  |</span><br><span class="line">| 157 | al-  |</span><br><span class="line">| 152 | Sou  |</span><br><span class="line">| 148 | Bat  |</span><br><span class="line">| 146 | Sal  |</span><br><span class="line">| 146 | Shi  |</span><br><span class="line">| 126 | Kam  |</span><br><span class="line">| 125 | Val  |</span><br><span class="line">+-----+------+</span><br><span class="line">SELECT COUNT(*) AS c, LEFT(city, 7) AS pref</span><br><span class="line">FROM city_demo GROUP BY pref ORDER BY c DESC LIMIT 10;</span><br><span class="line">+----+---------+</span><br><span class="line">| c  | pref    |</span><br><span class="line">+----+---------+</span><br><span class="line">| 76 | San Fel |</span><br><span class="line">| 66 | Valle d |</span><br><span class="line">| 63 | Santiag |</span><br><span class="line">| 54 | Ondo    |</span><br><span class="line">| 51 | London  |</span><br><span class="line">| 49 | Pontian |</span><br><span class="line">| 49 | Olomouc |</span><br><span class="line">| 47 | Kurgan  |</span><br><span class="line">| 46 | Jodhpur |</span><br><span class="line">| 46 | Almiran |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>
<p>不能只根据前缀索引选择性的值确定前缀长度，例如前缀长度为 5 的选择性看上去很接近完整列的选择性，但是如果查看出现次数最多的前 10 个城市，和完整列的结果相比，会发现数据分布很不均匀。如果查询以 South 前缀的某个城市，那么回表的次数会更多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT city) / COUNT(*) AS sel,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 3)) / COUNT(*) AS sel3,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 4)) / COUNT(*) AS sel4,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 5)) / COUNT(*) AS sel5,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 6)) / COUNT(*) AS sel6,</span><br><span class="line">COUNT(DISTINCT LEFT(city, 7)) / COUNT(*) AS sel7</span><br><span class="line">FROM city_demo;</span><br><span class="line">+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| sel    | sel3   | sel4   | sel5   | sel6   | sel7   |</span><br><span class="line">+--------+--------+--------+--------+--------+--------+</span><br><span class="line">| 0.0312 | 0.0236 | 0.0293 | 0.0305 | 0.0309 | 0.0310 |</span><br><span class="line">+--------+--------+--------+--------+--------+--------+</span><br><span class="line">SELECT COUNT(*) AS c, LEFT(city, 5) AS pref</span><br><span class="line">FROM city_demo GROUP BY pref ORDER BY c DESC LIMIT 10;</span><br><span class="line">+-----+--------+</span><br><span class="line">| c   | pref   |</span><br><span class="line">+-----+--------+</span><br><span class="line">| 118 | South  |</span><br><span class="line">| 104 | Santa  |</span><br><span class="line">|  78 | Chang  |</span><br><span class="line">|  76 | San F  |</span><br><span class="line">|  69 | Toulo  |</span><br><span class="line">|  68 | Xi´an  |</span><br><span class="line">|  66 | Valle  |</span><br><span class="line">|  64 | Saint  |</span><br><span class="line">|  64 | Shimo  |</span><br><span class="line">|  63 | Santi  |</span><br><span class="line">+-----+--------+</span><br></pre></td></tr></table></figure>
<h2 id="多列索引">多列索引</h2>
<p>在 film_actor 上有主键索引 <code>PRIMARY KEY (actor_id,film_id)</code>，有普通索引 <code>KEY idx_fk_film_id (film_id)</code>，以下查询计划表示合并两个索引的查询结果。索引合并策略有时效果不错，但更多时候表明表的索引建得很槽糕。如果优化器需要对多个索引做相交操作（由于多个 AND 条件），那么查看是否可以使用多列索引进行优化。</p>
<p>如果优化器需要对多个索引做联合操作（由于多个 OR 条件），且索引的选择性不高时，通常会在缓存、排序和合并上消耗大量 CPU 和内存资源。然而，优化器不会将这些操作计算到查询成本中，优化器只关心随机页面读取，所以有时索引合并的性能还不如全表扫描。这还会影响并发的查询，此时使用 UNION 改写，将单个查询拆分为多个查询，可以避免单个查询的执行时间过长，影响其他并发的查询（由于 2PL 协议，单个查询会在提交时才释放锁，当然不同隔离级别有细微差别）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT film_id, actor_id FROM film_actor</span><br><span class="line">WHERE actor_id = 1 OR film_id = 1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: PRIMARY,idx_fk_film_id</span><br><span class="line">          key: PRIMARY,idx_fk_film_id</span><br><span class="line">      key_len: 2,2</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 29</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using union(PRIMARY,idx_fk_film_id); Using where</span><br></pre></td></tr></table></figure>
<h2 id="聚簇索引">聚簇索引</h2>
<p>聚簇索引的每个叶子节点都包含主键值、事务 ID、用于事务和 MVCC 的回滚指针，以及所有的剩余列。二级索引的叶子节点存储主键值而不是物理指针，所以在移动主键索引中的记录时不需要修改二级索引。如果按照主键顺序插入行，聚簇索引不会发生页分裂，从而插入性能更高（减少磁盘 I/O）也不会产生内部碎片。不应该使用随机的主键（例如 UUID），如果没有按照主键顺序插入数据，可以使用 OPTIMIZE TABLE 命令重新组织表来消除内部碎片。</p>
<p>对于高并发负载，按主键顺序插入会产生较多竞争，可以通过更改  <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-auto-increment-handling.html">innodb_autoinc_lock_mode</a> 配置来提升性能。简单来说，有传统、连续和交错三种锁定模式，不同模式会根据语句的不同使用互斥锁（Lock）或者轻量级锁（CAS）。</p>
<p><img src="/img/MySQL.assets/1740555878074.png" alt=""></p>
<p><img src="/img/MySQL.assets/1740556365254.png" alt=""></p>
<p>对非唯一二级索引更新操作的优化：当更新非唯一二级索引时，如果页面不在缓冲池中，则使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-change-buffer.html">Change Buffer</a> 缓存更新操作。当其他读取操作将页面读到缓冲池中时，则会合并缓冲池中的更新操作，从而减少随机磁盘 I/O。</p>
<h2 id="查询优化">查询优化</h2>
<p>可以根据慢查询日志来优化查询，使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/explain-output.html">EXPLAIN</a> 查看执行计划。基本准则：只选择需要的列，而不是使用 <code>SELECT *</code>，从而允许覆盖索引优化、减少时间（I/O）和空间开销。不要重复执行相同的查询，可以在应用层使用缓存。对于不是很重要的查询，可以将大查询分解为小查询，将查询的时间分散到一个时间段中，减少查询对服务器性能的影响（减少单次查询持有锁的时间，以及避免事务日志堆积）。例如：DELETE 大量数据，可以使用 LIMIT 分解执行；当中间查询结果能缓存和重用时，可以将连接查询分解，然后在应用层做连接。</p>
<p>应用 WHERE 条件的方式：① 将条件从服务器下推到存储引擎，直接在索引中使用条件过滤记录（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/index-condition-pushdown-optimization.html">索引条件下推</a>，ICP），从而减少服务器访问存储引擎的次数，以及存储引擎访问基表的次数。② 使用覆盖索引获取记录（不需要回表），然后在服务器使用条件过滤记录。③ 回表之后，在服务器层使用条件。</p>
<p>MySQL 的局限性：无法将 UNION 外层的条件下推到内层。某些时候，等值传递会有问题（详细看书）。针对单个语句而言，无法利用多核并行执行查询，无法同时对某个表进行查询和更新（特指相关子查询）。</p>
<h3 id="UNION">UNION</h3>
<p>由于 UNION 查询无法使用到外层条件，所以需要手动将条件下推到 UNION 的各个子查询中。最好使用 UNION ALL 而不是 UNION，这样可以避免对临时表去重（UNION 查询总是会创建临时表）。</p>
<h3 id="COUNT">COUNT</h3>
<p><code>COUNT(*)</code> 统计行数，<code>COUNT(expr)</code> 统计非 NULL 值的数量。性能 <code>COUNT(*)=COUNT(1)&gt;COUNT(主键列)&gt;COUNT(普通列)</code>，如下所示 <code>COUNT(*)</code> 实际上是 <code>COUNT(0)</code>。根据条件统计数量，可以使用 <code>SUM(IF(expr, 1, 0))</code> 或者 <code>COUNT(expr OR NULL)</code>。如果允许使用近似值代替精确值，则可以去掉 WHERE 和 DISTINCT 之类的条件，优化查询性能。利用索引覆盖扫描优化性能，因为索引会比基表更小，减少 I/O 次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT COUNT(*) FROM film\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: idx_fk_language_id</span><br><span class="line">      key_len: 1</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1000</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select count(0) AS `COUNT(*)` from `sakila`.`film`</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="IN-EXIST">IN &amp; EXIST</h3>
<p>常见的说法是，在子查询数据较少时使用 IN，而在子查询数据较大时使用 EXIST。因为使用 IN 是不相关子查询，会创建临时表，然后在临时表中查找匹配的数据。而使用 EXIST 是相关子查询，会直接在内表中查找匹配的数据（多次执行子查询）。但是，实际上优化器会做优化，使用 IN 并不意味着就会创建临时表。下面查询所有没有交易记录的顾客信息，执行计划显示该查询被转化为相关子查询，会使用覆盖索引查找匹配的数据。（推荐阅读 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/subquery-optimization-with-exists.html">Optimizing Subqueries with the EXISTS Strategy</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM customer WHERE customer_id IN (</span><br><span class="line">    -&gt;   SELECT customer_id FROM payment</span><br><span class="line">    -&gt; )\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: customer</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 599</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: payment</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_fk_customer_id</span><br><span class="line">          key: idx_fk_customer_id</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: sakila.customer.customer_id</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index; FirstMatch(customer)</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `sakila`.`customer`.`customer_id` AS `customer_id`,`sakila`.`customer`.`store_id` AS `store_id`,`sakila`.`customer`.`first_name` AS `first_name`,`sakila`.`customer`.`last_name` AS `last_name`,`sakila`.`customer`.`email` AS `email`,`sakila`.`customer`.`address_id` AS `address_id`,`sakila`.`customer`.`active` AS `active`,`sakila`.`customer`.`create_date` AS `create_date`,`sakila`.`customer`.`last_update` AS `last_update` from `sakila`.`customer` semi join (`sakila`.`payment`) where (`sakila`.`payment`.`customer_id` = `sakila`.`customer`.`customer_id`)</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM customer WHERE customer_id IN (</span><br><span class="line">    -&gt;   SELECT customer_id FROM payment</span><br><span class="line">    -&gt; )\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop semijoin  (cost=271 rows=599) (actual time=0.0621..2.97 rows=599 loops=1)</span><br><span class="line">    -&gt; Table scan on customer  (cost=61.2 rows=599) (actual time=0.048..0.401 rows=599 loops=1)</span><br><span class="line">    -&gt; Covering index lookup on payment using idx_fk_customer_id (customer_id=customer.customer_id)  (cost=0.25 rows=1) (actual time=0.00418..0.00418 rows=1 loops=599)</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>而使用 EXIST 也不意味着执行相关子查询，如果将 payment 中的索引 idx_fk_customer_id 删除，然后重新执行上述查询。执行计划显示，子查询会生成索引临时表，索引用于去重，然后外表使用该索引查找匹配的数据。如果临时表较小，则会使用 MEMORY 存储引擎创建内存临时表，否则使用 InnoDB 存储引擎创建磁盘临时表。（推荐阅读 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/subquery-materialization.html">Optimizing Subqueries with Materialization</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE payment DROP FOREIGN KEY fk_payment_customer, DROP INDEX idx_fk_customer_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM customer WHERE EXISTS (</span><br><span class="line">    -&gt;   SELECT 1 FROM payment WHERE customer.customer_id = customer_id</span><br><span class="line">    -&gt; )\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: customer</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 599</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: &lt;subquery2&gt;</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: &lt;auto_distinct_key&gt;</span><br><span class="line">          key: &lt;auto_distinct_key&gt;</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: sakila.customer.customer_id</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: MATERIALIZED</span><br><span class="line">        table: payment</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 16086</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">3 rows in set, 2 warnings (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1276</span><br><span class="line">Message: Field or reference &#x27;sakila.customer.customer_id&#x27; of SELECT #2 was resolved in SELECT #1</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `sakila`.`customer`.`customer_id` AS `customer_id`,`sakila`.`customer`.`store_id` AS `store_id`,`sakila`.`customer`.`first_name` AS `first_name`,`sakila`.`customer`.`last_name` AS `last_name`,`sakila`.`customer`.`email` AS `email`,`sakila`.`customer`.`address_id` AS `address_id`,`sakila`.`customer`.`active` AS `active`,`sakila`.`customer`.`create_date` AS `create_date`,`sakila`.`customer`.`last_update` AS `last_update` from `sakila`.`customer` semi join (`sakila`.`payment`) where (`&lt;subquery2&gt;`.`customer_id` = `sakila`.`customer`.`customer_id`)</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM customer WHERE EXISTS (</span><br><span class="line">    -&gt;   SELECT 1 FROM payment WHERE customer.customer_id = customer_id</span><br><span class="line">    -&gt; )\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join  (cost=963672 rows=9.64e+6) (actual time=6.27..6.92 rows=599 loops=1)</span><br><span class="line">    -&gt; Table scan on customer  (cost=61.2 rows=599) (actual time=0.0789..0.422 rows=599 loops=1)</span><br><span class="line">    -&gt; Single-row index lookup on &lt;subquery2&gt; using &lt;auto_distinct_key&gt; (customer_id=customer.customer_id)  (cost=3241..3241 rows=1) (actual time=0.0107..0.0107 rows=1 loops=599)</span><br><span class="line">        -&gt; Materialize with deduplication  (cost=3241..3241 rows=16086) (actual time=6.18..6.18 rows=599 loops=1)</span><br><span class="line">            -&gt; Table scan on payment  (cost=1633 rows=16086) (actual time=0.245..3.54 rows=16044 loops=1)</span><br><span class="line"></span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="JOIN">JOIN</h3>
<p>确保 ON 或者 USING 的列上有索引。确保 GROUP BY 和 ORDER BY 只涉及一个表中的列，从而允许利用索引优化（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/group-by-optimization.html">松散/紧密索引扫描</a>、利用索引排序）。如果需要对聚合的结果做超级聚合，可以使用 <code>GROUP BY xxx WITH ROLLUP</code>（注意查看查询计划，确定是否有性能问题），也可以使用其他等价语句或者在应用层聚合。</p>
<p>上面执行 <code>SHOW WARNINGS\G</code> 都会显示半连接（semi join），所谓半连接就是从左表中查询和右表匹配的行。反连接（anti join）正好相反，从左表中查询和右表不匹配的行。下面的查询和上面的等价，但是更慢，没有使用半连接，在覆盖索引中使用 LIMIT 1 去重，在最后使用临时表去重（实际上没有必要，LIMIT 1 已经去重）。（推荐阅读 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/semijoins-antijoins.html">Optimizing IN and EXISTS Subquery Predicates with Semijoin and Antijoin Transformations</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT customer.* FROM customer INNER JOIN payment USING(customer_id)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: customer</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 599</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using temporary</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: payment</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_fk_customer_id</span><br><span class="line">          key: idx_fk_customer_id</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: sakila.customer.customer_id</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index; Distinct</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select distinct `sakila`.`customer`.`customer_id` AS `customer_id`,`sakila`.`customer`.`store_id` AS `store_id`,`sakila`.`customer`.`first_name` AS `first_name`,`sakila`.`customer`.`last_name` AS `last_name`,`sakila`.`customer`.`email` AS `email`,`sakila`.`customer`.`address_id` AS `address_id`,`sakila`.`customer`.`active` AS `active`,`sakila`.`customer`.`create_date` AS `create_date`,`sakila`.`customer`.`last_update` AS `last_update` from `sakila`.`customer` join `sakila`.`payment` where (`sakila`.`payment`.`customer_id` = `sakila`.`customer`.`customer_id`)</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT DISTINCT customer.* FROM customer INNER JOIN payment USING(customer_id)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Table scan on &lt;temporary&gt;  (cost=331..341 rows=599) (actual time=3.3..3.38 rows=599 loops=1)</span><br><span class="line">    -&gt; Temporary table with deduplication  (cost=331..331 rows=599) (actual time=3.3..3.3 rows=599 loops=1)</span><br><span class="line">        -&gt; Nested loop inner join  (cost=271 rows=599) (actual time=0.0668..2.13 rows=599 loops=1)</span><br><span class="line">            -&gt; Table scan on customer  (cost=61.2 rows=599) (actual time=0.0492..0.404 rows=599 loops=1)</span><br><span class="line">            -&gt; Limit: 1 row(s)  (cost=0.25 rows=1) (actual time=0.00271..0.00273 rows=1 loops=599)</span><br><span class="line">                -&gt; Covering index lookup on payment using idx_fk_customer_id (customer_id=customer.customer_id)  (cost=0.25 rows=1) (actual time=0.00262..0.00262 rows=1 loops=599)</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="LIMIT">LIMIT</h3>
<p>如果偏移量很大，例如 <code>LIMIT 10000, 20</code>，那么会扫描 10020 条记录，而只有最后 20 条是有效的。如果行中有很多数据，那么 I/O 次数就会很多。MySQL 的 LIMIT OFFSET 似乎不会下推到索引，从而 10020 条记录都会回表查询。查询计划中确实没有下推，奇怪的是索引只会扫描 10020 条记录，说明索引是有 LIMIT OFFSET 信息的。（参考 <a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/polardb/polardb-for-mysql/user-guide/limit-offset-pushdown">Limit Offset 下推</a>）</p>
<p>优化方式：① 使用覆盖索引执行 LIMIT，索引中只包含必要的列（如 ORDER BY 的列，当然默认包含主键），那么 LIMIT 扫描的数据会减少很多，最后使用主键做连接得到完整数据。（不能使用 IN，因为 <code>ERROR 1235 (42000): This version of MySQL doesn't yet support 'LIMIT &amp; IN/ALL/ANY/SOME subquery'</code>）② 如果只允许顺序翻页的话，通过记录上个页面的边界值，下次查询就可以使用该值定位到目标位置，而不会做无效的扫描。③ 一次性获取多页数据，在应用层缓存起来（类似缓存 I/O）。④ 其他方法，使用预先计算的汇总表，或者使用冗余表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment ORDER BY customer_id LIMIT 10000, 20\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Limit/Offset: 20/10000 row(s)  (cost=1633 rows=20) (actual time=11.6..11.6 rows=20 loops=1)</span><br><span class="line">    -&gt; Sort: payment.customer_id, limit input to 10020 row(s) per chunk  (cost=1633 rows=16086) (actual time=10.6..11.4 rows=10020 loops=1)</span><br><span class="line">        -&gt; Table scan on payment  (cost=1633 rows=16086) (actual time=0.434..5.5 rows=16044 loops=1)</span><br><span class="line"></span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment FORCE INDEX (idx_fk_customer_id) ORDER BY customer_id LIMIT 10000, 20\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Limit/Offset: 20/10000 row(s)  (cost=3129 rows=20) (actual time=11.1..11.1 rows=20 loops=1)</span><br><span class="line">    -&gt; Index scan on payment using idx_fk_customer_id  (cost=3129 rows=10020) (actual time=1.14..10.8 rows=10020 loops=1)</span><br><span class="line"></span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment INNER JOIN (SELECT payment_id FROM payment ORDER BY customer_id LIMIT 10000, 20) AS lim USING(payment_id)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join  (cost=3151 rows=20) (actual time=2.29..2.32 rows=20 loops=1)</span><br><span class="line">    -&gt; Table scan on lim  (cost=641..644 rows=20) (actual time=2.27..2.28 rows=20 loops=1)</span><br><span class="line">        -&gt; Materialize  (cost=641..641 rows=20) (actual time=2.27..2.27 rows=20 loops=1)</span><br><span class="line">            -&gt; Limit/Offset: 20/10000 row(s)  (cost=639 rows=20) (actual time=2.12..2.12 rows=20 loops=1)</span><br><span class="line">                -&gt; Covering index scan on payment using idx_fk_customer_id  (cost=639 rows=10020) (actual time=0.178..1.89 rows=10020 loops=1)</span><br><span class="line">    -&gt; Single-row index lookup on payment using PRIMARY (payment_id=lim.payment_id)  (cost=0.25 rows=1) (actual time=0.00204..0.00207 rows=1 loops=20)</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment WHERE payment_id IN (SELECT payment_id FROM (SELECT payment_id FROM payment ORDER BY customer_id LIMIT 10000, 20) AS lim)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Nested loop inner join  (cost=35413 rows=321720) (actual time=11.3..15.9 rows=20 loops=1)</span><br><span class="line">    -&gt; Table scan on payment  (cost=1633 rows=16086) (actual time=0.382..6.93 rows=16044 loops=1)</span><br><span class="line">    -&gt; Single-row index lookup on &lt;subquery2&gt; using &lt;auto_distinct_key&gt; (payment_id=payment.payment_id)  (cost=646..646 rows=1) (actual time=460e-6..460e-6 rows=0.00125 loops=16044)</span><br><span class="line">        -&gt; Materialize with deduplication  (cost=646..646 rows=20) (actual time=2.07..2.07 rows=20 loops=1)</span><br><span class="line">            -&gt; Table scan on lim  (cost=641..644 rows=20) (actual time=2.06..2.06 rows=20 loops=1)</span><br><span class="line">                -&gt; Materialize  (cost=641..641 rows=20) (actual time=2.06..2.06 rows=20 loops=1)</span><br><span class="line">                    -&gt; Limit/Offset: 20/10000 row(s)  (cost=639 rows=20) (actual time=2.05..2.06 rows=20 loops=1)</span><br><span class="line">                        -&gt; Covering index scan on payment using idx_fk_customer_id  (cost=639 rows=10020) (actual time=0.095..1.82 rows=10020 loops=1)</span><br><span class="line"></span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>
<h3 id="NOT-IN">NOT IN</h3>
<p>从文本文件读取数据，num 列有 100 万个 1、100 万个 2 和 1 个 3，测试一下 <code>NOT IN (1, 2)</code> 是否会使用索引。EXPLAIN ANALYZE 的结果显示，查询被分为三个区间，这样就可以利用索引范围扫描。（推荐阅读 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/insert-optimization.html">Optimizing INSERT Statements</a>，<a target="_blank" rel="noopener" href="https://dev.mysql.com/blog-archive/mysql-explain-analyze/">MySQL EXPLAIN ANALYZE</a>，<a target="_blank" rel="noopener" href="https://dev.mysql.com/blog-archive/a-must-know-about-not-in-in-sql-more-antijoin-optimization/">A must-know about NOT IN in SQL - more antijoin optimization</a>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">SET @@GLOBAL.local_infile = 1;</span><br><span class="line">CREATE TABLE test (num TINYINT NOT NULL, dummy TINYINT NOT NULL DEFAULT 0);</span><br><span class="line">LOAD DATA LOCAL INFILE &#x27;data.txt&#x27; INTO TABLE test (num);</span><br><span class="line">ALTER TABLE test ADD INDEX idx_num (num);</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM test WHERE num NOT IN (1, 2)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_num</span><br><span class="line">          key: idx_num</span><br><span class="line">      key_len: 1</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `sakila`.`test`.`num` AS `num`,`sakila`.`test`.`dummy` AS `dummy` from `sakila`.`test` where (`sakila`.`test`.`num` not in (1,2))</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM test WHERE num NOT IN (1, 2)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Index range scan on test using idx_num over (num &lt; 1) OR (1 &lt; num &lt; 2) OR (2 &lt; num), with index condition: (test.num not in (1,2))  (cost=3.38 rows=3) (actual time=0.0355..0.0383 rows=1 loops=1)</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM test WHERE num NOT IN (3)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: idx_num</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1996905</span><br><span class="line">     filtered: 50.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `sakila`.`test`.`num` AS `num`,`sakila`.`test`.`dummy` AS `dummy` from `sakila`.`test` where (`sakila`.`test`.`num` &lt;&gt; 3)</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN ANALYZE SELECT * FROM test WHERE num NOT IN (3)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Filter: (test.num &lt;&gt; 3)  (cost=201305 rows=998453) (actual time=0.0239..1133 rows=2e+6 loops=1)</span><br><span class="line">    -&gt; Table scan on test  (cost=201305 rows=2e+6) (actual time=0.0222..976 rows=2e+6 loops=1)</span><br><span class="line"></span><br><span class="line">1 row in set (1.26 sec)</span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/51/">上一页</a></div><div class="pagination-next"><a href="/page/53/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/51/">51</a></li><li><a class="pagination-link is-current" href="/page/52/">52</a></li><li><a class="pagination-link" href="/page/53/">53</a></li><li><a class="pagination-link" href="/page/54/">54</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">160</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-21T10:49:47.130Z">2025-09-21</time></p><p class="title"><a href="/2025/09/21/%E5%A4%8D%E7%8E%B0%20Apache%20Shiro%201.2.4%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">复现 Apache Shiro 1.2.4 反序列化漏洞</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-17T00:49:07.334Z">2025-09-17</time></p><p class="title"><a href="/2025/09/17/Garbage%20Collection/">Garbage Collection</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-26T00:11:50.404Z">2025-04-26</time></p><p class="title"><a href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> / <a href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-18T10:01:46.499Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">102</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">clist</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://csdiy.wiki/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdiy</span></span><span class="level-right"><span class="level-item tag">csdiy.wiki</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>