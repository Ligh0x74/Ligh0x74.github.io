<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-26T00:11:50.404Z" title="2025/4/26 08:11:50">2025-04-26</time>发表</span><span class="level-item"><time dateTime="2025-05-07T02:27:15.451Z" title="2025/5/7 10:27:15">2025-05-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span> / </span><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></span><span class="level-item">43 分钟读完 (大约6438个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://skyzh.github.io/mini-lsm/">mini-lsm</a>，<a target="_blank" rel="noopener" href="https://discord.com/channels/1197355762297610260/1197435686370947112">Discord</a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/">Rust Documentation</a>，<a target="_blank" rel="noopener" href="https://tourofrust.com/">Tour of Rust</a>。</p>
<h2 id="Week-1-Overview-Mini-LSM">Week 1 Overview: Mini-LSM</h2>
<h3 id="Memtables">Memtables</h3>
<p>如果要在内存中存储键值对，可以简单的使用哈希表，但是如果要支持顺序遍历以及范围查询，要使用特殊的数据结构，例如跳表、B/B+ 树、红黑树、AVL树等。<strong>为什么 LSM 实现使用跳表（<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam-skiplist/latest/crossbeam_skiplist/">crossbeam_skiplist</a>）作为内存表的数据结构？</strong> B/B+ 树主要是针对磁盘 I/O 做优化，插入/删除会涉及页分裂和合并，在纯内存的场景下不太适用。红黑树是近似平衡的，AVL 树是严格平衡的，所以红黑树的插入/删除效率更好，而 AVL 树的查找效率更好。跳表的实现更加简单，而且并发友好，只需要锁定局部数据。不过跳表是基于链表实现的，数据局部性可能较差，而且概率数据结构稳定性也会差点。</p>
<p><strong>为什么内存表在 delete 时只是将值置为空，而不是删除整个键值对？</strong> 因为如果当前内存表找不到指定的 Key，那么会继续在已经冻结的内存表中找，如果删除整个键值对，则会丢失该删除操作。<strong>为什么要有多个内存表呢？</strong> 当前内存表执行 get/put 操作的同时，可以基于冻结的内存表构建 SST，然后刷到磁盘中，而不会 STW 阻塞整个 LSM。</p>
<p><strong>何时使用 <code>state</code> 读写锁和 <code>state_lock</code> 独占锁？</strong> 由于使用的跳表是支持无锁并发的，读写跳表只需要加 <code>state</code> 读锁，但是判断是否冻结以及整个冻结操作都需要加 <code>state_lock</code> 独占锁来保证原子性，可以使用双重检查加锁来优化性能。然后冻结操作内会加 <code>state</code> 写锁，将当前内存表加入冻结列表，然后创建一个新的内存表。<strong>在内存表超出限制大小需要冻结时，将 <code>state</code> 读锁释放再加写锁，与直接将读锁升级为写锁有什么区别？</strong> 在释放读锁之后，依然允许其他线程执行 get/put 操作，此时当前冻结线程可以执行昂贵的磁盘 I/O 而不会影响整体的性能。</p>
<p><img src="/img/DB.assets/1745494765832.png" alt=""></p>
<h3 id="Merge-Iterator">Merge Iterator</h3>
<p>可以构建迭代器来遍历内存表，像是 Java 中的迭代器通常会有 <code>hasNext()</code> 和 <code>next()</code> 方法来判断迭代器的有效性以及获取下一个元素。<code>StorageIterator</code> 迭代器的设计有点不同，<code>next()</code> 只会移动内部的跳表迭代器而不会返回元素，获取元素是通过 <code>key()</code> 和 <code>value()</code> 方法实现的。<strong>为什么 <code>StorageIterator</code> 迭代器的设计和 Rust 风格的迭代器不同？为什么 <code>MemTableIterator</code> 需要自引用？</strong> 因为 <code>StorageIterator</code> 迭代器可能需要多次获取当前 Key 而不移动到下一个元素，所以将移动操作和取值操作分离是比较好的选择。使用自引用结构的目的是避免编写 Rust 的生命周期代码的复杂性。</p>
<p>实现单个内存表迭代器之后，因为除当前内存表外还有多个冻结内存表，所以需要一个合并迭代器，将所有内存表迭代器合并，从而实现顺序遍历。如果有多个内存表包含相同的键，需要返回该键的最新值，以及跳过其他包含旧值的键。可以使用堆来对多个迭代器排序，首先按照键的大小排序，然后按照内存表的新旧编号排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter1: b-&gt;del, c-&gt;4, d-&gt;5</span><br><span class="line">iter2: a-&gt;1, b-&gt;2, c-&gt;3</span><br><span class="line">iter3: e-&gt;4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;1, b-&gt;del, c-&gt;4, d-&gt;5, e-&gt;4</span><br></pre></td></tr></table></figure>
<p>Rust 的 <code>BinaryHeap</code> 在修改堆中元素之后，会自动排序保证堆的有效性。如果在修改之后迭代器报错，不能直接返回错误信息，而要首先从堆中移除失效的迭代器，从而避免访问失效的迭代器（会调用其方法获取 Key）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let Some(mut inner_iter) = self.iters.peek_mut() &#123;</span><br><span class="line">    inner_iter.next()?; // &lt;- will cause problem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现合并迭代器 <code>MergeIterator</code> 之后，外部还有一个 <code>LsmIterator</code> 做包装，用来过滤被逻辑删除的键，也就是在遍历时会自动跳过值为空的键。然后 <code>LsmIterator</code> 外部又有一个 <code>FusedIterator</code> 做包装，在底层迭代器报错之后，会避免再次访问底层迭代器。<strong>为什么不直接在 <code>MemTableIterator</code> 中过滤被逻辑删除的键？</strong> 在合并迭代器时需要知道该键在新内存表被删除避免读取到旧内存表的值。</p>
<h3 id="Block">Block</h3>
<p>当内存表数量超过系统限制时，会将内存表作为 SST 刷新到磁盘，一个 SST 由多个块组成，单个块的大小通常是 4KB。编码方式如下：键值对是变长编码，作为 Entry 存储在 Data Section，同时维护每个 Entry 的偏移量来支持二分查找，最后存储总的 Entry 数量从而支持定位 Offset Section 的起始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">|             Data Section             |              Offset Section             |      Extra      |</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">| Entry #1 | Entry #2 | ... | Entry #N | Offset #1 | Offset #2 | ... | Offset #N | num_of_elements |</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------</span><br><span class="line">|                           Entry #1                            | ... |</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">| key_len (2B) | key (keylen) | value_len (2B) | value (varlen) | ... |</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="Sorted-String-Table-SST">Sorted String Table (SST)</h3>
<p>SST 由存储在磁盘上的数据块和索引块组成，数据块是按需加载的，只有在用户请求时才会加载到内存中。索引块也可以按需加载，但在本项目中假设所有 SST 索引块（元数据块）都能装入内存。<strong>一个 SST 文件的大小通常是 256MB，在构建 SST 时最好预分配 <code>Vec</code> 的空间，避免频繁动态扩容的开销。</strong> 如果单个数据块的大小超出限制，会自动创建一个新块存储数据。SST 的元数据包括，每个数据块的第一个和最后一个键以及该数据块的偏移量。最后存储元数据的偏移量从而支持定位元数据的起始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">|         Block Section         |          Meta Section         |          Extra          |</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">| data block | ... | data block |            metadata           | meta block offset (u32) |</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>在实现 <code>SsTableIterator</code> 的 <code>seek_to_key</code> 方法时（找到第一个 <code>? &gt;= x</code> 的键），可以根据数据块的第一个键使用二分查找来快速定位目标数据块。需要注意的是，如果目标 Key 是 <code>x</code>，要找的是最后一个满足 <code>first_key &lt;= x</code> 的数据块，而且在调用该 <code>BlockIterator</code> 的 <code>seek_to_key</code> 方法之后，还要额外判断该 <code>BlockIterator</code> 是否失效。例如，查找 <code>b</code> 会定位到第一个数据块（正确），而查找 <code>d</code> 也会定位到第一个数据块（错误），然后在 <code>BlockIterator</code> 上调用 <code>seek_to_key</code> 会导致迭代器失效，此时需要跳到下一个块上，也就是说第二个数据块才是目标块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------</span><br><span class="line">| block 1 | block 2 |   block meta   |</span><br><span class="line">--------------------------------------</span><br><span class="line">| a, b, c | e, f, g | 1: a/c, 2: e/g |</span><br><span class="line">--------------------------------------</span><br></pre></td></tr></table></figure>
<p>可以使用缓存来加速数据块的访问，项目使用 <a target="_blank" rel="noopener" href="https://github.com/moka-rs/moka">moka-rs</a> 作为缓存库来实现块缓存，块由 <code>(sst_id, block_id)</code> 唯一标识。</p>
<h3 id="Read-Path-Write-Path">Read Path &amp; Write Path</h3>
<p>实现完成内存表和 SST 结构之后，可以实现 <code>TwoMergeIterator</code> 来合并两者的迭代器，理论上可以直接使用之前实现的 <code>MergeIterator</code>，不过这里只有两个迭代器需要合并，所以这里使用一个更简单的实现。然后可以修改 <code>LsmStorageInner</code> 的 <code>scan</code> 和 <code>get</code> 方法的实现，将 SST 添加到读取路径中。由于创建 SST 的迭代器会比较耗时（涉及磁盘 I/O），所以不要在整个过程持有 <code>state</code> 读锁，而是创建一个 <code>state</code> 快照，然后基于快照创建迭代器来访问数据。</p>
<p>创建 SST 的合并迭代器需要加载所有底层 SST 的第一个块，优化方式是并行创建迭代器。在 <code>LsmStorageInner::scan</code> 方法中，实际上可以利用参数 <code>lower</code> 和 <code>upper</code>，以及 SST 的 <code>first_key</code> 和 <code>last_key</code> 来过滤 SST，避免不必要的磁盘 I/O。当内存表的数量达到上限时，需要将最旧的冻结内存表以 SST 文件的形式刷到磁盘，刷新工作主要由后台线程负责。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">snapshot</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">read</span>();</span><br><span class="line">    Arc::<span class="title function_ invoke__">clone</span>(&amp;guard)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Snack-Time-SST-Optimizations">Snack Time: SST Optimizations</h3>
<p>可以在读取路径上集成<a target="_blank" rel="noopener" href="https://samwho.dev/bloom-filters/">布隆过滤器</a>来过滤 SST，布隆过滤器基于 SST 包含的数据创建，每个 SST 都包含一个持久化的布隆过滤器数据。由于数据块中的键是有序存储的，可以对键进行前缀压缩。<strong>根据相邻键进行键前缀压缩而不是根据块中的第一个键进行压缩有哪些优点/缺点？</strong> 项目中是根据数据块的 <code>first_key</code> 的前缀进行压缩，这样可以在查找时快速复原当前 Key。如果是根据相邻键压缩，那么压缩比例会更高，但是压缩和复原最坏需要遍历所有前缀数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">|         Block Section         |                            Meta Section                           |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">| data block | ... | data block | metadata | meta block offset | bloom filter | bloom filter offset |</span><br><span class="line">|                               |  varlen  |         u32       |    varlen    |        u32          |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_overlap_len (u16) | rest_key_len (u16) | key (rest_key_len)</span><br></pre></td></tr></table></figure>
<h2 id="Week-2-Overview-Compaction-and-Persistence">Week 2 Overview: Compaction and Persistence</h2>
<h3 id="Compaction-Implementation">Compaction Implementation</h3>
<p>可以对 L0 SST 文件进行压缩，避免读放大，由于各个 SST 之间的键范围存在重叠。最简单的方式是进行 Full Compaction，将所有键按顺序排序存储到一组新的 SST 中（被称为 sorted run）。压缩时允许并行执行读写操作，所以不持有 <code>state</code> 的读写锁，依然复制状态快照（不会复制 SST，只是复制状态），然后基于快照创建 L0 和 L1（之前压缩的 L1 需要和 L0 再次整合）的合并迭代器。</p>
<p>使用 <code>SsTableBuilder</code> 构建 SST，如果超出大小限制则拆分文件，在迭代时过滤已经被删除的键，重复的键已经在合并迭代器内部过滤。替换状态时只需要持有 <code>state_lock</code> 独占锁，<code>state</code> 读写锁依然只在复制状态快照时持有，允许并行执行读写内存表的操作。替换状态不会丢失内存表的修改，因为状态只包含内存表的指针。</p>
<p>由于在压缩时也会产生 L0 SST 文件，所以在替换状态时只删除被压缩的 L0 SST 文件、以及所有 L1 SST 文件。<strong>在 macOS/Linux 操作系统上，直接删除文件不会有问题，即使可能存在并行读取，因为操作系统只有在没有文件句柄被持有时才会真正删除该文件。在 Windows 上似乎会直接报错。</strong> 删除文件操作在解锁 <code>state_lock</code> 之后执行。</p>
<p><img src="/img/DB.assets/1745716942378.png" alt=""></p>
<h3 id="Simple-Compaction-Strategy">Simple Compaction Strategy</h3>
<p>实现 Simple Leveled Compaction 策略，基本想法是指定一个最大层数 <code>max_levels</code>（不包括 L0），然后在 L0 SST 文件数量达到阈值，或者下层文件数量和上层（&gt;= L1）文件数量的比值小于阈值时执行相邻层级之间的压缩。<strong>是否可以像 Full Compaction 一样直接过滤已经被删除的键？</strong> 只有当压缩 Level 是最底层时，才能过滤掉已经被删除的键，否则可能读取到下层 Level 的旧值。<strong>主动选择旧 Level 进行压缩，即使其没有达到指定阈值，是否是一个好主意？</strong> 参考 <a target="_blank" rel="noopener" href="https://disc-projects.bu.edu/lethe/">Lethe</a> 文章，定期压缩可以减少无效键导致的空间放大、压缩无效键导致的写放大、无效键占用布隆过滤器导致误报率提升。</p>
<h3 id="Tiered-Compaction-Strategy">Tiered Compaction Strategy</h3>
<p>实现 Tiered Compaction 策略（RocksDB 的 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/universal-compaction">Universal Compaction</a>），该压缩不会使用 L0，所有 SST 都直接存放到 <code>levels</code> 中，压缩过程中生成的 SST 总是会占据一个 tier，tier 的编号就是该 tier 包含的第一个 SST ID。</p>
<p>首先，只有当 tier 的数量超过阈值才会触发压缩。当估计的空间放大率 <code>all levels except last level size / last level size</code> 超过阈值会触发 Full Compaction，或者 <code>this tier size / sum of all previous tiers size</code> 超过阈值会触发前缀压缩。如果没有触发上述压缩，则会直接触发前缀压缩，压缩的最大层数由参数限制。由于压缩过程中也会生成 SST，所以修改状态时替换的是 <code>levels</code> 的中间部分而不一定是前缀。</p>
<h3 id="Leveled-Compaction-Strategy">Leveled Compaction Strategy</h3>
<p>实现 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">Leveled Compaction</a> 策略，相当于对 Simple Leveled Compaction 的优化。之前的策略会在相邻层级之间压缩数据，初始时会反复地将上层数据压缩到下面的空层中，更好的策略是跳过中间的空层，直接和有数据的低层进行压缩。在数据量不是很大的时候，没有必要分层压缩产生读放大，所以给最底层设置一个阈值 <code>base_level_size_mb</code>，在最底层的文件大小超过该阈值之前总是将数据压缩到最底层。</p>
<p>然后使用 <code>level_size_multiplier</code> 来确定各个层级的 <code>target size</code>，只允许有一个小于 <code>base_level_size_mb</code> 的正 <code>target size</code>，该层记作 <code>base level</code>。每次压缩 L0 的数据都直接压缩到 <code>base level</code>，这样可以确保在数据量比较小时使用较少的层级（后缀层级），避免较多层级产生读放大、以及反复压缩相邻空层产生写放大。</p>
<p>优先将满足 <code>current_size / target_size &gt; 1.0</code> 的比值最大的层级压缩到下层中，尽量减少空间放大。之前的策略总是将上层所有 SST 和下层做压缩，这样压缩过程中的空间放大会比较多。可以实现部分压缩，从上层选择最旧的 SST，然后和下层键范围重叠的 SST 做压缩。对于 L0 可以计算整个 L0 的最小最大键，然后和下层范围重叠的 SST 做压缩。<strong>需要考虑没有重叠的情况，此时压缩结果需要放在 Level 的开头或者末尾，比较简单的实现方式就是根据 SST 的 <code>first_key</code> 排序。</strong></p>
<h3 id="Manifest">Manifest</h3>
<p>可以持久化 LSM 存储引擎的状态，从而允许重启时恢复。简单的方法是，在状态被修改时将所有状态持久化，但是这样磁盘 I/O 开销较大，特别是修改操作比较频繁时。该项目使用 Manifest 文件维护 SST Flush 和 Compaction 操作记录，SST Flush 操作记录该 SST 的 <code>sst_id</code>，Compaction 操作记录压缩任务 <code>task</code> 和压缩结果 <code>output</code>。在不持有 <code>state</code> 读写锁时追加 Manifest 文件，允许并行读写内存表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| JSON record | JSON record | JSON record | JSON record |</span><br></pre></td></tr></table></figure>
<p>由于记录的信息有限，在重启恢复时只能先构建 <code>L0</code> 和 <code>levels</code> 元数据，然后根据这些元数据读取磁盘上的 SST 来构建 <code>sstables</code> 哈希表。如果在压缩过程中使用到 <code>sstables</code> 中 SST 的 <code>first_key</code> 排序，那么在恢复时需要特殊处理。不能在应用记录的过程中构建 <code>sstables</code>，因为记录中的 SST 可能已经被压缩，从而对应的文件已经从磁盘删除。</p>
<p><strong>为保证磁盘中 SST 和 Manifest 文件的一致性，需要在追加 Manifest 文件之前 Sync 整个存储目录，或者可以在修改文件之后总是执行 Sync。</strong> 在关闭 LSM 之前，需要将所有内存表刷新到 SST 中。在恢复时需要维护最大的 <code>max_sst_id</code>，恢复完成之后需要根据 <code>max_sst_id + 1</code> 创建当前的内存表。由于 Manifest 文件会记录所有操作，所以需要定时创建快照来截断日志（例如 Raft 中状态机快照），来减少空间占用以及加快恢复速度。</p>
<h3 id="Write-Ahead-Log-WAL">Write-Ahead Log (WAL)</h3>
<p>Manifest 文件可以保证正常关闭时，LSM 状态的持久性，但是如果发生崩溃，就需要依靠 WAL 来保证持久性。每个内存表对应一个 WAL 文件，如果冻结内存表被刷新到 SST 文件中，则可以将 WAL 文件删除，前提是该 SST 文件已经被 Sync 到磁盘中（默认在创建 SST 时就会 Sync）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len | key | value_len | value |</span><br></pre></td></tr></table></figure>
<p>为了能够在重启时恢复内存表，需要在 Manifest 文件中维护 NewMemtable 记录，该记录存储内存表的 ID。为减少磁盘 I/O 以及系统调用开销，可以在将当前内存表转移到冻结内存表时刷新 WAL 到磁盘，而不是在每次修改内存表时刷新，不过如果宕机则会丢失当前内存表的数据。创建 WAL 文件应该在追加 Manifest 记录之前，这样可以保证恢复时的一致性。在重启恢复时，依然不能在应用记录的过程中读取 WAL，因为记录中的 WAL 可能已经被删除，由于该内存表已经被刷新到 SST 中。</p>
<h3 id="Snack-Time-Batch-Write-and-Checksums">Snack Time: Batch Write and Checksums</h3>
<p>实现批量写入接口，允许用户提供一组 <code>put</code> 和 <code>delete</code> 操作批量执行。给 Block、SST Meta（Block Meta、Bloom Filter）、WAL 以及 Manifest 文件添加校验和，从而允许检查数据是否损坏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">|                   Block Section                     |                            Meta Section                           |</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">| data block | checksum | ... | data block | checksum | metadata | meta block offset | bloom filter | bloom filter offset |</span><br><span class="line">|   varlen   |    u32   |     |   varlen   |    u32   |  varlen  |         u32       |    varlen    |        u32          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">|                                                Meta Section                                            |</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">| no. of block | metadata | checksum | meta block offset | bloom filter | checksum | bloom filter offset |</span><br><span class="line">|     u32      |  varlen  |    u32   |        u32        |    varlen    |    u32   |        u32          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len | key | value_len | value | checksum |</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| len | JSON record | checksum | len | JSON record | checksum | len | JSON record | checksum |</span><br></pre></td></tr></table></figure>
<h2 id="Week-3-Overview-Multi-Version-Concurrency-Control">Week 3 Overview: Multi-Version Concurrency Control</h2>
<h3 id="Timestamp-Key-Encoding-Refactor">Timestamp Key Encoding + Refactor</h3>
<h3 id="Snapshot-Read-Memtables-and-Timestamps">Snapshot Read - Memtables and Timestamps</h3>
<h3 id="Snapshot-Read-Engine-Read-Path-and-Transaction-API">Snapshot Read - Engine Read Path and Transaction API</h3>
<p>为实现 MVCC 需要重构代码，首先替换 Key 的表示以包含时间戳字段，按照 <code>user_key</code> 升序 <code>ts</code> 降序排序，这样可以优先读到新版本的数据。然后修改内存表、Block、SST、WAL 以支持时间戳字段，在重启恢复 LSM 状态时需要根据 SST 和内存表中使用的最大时间戳来确定当前时间戳。在整个 <code>write_batch</code> 中需要持有 MVCC 的 <code>write_lock</code>，从而确保按照时间戳递增的顺序执行写入操作（只有写入操作会递增时间戳）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alternative key representation: | user_key (varlen) | ts (8 bytes) | in a single slice</span><br><span class="line">Our key representation: | user_key slice | ts (u64) |</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_overlap_len (u16) | remaining_key_len (u16) | key (remaining_key_len) | timestamp (u64)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len (exclude ts len) (u16) | key | ts (u64) | value_len (u16) | value | checksum (u32) |</span><br></pre></td></tr></table></figure>
<p>在压缩过程中，暂时忽略 <code>compact_to_bottom_level</code> 保留所有版本的数据（不执行实际的删除操作）。确保不同时间戳的相同 <code>user_key</code> 在同一个的 SST 中，即使超出 SST 的大小限制，从而简化其他功能的开发。个人认为主要是 Leveled Compaction 会从上层部分压缩到下层，如果多个版本不在一个 SST 中，会存在旧版本的键值对在上层而新版本的键值对被压缩到下层的情况。修改 <code>LsmIterator</code> 包含时间戳字段，只迭代 <code>&lt;=</code> 当前时间戳的最新数据，如果键被删除就跳过该键的所有旧版本。应该首先判断版本再判断删除，因为删除操作可能是在快照之后的版本执行的。</p>
<p>在 <code>get</code> 读取路径中，只需要根据当前时间戳创建事务，读取快照内可见的数据即可。不过由于内存表会包含多个版本的数据，所以只能使用范围查询来查找该 <code>user_key</code> 的最新可见版本。在 <code>scan</code> 读取路径中，如果 <code>lower</code> 和 <code>upper</code> 是 <code>Bound::Included</code>，则对应的时间戳是 <code>ts</code> 和 <code>TS_RANGE_END</code>。如果是 <code>Bound::Excluded</code>，则对应的时间戳是 <code>TS_RANGE_END</code> 和 <code>ts | TS_RANGE_BEGIN</code>。因为对于 <code>lower</code> 而言，必须定位到对应 <code>user_key_begin</code> 的最旧版本，才能确保迭代器跳过该 <code>user_key_begin</code>。对于 <code>upper</code> 而言，必须定位到 <code>ts</code> 及更新的版本才能确保迭代器跳过该 <code>user_key_end</code>。</p>
<h3 id="Watermark-and-Garbage-Collection">Watermark and Garbage Collection</h3>
<p>Watermark 是维护系统中 <code>lowest_read_ts</code> 的结构，可以在创建/终止事务时，使用 <code>BTreeMap</code> 维护各个时间戳的引用计数来实现。然后压缩操作保留所有键的最新快照以及所有 <code>&gt;= lowest_read_ts</code> 的快照，例外情况是如果当前压缩到 <code>compact_to_bottom_level</code>，且键的最新快照是删除操作，且该快照 <code>&lt;= lowest_read_ts</code>，则不保留该键值对到新 SST 中。</p>
<h3 id="Transaction-and-Optimistic-Concurrency-Control">Transaction and Optimistic Concurrency Control</h3>
<p>事务内执行的修改操作都存储到事务的 <code>local_storage</code> 本地内存表中，该表不包含时间戳信息。读取操作会先读取本地内存表，再读取公共内存表及 SST 文件。本地内存表迭代器 <code>TxnLocalIterator</code> 和之前没有时间戳的公共内存表实现相同，而 <code>TxnIterator</code> 会使用 <code>TwoMergeIterator</code> 合并本地和公共数据，不过需要跳过被删除的键，由于之前只有 <code>LsmIterator</code> 会执行该逻辑。</p>
<p>提交事务会将当前事务的状态设置为已提交，然后将本地内存表的数据通过 <code>LsmStorageInner::write_batch</code> 批量提交到公共内存表中。如果在写入公共内存表的过程中崩溃，恢复时的 WAL 无法区分事务之间的边界，从而不能保证事务的原子性。可以实现批量 WAL，将事务内的写入操作批量提交给 WAL，然后添加 Header 和 Footer 来区分事务边界。而且要保证批量写入操作都存储到相同的内存表中，从而使得事务内的批量操作只存储在一个 WAL 文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   HEADER   |                          BODY                                      |  FOOTER  |</span><br><span class="line">|     u32    |   u16   | var | u64 |    u16    |  var  |           ...            |    u32   |</span><br><span class="line">| batch_size | key_len | key | ts  | value_len | value | more key-value pairs ... | checksum |</span><br></pre></td></tr></table></figure>
<h3 id="A-Partial-Serializable-Snapshot-Isolation">(A Partial) Serializable Snapshot Isolation</h3>
<p>在事务内执行读写操作时维护读写集，然后在提交时验证当前事务是否和已提交事务冲突（OCC），从而实现可串行化快照隔离。首先，需要确保验证、提交操作的原子性，所以在 <code>commit</code> 方法开始时持有 MVCC 的 <code>commit_lock</code> 锁。然后遍历在 <code>(read_ts, expected_commit_ts)</code> 范围内提交的事务，判断当前事务的读集是否和这些事务的写集重叠。如果重叠则说明当前事务和已提交事务冲突，直接返回错误信息。例外情况是，如果当前事务是只读的，则不需要验证冲突。基本想法是，写操作会基于读操作的结果执行，而只读则不会修改公共数据。</p>
<p>在本项目中，对于 <code>scan</code> 操作只将扫描到的键加入读集而不是扫描范围，这样实现简单但是无法真正保证可串行化快照隔离（依然存在 write skew 异常）。在读写集中存储的是键的哈希值，这样可以减少内存空间占用、加快验证速度，但是会存在哈希冲突导致误报。在提交事务时可以将提交时间戳小于 <code>lowest_read_ts</code> 的已提交事务数据移除，然后将当前事务数据加入已提交事务集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txn1: len(scan(..)) = 2</span><br><span class="line">txn2: len(scan(..)) = 2</span><br><span class="line">txn1: put key1 = 2, commit, read set = &#123;a, b&#125;, write set = &#123;key1&#125;</span><br><span class="line">txn2: put key2 = 2, commit, read set = &#123;a, b&#125;, write set = &#123;key2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Snack-Time-Compaction-Filters">Snack Time: Compaction Filters</h3>
<p>如果需要删除以某个字符串为前缀的所有键，正常调用删除方法不但不会减少空间占用，反而会为每个键新增一个删除版本，只有压缩到最底层才会真正删除。可以使用压缩过滤器，添加前缀匹配规则到压缩过滤器，然后在压缩过程中不保留匹配的键值对到 SST 中。不过保证正确的前提是，所有事务都不会读取相关的键。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-18T10:01:46.499Z" title="2025/4/18 18:01:46">2025-04-18</time>发表</span><span class="level-item"><time dateTime="2025-04-18T10:02:38.716Z" title="2025/4/18 18:02:38">2025-04-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></span><span class="level-item">4 分钟读完 (大约665个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/RateLimiter.java">RateLimiter</a> 代码。</p>
<h2 id="基本使用">基本使用</h2>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">rateLimiter.acquire();</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<p>抽取 <code>SmoothBursty</code> 限流器的关键代码，梳理基本的实现流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最多可以存储多少秒的许可来应对突发流量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> maxBurstSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许存储的最大许可数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成许可的间隔时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前存储的许可数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许下一个请求获取许可的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">nextFreeTicketMicros</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每秒生成的许可数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RateLimiter(<span class="type">double</span> permitsPerSecond) &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxBurstSeconds = <span class="number">1.0</span>;</span><br><span class="line">        maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">        stableIntervalMicros = TimeUnit.SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定数量的许可，阻塞请求知道可以获取，返回等待的时间（秒）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">permits</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;Requested permits (%s) must be positive&quot;</span>, <span class="keyword">permits</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> microsToWait;</span><br><span class="line">        <span class="comment">// 加锁保证线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">            <span class="type">long</span> <span class="variable">nowMicros</span> <span class="operator">=</span> instant.getEpochSecond() * <span class="number">1_000_000</span> + instant.getNano() / <span class="number">1000</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(<span class="keyword">permits</span>, nowMicros);</span><br><span class="line">            microsToWait = max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.parkNanos(microsToWait * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前请求允许获取许可的时间，设置当前存储的许可数量，以及下一个请求允许获取许可的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前时间大于 nextFreeTicket，则重新生成当前时间存储的许可数量，以及当前请求允许获取许可的时间</span></span><br><span class="line">        <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / stableIntervalMicros;</span><br><span class="line">            storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">            nextFreeTicketMicros = nowMicros;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储当前请求允许获取许可的时间作为返回值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">        <span class="comment">// 消耗已有的许可数量，然后根据需要新获取的许可数量，生成下一次请求的等待时间</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits);</span><br><span class="line">        <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend;</span><br><span class="line">        <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span> (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line">        <span class="comment">// 将等待时间添加到 nextFreeTicketMicros 中，如果溢出则设置为 Long.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nextFreeTicketMicros = Math.addExact(nextFreeTicketMicros, waitMicros);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            nextFreeTicketMicros = Long.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        storedPermits -= storedPermitsToSpend;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RateLimiter</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">wait</span> <span class="operator">=</span> rateLimiter.acquire(<span class="number">2</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;等待时间: %fs, 剩余许可: %f\n&quot;</span>, wait, rateLimiter.storedPermits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时间大于 nextFreeTicket，生成 maxPermits 个许可</span></span><br><span class="line"><span class="comment">// 请求 2 个许可，当前只有 1 个许可，等待 0 s，下一个请求的等待时间是 1 s</span></span><br><span class="line">等待时间: <span class="number">0.</span>000000s, 剩余许可: <span class="number">0.000000</span></span><br><span class="line"><span class="comment">// 请求 2 个许可，当前只有 0 个许可，等待 1 s，下一个请求的等待时间是 2 s</span></span><br><span class="line">等待时间: <span class="number">0.</span>967138s, 剩余许可: <span class="number">0.000000</span></span><br><span class="line"><span class="comment">// 请求 2 个许可，当前只有 0 个许可，等待 2 s，下一个请求的等待时间是 2 s</span></span><br><span class="line">等待时间: <span class="number">1.</span>981604s, 剩余许可: <span class="number">0.000000</span></span><br><span class="line">等待时间: <span class="number">1.</span>989831s, 剩余许可: <span class="number">0.000000</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-17T16:42:59.185Z" title="2025/4/18 00:42:59">2025-04-18</time>发表</span><span class="level-item"><time dateTime="2025-09-20T11:18:48.864Z" title="2025/9/20 19:18:48">2025-09-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">20 分钟读完 (大约3060个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/18/CMU%2015-445645%20%E2%80%94%20Fall%202024%20Projects/">CMU 15-445/645 — Fall 2024 Projects</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2024/">课程网站</a>，<a target="_blank" rel="noopener" href="https://github.com/cmu-db/bustub">项目地址</a>，<a target="_blank" rel="noopener" href="https://www.gradescope.com/">测试网站</a>，<a target="_blank" rel="noopener" href="https://discord.com/invite/YF7dMCg">Discord 频道</a>。尝试做一下新版的项目。</p>
<h2 id="Project-0-C-Primer">Project #0 - C++ Primer</h2>
<h3 id="Task-1-Task-2">Task #1 &amp; Task #2</h3>
<h4 id="算法设计">算法设计</h4>
<p>HyperLogLog 主要用于近似计算 multiset 中的基数（不同元素的数量），相比精确计算需要的 \(O(n)\) 空间 \(n\) 为基数的大小），该算法只需要使用很少的内存。</p>
<p>基本想法是，使用哈希函数将多重集合的元素映射到均匀分布的随机数上，然后记录最左或者最右连续 \(0\) 的最大数量。利用哈希值的随机性，某个比特位为零的概率是 \(\frac{1}{2}\)，如果最多 \(n\) 个连续的零，则估计多重集合的基数为 \(2^{n}\)，因为该哈希值出现的概率是 \(\frac{1}{2^{n}}\)。</p>
<p>不过该算法方差较大，只要有一个哈希值包含很多零，就会严重高估基数。所以，可以将多重集合拆分为多个子集，通常是利用哈希值的前 \(k\) 个比特位确定元素拆分到的桶，然后每个桶内维护剩余比特位中连续零的最大值，取加权平均值 \(2^{\frac{1}{m}\sum_{i=1}^{m}{R_{i}}}\) 得到每个桶的平均基数（其中 \(m=2^{k}\)），然后再乘以 \(m\) 得到多重集合的基数估计值。</p>
<p>额外的优化是使用 <code>constant=0.79402</code> 和调和平均来提升准确率，使用稀疏布局和密集布局来平衡内存开销和准确率，最后计算公式如下。（参考 <a target="_blank" rel="noopener" href="https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/">HyperLogLog in Presto: A significantly faster way to handle cardinality estimation</a>，<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=lJYufx0bfpw">A problem so hard even Google relies on Random Chance</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>）</p>
<div>
$$
CARDINALITY_{HLL}=constant\cdot m\cdot \frac{m}{\sum_{i=1}^{m}2^{-R_{i}}}
$$
</div>
<h4 id="注意事项">注意事项</h4>
<p>① <code>n_bits</code> 的范围可以确定下限是 0，上限不确定，如果很大会内存溢出。② 很多地方使用的是无符号整数，在使用字面量时需要声明后缀（例如 <code>1UL</code>），以及做算术运算时需要避免溢出（例如取负值时需要转为有符号数）。③ 做移位操作 <code>1 &lt;&lt; x</code> 时需要注意 <code>x</code> 的大小，如果结果超出表示范围则行为未定义。经过测试不同环境 <code>1 &lt;&lt; 32</code> 会得到 <code>0</code> 或者 <code>1</code>。④ 可以使用 <code>./test/hyperloglog_test --gtest_filter=HyperLogLogTest.EdgeTest1</code> 执行指定的测试。</p>
<h2 id="Project-1-Buffer-Pool-Manager">Project #1 - Buffer Pool Manager</h2>
<h3 id="Task-1-LRU-K-Replacement-Policy">Task #1 - LRU-K Replacement Policy</h3>
<h4 id="设计思路">设计思路</h4>
<p>简单的实现，使用单个哈希表维护 <code>frame_id</code> 到 <code>LRUKNode</code> 的映射关系，<code>LRUKNode</code> 负责维护该页面的最后 <code>k</code> 次访问时间戳，在淘汰时通过扫描整个哈希表来确定需要淘汰哪个 <code>frame_id</code>，淘汰的时间复杂度为 \(O(n)\)。如果使用两个链表分别维护 <code>&lt;k</code> 和 <code>&gt;=k</code> 的 Frame 访问顺序，如果不考虑 Pin，那么可以 \(O(1)\) 时间实现淘汰。但是由于不知道 Frame 是否被 Pin，所以仍然需要遍历链表查找第一个未被 Pin 的 Frame。也可以使用类似 TreeMap 的结构，直接存储未被 Pin 的所有 Frame，按照次数、时间戳排序，淘汰的时间复杂度是 \(O(\log{n})\)，不过每次访问都需要重新删除插入来保证排序。（实际上都差不多，因为 BPM 的主要瓶颈在磁盘 I/O）</p>
<h3 id="Task-2-Disk-Scheduler">Task #2 - Disk Scheduler</h3>
<h4 id="设计思路-2">设计思路</h4>
<p>比较有意思的设计就是毒丸（poison pill），队列中存储的是 <code>std::optional&lt;bustub::DiskRequest&gt;</code> 类型的元素，向队列中添加 <code>std::nullopt</code> 元素，表示终止工作线程的执行。</p>
<h3 id="Task-3-Buffer-Pool-Manager">Task #3 - Buffer Pool Manager</h3>
<h4 id="设计思路-3">设计思路</h4>
<p>缓冲池的基本功能就是获取 Frame，可以从空闲列表或者淘汰 Frame 来获取。如果是通过淘汰获取，则需要删除 Frame 和 Page 的映射关系、将脏页刷盘以及重置 FrameHeader。然后可以将 Frame 和 Page 关联，需要设置 Frame 和 Page 的映射关系、设置 FrameHeader 的成员变量、从磁盘读取数据、调用 LRUK 相关函数。</p>
<p>最后可以将该 Frame 和 PageGuard 关联，由于 PageGuard 会获取 Frame 的读写锁，所以要在创建 PageGuard 之前解锁 BPM 独占锁，从而避免 BPM 阻塞在 Frame 的锁上。例如，典型的情况是有两个线程同时对相同的 Page 获取 WritePageGuard。</p>
<p>线上测试就只有 <code>BufferPoolManagerTest.SchedulerTest (0/0)</code> 没有过，花几个小时找 BUG 都没找到，最后还是简单暴力打印日志解决问题。只能说别想太多，问题出在 <code>is_dirty_</code> 的设置位置不对，我在 GetDataMut 方法中设置，而即使不调用该方法，NewPage 得到的空白页面也算是脏页，所以要在构造函数中设置。而且，调用 FlushPage/FlushAllPages 之后不应该将脏页标志重置，因为只要 WritePageGuard 还在那么页面依然可能变脏。（如果在刷盘的过程中修改页面，或许会产生问题，应该在刷盘之前获取 Frame 的读写锁，但是要避免和 BPM 独占锁产生死锁，这个点暂时不做）</p>
<h3 id="Leaderboard-Task-Optional">Leaderboard Task (Optional)</h3>
<h4 id="方案一（×）">方案一（×）</h4>
<p>简单的想法是在磁盘 I/O 时不持有 BPM 锁，而是直接解锁然后在磁盘 I/O 结束之后加锁。但是在如下交错下，相同的页面会占用多个 Frame（Problem #1）。解决方式也有，就是在解锁 BPM 之前更新 Page 和 Frame 之间的映射关系。但是会有新的并发问题，也就是之后的线程判断 Page 在缓冲池中，然后直接读写该 Frame，而此时之前的脏页还没有刷盘，Page 数据也没有读取到 Frame 中（Problem #2）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Problem #1</span><br><span class="line">thread A -&gt; fetch page 1 -&gt; bpm lock -&gt; evict -&gt; bpm unlock (t1) -&gt; dirty flush</span><br><span class="line">thread B -&gt; fetch page 1 -&gt; bpm lock (t2) -&gt; evict (error)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Problem #2</span><br><span class="line">... -&gt; bpm lock -&gt; evict -&gt; update map -&gt; bpm unlock (t1) -&gt; dirty flush</span><br><span class="line">... -&gt; bpm lock (t2) -&gt; exist -&gt; bpm unlock -&gt; frame lock -&gt; read/write page (error)</span><br></pre></td></tr></table></figure>
<p>所以需要在解锁 BPM 之前给 Frame 加独占锁，但是这样做需要调整代码结构来避免死锁，也就是把 BPM 级别的共享变量的更新都放在解锁 BPM 之前，从而避免之后再加锁 BPM。这里给 Frame 加锁不会像之前一样阻塞 BPM，因为此时的 Frame 不被任何 PageGuard 持有。如果 Page 在缓冲池中，设置 Replacer 相关的数据一定要持有 BPM 锁，因为淘汰时只会加 BPM 锁，要避免页面在淘汰之后立即被访问的情况。（特殊情况可以不加，但是要注意如何设置值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Problem #3</span><br><span class="line">... -&gt; frame lock -&gt; bpm unlock (t1) -&gt; dirty flush -&gt; bpm lock (deadlock)</span><br><span class="line">... -&gt; bpm lock (t2) -&gt; exist -&gt; bpm unlock -&gt; frame lock (deadlock) -&gt; read/write page</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Problem #4</span><br><span class="line">... -&gt; bpm lock -&gt; exist page 1 -&gt; frame lock -&gt; bpm unlock (t1) -&gt; access page 1 (t4)</span><br><span class="line">... -&gt; bpm lock (t2) -&gt; evict page 1 (t3) -&gt; ...</span><br></pre></td></tr></table></figure>
<p>这样还是有问题，就是淘汰的 Frame 在包含脏页刷盘时会解锁 BPM，而此时如果有线程获取该 Page，则会从磁盘读取到旧页面或者此时磁盘中没有该页面（如果该页面是 NewPage）。此时需要额外维护哈希表存储相关信息，使用额外的锁来保护，该锁需要在解锁 BPM 之前持有，否则依然会发生上述错误。如果当前读取的 Page 还没有完成刷盘，则直接从旧 Frame 复制到当前 Frame 中。可以发现使用这种解锁 BPM 的方案会有各种问题，这都是我上次实现时遇到过的，最后 QPS 从 3700+ 反向优化到 1000+。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Problem #4</span><br><span class="line">... -&gt; bpm lock -&gt; evict page 1 -&gt; bpm unlock (t1) -&gt; dirty flush</span><br><span class="line">... -&gt; fetch page 1 -&gt; bpm lock (t2) -&gt; disk read</span><br></pre></td></tr></table></figure>
<h4 id="方案二（×）">方案二（×）</h4>
<p>主要瓶颈在单个 BPM 独占锁，可以使用类似 Java 的 ConcurrentHashMap 的思路，将 BPM 锁拆分成多个锁。由于不能使用外部现有的并发库，那么可以使用哈希表数组，根据 Page 的编号映射到不同哈希表中。如果需要同时锁定多个分区，则需要按照顺序加锁来避免死锁，可以使用 <code>std::scoped_lock</code>。还有很多坑点和方案一类似，最后 QPS 从 3700+ 反向优化到 900+。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Problem #1</span><br><span class="line">thread A -&gt; bpm lock 1 -&gt; bpm lock 2 (deadlock)</span><br><span class="line">thread B -&gt; bpm lock 2 -&gt; bpm lock 1 (deadlock)</span><br></pre></td></tr></table></figure>
<h4 id="方案三（√）">方案三（√）</h4>
<p>可以不使用额外的锁，而是设置标志位表示该页面正在刷盘或者读取中，例如在 Page 到 Frame 的哈希表中记录无效的 Frame 编号，然后其他获取线程使用条件变量等待执行完成。需要注意等待的条件是哈希表中不存在该 Page 映射或者对应 Frame 编号有效，因为如果空闲列表为空且无法淘汰其他 Frame，则需要手动删除该临时键值对而不会设置有效的 Frame 编号。此时可以在磁盘 I/O 时解锁 BPM，之后加锁修改标志位，然后唤醒线程。</p>
<p>如果磁盘调度器不使用线程池，则 QPS 反向优化到 900+。如果使用单队列 + 8 线程，则 QPS 优化到 5300+。实际上不使用磁盘调度器的后台线程，而是直接调用 Schedule 方法，QPS 可以到 14700+。使用单队列 + 16 线程，则 QPS 优化到 14000+，因为工作线程总共有 16 个。</p>
<p>如果为每个线程分配一个队列，任务循环放置到每个队列，则 QPS 只有 11000+。有延迟场景性能更低可能是因为没有任务窃取机制，某个线程没被调度导致相应队列的任务积压。但是无延迟场景的 QPS 更接近不使用后台线程的情况，因为各个线程不必竞争相同队列的锁。（该优化会有问题，如果存在对同一页面的多个磁盘 I/O 请求，可以想到的情况是主动 Flush 脏页，会存在多个对相同页面的写请求，无法保证顺序）</p>
<p>由于测试使用 8 个 Scan 线程顺序读，8 个 Get 线程随机写（使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zipf%27s_law">Zipfian 分布</a>）。由于第三个测试结果的权值最大，主要优化第三个场景，也就是顺序读每 0.1ms 执行一次，随机写每 1ms 执行一次。理论上最大 QPS 是 88000，目前看来 Scan 操作的 QPS 优化空间较大。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan_qps_large / 1000 + get_qps_large / 1000 + scan_qps_small / 1000 + get_qps_small / 1000 + scan_qps_1ms + get_qps_1ms</span><br></pre></td></tr></table></figure>
<p>经过测试，Scan 操作的缓存命中率都是 0%，使用优先淘汰策略（不论优先淘汰什么类型）的 Scan 操作 QPS 可以提升到 30000+。使用默认的 LRUK 淘汰策略、优先淘汰只被 Scan 访问的 Frame、优先淘汰只被 Get 访问的 Frame 的 Get 操作命中率和 QPS 分别是 7% 5800+、11% 4300+ 和 3% 6500+。</p>
<p>虽然按理说优先淘汰只被 Scan 访问的 Frame 比较正常，因为 Scan 线程是顺序读本身就无法利用缓存，提前淘汰不会影响性能。基于单队列 + 16 线程的代码，可以将 QPS 从 14000+ 优化到 42000+。但是实际上优先淘汰任意访问类型的 Frame 都可以得到差不多的 QPS，因为只要提升 Evict 的速度，就可以大幅提升 Scan 操作的 QPS。另外，命中率更高的 Get 操作 QPS 反而更低，真不知道什么原因。</p>
<h4 id="排名">排名</h4>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_large</th>
<th>get_qps_large</th>
<th>scan_qps_small</th>
<th>get_qps_small</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>98</td>
<td>ALEX</td>
<td>41513</td>
<td>4156</td>
<td>48125</td>
<td>643</td>
<td>3433</td>
<td>248</td>
<td>3776</td>
</tr>
<tr>
<td>24</td>
<td>ALEX</td>
<td>19407</td>
<td>19844</td>
<td>17793</td>
<td>21289</td>
<td>2491</td>
<td>2788</td>
<td>5358</td>
</tr>
<tr>
<td>16</td>
<td>ALEX</td>
<td>107110</td>
<td>104764</td>
<td>99692</td>
<td>102739</td>
<td>8370</td>
<td>5930</td>
<td>14715</td>
</tr>
<tr>
<td>18</td>
<td>ALEX</td>
<td>13775</td>
<td>13869</td>
<td>14001</td>
<td>16822</td>
<td>8148</td>
<td>5829</td>
<td>14035</td>
</tr>
<tr>
<td>22</td>
<td>ALEX</td>
<td>70177</td>
<td>70478</td>
<td>65910</td>
<td>73478</td>
<td>5775</td>
<td>5049</td>
<td>11105</td>
</tr>
<tr>
<td>4</td>
<td>ALEX</td>
<td>19866</td>
<td>10945</td>
<td>20708</td>
<td>13994</td>
<td>37939</td>
<td>4325</td>
<td>42330</td>
</tr>
</tbody>
</table>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/55/">55</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">165</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">38</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/"><span class="level-start"><span class="level-item">协调服务</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/ZooKeeper/"><span class="level-start"><span class="level-item">ZooKeeper</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-14T09:16:58.479Z">2025-10-14</time></p><p class="title"><a href="/2025/10/14/Caffeine%20W-TinyLFU/">Caffeine W-TinyLFU</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-13T14:21:30.428Z">2025-10-13</time></p><p class="title"><a href="/2025/10/13/Linux%20Page%20Cache/">Linux Page Cache（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-21T10:49:47.130Z">2025-09-21</time></p><p class="title"><a href="/2025/09/21/%E5%A4%8D%E7%8E%B0%20Apache%20Shiro%201.2.4%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">复现 Apache Shiro 1.2.4 反序列化漏洞</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-31T16:00:00.000Z">2025-08-01</time></p><p class="title"><a href="/2025/08/01/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-08T16:00:00.000Z">2025-07-09</time></p><p class="title"><a href="/2025/07/09/%E4%BD%BF%E7%94%A8%20ZooKeeper%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">使用 ZooKeeper 实现分布式锁</a></p><p class="categories"><a href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/">协调服务</a> / <a href="/categories/%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1/ZooKeeper/">ZooKeeper</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">102</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">clist</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://csdiy.wiki/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdiy</span></span><span class="level-right"><span class="level-item tag">csdiy.wiki</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>