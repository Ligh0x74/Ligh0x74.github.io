<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-12T10:36:07.604Z" title="2024/2/12 下午6:36:07">2024-02-12</time>发表</span><span class="level-item"><time dateTime="2024-02-12T10:39:27.025Z" title="2024/2/12 下午6:39:27">2024-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/">Codeforces</a></span><span class="level-item">9 分钟读完 (大约1370个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/12/Codeforces%20Round%20924%20(Div.%202)/">Codeforces Round 924 (Div. 2)</a></p><div class="content"><h2 id="Rectangle-Cutting"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1928/problem/A">Rectangle Cutting</a></h2>
<h3 id="题目">题目</h3>
<p>输入两个整数 \(a\) 和 \(b\)，表示矩形 \(a\times b\)，判断是否能将矩形切割一次再拼接得到不同的矩形，切割线要求平行于某条边且得到的矩形边长为整数。</p>
<p>数据范围：\(1\leq a,b\leq 10^{9}\)。</p>
<h3 id="思路">思路</h3>
<p>以下讨论总是假设 \(a\leq b\)：</p>
<ul>
<li>首先我们总是应该对半切，如果不对半切，并且想要拼接得到矩形，那么只能切割更长的边 \(b\)，得到 \(a\times a\) 和 \(a\times(b-a)\)，但是不论怎么拼接都和原矩形相同。</li>
<li>如果 \(a\) 是偶数，可以总是对半切 \(a\)，然后拼接得到不同的矩形 \(\frac{a}{2}\times 2b\)。</li>
<li>如果 \(a\) 是奇数，\(b\) 必须是偶数，否则无法对半切。此时只能对半切 \(b\)，拼接得到矩形 \(2a\times\frac{b}{2}\)，当 \(a\neq\frac{b}{2}\) 时，得到的矩形和原矩形不同。</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> io.nextInt(), b = io.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span> || b % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; b != <span class="number">2</span> * a) &#123;</span><br><span class="line">        io.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        io.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Equalize"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1928/problem/B">Equalize</a></h2>
<h3 id="题目-2">题目</h3>
<p>输入长度为 \(n\) 的数组 \(a\)，可以选择一个 \([1,n]\) 的任意排列 \(p\)，执行 \(a_{i}=a_{i}+p_{i}\) 操作。输出执行操作之后，能够得到的数组 \(a\) 中相同元素最大出现次数的最大值。</p>
<p>数据范围：\(1\leq n\leq 2\cdot 10^{5}\)，\(1\leq a_{i}\leq 10^{9}\)。</p>
<h3 id="思路-2">思路</h3>
<p>将数组加上任意排列，肯定是更小的数对应更大的数，才能使相同元素的最大出现次数最大化。我们可以将数组 \(a\) 排序同时去重，之所以去重是因为相同元素加上排列之后必定不相同，然后将排列看作固定的递减数组。只要数组 \(a\) 中的两个数的差值小于 \(n\)，那么这两个数之间的元素必定可以在操作之后变成相同的元素。问题就转化为求区间的最大长度，同时最大值和最小值的差值小于 \(n\)，可以使用滑动窗口求解。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        set.add(io.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> set.size(), idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x : set) &#123;</span><br><span class="line">        a[idx++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[j] - a[i] &gt;= n) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Physical-Education-Lesson"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1928/problem/C">Physical Education Lesson</a></h2>
<h3 id="题目-3">题目</h3>
<p>输入两个整数 \(n\) 和 \(x\)，求 \(k\) 的个数，使得对于编号为 \(1\) 到 \(k\) 的位置，满足第 \(n\) 个位置的编号为 \(x\)。第 \(n\) 个位置是按往返来计算的，例如 \(1,2,\dots,k-1,k,k-1,\dots,2,1\)，第 \(1\) 和 \(1+2k-2\) 个位置的编号都为 \(1\)。当 \(k&gt;1\) 时，编号循环的周期就是 \(2k-2\)。题目限制 \(k&gt;1\)。</p>
<p>数据范围：\(1\leq x&lt;n\leq 10^{9}\)。</p>
<h3 id="思路-3">思路</h3>
<p>\(k\) 必须满足 \(k\geq x\)，同时 \((2k-2)\cdot t+x=n\) 或 \((2k-2)\cdot t+k+k-x=n\)，变形得到 \(n-x=2\cdot(k-1)\cdot t\) 或 \(n+x-2=2\cdot(k-1)\cdot(t+1)\)。求 \(k\) 的个数，可以首先求出 \(\frac{n-x}{2}\) 和 \(\frac{n+x-2}{2}\) 的约数，约数加一就是满足等式的 \(k\) 值，最后限制 \(k\geq x\)，得到答案。其实也可以不使用集合去重，只需要特判 \(x=1\) 和 \(k=x\) 的情况。</p>
<h3 id="代码-3">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt(), x = io.nextInt();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    calc(n - x, x, set);</span><br><span class="line">    calc(n + x - <span class="number">2</span>, x, set);</span><br><span class="line">    io.println(set.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Set&lt;Integer&gt; set)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= y) &#123;</span><br><span class="line">                set.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x / i != i &amp;&amp; x / i + <span class="number">1</span> &gt;= y) &#123;</span><br><span class="line">                set.add(x / i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lonely-Mountain-Dungeons"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1928/problem/D">Lonely Mountain Dungeons</a></h2>
<h3 id="题目-4">题目</h3>
<p>输入三个整数 \(n,b,x\)，以及长度为 \(n\) 的数组 \(c\)。有 \(n\) 种生物，每种生物的数量为 \(c_{i}\)。你需要将所有生物分为 \(k\) 组，位于不同组的每对同种生物会使总分增加 \(b\)，同时总分会减少 \((k-1)\cdot x\)。输出能够得到的最大分数。</p>
<p>数据范围：\(1\leq n\leq 2\cdot 10^{5}\)，\(1\leq b\leq 10^{6}\)，\(0\leq x\leq 10^{9}\)，\(1\leq c_{i}\leq 2\cdot 10^{5}\)，\(\sum_{i=1}^{n}c_{i}\leq 2\cdot 10^{5}\)。</p>
<h3 id="思路-4">思路</h3>
<p>首先需要知道，对于某种生物 \(i\) 和固定的 \(k\)，将 \(c_{i}\) 尽量平均分配是最优的，不过我也不知道该怎么证明。当 \(k&gt;c_{i}\) 时，得分总是为 \(C_{c_{i}}^{2}\cdot y^{2}\)。当 \(k\leq c_{i}\) 时，就需要将 \(c_{i}\) 分为，\(c_{i}\bmod k\) 组包含 \(y=\lceil\frac{c_{i}}{k}\rceil\) 个该种生物，\(k-c_{i}\bmod k\) 组包含 \(y^{\prime}=\lfloor\frac{c_{i}}{k}\rfloor\) 个该种生物。得分为：</p>
<div>
$$
C_{k-c_{i}\bmod k}^{2}\cdot y^{2}+C_{c_{i}\bmod k}^{2}\cdot y^{\prime 2}+(k-c_{i}\bmod k)\cdot(c_{i}\bmod k)\cdot y\cdot y^{\prime}
$$
</div>
<p>根据以上讨论，很容想到暴力枚举组数 \(k\)，然后内层循环计算该组数下的最大得分，总时间复杂度为 \(O(\max(c_{i})\cdot n)\)。由于题目限制 \(\sum_{i=1}^{n}c_{i}\leq 2\cdot 10^{5}\)，我们可以预处理得到所有 \(c_{i}\) 在组数为 \([1,c_{i}]\) 下的最大得分之和，从而可以将暴力枚举的内循环优化为 \(O(1)\) 时间复杂度。</p>
<h3 id="代码-4">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt(), b = io.nextInt(), x = io.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        c[i] = io.nextInt();</span><br><span class="line">        m = Math.max(m, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[] f = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="type">long</span>[] g = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= c[i]; j++) &#123;</span><br><span class="line">            f[j] += calc(c[i], j);</span><br><span class="line">        &#125;</span><br><span class="line">        g[c[i]] += calc(c[i], c[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ans = Math.max(ans, (f[i] + g[i - <span class="number">1</span>]) * b - (<span class="type">long</span>) (i - <span class="number">1</span>) * x);</span><br><span class="line">        g[i] += g[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / k, b = n % k;</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> (<span class="type">long</span>) (k - b) * (k - b - <span class="number">1</span>) / <span class="number">2</span> * a * a;</span><br><span class="line">    res += (<span class="type">long</span>) b * (b - <span class="number">1</span>) / <span class="number">2</span> * (a + <span class="number">1</span>) * (a + <span class="number">1</span>);</span><br><span class="line">    res += (<span class="type">long</span>) (k - b) * b * a * (a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-10T10:15:42.288Z" title="2024/2/10 下午6:15:42">2024-02-10</time>发表</span><span class="level-item"><time dateTime="2024-02-10T10:26:07.799Z" title="2024/2/10 下午6:26:07">2024-02-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></span><span class="level-item">17 分钟读完 (大约2528个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/10/Chain%20Replication%20for%20Supporting%20High%20Throughput%20and%20Availability/">Chain Replication for Supporting High Throughput and Availability</a></p><div class="content"><p>阅读论文 <a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2021/papers/cr-osdi04.pdf">Chain Replication</a>，参考 <a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2021/notes/l-cr.txt">note</a>。</p>
<h2 id="概述">概述</h2>
<p>链式复制是一种容错复制方式，可以保证高性能、高可用和强一致性（可线性化）。客户端的请求都以原子的方式执行，查询请求直接发送到 tail，更新请求发送到 head，然后沿着链传递到 tail。在没有故障的情况下，可线性化保证源于以下两点：只有 tail 会响应客户端的请求，以及更新操作只会在 head 计算一次，从而可以避免冗余计算和非确定性操作带来的一致性问题。</p>
<p><img src="/img/MIT_6.824.assets/1707445472863.png" alt=""></p>
<h2 id="实现">实现</h2>
<h3 id="基本概念">基本概念</h3>
<p>对象由 \(objID\) 唯一标识，\(Hist_{objID}\) 表示该对象上已执行的请求，\(Pending_{objID}\) 表示该对象上待执行的请求。对于链式复制来说，客户端视图中的 \(Hist_{objID}\) 被定义为 tail 存储的 \(Hist_{objID}\)，\(Pending_{objID}\) 被定义为任何服务器接收到的、没有被 tail 执行的客户端请求。注意，这两个状态都是对象的客户端视图，而不是实际存储在服务器中的数据。此外，论文只是为方便论证才将对象状态描述为 \(Hist_{objID}\)，实际的状态应该是对象的当前值。</p>
<p><img src="/img/MIT_6.824.assets/1707444919477.png" alt=""></p>
<h3 id="故障检测和恢复">故障检测和恢复</h3>
<p>链式复制使用额外的服务来检测故障，重新配置链，通知客户端链头和链尾对应的服务器。论文称该服务为 master，使用复制进行容错，使用 Paxos 维持多个 master 副本之间的一致性。可以将其视为类似 ZooKeeper 的协调服务。虽然论文没有提及，不过检测故障通常是使用定时心跳。</p>
<p><img src="/img/MIT_6.824.assets/1707452204180.png" alt=""></p>
<h4 id="链头故障">链头故障</h4>
<p>master 直接将 head 的下一个节点作为新的 head，然后通知客户端。所有旧 head 接收而未转发给后继的请求最终都会超时，然后客户端会重试。该过程相当于执行 T2 转移。</p>
<h4 id="链尾故障">链尾故障</h4>
<p>master 直接将 tail 的上一个节点作为新的 tail，然后通知客户端。因为更新是从前往后传播的，所以上一个节点的视图至少和旧 tail 的视图一样新，不会影响一致性。该过程相当于执行 T3 转移。</p>
<h4 id="中间故障">中间故障</h4>
<p>master 会修改故障节点的前驱和后继的指针，从而将故障节点从链中删除。但是，如果前驱转发更新请求到故障节点，而故障节点没有将其转发至后继，那么前驱需要一种机制识别这部分请求，然后重新将其转发至后继。</p>
<p>每个服务器维护一个更新请求的已转发列表 \(Sent\)，当服务器将请求转发到后继时，会将该请求添加到列表中。当更新请求 \(r\) 转发到尾节点，并被尾节点处理时，尾节点会向前驱发送确认信息 \(ack( r)\)。收到 \(ack( r)\) 的服务器会将 \(r\) 从 \(Sent\) 列表中删除，同时将 \(ack( r)\) 转发到前驱。</p>
<p><img src="/img/MIT_6.824.assets/1707469017397.png" alt=""></p>
<p>当中间节点 \(S\) 故障，master 向后继 \(S^{+}\) 发送其新的前驱 \(S^{-}\)，\(S^{+}\) 会响应 master 确认消息，其中包含 \(S^{+}\) 收到的最后一个更新请求的序列号。然后 master 向前驱 \(S^{-}\) 发送其新的后继 \(S^{+}\) 和序列号，\(S^{-}\) 会将在 \(Sent_{S^{-}}\) 中且在序列号之后的请求转发到 \(S+\)，这部分请求就是故障节点 \(S\) 未转发至 \(S^{+}\) 的请求。该机制的关键在于保留已发送请求的列表，\(ack\) 的作用只是回收空间。</p>
<p><img src="/img/MIT_6.824.assets/1707470237032.png" alt=""></p>
<h4 id="恢复冗余">恢复冗余</h4>
<p>发生故障的服务器会从链中删除，需要恢复冗余以保证容错。理论上，可以将新服务器添加到链中的任意位置。实践中，添加到链尾比较简单。master 会要求当前链尾 \(T\) 转发对象已执行的请求队列 \(Hist_{objID}^{T}\) 到新的链尾 \(T^{+}\)，在转发完成之前，依然是当前链尾 \(T\) 执行查询请求和前驱传来的更新请求，以及响应客户端。该过程中执行的更新请求同时会被添加到 \(Sent_{T}\)，该操作与 \(Sent_{T}\) 的定义不一致，之后会处理。当 \(Hist_{objID}^{T}=Hist_{objID}^{T^{+}}\oplus Sent_{T}\) 成立时，也就是转发开始时的 \(Hist_{objID}^{T}\) 都转发到 \(T^{+}\) 时，\(T^{+}\) 可以成为链尾。</p>
<p>过程如下：如果 master 收到上述不变式成立的通知，master 会通知 \(T\) 其不是链尾，之后 \(T\) 会将收到的查询请求转发到 \(T^{+}\)。然后 \(Sent_{T}\) 中的更新请求也会被转发到 \(T^{+}\)，转发完成之后，就符合 \(Sent_{T}\) 的定义，\(T\) 会通知 master 将 \(T^{+}\) 作为新的链尾。然后，master 会通知客户端新的链尾。PS：注意，此时 \(Sent^{T}\) 中的请求已经响应客户端。</p>
<h3 id="对比主从复制">对比主从复制</h3>
<p>链式复制可以视为特殊的主从复制，头节点和尾节点共同充当主节点，其他节点作为从节点。相比传统的主从复制（指的是强一致性的主从复制）：</p>
<ul>
<li>链式复制的查询，由链尾的服务器处理，不会被链中其他服务器的活动延迟。而主从复制的查询，主节点需要等待之前的更新被从节点确认，才能执行查询。PS：个人理解，指的应该是多客户端之间的更新和查询，单客户端是同步的，只有接收到上一个请求的响应才会发送下一个请求，否则链式复制是无法保证客户端的 FIFO 执行顺序。</li>
<li>链式复制串行传播更新，主从复制并行传播更新，所以链式复制的更新延迟更高，而且和链的长度成正比。</li>
</ul>
<h2 id="测试">测试</h2>
<p>根据论文中的模拟实验可以发现，链式复制比主从复制具有更高的读取性能，但是强一致性保证使得读写性能不能随着机器的数量线性扩展，不像 ZooKeeper。比较令人惊讶的是，在更新请求至少占总请求数的 15% 时，弱一致性保证的读取方案反而会降低系统的总吞吐量，因为在头节点的查询和更新会产生竞争。主从复制的吞吐量不会受复制因子的影响，而链式复制的更新是串行传播的，似乎吞吐量会随着链的长度增加而减少。但是，只要有足够多的更新请求，那么通过一个预热时间启动流水线，吞吐量可以恢复正常水平。</p>
<p><img src="/img/MIT_6.824.assets/1707534017384.png" alt=""></p>
<h2 id="问题">问题</h2>
<p>Q：更新请求不是幂等的，如果响应丢失，客户端重试更新请求怎么办？</p>
<p>A：目前讨论的系统：GFS 的 primary chunkserver 重试会导致重复追加，我猜客户端重试大致也是如此；VM-FT 请求是否幂等取决于虚拟机中的应用程序；Raft 要求请求包含唯一标识，在状态机层去重；尽管 ZooKeeper 的事务是幂等的，但是请求不是幂等的，没有讨论如何处理；链式复制论文提到可以在重试之前，进行查询判断更新是否已经执行。总的来说，是否要求幂等是根据系统的实际使用场景而定的，课程中也提到，ZooKeeper 和链式复制也可以使用和 Raft 类似的方法去重，从而实现幂等。</p>
<p>Q：更新请求的延迟和链的长度成正比，那么超时时间会更长，如果请求丢失似乎需要更多等待？</p>
<p>Q：如果链头 \(S\) 和 master 发生网络分区故障，那么 \(S^{+}\) 会成为新链头，而此时 \(S^{+}\) 依然会收到旧链头 \(S\) 的转发。节点必然需要一种机制判断是否应该忽略请求，这可以通过简单的判断请求的来源是否是其前驱来实现。</p>
<p>Q：客户端在连接到服务器时，以及链头或链尾被改变时，master 需要通知客户端，如果客户端很多会有什么问题？</p>
<h2 id="总结">总结</h2>
<p>课程提到，复制状态机有两种主要的实现方式，一种是使用共识算法复制所有操作，另一种是使用配置服务 + 主从复制，配置服务中的共识算法仅复制元数据，其他操作不需要使用共识算法复制。链式复制使用的是第二种方式，它需要利用额外的配置服务进行故障恢复，同时避免脑裂。链式复制概念简单，只有中间故障和恢复冗余稍微复杂一点。和共识算法不同，只要有一个服务器故障，就可能会导致读请求或写请求的短暂中断。论文在模拟实验中提到多链和对象放置策略，我认为论文的描述很模糊，所以没介绍。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-05T00:49:58.762Z" title="2024/2/5 上午8:49:58">2024-02-05</time>发表</span><span class="level-item"><time dateTime="2024-02-05T00:52:11.655Z" title="2024/2/5 上午8:52:11">2024-02-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></span><span class="level-item">26 分钟读完 (大约3869个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/05/ZooKeeper%20Wait-free%20coordination%20for%20Internet-scale%20systems/">ZooKeeper: Wait-free coordination for Internet-scale systems</a></p><div class="content"><p>阅读论文 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf">ZooKeeper</a>，参考 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/zookeeper-faq.txt">FAQ</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/l-zookeeper.txt">note</a>，<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/current/index.html">官方文档</a>，另一个课程的 <a target="_blank" rel="noopener" href="http://www.scs.stanford.edu/20sp-cs244b/notes/zookeeper.txt">note</a>。</p>
<h2 id="概述">概述</h2>
<p>ZooKeeper 是一个协调服务，用于协调分布式应用程序。它没有实现特定的协调原语（例如：配置、选举、锁），而是提供 API 供应用程序开发者使用，让开发者根据实际需要实现协调原语。ZooKeeper API 具有无等待特性，提供事件驱动机制。ZooKeeper 使用流水线（pipeline）架构处理请求，流水线自动支持客户端请求的 FIFO 执行顺序，从而允许客户端异步发送请求。ZooKeeper 没有实现可线性化一致性模型，它仅保证写操作的异步可线性化，以及读操作的写后读和单调读一致性（术语取自 DDIA），适合读多写少的工作负载。</p>
<h2 id="会话">会话</h2>
<p>客户端在连接到服务器时建立一个会话（session），同时获得一个会话 ID。只要会话 ID 有效，应用程序就可以通过客户端调用 ZooKeeper API。客户端会定期向服务器发送心跳，如果服务器在超时时间内没有收到心跳，则服务器会结束会话。如果客户端当前连接的服务器故障，则客户端在会话 ID 过期之前自动尝试连接到另一台服务器。</p>
<p><img src="/img/MIT_6.824.assets/1706791513708.png" alt=""></p>
<p>PS：创建会话类似写操作，需要经过多数服务器同意，会话的状态也会使用日志持久化，它是一个全局会话。这也可以解释，为什么客户端可以使用同一个会话 ID 透明地切换到另一台服务器。由于开销较大，ZooKeeper 在之后的版本添加了本地会话功能，本地会话只能执行全局会话操作的子集，状态只在本地服务器维护。</p>
<h2 id="数据模型和监视">数据模型和监视</h2>
<p>ZooKeeper 以类似文件系统的树形结构在内存中存储协调数据（应用程序元数据），树中的数据节点被称为 znode，由路径名唯一标识。不同的应用程序在各自的子树中组织数据，存储在节点中的数据以原子的方式被读写。节点会维护一个统计结构，包含版本号、时间戳和事务 ID（zxid）等元数据。节点分为常规（Regular）和临时（Ephemeral）两种类型，客户端可以显示创建和删除节点。特别的，临时节点如果没有被显示删除，则在创建它们的会话终止时被自动删除，以及临时节点不能有子节点。</p>
<p><img src="/img/MIT_6.824.assets/1706793448885.png" alt=""></p>
<p>创建节点时，客户端可以设置顺序（sequential）标志，从而将一个计数值附加到该节点的路径末尾，同一父节点的子节点的计数值根据创建顺序单调递增。客户端可以为节点设置一次性监视（watch）标志，该标志在客户端连接的服务器本地维护。当监视触发时，服务器会向客户端发送一个监视事件，同时取消监视。有两种监视类型，监视数据和监视子节点。有四种监视事件，创建、删除、数据变化、子节点变化（不包含子节点的数据变化）。监视和会话相关，当会话结束时，监视也会被取消。ZooKeeper 保证设置监视的客户端在看到变化之前，会收到服务器的通知。会话事件也会触发监视，以便客户端知道监视事件可能延迟。</p>
<h2 id="原语示例">原语示例</h2>
<p>客户端可以使用 ZooKeeper API 实现更强的原语，示例如下。更多示例（双重屏障、2PC、选举）可以查看<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/r3.9.1/recipes.html">官方文档</a>。</p>
<h3 id="配置管理">配置管理</h3>
<p>ZooKeeper 可用于分布式应用程序的配置管理，可以将配置存储在 znode 中。客户端从 znode 读取配置，同时设置监视标志。如果配置被更新，则客户端会收到通知，然后再次从该 znode 读取配置和设置监视标志。</p>
<h3 id="群组成员">群组成员</h3>
<p>客户端可以创建一个 znode 表示一个群组，当进程以该群组的成员身份启动时，它会在该 znode 下创建一个临时子 znode。如果每个进程有一个唯一的名称，则将该标识作为子 znode 的名称，否则可以使用顺序标志，使其获得唯一的名称。进程可以将其元数据存储在该子 znode 中，例如地址和端口。如果进程终止，则临时节点会被自动删除。可以通过在 znode 上设置监视标志，从而监视群组成员的变化。</p>
<h3 id="简单锁">简单锁</h3>
<p>可以将一个指定路径的 znode 作为锁，客户端可以创建临时 znode 来获取锁，其他客户端通过判断 znode 是否存在来判断是否能够获取锁，同时设置监视标志。当临时 znode 被显示或自动删除，则表示锁被释放。此时，等待锁的客户端将收到通知。但是该实现存在羊群效应（herd effect）：在锁被释放时，许多客户端会争抢同一个锁。</p>
<h3 id="无羊群效应的简单锁">无羊群效应的简单锁</h3>
<p>直觉上来说，将获取锁的请求按照 FIFO 的顺序排队处理，那么就可以避免羊群效应。可以使用顺序标志在指定父 znode 下创建临时子 znode，客户端通过判断其创建的临时 znode 是否是序号最小的，来判断它是否已获取锁。当客户端需要释放锁时，只需删除其创建的临时 znode。个人认为，有无羊群效应的简单锁，有点像是 <code>notify_all</code> 和 <code>notify_one</code> 的区别。</p>
<p><img src="/img/MIT_6.824.assets/1706926084364.png" alt=""></p>
<p>特别的，在代码实现时有一个陷阱，ZooKeeper 没有提供监视来通知当前 znode 的序号是否最小。在创建 znode 之后， 我们首先需要获取子 znode 列表，判断当前是否是最小的。如果不是，则可以在前一个节点上设置监视。但是，该监视触发并不意味着当前客户端已获取锁，因为有可能只是前一个客户端提前结束会话，此时仍存在更小的序号。</p>
<h3 id="读写锁">读写锁</h3>
<p><img src="/img/MIT_6.824.assets/1706928532308.png" alt=""></p>
<h2 id="实现细节">实现细节</h2>
<p>ZooKeeper 使用复制提供容错，使用原子广播协议（ZAB）保证多个副本之间的一致性。客户端仅连接到一个服务器发送请求，写请求会被转发给领导者，读请求读取本地数据库而不需要通过领导者。本地处理读请求使得读取性能可以随着服务器的数量增加而增加，而不会受限于单个领导者。复制数据库是一个内存数据库，当日志持久化到磁盘时，才会将日志应用到内存数据库，同时会定期为数据库生成快照。PS：类似 Raft，内存数据库实际上就是一个状态机。</p>
<p><img src="/img/MIT_6.824.assets/1706932348740.png" alt=""></p>
<p>ZooKeeper 使用 ZAB 保证写操作的可线性化，同时保证异步请求按照客户端 FIFO 的顺序执行，从而实现写操作的异步可线性化（A-linearizability）。当领导者收到写请求时，如果请求包含的版本号和目标 znode 的未来版本号匹配，就会将请求转换为事务。之所以要和未来版本号匹配，是因为可能存在尚未应用到数据库的事务。如果事务未提交（复制到大多数），则无法应用到数据库。ZooKeeper 保证事务是幂等的，〈transactionType, path, value, new-version〉。</p>
<p>ZooKeeper 使用的是模糊快照（fuzzy snapshot），因为允许在创建快照的过程中更改状态机，而且也不像 Raft 使用写时复制，所以快照不对应某个时刻的状态，故称为模糊快照。不过，由于事务的幂等性，重放相同的日志也没有关系。从日志的角度看，模糊快照并不对应一个连续的日志范围，可能是断断续续的。</p>
<p>客户端向服务器发送读写请求和心跳消息，得到的响应中会包含服务器的 zxid。如果客户端连接到新服务器，会检查客户端的 zxid 和新服务器的 zxid，确保新服务器满足客户端的单调读一致性。如果新服务器的视图更旧，客户端可以连接另一台服务器。</p>
<h2 id="问题">问题</h2>
<p>Q：无等待（wait-free）是什么意思？</p>
<p>A：论文 <a target="_blank" rel="noopener" href="https://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf">Wait-Free Synchronization</a> 进行了介绍，并发数据对象的无等待实现可以保证，任何进程都能在有限步中完成任何操作，而不论其他进程的执行速度如何。个人认为这个定义有点抽象，无等待还有一个层次结构和共识数。类似的术语还有无锁、无障碍、无阻塞。FAQ 提供了一个简单的解释，为什么 ZooKeeper 是无等待的，因为客户端调用 API 不会被其他客户端阻塞，ZooKeeper 没有使用锁来阻塞调用。</p>
<p>Q：为何流水线自动支持客户端请求的 FIFO 执行顺序？异步请求为何能提高性能？</p>
<p>A：我的理解是 TCP 可以保证客户端请求的 FIFO 到达顺序。流水线将一个处理过程分解为多个组件，能够充分利用系统的资源。但流水线依然是一个顺序的处理过程，一般就是按照到达顺序处理的，所以能够自动支持 FIFO 执行顺序。异步请求能提高性能是流水线的特性，如果同步发送请求，流水线中的很多组件会处于空闲状态。</p>
<p>FAQ 中有问到 ZooKeeper 如何实现异步请求的 FIFO 执行顺序，按照论文的逻辑，这个问题就不对。论文首先说流水线支持 FIFO 执行顺序，然后推出客户端可以发送异步请求。从而我觉得，FAQ 的答案也不对。FAQ 对流水线的解释也有问题，他把流水线解释为批处理。</p>
<p>Q：如何实现读操作的写后读和单调读一致性？</p>
<p>A：写后读一致性可以由客户端的 FIFO 执行顺序保证，而单调读一致性通过检查客户端和服务器的 zxid 保证。</p>
<p>Q：ZooKeeper 如何实现监视（watch）？</p>
<p>A：FAQ 有解释，客户端通常会注册一个回调函数，该函数在监视触发时调用。Go 使用通道（channel）来实现，当监视触发时，服务器会向通道发送一个事件，然后应用程序可以从通道中获取该事件。但是有个疑问，Go 的通道能跨网络传输数据么。</p>
<p>Q：为什么请求不幂等，而事务幂等？</p>
<p>A：假设有一个带顺序标志的创建节点的请求，那么多次发送请求会创建不同的节点。事务是请求的幂等形式，论文中提到形如 〈transactionType, path, value, new-version〉。</p>
<p>Q：ZooKeeper 服务器、客户端和应用程序的关系？</p>
<p>A：个人理解，服务器提供低级原语，客户端使用 API 实现更高级的原语，应用程序使用客户端提供的高级原语。</p>
<p>Q：ZooKeeper 中的 zxid 和版本号有什么关系？</p>
<p>A：ZooKeeper 的每次状态更改（写操作）都会递增 zxid，而版本号则是 znode 的属性。个人认为，zxid 是 ZAB 层面的，版本号是数据库（状态机）层面的。</p>
<p>Q：可线性化和可串行化的区别？</p>
<p>A：可以看下 <a target="_blank" rel="noopener" href="http://www.bailis.org/blog/linearizability-versus-serializability/">Linearizability versus Serializability</a>，很清晰。</p>
<h2 id="总结">总结</h2>
<p>刚开始看这篇论文，涉及很多没见过的术语，看着比较折磨。如果深入细节的话，会花费很多时间。我确实一开始没有抓住重点，陷入如何在代码层面使用 ZooKeeper，无等待和通用对象是什么意思之类的。但是，如果从更高的层面来看，ZooKeeper 可以理解为 ZAB + 数据库（状态机），就是使用数据树结构提供一个通用的 API。</p>
<p>在查找资料的过程中发现很多不一致的地方，例如：<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/r3.9.1/apidocs/zookeeper-server/org/apache/zookeeper/ZooKeeper.html">API 文档</a>中描述异步请求会排队等待发送，但按照论文的描述应该不是这样的，不然怎么提高性能；<a target="_blank" rel="noopener" href="https://zookeeper.apache.org/doc/r3.9.1/zookeeperProgrammers.html#ch_zkGuarantees">一致性保证</a>中提到单一系统映像，定义首先说保证看到相同的视图，然后又说不会看到旧视图，但这完全不是一个意思；FAQ 中对异步请求如何实现客户端 FIFO 执行顺序的讨论，我认为论文和另一份笔记都证明 FAQ 的错误。</p>
<p>在阅读论文和资料的过程中，经常会看到某个描述，感觉模糊不清，只能凭自己的猜测去理解。实际上确实有很多模糊的地方，没有描述具体的实现方式，但有些问题其实论文中也给出了回答。所以，在读论文的过程中还是要仔细一点，遇到不懂的不要随便猜测，先记下问题，因为很可能是一个错误的猜测，还会干扰之后的理解。总之，论文只是提供一个简要的说明，深入理解还需要实际使用 ZooKeeper，以及阅读源码。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-29T14:24:44.457Z" title="2024/1/29 下午10:24:44">2024-01-29</time>发表</span><span class="level-item"><time dateTime="2024-01-31T16:30:27.717Z" title="2024/2/1 上午12:30:27">2024-02-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></span><span class="level-item">34 分钟读完 (大约5026个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/29/In%20Search%20of%20an%20Understandable%20Consensus%20Algorithm%20(Extended%20Version)/">In Search of an Understandable Consensus Algorithm (Extended Version)</a></p><div class="content"><p>阅读论文 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">Raft</a>，参考 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-faq.txt">FAQ1</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/l-raft.txt">note1</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft2-faq.txt">FAQ2</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/l-raft2.txt">note2</a>。</p>
<h2 id="概述">概述</h2>
<p>MapReduce 的 master、GFS 的 master 和 VM FT 的共享磁盘都存在单点故障（即使 GFS 的 master 存在副本，其依然是单点故障，因为故障时系统会停止），从而可以很简单的避免脑裂。脑裂会发生的根本原因在于，无法区分机器故障和网络分区故障。共识算法使用多数原则（仲裁协议，quorum），可以在复制的同时避免脑裂。如果集群中有 \(2f+1\) 个服务器，则共识算法可以容忍 \(f\) 个服务器故障。共识算法通常使用状态机复制，以复制日志的方式实现。客户端、服务器以及共识算法和状态机的关系见下图。</p>
<p><img src="/img/MIT_6.824.assets/1706325532181.png" alt=""></p>
<p>Raft 的主要设计目标是可理解性，通过分解问题和减少状态来实现。问题被分解为多个子集，例如：领导者选举、日志复制、安全性和成员变更。使用随机化超时时间、限制选举保证日志单向流动等方式，来减少状态。</p>
<p><img src="/img/MIT_6.824.assets/1706326579904.png" alt=""></p>
<h2 id="实现">实现</h2>
<h3 id="基础知识">基础知识</h3>
<p>服务器有三种状态：leader、follower、candidate，服务器初始时都是 follower。正常情况下，只有一个 leader 和多个 follower。只有 leader 会处理客户端的请求，如果客户端将请求发送给 follower，该 follower 会将其重定向到 leader。服务器之间使用远程过程调用（RPC）进行通信，基本的 Raft 算法使用两种 RPC，candidate 在选举时会发起 RequestVote RPC，leader 在复制日志和发送心跳时会发起 AppendEntries RPC（心跳消息是没有日志条目的 AppendEntries RPC）。Raft 保证 RPC 是幂等的。</p>
<p><img src="/img/MIT_6.824.assets/1706240528316.png" alt=""></p>
<p>时间被划分为任期（term），使用单调递增的连续整数表示。每个服务器都会持久存储当前任期，不同服务器的任期可能不同（由于故障）。服务器之间进行通信时会交换任期，处于旧任期的服务器会更新其任期。如果 leader 或 candidate 发现自己包含旧任期，它会成为 follower。如果服务器收到具有旧任期的请求，它会拒绝该请求。</p>
<p><img src="/img/MIT_6.824.assets/1706241065591.png" alt=""></p>
<h3 id="领导者选举">领导者选举</h3>
<p>如果一个 follower 在超时时间（该时间被称为选举超时，election timeout）内没有收到来自 leader 或 candidate 的有效 RPC（何为有效，个人认为任期不旧就是有效），它将递增其任期成为 candidate，开始选举新的 leader。它为自己投票，然后向集群中的其它服务器发送 RequestVote RPC。</p>
<ul>
<li>如果 candidate 收到大多数服务器的投票，它会成为新的 leader，同时向其他服务器发送心跳消息，以建立其权威防止新的选举。每个服务器在给定的任期内，只能投票给一个 candidate。服务器是否投票给某个 candidate 存在限制，将在安全性中讨论。</li>
<li>如果在等待投票时，candidate 收到 leader 的 AppendEntries RPC，且 leader 的任期大于等于 candidate 的任期，那么 candidate 会成为 follower。如果 leader 的任期更小，则 candidate 会拒绝该 RPC。或者收到其他 candidate 的 RequestVote RPC，且其任期大于当前 candidate 的任期，当前 candidate 同样会成为 follower。</li>
<li>如果存在多个 candidate 使选票分裂，使得没有 candidate 可以得到大多数服务器的投票，则每个 candidate 都会超时，继续递增任期，重新开始选举。Raft 使用随机 election timeout 来确保选票分裂很少发生（避免同时超时），election timeout 是从一个固定间隔中随机选择的（例如 [150, 300] 毫秒），每个候选人在开始选举时会重新随机化 election timeout。</li>
</ul>
<p>如果 follower 在执行完成 AppendEntries RPC 之后，回复之前发生崩溃，则 leader 会重试 RPC。如果 follower 重新上线，它会忽略重复请求中的日志条目。如果 candidate 在发送 RequestVote RPC 之后崩溃，重启之后它会重新发送 RPC，follower 会持久存储其投票的 candidate，避免在同一任期内多次投票。</p>
<p>为了保证系统的可用性，election timeout 存在如下要求：</p>
<div>
$$
broadcastTime\ll electionTimeout\ll MTBF
$$
</div>
<p>其中 \(broadcastTime\) 是发送 RPC 的平均往返时间，\(electionTimeout\) 是 follower 的超时时间，\(MTBF\) 是单个服务器的平均故障间隔时间。broadcast time 应该比 election timeout 小一个数量级，防止 follower 开始不必要的选举。election timeout 应该比 MTBF 小几个数量级，这样在 leader 真正发生故障时客户端不会等待太久。</p>
<h3 id="日志复制">日志复制</h3>
<p>客户端会向 leader 发送请求，请求包含由复制状态机执行的命令，leader 会将当前任期和命令作为一个条目（entry）追加到日志中（只读命令可以不记录日志，但有额外的限制，在可线性化中描述），由日志索引标识其位置。然后 leader 向其他服务器并行发送 AppendEntries RPC 以复制该条目，当大多数服务器确认复制该条目时，leader 将条目应用到其状态机（即状态机执行条目中的命令），并将执行结果返回给客户端，之后 leader 通过不断地失败重试保证剩余服务器会复制该条目。</p>
<p><img src="/img/MIT_6.824.assets/1706265536317.png" alt=""></p>
<p>只要创建日志条目的 leader 将其复制到大多数服务器上，该日志条目就是已提交的（committed）。注意，是创建日志条目的 leader，而不是之后的 leader，这将在安全性中讨论。Raft 保证已提交的条目是持久的，并且最终会被所有可用的状态机执行。leader 提交其创建的日志条目时，也会提交 leader 日志中在该日志条目之前的所有日志条目，包含由之前 leader 创建的条目（会在安全性中解释原因）。leader 会跟踪其已提交日志条目的最高索引，并且在之后的 AppendEntries RPC 中包含该索引，以通知 follower 哪些日志条目已提交，之后 follower 会应用已提交的日志条目到本地状态机（按照日志顺序）。</p>
<p>Raft 的日志匹配（Log Matching）属性保证不同服务器之间日志的一致性：如果两个日志在同一索引位置的条目具有相同任期，则两个日志中所有小于等于该索引位置的条目都相同。如何实现该属性？leader 在给定任期只会对自己的日志进行追加，而不会覆盖。当 leader 向 follower 发送 AppendEntries RPC 时，会进行一致性检查。请求中会包含上一个条目的索引和任期，如果 follower 中对应索引的任期不同，则 follower 会拒绝该请求，回复 leader 匹配失败。如果系统正常运行，那么所有服务器上的日志都会相同。</p>
<p><img src="/img/MIT_6.824.assets/1706269942802.png" alt=""></p>
<p>但是当发生故障时，服务器之间的日志会产生不一致。如何处理不一致？leader 会为每个 follower 维护一个 nextIndex，表示 leader 下次向 follower 发送该索引位置的日志条目，如果 follower 拒绝 leader 的 AppendEntries RPC，则 leader 会将该 follower 对应的 nextIndex 递减，然后重试 RPC 直到 follower 和 leader 的日志完全相同（冲突条目将被删除）。整个过程表现为，递减 follower 的 nextIndex 到和 leader 日志最长相等前缀之后的一个位置，然后追加条目到 follower 直到其 nextIndex 和 leader 日志的尾后索引相等。</p>
<p>可以对上述算法进行优化，不是将 nextIndex 每次递减 1，而是递减整个任期，这通过在 follower 回复的信息中包含冲突条目的任期以及该任期在其日志中的第一个索引位置来实现。从而，每个冲突的任期都需要一个 AppendEntries RPC，而不是每个冲突的条目一个 RPC。为什么直接返回第一个索引位置，论文并没有描述之后该如何处理。我的理解是，其实并不是从该索引位置开始重传日志条目，因为这样可能会导致不必要的重传已提交的日志条目。在 leader 接收到冲突的任期和第一个索引之后，应该会递增该索引直到任期不同为止（之所以可以这样，是因为日志匹配属性），然后再传递该位置的日志条目。这样关于课程中提出的问题，为什么需要返回任期，而不是只返回第一个索引，也可以得到解答。</p>
<h3 id="安全性">安全性</h3>
<h4 id="选举限制">选举限制</h4>
<p>即使日志一致，两个状态机也可能执行不同的命令序列。例如，leader 提交日志时，某个 follower 可能发生故障，如果它成为 leader，它将覆盖旧 leader 中的条目，而这些条目可能已经应用于旧 leader 的状态机上。为此 Raft 的领导者完整性（Leader Completeness）属性保证在某个任期被提交的日志条目必定会出现在更高任期的 leader 日志中，从而可以保证所有状态机执行相同的命令序列。</p>
<p>如何实现该属性？candidate 在发送 RequestVote RPC 时，会包含其日志信息，如果投票者的日志比 candidate 的日志更（读第四声）新，则投票者会拒绝投票。更新的定义如下：如果两个日志的最后一个条目具有不同任期，则更大任期的日志更新；否则，更长的日志更新。上述限制使得，只有包含所有已提交日志条目的 candidate 才有可能当选 leader，日志只会从 leader 流向 follower。</p>
<h4 id="提交之前任期的条目">提交之前任期的条目</h4>
<p>在日志复制中提到，创建日志条目的 leader 将其复制到大多数服务器上，则该日志条目就是已提交的。之所这样定义，是因为即使 leader 将之前任期的条目（不是由当前 leader 创建）复制到大多数服务器上，依然可能会被之后的 leader 覆盖（根据之前描述的日志匹配属性）。如果将其视为已提交，则会违反领导者完整性属性，导致状态机不一致。那么之前任期的条目何时视为已提交？当前任期的一个日志条目被提交时，由于日志匹配属性，之前任期的条目将会间接提交。</p>
<p><img src="/img/MIT_6.824.assets/1706279525227.png" alt=""></p>
<h3 id="日志压缩">日志压缩</h3>
<p>日志可能会变得很大，导致崩溃恢复需要花费很多时间重放所有日志，以及日志占用大量空间，Raft 通过使用快照来压缩日志。每个服务器会定期创建快照（通常是当日志达到固定大小时），快照中包含状态机的状态、状态对应的最后一个日志条目的索引和任期（以支持 AppendEntries PRC 的一致性检查）、当时的配置信息（用于集群成员变更）。当服务器将快照持久化之后，可以删除该快照之前的日志和之前的快照（剩余日志的索引并不会重置为从 1 开始，或许会新开一个数组从 1 开始存储，但是对外来说索引总是会加上某个偏移量）。</p>
<p><img src="/img/MIT_6.824.assets/1706500585471.png" alt=""></p>
<p>如果有一个严重滞后或新加入集群的 follower，它需要的日志可能已经被 leader 删除，此时 leader 需要使用 InstallSnapshot RPC 向滞后的 follower 发送快照。通常快照会比 follower 的日志更新，follower 会丢弃整个日志，使用快照替代。但是，由于重传或错误，follower 可能会收到描述其日志前缀的快照，此时仅会删除快照覆盖的日志，快照之后的日志将被保留。</p>
<p>为了避免在创建快照时停止操作，可以使用写时复制技术。状态机可以通过实现某种数据结构支持写时复制，或者使用操作系统的写时复制支持（例如，Linux 的 fork）来创建状态机的内存快照（作者使用该实现方式）。具体来说，Linux 的 fork 创建的子进程会共享和父进程相同的内存页面，如果父进程更新页面，则操作系统会对该页面执行写时复制。</p>
<h3 id="可线性化">可线性化</h3>
<p>什么是可线性化？每个操作似乎在其调用和响应之间的某个时刻以原子的方式执行。Raft 如何实现可线性化语义？如果 leader 在执行命令之后回复客户端之前崩溃，然后客户端在新的 leader 重试请求，将会多次执行同一个命令。如果客户端向新 leader 发送读请求，由于旧 leader 在回复客户端之后发送下一个 AppendEntries RPC 之前崩溃，新 leader 可能并没有将某些已提交的命令应用到状态机，此时客户端可能会从新 leader 读取到旧数据。如果出现网络分区故障，旧 leader 可能不知道它已经被新 leader 取代，此时客户端可能从旧 leader 读取到旧数据。</p>
<p>首先，客户端需要为每个命令分配唯一的序列号，状态机会跟踪为每个客户端处理的最后的序列号以及相关响应。如果状态机收到已被执行的命令，它不会执行该命令而是直接返回响应。注意，日志中依然包含重复命令的日志条目。其次，每个 leader 在任期开始时会提交一个无操作日志条目，从而确定哪些日志条目已被提交并将其应用到状态机。能否通过心跳消息确定哪些日志条目已提交，个人认为不能，就是之前提到的旧任期日志条目不能通过计数判断是否已提交。最后，leader 在回复读请求之前，需要和集群中的大多数交换心跳消息，以确保它仍然是 leader（或者可以使用租约，论文中没有详细介绍，不过课程笔记中有提到具体方式）。</p>
<h2 id="问题">问题</h2>
<p>Q：Raft 集群是部署在一个数据中心，还是多个数据中心？</p>
<p>A：通常是一个数据中心，这样可以避免 leader 跨数据中心向多个 follower 发送 RPC（网络延迟）。</p>
<p>Q：客户端如何知道谁是新的 leader？</p>
<p>A：客户端包含所有 server 的地址，它可以随机发送请求，follower 会将请求重定向到它认为的 leader。</p>
<p>Q：为什么日志的索引从 1 开始？</p>
<p>A：可以将其视为从 0 开始，索引 0 包含任期为 0 的空日志条目，以方便 AppendEntries RPC 在初始时的一致性检查。个人认为，类似于求数组的前缀和时从索引 1 开始。</p>
<p>Q：Raft 何时将其状态（currentTerm、votedFor、log）持久化到磁盘？</p>
<p>A：在内存中修改状态的同时刷盘，只有持久化之后 leader 才能向 follower 发送 RPC，follower 才能回复 leader，leader 才能将命令应用到状态机。否则，如果服务器发生崩溃，Raft 的各种属性将无法得到保证。</p>
<p>Q：图 2 中的 lastApplied 为何不需要持久化？如果发生崩溃，服务器如何知道日志条目是否应用于状态机？</p>
<p>A：论文作者在<a target="_blank" rel="noopener" href="https://groups.google.com/g/raft-dev/c/KIozjYuq5m0">会话</a>中对该问题以及下一个问题进行了解释（推荐阅读）。实际上 lastApplied 是否被持久化取决于状态机是否被持久化。如果状态机不被持久化，那么崩溃恢复之后需要重放所有日志，所以 lastApplied 会被初始化为 0。否则，只需重放 lastApplied 之后的日志。按我的理解，由于快照的存在，以及更新状态机的同时持久化产生的随机 I/O 开销较大，所以状态机一般不会实时持久化。如果存在快照，lastApplied 会被赋值为快照中包含的索引。</p>
<p>Q：图 2 中的 matchIndex 有什么作用？</p>
<p>A：matchIndex 表示 follower 和 leader 匹配的最高日志条目的索引（可能会小于实际值），只要大多数 follower 的 matchIndex 超过 leader 的 commitIndex，并且 log[matchIndex] 条目的任期是当前 leader 的任期（参见提交的定义），则 leader 可以增加 commitIndex。</p>
<p>Q：图 7 的 leader 崩溃之后，谁有可能成为新的 leader？</p>
<p>A：服务器 acd 都有可能成为新的 leader。首先日志 9 是最后一个提交的日志条目，根据领导者完整性属性，只能从 acd 中选择 leader。同时，acd 都有可能得到大多数服务器的投票，对于 a 来说是 abef，对于 c 来说是 abcef，对于 d 来说是 abcdef。有一点需要注意，服务器最后一个日志条目的任期可能并不是其当前任期。</p>
<h2 id="总结">总结</h2>
<p>Raft 共识算法实现可线性化一致性模型，核心内容包括领导者选举、日志复制和安全性。论文中还提到 Raft 的集群成员变更机制，我并没有做介绍。然后日志压缩可以看作是 Raft 的额外补充。如课程中所述，论文中也有很多细节没有介绍，单个机制可以有多种不同的实现方式。课程视频、问答和笔记是对论文很好的补充，其中还提到一篇文章 <a target="_blank" rel="noopener" href="https://decentralizedthoughts.github.io/2020-12-12-raft-liveness-full-omission/">Raft does not Guarantee Liveness in the face of Network Faults</a>，讲述 Raft 在特定情况下无法建立稳定的领导者，除非使用 PreVote 和 CheckQuorum 技术。可见这篇论文介绍的仅仅是 Raft 的基本实现，现实中面临各种复杂场景，或许需要添加很多额外的机制。</p>
<h2 id="附录">附录</h2>
<p><img src="/img/MIT_6.824.assets/1706326869038.png" alt=""></p>
<p><img src="/img/MIT_6.824.assets/1706500649548.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-28T08:22:36.304Z" title="2024/1/28 下午4:22:36">2024-01-28</time>发表</span><span class="level-item"><time dateTime="2024-01-28T08:23:53.733Z" title="2024/1/28 下午4:23:53">2024-01-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">3 分钟读完 (大约467个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/28/%E7%AC%AC%20382%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 382 场力扣周赛</a></p><div class="content"><h2 id="给定操作次数内使剩余元素的或值最小"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/">给定操作次数内使剩余元素的或值最小</a></h2>
<p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的整数数组 \(nums\) 和整数 \(k\)，输出执行至多 \(k\) 次操作之后，将数组中所有剩余元素按位或的最小值。每次操作可以选择一个下标 \(i\)，满足 \(0\leq i&lt;n\)，将 \(nums[i]\) 和 \(nums[i+1]\) 替换为它们按位与的结果。注意，是两个数替换为一个数。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)，\(0\leq nums[i]&lt;2^{30}\)，\(0\leq k&lt; n\)。</p>
<p><strong>思路</strong></p>
<p>要使按位或的结果最小，肯定是从高位到低位消除。但是高位消除的方式会影响低位消除的方式，它们是相关的，不能单独计算每一位的操作次数。如果暴力枚举所有位的组合，会有 \(2^{30}\) 种情况，肯定会超时。如何计算？其实，只需要考虑从高位到低位的组合方式。从高位开始，能够消除的位总是应该被消除，然后判断加上更低的一位是否能被消除（保留相关性），如果不能，则该低位就永远不会被消除，以此类推。那么如何判断某个位的组合是否能被消除？从前往后遍历数组，贪心的将数组分割为若干按位与结果为 0 的子数组（假设为 \(m\)），则当前组合消除所需的操作次数为 \(n-m\)。具体可以看下<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/solutions/2622658/shi-tian-fa-pythonjavacgo-by-endlesschen-ysom/">灵茶山的题解</a>和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/solutions/2622684/xiao-yang-xiao-en-wei-yun-suan-yu-tan-xi-411t/">小羊的题解</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-23T12:56:53.532Z" title="2024/1/23 下午8:56:53">2024-01-23</time>发表</span><span class="level-item"><time dateTime="2024-01-28T08:30:50.502Z" title="2024/1/28 下午4:30:50">2024-01-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></span><span class="level-item">14 分钟读完 (大约2113个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/23/The%20Design%20of%20a%20Practical%20System%20for%20Fault-Tolerant%20Virtual%20Machines/">The Design of a Practical System for Fault-Tolerant Virtual Machines</a></p><div class="content"><p>阅读论文 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf">Fault-Tolerant Virtual Machines</a>，参考 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/vm-ft-faq.txt">FAQ</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/l-vm-ft.txt">note</a>。</p>
<h2 id="概述">概述</h2>
<p>论文使用虚拟机、机器级别的主从复制（一主一从）和共享磁盘的方式设计容错系统，目前只支持单处理器的虚拟机。</p>
<p>有两种复制方式，状态转移复制和状态机复制。状态转移复制是将主节点的所有状态复制到从节点；而状态机复制要求节点是一个确定性状态机，不同节点从同一个状态以相同的顺序执行操作，可以得到相同的结果。</p>
<p>比较有意思的是，不像我所了解的常规数据复制，论文实现的系统使用机器级别的复制，状态包含 CPU、内存和 I/O 设备的状态，操作是 x86 指令。在机器级别上，状态转移复制的缺点是会将所有状态的更改通过网络进行传输，发送状态需要很多带宽；状态机复制使用更少的网络带宽，但是需要特殊处理非确定性操作（例如：获取时间、定时中断）来保证主从一致，这在物理服务器上很难实现，特别是当处理器频率增加时。</p>
<p>PS：时间是非确定的很好理解，但是定时中断为什么是非确定的，我的想法是虽然主从的状态是一致的（如果没有中断），但是执行速度也不是完全一致，所以中断的时机可能不同。</p>
<p>论文设计的系统使用状态机复制，利用虚拟机（VM）由虚拟机管理程序完全控制的特性，当主虚拟机执行非确定性操作时，虚拟机管理程序可以捕获必要的信息发送给从虚拟机，将非确定性操作转化为确定性操作，从而保证主从一致。只支持单处理器虚拟机，因为多处理器产生的并发操作是非确定性的，存在显著的性能问题。</p>
<p><img src="/img/MIT_6.824.assets/1706013051679.png" alt=""></p>
<p>主从虚拟机运行在不同的服务器上，从虚拟机和主虚拟机以相同的方式运行，并且总是有较小的延迟（小于 100 毫秒），课程讲义提到至少滞后一个日志项。只有主虚拟机在网络上发布其存在，输入（例如：网络、磁盘、键盘、鼠标）只会发送给主虚拟机，主虚拟机通过网络连接（称为日志通道，logging channel）将其转发给从虚拟机。同时，只有主虚拟机会产生输出，从虚拟机的输出将被虚拟机管理程序丢弃。</p>
<h2 id="确定性重放">确定性重放</h2>
<p>VMware FT 使用确定性重放，使从虚拟机能够通过重放日志达到和主虚拟机相同的状态。具体来说，主虚拟机的输入和非确定性操作都会被虚拟机管理程序捕获，然后生成日志（不会写入磁盘），发送给从虚拟机。对于非确定性操作，日志会记录必要的信息，保证主从一致。例如，对于中断操作，日志会记录操作发生时所完成的指令数量。论文提到该技术的实现有使用硬件性能计数器（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hardware_performance_counter">HPC</a>）。</p>
<p>特别注意，日志仅包含输入和非确定性操作相关的信息，确定性操作在从虚拟机的本地执行。具体来说，主虚拟机和从虚拟机都是状态机，会自动执行操作（由 VM 中的 Linux 和 App 发起，这也说明了为什么主从虚拟机的初始状态必须相同），只不过输入只会发送给主虚拟机，以及存在非确定性操作，所以输入和非确定性操作需要以日志的形式包含额外信息发送给从虚拟机。</p>
<h2 id="容错协议">容错协议</h2>
<p>但是仅使用确定性重放还不够，需要额外的机制保证系统的容错性。如果主虚拟机在执行输出操作之后发生故障，而日志没有发送给从虚拟机，那么从虚拟机接管之后，在其输出之前的非确定性操作（未收到日志的）可能会得到不同的输出结果，从而产生不一致（不一致主要是针对客户端的感知而言）。</p>
<p>解决方案是在主虚拟机发送输出之前，向从虚拟机发送输出操作的日志并等待其确认，当从虚拟机接收到该输出操作及之前的所有日志之后，从虚拟机回复一个确认，然后主虚拟机可以向外部发送输出。注意，主虚拟机只是延迟发送输出，但是没有停止执行（即在等待输出的同时会继续执行其他操作，就像在某个线程等待磁盘 I/O 时会切换到其他线程一样）。该机制在主虚拟机发生故障时，可能会产生两次相同的输出，因为从虚拟机无法得知主虚拟机是否发送输出，但是论文随后提到 TCP 可以保证网络数据包的去重（我的理解是 TCP 是根据序列号去重的，由于主从虚拟机状态相同，所以会产生相同的序列号）。</p>
<h2 id="故障检测和恢复">故障检测和恢复</h2>
<p>系统通过监控节点的心跳（使用 UDP），以及日志通道上的流量来判断节点是否发生故障（使用定时中断，保证流量不会停止）。</p>
<ul>
<li>从虚拟机故障：主虚拟机继续执行，但是停止发送日志。</li>
<li>主虚拟机故障：从虚拟机重放日志以追赶主虚拟机，然后将从虚拟机提升为主虚拟机。VMware FT 会在网络上发布新的主虚拟机的 MAC 地址，以便交换机知道其位于哪个服务器上。</li>
<li>网络分区故障：主虚拟机可能由于网络问题和从虚拟机中断连接，如果此时将从虚拟机提升为主虚拟机，将会导致脑裂。为避免该问题，容错协议要求在检测到故障时，主从虚拟机需要在共享磁盘上执行 test-and-set 原子操作。操作成功的虚拟机作为主虚拟机存活，操作失败的虚拟机会自行中止。</li>
</ul>
<p>不论是启动系统时，还是故障恢复时，都需要保证存在一个从虚拟机。VMware FT 使用 FT VMotion 功能，将虚拟机复制到集群中的某个服务器上（根据资源使用情况和其他约束条件选择）。该功能会建立从源虚拟机到目标虚拟机的日志通道，并且将源虚拟机设置为主虚拟机（记录日志模式），目标虚拟机设置为从虚拟机（重放日志模式）。该功能仅会中断源虚拟机小于 1 秒的时间，在复制的过程中源虚拟机仍会正常执行，日志会被存放在缓冲区中。</p>
<h2 id="总结">总结</h2>
<p>论文介绍容错虚拟机的实现，还提到磁盘 I/O 和网络问题及其解决方案，不同设计的决策以及对各个负载的性能测试，详情参见论文。PS：课程讲义很不错，可以加深对论文内容的理解，我的理解还是太浅。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-19T03:56:59.101Z" title="2024/1/19 上午11:56:59">2024-01-19</time>发表</span><span class="level-item"><time dateTime="2024-01-31T16:23:13.888Z" title="2024/2/1 上午12:23:13">2024-02-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></span><span class="level-item">28 分钟读完 (大约4230个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/19/The%20Google%20File%20System/">The Google File System</a></p><div class="content"><p>阅读论文 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">GFS</a>，参考 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/gfs-faq.txt">FAQ</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/l-gfs.txt">note</a>。</p>
<h2 id="概念">概念</h2>
<p>GFS 是一个分布式文件系统，用于大型分布式数据密集型应用程序，例如 MapReduce。系统的设计基于以下场景：</p>
<ul>
<li>系统由许多机器组成，所以会频繁发生故障。</li>
<li>GB 级别的文件很多，普通文件系统会将文件划分为很多块，不便管理。</li>
<li>读负载由大量顺序读和少量随机读组成，写负载由大量追加写和少量随机写组成。</li>
<li>高持续带宽比低延迟更重要，应用程序需要快速进行批处理，而对响应时间没有严格要求。</li>
</ul>
<h2 id="实现">实现</h2>
<p>GFS 集群由单个 master 和多个 chunkserver 组成，由多个客户端访问。文件被划分为 64 MB 的块（chunk），每个块都是 chunkserver 中的一个文件。在分配空间时使用懒分配策略，避免产生内部碎片从而浪费空间。master 在创建块时，会为其分配一个不可变且全局唯一的 64 位块句柄（chunk handle）。每个块都会被复制到多个 chunkserver 上（默认三个），以保证系统的可靠性。</p>
<p>master 主要负责维护系统的元数据、存储日志和检查点、租约管理以及控制垃圾收集、重新复制、负载均衡和快照创建。元数据包括命名空间、访问控制信息、从文件名到块句柄数组的映射，以及为每个块维护版本号和副本所在 chunkserver 的列表。master 通过心跳消息定期与 chunkserver 通信，向其发出指令和收集其状态。chunkserver 主要负责存储文件数据、版本号和校验和，64 MB 的 chunk 被划分为 64 KB 的 block，每个 block 都有一个 32 位的校验和。</p>
<p>链接到应用程序的 GFS 客户端代码实现文件系统 API，通过与 master 和 chunkserver 通信来代表应用程序读写数据。客户端从 master 获取元数据，从 chunkserver 获取文件数据。客户端不需要缓存文件数据（但会缓存元数据），因为负载通常是顺序读和追加写。客户端没有实现 POSIX API，因此不需要挂钩到 Linux vnode 层。PS：我没有查到 Linux vnode 相关的资料，vnode 似乎是 BSD 中的概念，和 VFS 有关。</p>
<p><img src="/img/MIT_6.824.assets/1705403780344.png" alt=""></p>
<h3 id="块大小">块大小</h3>
<p>Linux 文件系统的默认块大小为 4 KB，GFS 使用 64 MB 的块大小是基于其 GB 级文件场景而设计的，优势如下：</p>
<ul>
<li>由于应用程序通常是顺序读写文件数据，所以 64 MB 的块大小可以减少客户端和 master 的交互次数。</li>
<li>许多操作会发生在同一个块中，使得客户端和 chunkserver 保持长 TCP 连接，有利于减少网络开销。</li>
<li>master 中的元数据更少，从而可以全部放入内存，避免磁盘 I/O。</li>
</ul>
<p>同时，论文提到小文件可能只有一个块，面对多个应用程序的访问，存储该块的 chunkserver 有可能成为热点。GFS 的解决方案是使用更高的复制因子存储小文件，同时使批处理队列系统错开应用程序访问小文件的时间。潜在的解决方案是允许客户端在该情况下从其他客户端读取数据。</p>
<h3 id="元数据">元数据</h3>
<p>命名空间和映射会以操作日志（operation log）的形式持久化到 master 的本地磁盘和复制到远程机器，保证 master 能够在崩溃之后恢复。为保证一致性，只有在本地和远程将相应的日志刷新到磁盘之后，master 才会响应客户端的操作。可以对刷新和复制批处理，从而减少开销。当日志超过一定大小时，会创建检查点（使用 B 树），从而避免崩溃恢复时重放所有日志。由于创建检查点比较耗时，master 会切换到新的日志文件，并在单独的线程中创建检查点，以避免在创建检查点时停止执行（写）操作。检查点同样也会被复制到远程机器。</p>
<p>master 不会持久化块的位置列表，而是在启动时以及 chunkserver 加入集群时，向 chunkserver 询问其包含的块。因为块是否存在于某个 chunkserver 是由该 chunkserver 决定的，所以在 master 中持久化该信息没有任何意义，反而会面临同步问题。PS：说明 master 内存中的位置列表可能因为 chunkserver 故障，从而产生不一致。</p>
<p>命名空间其实就是一个将目录名和文件名作为节点的树，通过使用读写锁保证写操作的正确性。具体来说，读/写操作会获取路径上所有祖先节点的读锁，以及目标节点的读/写锁。锁在层级间按照自顶向下的顺序获取，在层级内按照字典序获取，从而避免死锁。PS：这让我想到 B+ 树的蟹行协议只锁定会被修改的节点，大概是因为 B+ 树的数据和路径不像文件和路径那样具有很强的关联性。</p>
<h3 id="读操作">读操作</h3>
<p>客户端使用固定的块大小，将应用程序指定的文件名和字节偏移量转换为文件内的块索引。然后，它向 master 发送包含文件名和块索引的请求，master 回复相应的块句柄（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Handle_(computing)">handle</a>）、副本的位置列表，客户端使用文件名和块索引作为键来缓存该信息（会有过期时间）。</p>
<p>然后，客户端选择其中一个副本发送请求（很可能是距离最近的副本），该请求指定块句柄和块内字节范围。在缓存信息过期或重新打开文件之前，客户端不需要和 master 进行交互。客户端可以在向 master 发送的一个请求中请求多个块，master 也可以在回复中包含请求块之后的多个块信息（利用空间局部性），从而减少客户端和 master 交互的次数。</p>
<h3 id="写操作">写操作</h3>
<p>在发生写操作时，需要保证多个副本之间的一致性。GFS 使用租约（lease）实现一致性（租约是按块授予的），持有租约的 chunkserver 被称为 primary，其他包含副本的 chunkserver 被称为 secondary。租约的超时时间为 60 秒，primary 可以根据需要续约，续约请求包含在定期的心跳消息中发送给 master，master 也可以在租约到期之前撤销租约（用于快照创建）。如果 master 和 primary 发生网络分区故障，master 可以在旧租约到期之后向另一个副本授予租约，从而避免脑裂。</p>
<p><img src="/img/MIT_6.824.assets/1705501645876.png" alt=""></p>
<p>写操作的流程如下：</p>
<ul>
<li>客户端首先向 master 询问 primary 和 secondary 的位置并将其缓存。如果 primary 不存在，则 master 任选一个包含副本的 chunkserver 授予租约。客户端会缓存位置信息，当 primary 不可达或者回复其租约过期时，客户端会重新联系 master。然后，客户端以流水线的方式将数据发送到 primary 和 secondary（存储在缓冲区中），并且等待它们的确认响应。</li>
<li>客户端收到所有副本的确认之后，向 primary 发送写请求，该请求会使用之前发送的数据。primary 为其收到的来自多个客户端的请求分配序列号（单个客户端的请求肯定是同步的，在收到响应之前不会发送第二个请求，因为 GFS 没法保证客户端请求的 FIFO 顺序），只有当 primary 本地执行成功之后，才会转发给所有 secondary，请求在所有副本上都按照序列号的顺序执行。当 primary 收到所有 secondary 的完成响应时，primary 回复客户端完成。</li>
<li>论文提到，副本的任何错误都会被报告给客户端，客户端会首先从步骤三开始重试几次，然后从步骤一开始重试。论文有一个前后矛盾的点，首先提到 primary 分配序列号然后应用到本地，之后又说如果在 primary 执行失败就不会分配序列号和转发。不过无关紧要。</li>
</ul>
<h3 id="一致性模型">一致性模型</h3>
<p>GFS 具有宽松的一致性模型，数据突变之后文件区域的状态，取决于突变的类型（随机写和追加写）以及是否存在并发，如下图所示。如果无论客户端从哪个副本读取，始终看到相同的数据，则文件区域是一致的。如果文件区域一致，且客户端将会看到整个突变的内容，则文件区域是定义的。PS：这里的一致并不是严格一致性（可线性化）。</p>
<p><img src="/img/MIT_6.824.assets/1705543314022.png" alt=""></p>
<p>随机写：顺序突变成功状态是定义的和一致的；并发突变成功状态是一致的但是未定义，因为 GFS 使用租约保证突变以相同的顺序应用到所有副本（一致的），但是突变没有对文件区域加锁（未定义）。</p>
<p>追加写：不论是顺序还是并发突变成功，状态都是定义的，因为追加是原子操作且按照指定顺序应用到所有副本。只要有一个副本追加失败，客户端会重试整个追加操作，使得在未失败的机器上多次追加相同的数据，在失败的机器上填充无效的数据（因为追加会指定偏移量），从而产生不一致。特别的，追加的偏移量由 primary 指定，而不是单纯的追加到文件末尾，这可以保证多个副本在成功执行追加的偏移位置的数据是一致的，即使之前发生过失败。也就是说，中间区域不一致，最后区域一致。</p>
<p>此外，失败的突变总是会导致不一致。即使突变成功，数据最终一致，客户端仍可能观察到不一致，因为数据可以从任何包含副本的 chunkserver 读取。假设突变由客户端 A 发起，首先应用到 primary，再发送到 secondary。客户端 B 和 C 在突变过程中分别读取 primary 和 secondary，可以观察到不一致的情况。如果突变很慢，由于网络延迟或故障重试，单个客户端也可以观察到不一致。应用程序需要自行适应 GFS 的宽松一致性模型。</p>
<h3 id="版本检测">版本检测</h3>
<p>如果 chunkserver 发生故障，从而错过突变，其上的块副本将会过时。master 和 chunkserver 会为块维护一个版本号，以此来区分新副本和旧副本。当 master 授予某个块租约时，它会递增该块的版本号，同时和 chunkserver 通信来递增最新副本的版本号。任何包含旧副本的 chunkserver 都不会返回给客户端，master 会在心跳检测中检查副本的版本，然后 master 会指示 chunkserver 对旧副本垃圾收集。作为额外的保护措施，master 会在回复客户端请求或指示 chunkserver 复制时包含版本号，客户端和 chunkserver 会在执行操作时进行验证。</p>
<h3 id="故障处理">故障处理</h3>
<h4 id="master-故障">master 故障</h4>
<p>当 master 发生故障时，GFS 的外部监控基础设施会使用检查点和日志快速恢复，即使磁盘发生故障也可以在其他机器上使用检查点和日志的副本进行恢复。客户端仅使用 DNS 别名访问 master（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CNAME_record">CNAME</a>），其映射可以随时更改，以适应 master 机器的变更。此外，GFS 使用 shadow master 在 master 故障时提供对文件系统的只读访问，shadow master 略微滞后于 master。由于它存储的是元数据，文件数据存储在 chunkserver 中，所以客户端实际上不会读取到旧数据。</p>
<p>PS：论文提到 shadow master 会按顺序执行操作日志的副本，似乎 master 和 shadow master 的关系就是主从复制，但是为什么 shadow master 只提供只读访问，即使在 master 故障之后。它和 master 应该是最终一致的，为什么论文没有说 shadow master 在执行完所有日志之后会被提升为 master，虽然可以肯定需要人工操作，以避免原 master 只是网络分区故障，从而导致脑裂。</p>
<h4 id="chunkserver-故障">chunkserver 故障</h4>
<p>master 使用心跳消息判断 chunkserver 是否存活，如果 master 判断 chunkserver 故障，它会指示其他 chunkserver 对不满足复制因子的数据块重新复制。当故障的 chunkserver 上线时，master 也会删除多余的副本，以及因错过突变而过时的副本。</p>
<h3 id="其他功能">其他功能</h3>
<p>使用写时复制实现快照功能；跨机架的块放置策略；根据服务器的负载进行块放置和块迁移；根据优先级重新复制块以恢复冗余；延迟删除和垃圾收集；使用校验和检测数据块是否损坏；生成诊断日志（包含 chunkserver 的启动/关闭，RPC 的请求/回复记录，不包括文件数据）。</p>
<h2 id="问题">问题</h2>
<p>Q：租约具体是如何工作的，master 和 chunkserver 如何判断租约是否过期？如何撤销租约？</p>
<p>A：论文没有说明，我猜测：master 首先发送授予租约的请求，chunkserver 收到请求之后开始计时，同时发送响应给 master，master 收到响应之后开始计时。这样 chunkserver 和 master 都可以判断租约是否到期，以及 master 的计时总是晚于 chunkserver，可以保证避免脑裂。撤销租约只修改 master 本地元数据肯定是不行的，因为客户端可能正在和持有租约的 chunkserver 通信，master 必须直接向 primary 发送撤销请求。</p>
<p>Q：根据上述猜测，如果授予租约的响应丢失，master 该如何处理？是否需要考虑时钟同步问题？</p>
<p>A：如果 master 没有收到响应，它就不会把该 chunkserver 记作 primary 返回给客户端，那么该租约实际上是一个无效租约，master 可以重试或者另选一个包含副本的 chunkserver。计算超时使用的是单调时钟，不需要同步。也可以使用时间戳判断租约是否到期，但是使用的是墙上时钟，需要服务器之间时钟同步。</p>
<h2 id="总结">总结</h2>
<p>GFS 使用复制进行容错，从而引入多个副本间的一致性问题。但是仅保证宽松的一致性，而将问题交由应用程序处理，该设计基于其特殊的使用场景，顺序读写以及用于批处理，似乎强一致性显得不是很重要。可以查看课程的笔记和问答加深对论文的理解，笔记结尾的优缺点总结还是很不错的，有一个全局的视角，我有点过于关注一致性了。更多关于 GFS 的讨论，可以阅读 <a target="_blank" rel="noopener" href="https://queue.acm.org/detail.cfm?id=1594206">GFS: Evolution on Fast-forward</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-10T13:27:51.992Z" title="2024/1/10 下午9:27:51">2024-01-10</time>发表</span><span class="level-item"><time dateTime="2024-01-10T13:28:28.501Z" title="2024/1/10 下午9:28:28">2024-01-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></span><span class="level-item">7 分钟读完 (大约1063个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/10/Threads%20and%20RPC/">Threads and RPC</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/tour-faq.txt">Go FAQ</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/crawler.go">crawler.go</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/kv.go">kv.go</a>，<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/notes/l-rpc.txt">note</a>。</p>
<h2 id="Exercise-Web-Crawler"><a target="_blank" rel="noopener" href="https://go.dev/tour/concurrency/10">Exercise: Web Crawler</a></h2>
<h3 id="串行爬虫">串行爬虫</h3>
<p>就是 DFS。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serial</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fetched[url] &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fetched[url] = <span class="literal">true</span></span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		Serial(u, fetcher, fetched)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行爬虫">并行爬虫</h3>
<h4 id="共享-锁">共享 + 锁</h4>
<p>在 DFS 的基础上，同时启动多个线程来爬取网页，通过使用锁保护共享变量，使用计数器等待所有线程执行完成。如果网页很多，可能会创建非常多的线程，可以通过使用线程池限制线程的数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fetchState)</span></span> testAndSet(url <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	fs.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> fs.mu.Unlock()</span><br><span class="line">	r := fs.fetched[url]</span><br><span class="line">	fs.fetched[url] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, fs *fetchState)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fs.testAndSet(url) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		done.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> done.Done()</span><br><span class="line">			ConcurrentMutex(u, fetcher, fs)</span><br><span class="line">		&#125;(u)</span><br><span class="line">	&#125;</span><br><span class="line">	done.Wait()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeState</span><span class="params">()</span></span> *fetchState &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;fetchState&#123;fetched: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通道（channel）">通道（channel）</h4>
<p>使用 channel 实现同步，不需要 DFS，没有任何共享变量，自然也不需要使用锁（尽管 channel 内部会使用锁）。代码的组织方式有点像 MapReduce。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ch &lt;- urls</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coordinator</span><span class="params">(ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	fetched := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> urls := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">			<span class="keyword">if</span> fetched[u] == <span class="literal">false</span> &#123;</span><br><span class="line">				fetched[u] = <span class="literal">true</span></span><br><span class="line">				n += <span class="number">1</span></span><br><span class="line">				<span class="keyword">go</span> worker(u, ch, fetcher)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentChannel</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- []<span class="type">string</span>&#123;url&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	coordinator(ch, fetcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go-RPC"><a target="_blank" rel="noopener" href="https://pkg.go.dev/net/rpc">Go RPC</a></h2>
<p>远程过程调用（Remote procedure call，RPC），指程序调用的过程在远程计算机执行。通常表现为客户端向服务器发送请求，服务器向客户端返回响应。数据在通过网络传输时需要进行序列化和反序列化，序列化是将数据转换为可以存储或传输的格式的过程，反序列化是序列化的逆过程。远程过程调用和本地过程调用的区别在于，如何处理失败的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> *rpc.Client &#123;</span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	client := connect()</span><br><span class="line">	args := GetArgs&#123;<span class="string">&quot;subject&quot;</span>&#125;</span><br><span class="line">	reply := GetReply&#123;&#125;</span><br><span class="line">	err := client.Call(<span class="string">&quot;KV.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line">	<span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(key <span class="type">string</span>, val <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	client := connect()</span><br><span class="line">	args := PutArgs&#123;<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;6.824&quot;</span>&#125;</span><br><span class="line">	reply := PutReply&#123;&#125;</span><br><span class="line">	err := client.Call(<span class="string">&quot;KV.Put&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KV <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.Mutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kv := &amp;KV&#123;data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;&#125;</span><br><span class="line">	rpcs := rpc.NewServer()</span><br><span class="line">	rpcs.Register(kv)</span><br><span class="line">	l, e := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;listen error:&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := l.Accept()</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		l.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KV)</span></span> Get(args *GetArgs, reply *GetReply) <span class="type">error</span> &#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	reply.Value = kv.data[args.Key]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KV)</span></span> Put(args *PutArgs, reply *PutReply) <span class="type">error</span> &#123;</span><br><span class="line">	kv.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	kv.data[args.Key] = args.Value</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他问题">其他问题</h2>
<p>Q：为什么闭包函数可以使用外部函数的变量？</p>
<p>A：闭包函数引用的外部变量存储在堆中，所以当外部函数返回时，变量依旧存在，垃圾收集器会根据引用计数判断是否回收该变量。注意，如果需要引用循环中的变量，需要通过参数传递（值传递），因为外部变量会随循环变化。</p>
<p>Q：假设有两个线程，线程 A 使用条件变量等待某个条件，线程 B 在达到条件时通知线程 A。如果线程 B 在解锁之前通知线程 A 会有问题吗？</p>
<p>A：如果在解锁之前唤醒线程 A，假设线程 A 在 B 解锁之前被调度，那么线程 A 在获取锁时会被阻塞。之后的某个时刻，操作系统会调度线程 B 解锁，此时线程 A 可以重新被调度。注意，条件变量和锁的阻塞队列是独立的，所以不需要再次通知线程 A。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-07T13:32:42.361Z" title="2024/1/7 下午9:32:42">2024-01-07</time>发表</span><span class="level-item"><time dateTime="2024-01-07T13:34:01.208Z" title="2024/1/7 下午9:34:01">2024-01-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">4 分钟读完 (大约563个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/07/%E7%AC%AC%20379%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 379 场力扣周赛</a></p><div class="content"><h2 id="移除后集合的最多元素数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-size-of-a-set-after-removals/">移除后集合的最多元素数</a></h2>
<p><strong>题目</strong></p>
<p>输入长度为偶数 \(n\) 的数组 \(a\) 和 \(b\)，输出从 \(a\) 和 \(b\) 中分别选择一半元素构成的集合的最大大小。</p>
<p>数据范围：\(1\leq n\leq 2\times 10^{4}\)。</p>
<p><strong>思路</strong></p>
<p>要使集合尽可能大，肯定优先选择除 \(a\) 和 \(b\) 交集以外的元素，假设分别为 \(x\) 和 \(y\)，则可以选择 \(s=\min(x,\frac{n}{2})+\min(y,\frac{n}{2})\) 个不同元素。此时还有 \(n-s\) 个元素待选，假设交集的大小为 \(z\)，则答案为 \(s+\min(n-s,z)\)。</p>
<h2 id="执行操作后的最大分割数量"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/">执行操作后的最大分割数量</a></h2>
<p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的字符串 \(s\) 和一个整数 \(k\)，输出至多改变一个字符时，执行操作能够得到的最大分割数。每次操作可以分割 \(s\) 的最多包含 \(k\) 个不同字符的最长前缀。</p>
<p>数据范围：\(1\leq n\leq 10^{4}\)，\(1\leq k\leq 26\)。</p>
<p><strong>思路</strong></p>
<p>首先，很容易想到暴力做法，枚举每个位置的所有改变情况，然后通过遍历求分割数，时间复杂度为 \(O(n^{2}|\Sigma|\log{|\Sigma|})\)。显然，可以优化的部分就是最后遍历求分割数的 \(O(n\log{|\Sigma|})\)。然后观察修改字符相比不修改字符会产生什么变化，可以发现修改字符所在的分割段的长度可能发生变化，而前缀的分割数是固定的。可以想到预处理原字符串每个位置 \(i\) 的后缀分割数，问题就剩下如何快速求得修改字符所在段的右端点。由于字符数随着长度的增加而增加，所以可以通过二分求得该段的右端点，这还需要花费 \(O(n|\Sigma|)\) 的时间提前预处理出字符数的前缀和。最后，分割数为前缀 + 中间 + 后缀的段数。代码实现时，还有很多其他细节需要注意，强烈建议自己实现一下。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-07T13:31:11.249Z" title="2024/1/7 下午9:31:11">2024-01-07</time>发表</span><span class="level-item"><time dateTime="2024-01-07T13:32:19.492Z" title="2024/1/7 下午9:32:19">2024-01-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/">Codeforces</a></span><span class="level-item">几秒读完 (大约70个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/07/Hello%202024/">Hello 2024</a></p><div class="content"><h2 id="Grouping-Increases"><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1919/problem/C">Grouping Increases</a></h2>
<p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的数组 \(a\)，将数组 \(a\) 分割为两个子序列（可能为空），输出两个子序列中满足 \(b_{i}&lt;b_{i+1}\) 的下标 \(i\) 的数量之和的最小值。</p>
<p>数据范围：\(1\leq n\leq 2\times 10^{5}\)，\(1\leq a_{i}\leq n\)。</p>
<p><strong>思路</strong></p>
<p>贪心。假设将数组 \(a\) 分割为数组 \(b\) 和 \(c\)，从空数组开始，将 \(a\) 中的元素添加到 \(b\) 或 \(c\)。假设 \(b\) 和 \(c\) 的最后一个元素分别为 \(x\) 和 \(y\)（\(x\leq y\)），如果 \(a_{i}\leq x\) 或 \(a_{i}&gt;y\)，则将 \(a_{i}\) 添加到 \(b\)，否则添加到 \(c\)。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/13/">13</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">128</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-20T02:58:46.061Z">2024-08-20</time></p><p class="title"><a href="/2024/08/20/GAMES101%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">GAMES101 课程总结</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/">GAMES101</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-17T15:31:02.381Z">2024-08-17</time></p><p class="title"><a href="/2024/08/17/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">南京大学 软件分析 课程总结</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/">NJU Static Analysis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-16T11:35:55.194Z">2024-08-16</time></p><p class="title"><a href="/2024/08/16/CSAPP%20%E7%AC%AC%206%20%E7%AB%A0%20+%20OSTEP%20%E6%8C%81%E4%B9%85%E6%80%A7/">CSAPP 第 6 章 + OSTEP 持久性</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a> / <a href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/">CSAPP/OSTEP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-16T10:12:43.657Z">2024-08-16</time></p><p class="title"><a href="/2024/08/16/CSAPP%20%E7%AC%AC%208%20&amp;%209%20%E7%AB%A0%20+%20OSTEP%20%E8%99%9A%E6%8B%9F%E5%8C%96/">CSAPP 第 8 &amp; 9 章 + OSTEP 虚拟化</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a> / <a href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/">CSAPP/OSTEP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-16T07:50:07.806Z">2024-08-16</time></p><p class="title"><a href="/2024/08/16/CSAPP%20%E7%AC%AC%201%20&amp;%202%20%E7%AB%A0/">CSAPP 第 1 &amp; 2 章</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a> / <a href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/">CSAPP/OSTEP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">95</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/I-O/"><span class="tag">I/O</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CLIST</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://csdiy.wiki/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDIY</span></span><span class="level-right"><span class="level-item tag">csdiy.wiki</span></span></a></li><li><a class="level is-mobile" href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">阮一峰的网络日志</span></span><span class="level-right"><span class="level-item tag">www.ruanyifeng.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>