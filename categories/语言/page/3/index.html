<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 语言 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">语言</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-31T16:00:00.000Z" title="2024/1/1 00:00:00">2024-01-01</time>发表</span><span class="level-item"><time dateTime="2025-06-09T14:33:09.688Z" title="2025/6/9 22:33:09">2025-06-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Go/">Go</a></span><span class="level-item">1 小时读完 (大约13350个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/01/Go%20%E5%9F%BA%E7%A1%80/">Go 基础</a></p><div class="content"><p>参考<a target="_blank" rel="noopener" href="https://go.dev/">官方网站</a>，<a target="_blank" rel="noopener" href="https://www.gopl.io/">GOPL</a>，<a target="_blank" rel="noopener" href="https://pkg.go.dev/std">STD</a>，<a target="_blank" rel="noopener" href="https://github.com/golang/go">源代码</a>，<a target="_blank" rel="noopener" href="https://draven.co/golang/">Go 语言设计与实现</a>。</p>
<h2 id="Tutorial">Tutorial</h2>
<h3 id="Hello-World">Hello, World</h3>
<p>使用 <code>go run</code> 编译运行程序，<code>go build</code> 编译程序，<code>go doc</code> 查看文档。</p>
<p>某些标记之后的换行符会被转换为分号，因此换行符的位置对于正确解析 Go 代码至关重要。例如，函数的左括号 <code>&#123;</code> 必须与函数声明的结尾在同一行，否则会报错 <code>unexpected semicolon or newline before &#123;</code>。而在表达式 <code>x + y</code> 中，可以在 <code>+</code> 运算符之后换行，但不能在之前换行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Command-Line-Arguments">Command-Line Arguments</h3>
<p>可以使用 <code>os.Args</code> 变量获取命令行参数，该变量是一个字符串切片。<code>os.Args[0]</code> 是命令本身，剩余元素是程序启动时用户传递的参数。使用 <code>var</code> 声明语句定义变量，变量可以在声明时进行初始化。如果未显式初始化，则隐式初始化为该类型的零值（zero value），数值类型为 <code>0</code>，字符串类型为空串 <code>&quot;&quot;</code>。</p>
<p><code>for</code> 语句是 Go 中唯一的循环语句，可以充当其他语言中常规的 <code>for</code>、<code>while</code> 循环以及无限循环。Go 语言不允许未使用的局部变量，否则会报错 <code>declared and not used</code>。使用 <code>+=</code> 在循环中拼接字符串的开销较大，每次都会生成新字符串，而旧字符串则不再使用等待 GC，可以使用 <code>strings.Join</code> 方法提升性能，一次性拼接所有字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下几种声明变量的方式都是等价的。第一种简洁但只能在函数中使用，而不能用于包级变量，第二种使用默认初始化，第三种形式仅在声明多个变量时使用，第四种仅在声明类型和初始值类型不同时使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := &quot;&quot;</span><br><span class="line">var s string</span><br><span class="line">var s = &quot;&quot;</span><br><span class="line">var s string = &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Finding-Duplicate-Lines">Finding Duplicate Lines</h3>
<p><code>input.Scan()</code> 读取下一行数据并移除行尾的换行符，可以调用 <code>input.Text()</code> 方法获取结果。<code>map</code> 的迭代顺序未明确指定，但在实际操作中是随机的，这种设计是有意为之，防止程序依赖特定的顺序。<code>map</code> 是一个由 <code>make</code> 创建的数据结构的引用（reference），当将 <code>map</code> 作为参数传递时，函数会收到引用的副本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	files := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">		countLines(os.Stdin, counts)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">			f, err := os.Open(arg)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">&quot;dup2: %v\n&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			countLines(f, counts)</span><br><span class="line">			f.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	input := bufio.NewScanner(f)</span><br><span class="line">	<span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">		counts[input.Text()]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Animated-GIFs">Animated GIFs</h3>
<p><code>const</code> 常量的值必须是数字、字符串或者布尔值。以下程序使用 <code>web</code> 方式可以正常显示图像，但是如果使用 <code>./main &gt; out.gif</code> 重定向输出的方式，则在 Windows 中不能正常显示。因为 Windows 标准输出默认以文本模式处理数据，会修改输出的数据从而导致图像损坏。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	whiteIndex = <span class="number">0</span> <span class="comment">// first color in palette</span></span><br><span class="line">	blackIndex = <span class="number">1</span> <span class="comment">// next color in palette</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//!-main</span></span><br><span class="line">	<span class="comment">// The sequence of images is deterministic unless we seed</span></span><br><span class="line">	<span class="comment">// the pseudo-random number generator using the current time.</span></span><br><span class="line">	<span class="comment">// Thanks to Randall McPherson for pointing out the omission.</span></span><br><span class="line">	rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">&quot;web&quot;</span> &#123;</span><br><span class="line">		<span class="comment">//!+http</span></span><br><span class="line">		handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			lissajous(w)</span><br><span class="line">		&#125;</span><br><span class="line">		http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">		<span class="comment">//!-http</span></span><br><span class="line">		log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//!+main</span></span><br><span class="line">	lissajous(os.Stdout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		cycles  = <span class="number">5</span>     <span class="comment">// number of complete x oscillator revolutions</span></span><br><span class="line">		res     = <span class="number">0.001</span> <span class="comment">// angular resolution</span></span><br><span class="line">		size    = <span class="number">100</span>   <span class="comment">// image canvas covers [-size..+size]</span></span><br><span class="line">		nframes = <span class="number">64</span>    <span class="comment">// number of animation frames</span></span><br><span class="line">		delay   = <span class="number">8</span>     <span class="comment">// delay between frames in 10ms units</span></span><br><span class="line">	)</span><br><span class="line">	freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// relative frequency of y oscillator</span></span><br><span class="line">	anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">	phase := <span class="number">0.0</span> <span class="comment">// phase difference</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">		rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">		img := image.NewPaletted(rect, palette)</span><br><span class="line">		<span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">			x := math.Sin(t)</span><br><span class="line">			y := math.Sin(t*freq + phase)</span><br><span class="line">			img.SetColorIndex(size+<span class="type">int</span>(x*size+<span class="number">0.5</span>), size+<span class="type">int</span>(y*size+<span class="number">0.5</span>),</span><br><span class="line">				blackIndex)</span><br><span class="line">		&#125;</span><br><span class="line">		phase += <span class="number">0.1</span></span><br><span class="line">		anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">		anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">	&#125;</span><br><span class="line">	gif.EncodeAll(out, &amp;anim) <span class="comment">// <span class="doctag">NOTE:</span> ignoring encoding errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fet-ching-URLs-Concurrently">Fet ching URLs Concurrently</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">go</span> fetch(url, ch) <span class="comment">// start a goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">		fmt.Println(&lt;-ch) <span class="comment">// receive from channel ch</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprint(err) <span class="comment">// send to channel ch</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nbytes, err := io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">	resp.Body.Close() <span class="comment">// don&#x27;t leak resources</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ch &lt;- fmt.Sprintf(<span class="string">&quot;while reading %s: %v&quot;</span>, url, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	secs := time.Since(start).Seconds()</span><br><span class="line">	ch &lt;- fmt.Sprintf(<span class="string">&quot;%.2fs  %7d  %s&quot;</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="A-Web-Server">A Web Server</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!+handler</span></span><br><span class="line"><span class="comment">// handler echoes the HTTP request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Host = %q\n&quot;</span>, r.Host)</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)</span><br><span class="line">	<span class="keyword">if</span> err := r.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Form[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Loose-Ends">Loose Ends</h3>
<p><code>switch</code> 语句的 <code>case</code> 不需要显式使用 <code>break</code>，默认不会 <code>fallthrough</code> 到下一个 <code>case</code>。可以省略 <code>switch</code> 之后的操作数，此时等价于 <code>switch true</code>。和 <code>for</code> 和 <code>if</code> 一样，在 <code>switch</code> 之后可以跟一个简单语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Signum</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> x &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> x &lt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Program-Structure">Program Structure</h2>
<h3 id="Names">Names</h3>
<p>名称以字母（Unicode 字母）或下划线开头，可以包含任意数量的字母、数字和下划线，大小写敏感。关键字（keywords）不可作为名称被使用，而预声明（predeclared）的名称（内置常量、类型和函数）可以重新声明，但是存在混淆的风险。在函数内声明的实体仅在函数内可见，在函数外声明的实体包可见，名称的首字母大写则在包外可见。包名总是小写的，实体命名使用驼峰命名法。</p>
<h3 id="Declarations">Declarations</h3>
<p>声明（declaration）命名一个程序实体，有四种主要的声明类型，<code>var</code>、<code>const</code>、<code>type</code> 和 <code>func</code>。Go 程序存储在以 <code>.go</code> 为后缀的文件中，每个文件开头都有包声明，之后是导入声明，然后是以任意顺序排列的包级（package-level）的类型、变量、常量和函数声明。函数的返回值列表是可选的（多个返回值构成列表），如果不返回任何值则可以省略。</p>
<h3 id="Variables">Variables</h3>
<p>变量声明的通用形式为 <code>var name type = expression</code>。如果省略 <code>type</code> 则类型由表达式推断，如果省略 <code>= expression</code> 则必须显式指定类型，初始值为该类型的零值。数值类型为 <code>0</code>，字符串类型为空串 <code>&quot;&quot;</code>，布尔类型为 <code>false</code>，接口和引用类型（切片、指针、哈希表、通道和函数）为 <code>nil</code>。像数组或者结构体聚合类型的元素或字段的零值就是自身的零值。</p>
<p>零值机制确保变量始终有其类型所定义的明确值，Go 语言中不存在未初始化变量的概念。可以同时声明一组变量，如果省略类型则可以同时声明不同类型的变量。包级变量会在 <code>main</code> 函数开始之前初始化，局部变量在声明时初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span> <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span> <span class="comment">// bool, float64, string</span></span><br><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open returns a file and an error</span></span><br></pre></td></tr></table></figure>
<h4 id="Short-Variable-Declarations">Short Variable Declarations</h4>
<p>在函数中可以使用简短变量声明（short variable declaration）的形式声明和初始化局部变量，形式为 <code>name := expression</code>。简短变量声明常用于声明和初始化大多数局部变量，而 <code>var</code> 声明常用于变量类型和表达式类型不同、或者稍后赋值且初始值不重要的局部变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">100</span> <span class="comment">// an int</span></span><br><span class="line"><span class="keyword">var</span> boiling <span class="type">float64</span> = <span class="number">100</span> <span class="comment">// a float64</span></span><br><span class="line">i, j = j, i <span class="comment">// swap values of i and j</span></span><br></pre></td></tr></table></figure>
<p>区分 <code>:=</code> 是声明而 <code>=</code> 是赋值。需要注意，如果简短变量声明中的变量已经在相同词法块（lexical block）中被声明过，那么该声明相当于对该变量赋值。而且简短变量声明必须至少声明一个新变量，否则代码将无法通过编译。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure>
<h4 id="Pointers">Pointers</h4>
<p>指针（pointer）是变量的地址（address），可以通过指针间接地读写变量的值，而无需知晓变量的名称。指针的零值是 <code>nil</code>，如果指针指向某个变量则其值必然不为 <code>nil</code>。两个指针相等仅当它们指向相同的变量或者都为 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">*p = <span class="number">2</span> <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数返回局部变量的地址是安全的，即使函数调用返回该局部变量 <code>v</code> 仍会存在。由编译器逃逸分析确定，该变量会在堆上分配。根据静态分析知识，为保证安全性，分析肯定是偏向误报（Sound）而不是漏报（Complete）。每次调用函数 <code>f</code> 返回的值都不同。每次获取变量的地址或者复制指针时，都会为该变量创建新的别名（aliases），<code>*p</code> 是 <code>v</code> 的别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    v := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">&quot;n&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;omit trailing newline&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;separator&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Print(strings.Join(flag.Args(), *sep))</span><br><span class="line">	<span class="keyword">if</span> !*n &#123;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="The-new-Function">The new Function</h4>
<p>另一种创建变量的方式是使用内置函数 <code>new</code>，表达式 <code>new(T)</code> 创建类型为 <code>T</code> 的未命名变量，将其初始化为类型 <code>T</code> 的零值，返回类型为 <code>*T</code> 的地址值。使用 <code>new</code> 创建的变量和普通局部变量没有区别，只是后者需要显式获取地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dummy <span class="type">int</span></span><br><span class="line">	<span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常每次调用 <code>new</code> 都会返回具有唯一地址的不同变量，例外情况是，如果两个变量的类型不携带任何信息且大小为零（例如 <code>struct&#123;&#125;</code> 或 <code>[0]int</code>），则根据实现的不同可能会具有相同的地址（实测得到的是不同地址）。由于 <code>new</code> 是内置函数而不是关键字，所以可以被重新定义为其他东西，不过此时不能在 <code>delta</code> 中使用内置的 <code>new</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">new</span> - old &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Lifetime-of-Variables">Lifetime of Variables</h4>
<p>变量的声明周期是指其在程序执行过程中的存活时间。包级变量在整个程序执行过程中存活，局部变量在声明时创建，在不被引用时回收（GC 可达性分析）。因为变量的生命周期取决于可达性，所以局部变量在函数返回之后仍有可能存活。编译器会决定将变量分配到堆中还是栈中，这一决定并非取决于使用 <code>var</code> 还是 <code>new</code> 来声明变量（Pointers 小节中提到过的逃逸分析）。例如，下面示例中 <code>x</code> 必须在堆上分配，而 <code>y</code> 可以在栈上分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	x = <span class="number">1</span></span><br><span class="line">	global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">	y := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">	*y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Assignments">Assignments</h3>
<p>Go 语言中仅有后置 <code>x++</code> 和 <code>x--</code> 而没有前置写法，而且该操作被视为语句而不是表达式，所以不能将其赋值给变量或者参与运算。</p>
<h4 id="Tuple-Assignment">Tuple Assignment</h4>
<p>元组赋值（tuple assignment）允许一次为多个变量赋值，在对任何变量更新之前，所有右侧表达式都会被计算出来。如果函数具有多个返回值，则赋值语句左侧必须包含相同数量的变量，可以使用 <code>_</code> 忽略不需要的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line">_, err = io.Copy(dst, src) <span class="comment">// discard byte count</span></span><br></pre></td></tr></table></figure>
<h4 id="Assignability">Assignability</h4>
<p>当值能够赋值给变量的类型时，该赋值操作才是合法的，不同类型有不同的赋值规则。只有当两个变量可以相互赋值时，它们才能够使用 <code>==</code> 和 <code>!=</code> 进行比较。（Java 中引用类型之间总是可以使用该运算符相互比较）</p>
<h3 id="Type-Declarations">Type Declarations</h3>
<p>类型声明形如 <code>type name underlying-type</code>，用于定义一个新的具有某个底层类型（underlying type）的命名类型（named type）。即使两个类型具有相同的底层类型，它们也是不同的类型，不能直接比较或组合，而需要使用 <code>T(x)</code> 进行显式类型转换。命名类型将底层类型的不同使用方式区分开来，避免不同使用方式之间混淆。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="type">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">	FreezingC     Celsius = <span class="number">0</span></span><br><span class="line">	BoilingC      Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span></span> Fahrenheit &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span></span> Celsius &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span></span> String() <span class="type">string</span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Packages-and-Files">Packages and Files</h3>
<p>在 Go 语言中，包的作用与其他语言中的库或模块相同，支持模块化、封装、独立编译和代码复用。一个包的源代码在一个或多个 <code>.go</code> 文件中，通常这些文件位于一个目录中，该目录的名称以导入路径结尾。例如 <code>gopl.io/ch1/helloworld</code> 包的文件存储在 <code>$GOPATH/src/gopl.io/ch1/helloworld</code> 目录中。</p>
<h4 id="Imports">Imports</h4>
<p>每个包都由其导入路径标唯一标识，包名要求和导入路径的最后一部分相同，例如 <code>gopl.io/ch2/tempconv</code> 导入路径的包名是 <code>tempconv</code>。不同导入路径的包名可能冲突，可以在导入时指定别名来避免冲突。</p>
<h4 id="Package-Initialization">Package Initialization</h4>
<p>包初始化首先会按照声明顺序初始化包级变量，如果包中有多个 <code>.go</code> 文件，<code>go</code> 工具会对按照文件名对文件进行排序，然后调用编译器，文件按照传入编译器的顺序进行初始化。如果变量之间存在依赖关系，则会优先按照依赖关系初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a initialized third, to 3</span></span><br><span class="line"><span class="keyword">var</span> b = f() <span class="comment">// b initialized second, to 2, by calling f</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> <span class="comment">// c initialized first, to 1</span></span><br></pre></td></tr></table></figure>
<p>可以使用 <code>init</code> 函数来初始化包级变量，每个文件都可以包含任意数量的 <code>init</code> 函数，按照声明顺序执行。包按照导入顺序依次初始化，如果包之间存在依赖关系，则会优先按照依赖关系初始化。<code>main</code> 包最后被初始化，从而保证 <code>main</code> 函数开始之前所有包都完成初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pc[i] is the population count of i.</span></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">		pc[i] = pc[i/<span class="number">2</span>] + <span class="type">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PopCount returns the population count (number of set bits) of x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</span><br><span class="line">		pc[<span class="type">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BitCount</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// Hacker&#x27;s Delight, Figure 5-2.</span></span><br><span class="line">	x = x - ((x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>)</span><br><span class="line">	x = (x &amp; <span class="number">0x3333333333333333</span>) + ((x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>)</span><br><span class="line">	x = (x + (x &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f0f0f0f0f</span></span><br><span class="line">	x = x + (x &gt;&gt; <span class="number">8</span>)</span><br><span class="line">	x = x + (x &gt;&gt; <span class="number">16</span>)</span><br><span class="line">	x = x + (x &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(x &amp; <span class="number">0x7f</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCountByClearing</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">		x = x &amp; (x - <span class="number">1</span>) <span class="comment">// clear rightmost non-zero bit</span></span><br><span class="line">		n++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCountByShifting</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">0</span>); i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> x&amp;(<span class="number">1</span>&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">			n++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go 1.6, 2.67GHz Xeon</span></span><br><span class="line"><span class="comment">// $ go test -cpu=4 -bench=. gopl.io/ch2/popcount</span></span><br><span class="line"><span class="comment">// BenchmarkPopCount-4                  200000000         6.30 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkBitCount-4                  300000000         4.15 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByClearing-4        30000000         45.2 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByShifting-4        10000000        153 ns/op</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Go 1.6, 2.5GHz Intel Core i5</span></span><br><span class="line"><span class="comment">// $ go test -cpu=4 -bench=. gopl.io/ch2/popcount</span></span><br><span class="line"><span class="comment">// BenchmarkPopCount-4                  200000000         7.52 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkBitCount-4                  500000000         3.36 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByClearing-4        50000000         34.3 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByShifting-4        20000000        108 ns/op</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Go 1.7, 3.5GHz Xeon</span></span><br><span class="line"><span class="comment">// $ go test -cpu=4 -bench=. gopl.io/ch2/popcount</span></span><br><span class="line"><span class="comment">// BenchmarkPopCount-12                 2000000000        0.28 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkBitCount-12                 2000000000        0.27 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByClearing-12       100000000        18.5 ns/op</span></span><br><span class="line"><span class="comment">// BenchmarkPopCountByShifting-12       20000000         70.1 ns/op</span></span><br></pre></td></tr></table></figure>
<h3 id="Scope">Scope</h3>
<p>区分作用域（Scope）和生命周期（lifetime），声明的作用域是指程序文本中的一个区域，是编译时的属性。而变量的生命周期是指程序执行期间，其他部分可以引用该变量的时间范围，是运行时的属性。</p>
<p>语法块（syntactic block）是指由花括号包围的语句块，词法块（lexical block）是对语法块概念的泛化，以涵盖未明确使用花括号包围的其它声明组合。整个源代码也是词法块，被称为宇宙块（universe block）。程序可以包含多个同名的声明，只要声明在不同词法块中。当编译器遇到对某个名称的引用，它会从最内层的词法块开始向外找，直到宇宙块为止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x := f(); x == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> y := g(x); x == y &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(x, y) <span class="comment">// compile error: x and y are not visible here</span></span><br></pre></td></tr></table></figure>
<h2 id="Basic-Data-Types">Basic Data Types</h2>
<p>Go 语言的类型分为四类：基本类型、聚合类型、引用类型和接口类型。基本类型包括数值类型、字符串和布尔类型，聚合类型包括数组和结构体，引用类型包括指针、切片、哈希表、函数和通道。</p>
<h3 id="Integers">Integers</h3>
<p>数值类型包括整数、浮点数和复数。Go 提供有符号和无符号整数运算，它们分别有四种不同大小的类型，<code>int8, int16, int32, int64</code> 和  <code>uint8, uint16, uint32, uint64</code>。还有 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 类型，通常为 32 位或 64 位，具体位数由编译器决定。</p>
<p><code>rune</code> 和 <code>int32</code> 等价，通常用于表示 Unicode 码点。<code>byte</code> 和 <code>uint8</code> 等价，通常用于表示字节数据。在 Go 语言中，<code>%</code> 运算符得到的余数符号总是和被除数相同。没有 <code>~x</code> 按位取反，而是使用 <code>^x</code> 执行按位取反。对于有符号数而言，<code>&gt;&gt;</code> 会使用符号位填充。</p>
<h3 id="Floating-Point-Numbers">Floating-Point Numbers</h3>
<p>浮点类型有 <code>float32</code> 和 <code>float64</code> 两种，遵循 IEEE 754 标准。32 位浮点数的小数精度大约是 6 位，64 位浮点数的精度大约是 15 位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="type">float64</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z) <span class="comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Complex-Numbers">Complex Numbers</h3>
<p>有两种复数类型 <code>complex64</code> 和 <code>complex128</code>，它们的元素分别是 <code>float32</code> 和 <code>float64</code> 类型。可以使用内置函数 <code>complex</code>、<code>real</code> 和 <code>imag</code> 处理复数，可以直接使用 <code>i</code> 来声明复数的虚部。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y) <span class="comment">// &quot;(-5+10i)&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y)) <span class="comment">// &quot;-5&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Strings">Strings</h3>
<p>字符串是不可变的字节序列，内置函数 <code>len</code> 返回字符串的字节数量，而不是字符数量，索引操作 <code>s[i]</code> 获取字符串 <code>s</code> 的第 <code>i</code> 个字节。字符串的第 <code>i</code> 个字节不一定就是第 <code>i</code> 个字符，因为非 ASCII 码点的 UTF-8 编码需要多个字节。使用 <code>s[i:j]</code> 可以获取子字符串，该子字符串是一个新的字符串，不过和原串共享底层字节数组。由于可以共享底层内存，所以字符串的复制和子串操作的开销很低。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// &quot;12&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>]) <span class="comment">// &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749296835958.png" alt=""></p>
<p>可以在字符串中插入转义序列，特别地，有十六进制转义 <code>\xhh</code> 和八进制转义 <code>\ooo</code>，其中 <code>hh</code> 和 <code>ooo</code> 表示十六进制和八进制数字，八进制数不超过 <code>\377</code> 对应十进制 255。原始字符串字面量（raw string literal）使用的是反引号而不是单引号，输出时不会处理原始字符串字面量中的转义序列。 例外情况是，当原始字符串字面量跨多行编写时，会删除回车符 <code>\r</code>，从而使字符串在所有平台上保持一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GoUsage = <span class="string">`Go is a tool for managing Go source code.</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">go command [arguments]</span></span><br><span class="line"><span class="string">...`</span></span><br></pre></td></tr></table></figure>
<h4 id="Unicode">Unicode</h4>
<p>Unicode 是字符编码标准，每个字符对应一个 Unicode 码点，在 Go 中使用 <code>rune</code> 表示（<code>int32</code> 的同义词），即使用 UTF-32 编码方式定长存储 Unicode 码点，但是这样空间开销较大。</p>
<h4 id="UTF-8">UTF-8</h4>
<p>UTF-8 变长编码（由 Go 语言开发者发明）使用 1 到 4 字节表示 <code>rune</code>，第一个字节的高位指示当前 <code>rune</code> 使用多少字节表示。变长编码无法直接通过索引访问字符串中的第 <code>n</code> 个字符，但这种编码方式空间有诸多优点。空间占用小，和 ASCII 兼容，自同步（可以通过后退不超过 3 个字节找到字符的开头），从左向右解码不会有歧义。任何字符的编码都不是其他一个或多个字符编码的子串，因此可以通过查找字节来查找字符，而无需担心前面的上下文。字典序和 Unicode 码点顺序相同，不存在嵌入的 NUL 字节（零字节），对于使用 NUL 终止字符串的语言来说非常方便。</p>
<p><img src="/img/Go.assets/1749298903599.png" alt=""></p>
<p>Go 的源文件始终使用 UTF-8 编码方式，UTF-8 是 Go 程序处理文本字符串的首选编码方式。可以在字符串中使用 <code>\uhhhh</code> 表示 16 位码点，使用 <code>\Uhhhhhhhh</code> 表示 32 位码点，其中 <code>h</code> 是十六进制数字，每种形式都表示码点的 UTF-8 编码。例如，以下字符串字面量都表示相同的 6 字节字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;世界&quot;</span></span><br><span class="line"><span class="string">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span></span><br><span class="line"><span class="string">&quot;\u4e16\u754c&quot;</span></span><br><span class="line"><span class="string">&quot;\U00004e16\U0000754c&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>rune</code> 字面量中也可以使用 Unicode 转义字符，下面三种字面量是等价的。对于值小于 256 的 <code>rune</code> 可以使用单个十六进制转义字符表示，例如 <code>'\x41'</code> 表示 <code>'A'</code>。但是更大的值必须使用 <code>\u</code> 或 <code>\U</code> 转义，<code>'\xe4\xb8\x96'</code> 不是合法的 <code>rune</code> 字面量，即使这三个字节是单个码点的 UTF-8 编码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;世&#x27;</span> <span class="string">&#x27;\u4e16&#x27;</span> <span class="string">&#x27;\U00004e16&#x27;</span></span><br></pre></td></tr></table></figure>
<p>由于 UTF-8 的特性，许多字符串操作都无需解码。可以使用以下方法检验一个字符串是否是另一个字符串的前缀。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串 <code>s</code> 占用 13 个字节，包含 9 个码点/字符/<code>rune</code>，要处理字符可以使用 UTF-8 解码器 <code>DecodeRuneInString</code>。不过 Go 的 <code>range</code> 循环在应用于字符串时会自动进行 UTF-8 解码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// &quot;13&quot;</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(s)) <span class="comment">// &quot;9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%c\n&quot;</span>, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749301168174.png" alt=""></p>
<p>如果 UTF-8 解码遇到非法字节，则会生成特殊的 Unicode 替换字符 <code>\uFFFD</code>，显示为白色问号周围环绕黑色六边形或菱形图案。将 UTF-8 编码的字符串转换为 <code>[]rune</code> 之后，会得到 Unicode 码点序列，反之亦然。将整数转换为字符串会将其解释为单个 <code>rune</code> 值，然后将其转换为 UTF-8 表示形式，如果对应的 <code>rune</code> 是无效的，则会使用替换字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;program&quot; in Japanese katakana</span></span><br><span class="line">s := <span class="string">&quot;プログラム&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;% x\n&quot;</span>, s) <span class="comment">// &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;</span></span><br><span class="line">r := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, r) <span class="comment">// &quot;[30d7 30ed 30b0 30e9 30e0]&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Strings-and-Byte-Slices">Strings and Byte Slices</h4>
<p>字符串 <code>s</code> 可以使用 <code>[]byte(s)</code> 转换为字节切片，然后使用 <code>string(b)</code> 转换回来。两个操作通常都会进行复制操作，以确保 <code>b</code> 的可变性和 <code>s2</code> 的不可变性。<code>bytes</code> 包提供 <code>Buffer</code> 类型，类似 Java 中的 <code>StringBuilder</code>，该类型无需初始化，其零值可以直接使用，因为之后调用的方法中会判断底层切片 <code>buf</code> 是否为 <code>nil</code>，然后为其分配内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="type">byte</span>(s)</span><br><span class="line">s2 := <span class="type">string</span>(b)</span><br></pre></td></tr></table></figure>
<h4 id="Conversions-between-Strings-and-Numbers">Conversions between Strings and Numbers</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">123</span></span><br><span class="line">y := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">fmt.Println(y, strconv.Itoa(x)) <span class="comment">// &quot;123 123&quot;</span></span><br><span class="line"></span><br><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>) <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br></pre></td></tr></table></figure>
<h3 id="Constants">Constants</h3>
<p><code>const</code> 常量的底层类型必须是基本类型（和 Java 中的 <code>final</code> 很不一样）。当常量作为一个组声明时，除该组的第一个元素外，剩余元素的右侧表达式可以省略，此时默认会使用之前元素的表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) <span class="comment">// &quot;1 1 2 2&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="The-Constant-Generator-iota">The Constant Generator iota</h4>
<p>可以使用常量生成器 <code>iota</code> 创建枚举常量组，<code>iota</code> 的值从 0 开始，每次递增 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags <span class="type">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    FlagUp           Flags = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// is up</span></span><br><span class="line">    FlagBroadcast                      <span class="comment">// supports broadcast access capability</span></span><br><span class="line">    FlagLoopback                       <span class="comment">// is a loopback interface</span></span><br><span class="line">    FlagPointToPoint                   <span class="comment">// belongs to a point-to-point link</span></span><br><span class="line">    FlagMulticast                      <span class="comment">// supports multicast access capability</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="Untyped-Constants">Untyped Constants</h4>
<p>没有指定类型的常量是无类型（untyped）常量，编译器会以比基本类型更高的数值精度来表示无类型常量，并且在其上执行高精度运算而不是机器运算（受限于 CPU 的位数），至少可以假设其具有 256 位精度。例如 <code>ZiB</code> 和 <code>YiB</code> 无法存储在任何整型变量中，但是可以在下面的表达式中使用。有六种无类型常量：untyped boolean、untyped integer、untyped rune、untyped floating-point、untyped complex 和 untyped string。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _   = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    KiB <span class="comment">// 1024</span></span><br><span class="line">    MiB <span class="comment">// 1048576</span></span><br><span class="line">    GiB <span class="comment">// 1073741824</span></span><br><span class="line">    TiB <span class="comment">// 1099511627776 (exceeds 1 &lt;&lt; 32)</span></span><br><span class="line">    PiB <span class="comment">// 1125899906842624</span></span><br><span class="line">    EiB <span class="comment">// 1152921504606846976</span></span><br><span class="line">    ZiB <span class="comment">// 1180591620717411303424 (exceeds 1 &lt;&lt; 64)</span></span><br><span class="line">    YiB <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(YiB/ZiB) <span class="comment">// &quot;1024&quot;</span></span><br></pre></td></tr></table></figure>
<p>浮点型常量 <code>math.Pi</code> 可以在需要浮点或复数的情况下使用，但是如果为其指定类型 <code>float64</code>，则精度会降低，而且在需要使用 <code>float32</code> 或 <code>complex128</code> 类型的值时需要显式类型转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi64 <span class="type">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float32</span> = <span class="type">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="type">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="type">complex128</span> = <span class="type">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure>
<p>只有常量可以不指定类型，当将无类型常量赋值给变量时，该常量会隐式转换为变量的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">3</span> + <span class="number">0i</span> <span class="comment">// untyped complex -&gt; float64</span></span><br><span class="line">f = <span class="number">2</span>                  <span class="comment">// untyped integer -&gt; float64</span></span><br><span class="line">f = <span class="number">1e123</span>              <span class="comment">// untyped floating-point -&gt; float64</span></span><br><span class="line">f = <span class="string">&#x27;a&#x27;</span>                <span class="comment">// untyped rune -&gt; float64</span></span><br></pre></td></tr></table></figure>
<p>无论隐式还是显式转换，在转换时目标类型必须能够表示原始值，对于实数和复数的浮点数，允许四舍五入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    deadbeef = <span class="number">0xdeadbeef</span>        <span class="comment">// untyped int with value 3735928559</span></span><br><span class="line">    a        = <span class="type">uint32</span>(deadbeef)  <span class="comment">// uint32 with value 3735928559</span></span><br><span class="line">    b        = <span class="type">float32</span>(deadbeef) <span class="comment">// float32 with value 3735928576 (rounded up)</span></span><br><span class="line">    c        = <span class="type">float64</span>(deadbeef) <span class="comment">// float64 with value 3735928559 (exact)</span></span><br><span class="line">    d        = <span class="type">int32</span>(deadbeef)   <span class="comment">// compile error: constant overflows int32</span></span><br><span class="line">    e        = <span class="type">float64</span>(<span class="number">1e309</span>)    <span class="comment">// compile error: constant overflows float64</span></span><br><span class="line">    f        = <span class="type">uint</span>(<span class="number">-1</span>)          <span class="comment">// compile error: constant underflows uint</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在未显式指定类型的变量声明中，无类型常量的特性会决定变量的默认类型。无类型整型默认转换为 <code>int</code> 类型，无类型浮点数和复数默认转换为 <code>float64</code> 和 <code>complex128</code>。如果要使用其他类型，需要显示类型转换，或者在变量声明中指定类型。在将无类型常量转换为接口值时，默认值非常重要，因为它们会决定接口的动态类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span>      <span class="comment">// untyped integer; implicit int(0)</span></span><br><span class="line">r := <span class="string">&#x27;\000&#x27;</span> <span class="comment">// untyped rune; implicit rune(&#x27;\000&#x27;)</span></span><br><span class="line">f := <span class="number">0.0</span>    <span class="comment">// untyped floating-point; implicit float64(0.0)</span></span><br><span class="line">c := <span class="number">0i</span>     <span class="comment">// untyped complex; implicit complex128(0i)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0</span>)      <span class="comment">// &quot;int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0.0</span>)    <span class="comment">// &quot;float64&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="number">0i</span>)     <span class="comment">// &quot;complex128&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, <span class="string">&#x27;\000&#x27;</span>) <span class="comment">// &quot;int32&quot; (rune)</span></span><br></pre></td></tr></table></figure>
<h2 id="Composite-Types">Composite Types</h2>
<h3 id="Arrays">Arrays</h3>
<p>数组元素默认初始化为元素类型的零值，可以使用数组字面量（array literal）来初始化数组。在数组字面量中，如果使用省略号 <code>...</code> 代替数组长度，则数组长度就是列表中元素的数量。数组大小属于类型的一部分，<code>[3]int</code> 和 <code>[4]int</code> 是不同的类型。大小必须是一个常量表达式，在编译时能够确定值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span> <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>]) <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, q) <span class="comment">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>
<p>除指定值列表外，还可以指定索引和值构成的列表，索引可以按任意顺序排列，不需要列出所有索引，未指定值的索引默认取零值。下面的数组 <code>r</code> 包含 100 个元素，其中最后一个元素的值为 -1。如果数组元素是可比较的，那么相同数组类型之间也可以相互比较，只有当所有对应元素都相等时，两个数组才相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="type">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>将数组作为参数传递时，传递的是数组的副本，如果函数想要修改原数组，需要传递指向数组的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">	*ptr = [<span class="number">32</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slices">Slices</h3>
<p>切片是可变长的序列，由指针、长度和容量组成。指针指向该切片能够访问的底层数组的第一个元素，该元素不一定是底层数组的第一个元素。长度是切片包含的元素数量，容量是切片起始位置到底层数组末尾之间的元素数量，长度不会超过容量。多个切片可以共享相同的底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;January&quot;</span>, <span class="comment">/* ... */</span>, <span class="number">12</span>: <span class="string">&quot;December&quot;</span>&#125;</span><br><span class="line">Q2 := months[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(Q2) <span class="comment">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span><br><span class="line">fmt.Println(summer) <span class="comment">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749365784634.png" alt=""></p>
<p>超出切片容量 <code>cap(s)</code> 会导致 <code>panic</code>，超出长度 <code>len(s)</code> 会扩展切片长度。由于切片包含指向底层数组的指针，所以将其作为参数传递不会复制数组元素，参数和切片共享底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of range</span></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// extend a slice (within capacity)</span></span><br><span class="line">fmt.Println(endlessSummer) <span class="comment">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure>
<p>切片字面量和数组字面量类似，只是未给出大小，它会先创建具有正确大小的数组，然后将该数组作为切片的底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>和数组不同，切片无法进行比较，不能使用 <code>==</code> 判断两个切片是否相等。标准库提供对 <code>[]byte</code> 切片的比较函数 <code>bytes.Equal</code>，对于其他类型的切片，需要自己实现比较逻辑。例外情况是，切片可以和 <code>nil</code> 进行比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> summer == <span class="literal">nil</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>切片的零值是 <code>nil</code>，<code>nil</code> 切片的长度和容量都是零。不过长度和容量为零的切片不一定是 <code>nil</code> 切片，例如 <code>[]int&#123;&#125;</code> 或 <code>make([]int, 3)[3:]</code>。除和 <code>nil</code> 进行相等性比较之外，<code>nil</code> 切片和任何其他长度为零的切片具有相同的行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="type">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="type">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>
<p>内置函数 <code>make</code> 用于创建切片，如果省略容量参数，则容量默认和长度相等。内部实现上，<code>make</code> 会创建未命名的数组变量，然后返回该数组的一个切片，该数组只能通过切片访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>
<h4 id="The-append-Function">The append Function</h4>
<p>内置函数 <code>append</code> 将元素添加到切片。如果容量足够则扩展切片长度，这会返回一个更大的新切片，和原切片共享底层数组。如果容量不足，则需要创建新数组，将旧数组的元素复制到新数组，此时和原切片的底层数组不同。下面是一个简易实现示例，内置函数 <code>append</code> 可能更加复杂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="type">int</span>, y <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> z []<span class="type">int</span></span><br><span class="line">	zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">		<span class="comment">// There is room to grow.  Extend the slice.</span></span><br><span class="line">		z = x[:zlen]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// There is insufficient space.  Allocate a new array.</span></span><br><span class="line">		<span class="comment">// Grow by doubling, for amortized linear complexity.</span></span><br><span class="line">		zcap := zlen</span><br><span class="line">		<span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">			zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">		&#125;</span><br><span class="line">		z = <span class="built_in">make</span>([]<span class="type">int</span>, zlen, zcap)</span><br><span class="line">		<span class="built_in">copy</span>(z, x) <span class="comment">// a built-in function; see text</span></span><br><span class="line">	&#125;</span><br><span class="line">	z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749368591004.png" alt=""></p>
<p><img src="/img/Go.assets/1749368654320.png" alt=""></p>
<p>内置的 <code>append</code> 函数允许添加多个元素或切片，省略号 <code>...int</code> 表示函数具有可变参数，在切片之后添加省略号表示将其展开为参数列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="type">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x, x...) <span class="comment">// append the slice x</span></span><br><span class="line">fmt.Println(x)      <span class="comment">// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Maps">Maps</h3>
<p><code>map</code> 是对哈希表的引用，表示为 <code>map[K]V</code>，其中 <code>K</code> 和 <code>V</code> 分别是键值的类型。键类型必须能够使用 <code>==</code> 比较，不建议使用浮点数作为键，因为浮点数可以是 <code>NaN</code>。可以使用内置函数 <code>make</code> 或哈希表字面量（map literal）创建 <code>map</code>，使用内置函数 <code>delete</code> 删除键。如果键不在哈希表中，则会返回值类型对应的零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line">ages[<span class="string">&quot;alice&quot;</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">&quot;alice&quot;</span>]) <span class="comment">// &quot;32&quot;</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;alice&quot;</span>) <span class="comment">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>map</code> 元素不是变量，无法获取其地址，原因之一是扩容会导致地址失效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">&quot;bob&quot;</span>] <span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>
<p>可以使用基于范围的 <code>for</code> 循环遍历哈希表。<code>map</code> 的迭代顺序不是确定性的，实际实现为随机顺序，如果要按照顺序遍历，需要对键进行排序。由于已知 <code>names</code> 的最终大小，所以预分配指定容量的数组会更高效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">names := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ages))</span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code> 类型的零值是 <code>nil</code>，表示没有引用哈希表。对 <code>nil</code> 映射执行 <code>[]</code>、<code>delete</code>、<code>len</code> 和 <code>range</code> 都是安全的，其行为和空映射 <code>map[string]int&#123;&#125;</code> 类似。但是不允许向其中存储数据，会导致程序崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(ages == <span class="literal">nil</span>)    <span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ages) == <span class="number">0</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line">ages[<span class="string">&quot;carol&quot;</span>] = <span class="number">21</span> <span class="comment">// panic: assignment to entry in nil map</span></span><br></pre></td></tr></table></figure>
<p>可以使用以下形式判断 <code>map</code> 中是否存在指定的键，以和默认零值区分开来。和切片类似，<code>map</code> 之间不能相互比较，只允许其和 <code>nil</code> 进行比较。如果想要将切片作为键，由于切片是不可比较的，所以可以将切片转换为字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;bob&quot;</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Structs">Structs</h3>
<p>使用 <code>type xxx struct</code> 形式声明结构体，指向结构体的指针可以直接通过 <code>.</code> 访问其字段（不像 C++ 需要使用 <code>-&gt;</code>），该写法等价于显式解引用之后再使用 <code>.</code>。字段通常一行写一个，不过相同类型的连续字段可以合并书写。字段顺序对于类型标识至关重要，不同字段顺序定义得到的是不同的类型。如果字段名称以大写开头，则该字段会被导出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            <span class="type">int</span></span><br><span class="line">    Name, Address <span class="type">string</span></span><br><span class="line">    DoB           time.Time</span><br><span class="line">    Position      <span class="type">string</span></span><br><span class="line">    Salary        <span class="type">int</span></span><br><span class="line">    ManagerID     <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class="line">employeeOfTheMonth.Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br><span class="line">(*employeeOfTheMonth).Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br></pre></td></tr></table></figure>
<p>具有名称 <code>S</code> 的结构体不能声明类型为 <code>S</code> 的字段，即不能包含自身类型的字段，但是可以包含指向自身类型的指针。结构体的零值由其每个字段的零值组合而成。没有字段的结构体 <code>struct&#123;&#125;</code> 被称为空结构体，其大小为零，可以用作 <code>map[string]struct&#123;&#125;&#123;&#125;</code> 表示集合类型。</p>
<h4 id="Struct-Literals">Struct Literals</h4>
<p>可以使用结构体字面量（struct literal）初始化结构体，如果不指定类型，需要按照字段声明顺序，给所有字段指定初始值。如果指定类型，则可以随意指定某些字段的初始值，剩余字段默认初始化为零值。结构体作为参数传递使用的是值传递，可以仅传递指针来提高效率。两种形式不能在相同字面量中混合使用。</p>
<h4 id="Comparing-Structs">Comparing Structs</h4>
<p>如果结构体的所有字段都是可比较的，那么该结构体就是可比较的，因此可以使用 <code>==</code> 或 <code>!=</code> 进行比较。和其他可比较类型类似，可比较的结构体也可以作为 <code>map</code> 的键。</p>
<h4 id="Struct-Embedding-and-Anonymous-Fields">Struct Embedding and Anonymous Fields</h4>
<p>可以使用结构体嵌入（struct embedding）将一个结构体作为另一个结构体的匿名字段，从而允许将形如 <code>x.d.e.f</code> 的字段链简化为 <code>x.f</code>。Go 中使用组合而不是继承复用代码，结构体嵌入可以简化组合产生的过长字段链。由于匿名字段实际上有隐含的名称，所有不能有两个相同类型的匿名字段，因为它们会相互冲突。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>      <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span>      <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span> <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON">JSON</h3>
<p>将 Go 数据结构序列化为 JSON 字符串，可以使用 <code>json.Marshal</code> 函数。序列化会将 Go 结构体字段名称用作 JSON 对象的字段名称，只有导出的字段才会被序列化。通过定义适当的数据结构，在反序列化时可以获取指定的数据，其余数据将被忽略。可以使用字段标签（field tags）替换 JSON 中默认的字段名称，使用 <code>key:&quot;value&quot;</code> 形式声明字段标签。字段标签通常用于将 Go 字段的驼峰命名转换为 JSON 字段的下划线命名，可以使用 <code>omitempty</code> 表示字段为零值或者为空时不生成对应的 JSON 输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title  <span class="type">string</span></span><br><span class="line">	Year   <span class="type">int</span>  <span class="string">`json:&quot;released&quot;`</span></span><br><span class="line">	Color  <span class="type">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span></span><br><span class="line">	Actors []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">	&#123;Title: <span class="string">&quot;Casablanca&quot;</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">		Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Humphrey Bogart&quot;</span>, <span class="string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class="line">	&#123;Title: <span class="string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">		Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class="line">	&#123;Title: <span class="string">&quot;Bullitt&quot;</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">		Actors: []<span class="type">string</span>&#123;<span class="string">&quot;Steve McQueen&quot;</span>, <span class="string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//!+Marshal</span></span><br><span class="line">		data, err := json.Marshal(movies)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line">		<span class="comment">//!-Marshal</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//!+MarshalIndent</span></span><br><span class="line">		data, err := json.MarshalIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data)</span><br><span class="line">		<span class="comment">//!-MarshalIndent</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//!+Unmarshal</span></span><br><span class="line">		<span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="type">string</span> &#125;</span><br><span class="line">		<span class="keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(titles) <span class="comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br><span class="line">		<span class="comment">//!-Unmarshal</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions">Functions</h2>
<h3 id="Function-Declarations">Function Declarations</h3>
<p>函数声明包含名称、参数列表、返回值列表以及函数体。如果函数值返回单个未命名返回值或者没有返回值，则可以省略返回值列表的括号。可以给返回值命名，此时默认会为每个名称声明对应的局部变量，初始化为其类型的零值。有返回值列表的函数必须以 <code>return</code> 语句结束，除非程序不会到达函数末尾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span></span> (result-list) &#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同类型的参数可以分为一组，仅编写一次类型。空标识 <code>_</code> 表示参数未被使用。函数的类型有时被称为其签名（signature），如果两个函数具有相同的参数类型和返回值类型，那么它们就具有相同的签名。参数和返回值的名称不会影响签名，签名也不受分组形式声明的影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) &#123; z = x - y; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="type">int</span>, _ <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, sub) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, first) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, zero) <span class="comment">// &quot;func(int, int) int&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数总是值传递的，函数会接受参数的副本，对副本进行修改不会影响调用者。当参数是引用类型时，函数可以修改该参数间接引用的变量。如果发现某个函数没有函数体，则说明该函数是使用其他语言编写的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> <span class="comment">// implemented in assembly language</span></span><br></pre></td></tr></table></figure>
<h3 id="Recursion">Recursion</h3>
<p>许多编程语言使用固定大小的函数栈，通常为 64KB 到 2MB之间。固定大小的函数栈会限制递归调用的深度，需要小心避免栈溢出。Go 使用可变大小的栈，初始较小然后根据需要增大，直至达到大约 1GB 的上限。</p>
<h3 id="Multiple-Return-Values">Multiple Return Values</h3>
<p>Go 语言的垃圾回收机制会回收未使用的内存，但它不会自动释放未使用的操作系统资源，比如打开的文件和网络连接，这些资源应当显式的关闭。具有命名返回值的函数可以省略 <code>return</code> 语句的操作数，这被称为裸返回（bare return）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Size</span><span class="params">(rect image.Rectangle)</span></span> (width, height <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(path <span class="type">string</span>)</span></span> (dir, file <span class="type">string</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HourMinSec</span><span class="params">(t time.Time)</span></span> (hour, minute, second <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Errors">Errors</h3>
<p>对于失败（failure）是预期行为的函数，通常会有额外的返回值。如果失败的原因只有一个，那么额外返回布尔类型，否则应该返回 <code>error</code> 类型。内置类型 <code>error</code> 是接口类型，为 <code>nil</code> 时表示成功，反之则表示失败。和其他使用异常机制的语言不同，Go 语言使用 <code>panic</code> 表示非预期的错误，预期错误则使用 <code>if</code> 和 <code>return</code> 控制流机制实现错误处理。</p>
<h4 id="Error-Handling-Strategies">Error-Handling Strategies</h4>
<p>当函数调用出现错误时，调用方有责任检查并采取相应措施。最常见的处理方式是传播错误，也可以为错误添加额外信息。因为错误通常是链式的，所以消息字符串不应该大小，也不应该使用换行符。通常函数 <code>f(x)</code> 负责报告所执行的操作 <code>f</code> 以及与错误相关的参数 <code>x</code>，而调用者负责补充 <code>f(x)</code> 没有的其它信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种错误处理方式是重试，需要设置重试次数和重试前的等待时间。如果无法取得进展，调用者可以打印错误信息并终止程序，但这种处理方式仅用于程序的主要模块中。库函数通常应该将错误信息传递给调用者，除非该错误是 BUG。在某些情况下，可以仅记录错误信息并继续运行。极少数情况下，可以完全忽略某个错误。</p>
<h4 id="End-of-File-EOF">End of File (EOF)</h4>
<p>文件结束条件会产生 <code>io.EOF</code> 错误，需要特殊处理该错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;read failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...use r...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function-Values">Function Values</h3>
<p>在 Go 语言中，函数是一等公民（first-class values），像其他值一样，函数值也有类型，也可以作为参数传递给函数或从函数返回。函数类型的零值是 <code>nil</code>，调用 <code>nil</code> 函数会导致 <code>panic</code>，函数值之间是不可比较的，只能和 <code>nil</code> 比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span>     &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span>   &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> m * n &#125;</span><br><span class="line"></span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// &quot;9&quot;</span></span><br><span class="line"></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>))     <span class="comment">// &quot;-3&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(int) int&quot;</span></span><br><span class="line"></span><br><span class="line">f = product           <span class="comment">// compile error: can&#x27;t assign f(int, int) int to f(int) int</span></span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Functions">Anonymous Functions</h3>
<p>命名函数只能在包级进行声明，而匿名函数可以在任意表达式中使用。每次调用 <code>squares</code> 都会创建一个局部变量 <code>x</code>，并返回一个类型为 <code>func() int</code> 的匿名函数。此时，匿名函数可以访问和修改外层函数的局部变量 <code>x</code>。这些隐含的变量就是将函数视为引用类型，以及函数值之间无法比较的原因。这类函数值使用闭包（closures）技术实现。就像之前提到的返回局部变量的地址的例子，闭包示例也说明变量的生命周期不是由作用域决定，而是由可达性决定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// squares returns a function that returns</span></span><br><span class="line"><span class="comment">// the next square number each time it is called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		x++</span><br><span class="line">		<span class="keyword">return</span> x * x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := squares()</span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;4&quot;</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;9&quot;</span></span><br><span class="line">	fmt.Println(f()) <span class="comment">// &quot;16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当匿名函数需要递归时，必须先声明一个变量，然后将匿名函数赋值给该变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visitAll := <span class="function"><span class="keyword">func</span><span class="params">(items []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    visitAll(m[item]) <span class="comment">// compile error: undefined: visitAll</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Caveat-Capturing-Iteration-Variables">Caveat: Capturing Iteration Variables</h4>
<p>在迭代中使用匿名函数时，需要避免捕获迭代变量的陷阱，正确的做法是声明一个同名的局部变量覆盖迭代变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">dirs := tempDirs()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dirs); i++ &#123;</span><br><span class="line">    os.MkdirAll(dirs[i], <span class="number">0755</span>) <span class="comment">// OK</span></span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dirs[i]) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Variadic-Functions">Variadic Functions</h3>
<p>可变参函数的最后一个参数类型前面使用省略号 <code>...</code>，表示可以接收任意数量的该类型参数。实际上，调用者会创建一个数组，将参数赋值到其中，然后将数组的切片传递给函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">		total += val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>...int</code> 参数的行为类似切片，但是可变参函数的类型和带有切片参数函数的类型并不相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(...<span class="type">int</span>)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">([]<span class="type">int</span>)</span></span>  &#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f) <span class="comment">// &quot;func(...int)&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, g) <span class="comment">// &quot;func([]int)&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Deferred-Function-Calls">Deferred Function Calls</h3>
<p><code>defer</code> 关键字之后跟函数调用，表示延迟执行该调用。函数和参数表达式在执行该语句时就会被计算，而实际调用则会推迟到包含该 <code>defer</code> 语句的函数执行完毕时，无论函数是正常/异常结束。可以有任意数量的调用被延迟执行，它们会以执行 <code>defer</code> 语句相反的顺序依次执行（类似栈 LIFO）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在单个 <code>defer</code> 语句中，对函数的入口和出口进行检测。下面的 <code>trace</code> 函数会立即被调用，而其返回的函数在 <code>bigSlowOperation</code> 函数结束时被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bigSlowOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> trace(<span class="string">&quot;bigSlowOperation&quot;</span>)() <span class="comment">// don&#x27;t forget the extra parentheses</span></span><br><span class="line">	<span class="comment">// ...lots of work...</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second) <span class="comment">// simulate slow operation by sleeping</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	log.Printf(<span class="string">&quot;enter %s&quot;</span>, msg)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; log.Printf(<span class="string">&quot;exit %s (%s)&quot;</span>, msg, time.Since(start)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟执行的函数在 <code>return</code> 语句更新完返回值变量之后执行，可以在其中修改返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">	<span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// &quot;12&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Panic">Panic</h3>
<p>当 Go 运行时检测到严重的错误时，会产生 <code>panic</code>，正常执行会停止，从函数栈顶到 <code>main</code> 函数的所有延迟函数调用会依次执行，然后程序会崩溃并记录日志。可以显示调用内置的 <code>painc</code> 函数。对于函数的前置条件进行确认是良好的做法，但是除非能够提供更详细的错误信息或更早地检测到错误，否则没有必要去确认在运行时会自动检查的条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reset</span><span class="params">(x *Buffer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;x is nil&quot;</span>) <span class="comment">// unnecessary!</span></span><br><span class="line">	&#125;</span><br><span class="line">	x.elements = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Recover">Recover</h3>
<p>如果在延迟函数中调用内置的 <code>recover</code> 函数，且包含该 <code>defer</code> 语句的函数发生 <code>panic</code>，那么 <code>recover</code> 会终止当前的 <code>panic</code> 状态并返回 <code>panic</code> 的值。发生 <code>panic</code> 的函数不会继续执行，而是直接返回。在没有发生 <code>panic</code> 时调用 <code>recover</code> 函数不会有任何效果，仅仅返回 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="type">string</span>)</span></span> (s *Syntax, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;internal error: %v&quot;</span>, p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Methods">Methods</h2>
<h3 id="Method-Declarations">Method Declarations</h3>
<p>方法声明就是在函数名之前添加额外的参数，该参数将函数和该参数的类型绑定。额外的参数 <code>p</code> 被称作该方法的接收者（receiver），在 Go 语言中，没有使用 <code>this</code> 或 <code>self</code> 表示接收者，而是像对待普通参数一样选择接收者的名称，通常使用类型的首字母作为其名称。以下两个函数声明不会相互冲突，一个是包级函数，另一个是 <code>Point</code> 类型的方法。</p>
<p>在 Go 语言中，字段和方法不能同名（和 Java 不同）。和其他面向对象语言不同，Go 中可以为大多数类型定义方法，而不仅仅是结构体类型。例外情况是：① 不能直接为基本类型定义方法，而必须使用 <code>type</code> 创建命名类型；② 不能为指针和接口类型定义方法，但是接收者可以是指向非指针类型的指针。另外，类型和方法必须定义在相同的包中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Methods-with-a-Pointer-Receiver">Methods with a Pointer Receiver</h3>
<p>如果方法使用 <code>(p Point)</code> 声明，则和普通参数一样会复制该变量，如果想要在方法中修改相关变量，则应该使用 <code>(p *Point)</code> 指针类型接收变量的地址。在调用时也需要通过指针调用该方法，不过语法上允许直接通过 <code>Point</code> 变量而不是 <code>*Point</code> 调用 <code>ScaleBy</code> 方法，编译器会对其隐式地执行 <code>&amp;</code> 取址操作。对于临时值由于还没有为其分配地址，所以不能使用简写形式。同样可以通过 <code>*Point</code> 变量调用 <code>Distance</code> 方法，编译器会隐式地执行 <code>*</code> 解引用操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">	p.X *= factor</span><br><span class="line">	p.Y *= factor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>) <span class="comment">// compile error: can&#x27;t take address of Point literal</span></span><br></pre></td></tr></table></figure>
<h4 id="Nil-Is-a-Valid-Receiver-Value">Nil Is a Valid Receiver Value</h4>
<p>正如函数允许将 <code>nil</code> 指针作为参数，接收者也可以为 <code>nil</code>，当 <code>nil</code> 是该类型有意义的零值时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntList is a linked list of integers.</span></span><br><span class="line"><span class="comment">// A nil *IntList represents the empty list.</span></span><br><span class="line"><span class="keyword">type</span> IntList <span class="keyword">struct</span> &#123;</span><br><span class="line">	Value <span class="type">int</span></span><br><span class="line">	Tail  *IntList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum returns the sum of the list elements.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *IntList)</span></span> Sum() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list.Value + list.Tail.Sum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Composing-Types-by-Struct-Embedding">Composing Types by Struct Embedding</h3>
<p>结构体嵌入会将内部组合结构体的方法提升到外部结构体中。这种组合方式和继承不同，两种类型并不是父子关系，不具有多态性。实际上，编译器会生成包装方法，其内部会调用字段的对应方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point</span><br><span class="line">	Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>&#125;</span><br><span class="line">blue := color.RGBA&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, red&#125;</span><br><span class="line"><span class="keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="number">5</span>, <span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">q.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p.Distance(q.Point)) <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ColoredPoint)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.Point.Distance(q)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ColoredPoint)</span></span> ScaleBy(factor <span class="type">float64</span>) &#123;</span><br><span class="line">	p.Point.ScaleBy(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Method-Values-and-Expressions">Method Values and Expressions</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distanceFromP := p.Distance        <span class="comment">// method value</span></span><br><span class="line">fmt.Println(distanceFromP(q))      <span class="comment">// &quot;5&quot;</span></span><br><span class="line"><span class="keyword">var</span> origin Point                   <span class="comment">// &#123;0, 0&#125;</span></span><br><span class="line">fmt.Println(distanceFromP(origin)) <span class="comment">// &quot;2.23606797749979&quot;, ;5</span></span><br><span class="line"></span><br><span class="line">scaleP := p.ScaleBy                <span class="comment">// method value</span></span><br><span class="line">scaleP(<span class="number">2</span>)                          <span class="comment">// p becomes (2, 4)</span></span><br><span class="line">scaleP(<span class="number">3</span>)                          <span class="comment">// then (6, 12)</span></span><br><span class="line">scaleP(<span class="number">10</span>)                         <span class="comment">// then (60, 120)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// method expression</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// &quot;5&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance) <span class="comment">// &quot;func(Point, Point) float64&quot;</span></span><br><span class="line"></span><br><span class="line">scale := (*Point).ScaleBy</span><br><span class="line">scale(&amp;p, <span class="number">2</span>)</span><br><span class="line">fmt.Println(p)            <span class="comment">// &quot;&#123;2 4&#125;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, scale) <span class="comment">// &quot;func(*Point, float64)&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Interfaces">Interfaces</h2>
<h3 id="Interface-Satisfaction">Interface Satisfaction</h3>
<p>接口类型是抽象类型，其定义一组方法，只要具体类型有这些方法，就可以被视为该接口的实例（隐式实现接口）。接口类型之间也可以嵌入，使得当前接口具有另一个接口的方法，而不需要显示的全部定义出来。只要具体类型或接口类型有某个接口类型的所有方法，就可以将其赋值给该接口类型。可以将任何值赋值给空接口类型 <code>interface&#123;&#125;</code>。可以使用以下方式，在编译时断言 <code>bytes.Buffer</code> 类型满足 <code>io.Writer</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">&quot;hello&quot;</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer must satisfy io.Writer</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Interface-Values">Interface Values</h3>
<p>接口类型的值（interface value）包含两个组成部分，即具体类型以及该类型的值，它们被称为动态类型（dynamic type）和动态值（dynamic value）。动态类型由类型描述符（type descriptor）表示，其提供类型的字段和方法信息。接口的零值，其类型和值的组成部分都被设置为 <code>nil</code>。如果接口的类型部分是 <code>nil</code>，则该接口值就是 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;&lt;nil&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">w = os.Stdout</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*os.File&quot;</span></span><br><span class="line"></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, w) <span class="comment">// &quot;*bytes.Buffer&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749473744332.png" alt=""></p>
<p><img src="/img/Go.assets/1749474247823.png" alt=""></p>
<p><img src="/img/Go.assets/1749474389546.png" alt=""></p>
<p>可以使用 <code>==</code> 和 <code>!=</code> 比较接口值，如果两个接口值均为 <code>nil</code>，或者它们的动态类型和动态值都相同，则这两个接口值相同。如果两个接口值的动态类型相同，但是它们的动态类型不支持比较操作，则会引发 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(x == x) <span class="comment">// panic: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure>
<h4 id="Caveat-An-Interface-Containing-a-Nil-Pointer-Is-Non-Nil">Caveat: An Interface Containing a Nil Pointer Is Non-Nil</h4>
<p>当 <code>debug = false</code> 时，下面的代码会引发 <code>panic</code>，因为接口值的动态类型不是 <code>nil</code>，而动态值是 <code>nil</code>，在调用 <code>(*bytes.Buffer).Write</code> 方法时会出问题。解决方案是，将 <code>buf</code> 声明为 <code>var buf io.Writer</code>，避免将无效值（<code>bytes.Buffer</code> 类型的 <code>nil</code> 指针）赋值给接口类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">	&#125;</span><br><span class="line">	f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		<span class="comment">// ...use buf...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...do something...</span></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">		out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>)) <span class="comment">// panic: nil pointer dereference</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/Go.assets/1749475099821.png" alt=""></p>
<h3 id="Type-Assertions">Type Assertions</h3>
<p>类型断言（type assertion）是对接口值执行的操作，形如 <code>x.(T)</code>，其中 <code>x</code> 是接口类型的表达式，<code>T</code> 是断言类型。如果 <code>T</code> 是具体类型，那么类型断言会检查 <code>x</code> 的动态类型是否和 <code>T</code> 相同，如果相同则返回 <code>x</code> 的动态值，否则引发 <code>panic</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)      <span class="comment">// success: f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic: interface holds *os.File, not *bytes.Buffer</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>T</code> 是接口类型，那么类型断言会检查 <code>x</code> 的动态类型是否满足 <code>T</code>，如果满足则返回类型为 <code>T</code> 的接口值，该接口值和 <code>x</code> 具有相同的动态类型和动态值。不论 <code>T</code> 是什么类型，如果 <code>x</code> 是 <code>nil</code>，则断言会失败。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// success: *os.File has both Read and Write</span></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) <span class="comment">// panic: *ByteCounter has no Read method</span></span><br></pre></td></tr></table></figure>
<p>如果使用以下类型断言方式，则断言失败不会引发 <code>panic</code>，而是额外返回 <code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File) <span class="comment">// success: ok, f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer) <span class="comment">// failure: !ok, b == nil</span></span><br></pre></td></tr></table></figure>
<h3 id="Type-Switches">Type Switches</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> x := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>:</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x) <span class="comment">// x has type interface&#123;&#125; here.</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">		<span class="keyword">if</span> x &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;TRUE&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;FALSE&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		<span class="keyword">return</span> sqlQuoteString(x) <span class="comment">// (not shown)</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unexpected type %T: %v&quot;</span>, x, x))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-31T16:00:00.000Z" title="2024/1/1 00:00:00">2024-01-01</time>发表</span><span class="level-item"><time dateTime="2025-06-12T02:31:54.595Z" title="2025/6/12 10:31:54">2025-06-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Rust/">Rust</a></span><span class="level-item">40 分钟读完 (大约5935个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/01/Rust%20%E5%9F%BA%E7%A1%80/">Rust 基础</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/">Rust Documentation</a>，<a target="_blank" rel="noopener" href="https://tourofrust.com/">Tour of Rust</a>，<a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a>。</p>
<h2 id="Getting-Started">Getting Started</h2>
<h3 id="Hello-World">Hello, World!</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<h2 id="Common-Programming-Concepts">Common Programming Concepts</h2>
<h3 id="Variables-and-Mutability">Variables and Mutability</h3>
<p>使用 <code>let</code> 声明变量，变量默认是不可变的，使用 <code>mut</code> 关键字使其可变。使用 <code>const</code> 声明常量，不允许对常量使用 <code>mut</code>，并且必须显示指定其类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>和其他语言不同，Rust 允许在相同作用域中遮蔽（shadowing）变量，而且允许使用不同的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Data-Types">Data Types</h3>
<p>Rust 数据类型分为两种：标量类型（scalar）和复合类型（compound）。有四种基本的标量类型：整型、浮点类型、布尔类型和字符类型。编译器通常可以推断出类型，如果不能则需要显式写出类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Scalar-Types">Scalar Types</h4>
<p>有符号整型有 <code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>isize</code>，其中 <code>isize</code> 类型和机器相关。无符号整型类似，只是将 <code>i</code> 开头替换为 <code>u</code> 开头。整型字面量：十进制 <code>98_222</code>、十六进制 <code>0xff</code>、八进制 <code>0o77</code>、二进制 <code>0b1111_0000</code> 和单字节字符 <code>b'A'</code>（仅限 <code>u8</code> 类型）。可以使用标准库函数显示处理整型溢出：<code>wrapping_*</code>、<code>checked_*</code>、<code>overflowing_*</code> 和 <code>saturating_*</code>。</p>
<p>浮点类型有 <code>f32</code> 和 <code>f64</code>，默认使用 <code>f64</code>。布尔类型 <code>bool</code> 的值有 <code>true</code> 和 <code>false</code> 两种。字符类型 <code>char</code> 大小为 4 字节，使用 UTF-32 编码方式。</p>
<h4 id="Compound-Types">Compound Types</h4>
<p>Rust 有两个原生的复合类型，元组（tuple）和数组（array）。元组可以将一个或多个不同类型的值组合起来，声明之后长度固定不变。可以使用 <code>.index</code>、模式匹配（pattern matching）和解构（destructure）获取元组元素，其中 <code>index</code> 是元素的索引。不包含任何值的元组 <code>()</code> 被称为单元（unit），表示空值或空返回类型，如果表达式不返回其他值，则会隐式地返回单元值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>数组中每个元素的类型都必须相同，数组长度也是固定的，在栈上分配空间。在声明类型时，需要在方括号中包含元素类型和数量。在初始化时，可以使用方括号包含初始值和元素数量，创建每个元素都相同的数组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Functions-Control-Flow">Functions &amp; Control Flow</h3>
<p>Rust 代码中的变量和函数名使用 snake case 风格，使用下划线分隔单词。Rust 是基于表达式的语言（expression-based），函数体由一系列语句（statement）和可选地结尾表达式（expression）组成，语句不会返回值而表达式会。表达式结尾没有分号，如果加上分号它就变为语句。如果函数没有返回值，则可以省略返回类型，会隐式地返回空元组，否则需要使用 <code>-&gt;</code> 显式声明。代码块 <code>&#123;&#125;</code>和 <code>if</code> 都是表达式，可以在 <code>let</code> 语句右侧使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Rust 有三种循环 <code>loop</code>、<code>while</code> 和 <code>for</code>。<code>loop</code> 表示无限循环，可以使用 <code>break</code> 终止并指定返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..n &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> (<span class="number">0</span>..n).<span class="title function_ invoke__">rev</span>() &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;arr &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> arr &#123; ... &#125;</span><br><span class="line"><span class="title function_ invoke__">for</span> (i, item) <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Understanding-Ownership">Understanding Ownership</h2>
<h3 id="What-Is-Ownership">What Is Ownership?</h3>
<p>所有权（ownership）是 Rust 用于管理内存的一组规则。栈中的所有数据都必须占用已知且固定的大小，在编译时大小未知或大小可能变化的数据，需要存储在堆上，所有权主要目的就是管理堆数据。所有权规则：① Rust 中的每个值都有所有者（owner）；② 每个值在任意时刻有且仅有一个所有者；③ 当所有者离开作用域之后，该值将被丢弃。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is valid from this point forward</span></span><br><span class="line">    <span class="comment">// do stuff with s</span></span><br><span class="line">&#125; <span class="comment">// this scope is now over, and s is no longer valid</span></span><br></pre></td></tr></table></figure>
<p>所有权（Ownership）机制让 Rust 无需 GC 就能保证内存安全。GC 是运行时根据可达性分析回收内存，而所有权是在编译时确定变量的作用域，当内存的所有者变量离开作用域之后，相应内存就可以被释放。当变量离开作用域时，Rust 会自动调用 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a> 函数来释放内存，类似 C++ 的 RAII 机制。</p>
<p>字符串 <code>String</code> 的数据存储在堆上，字符串变量包含指向堆中数据的指针、数据的长度和容量，其存储在栈上。使用 <code>let s2 = s1;</code> 只会复制引用（浅拷贝），为避免 <code>s1</code> 和 <code>s2</code> 离开作用域之后，释放相同内存两次（调用 <code>drop</code> 函数），该语句执行之后 Rust 会使 <code>s1</code> 无效，不需要在其离开作用域之后回收内存，该操作被称为移动（move）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, world!&quot;</span>); <span class="comment">// error[E0382]: borrow of moved value: `s1`</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/Rust.assets/1749562966879.png" alt=""></p>
<p>当给已有值的变量赋新值时，Rust 会立即调用 <code>drop</code> 释放原始值的内存。如果想要执行深拷贝，可以使用 <code>clone</code> 函数。如果类型实现 <code>Copy</code> 特征，则旧变量在被赋值给其他变量之后仍然有效。不能为实现 <code>Drop</code> 特征的类型实现 <code>Copy</code> 特征。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ahoy&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;, world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="References-and-Borrowing">References and Borrowing</h3>
<p>引用（reference）类似指针，它是一个地址，但是和指针不同，Rust 保证引用指向某个特定类型的有效值。传递引用值不会转移所有权，所以可以在 <code>main</code> 中继续使用 <code>s1</code>。函数 <code>calculate_length</code> 中的局部变量 <code>s</code> 是引用类型，其不拥有值的所有权，所以离开作用域之后，其指向的值也不会被回收，所以创建引用的行为被称为借用（borrowing）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认不能通过引用 <code>&amp;</code> 修改指向的值，除非声明的是可变引用 <code>&amp;mut</code>，只能对可变变量（使用 <code>let mut</code> 声明）创建可变引用。如果变量有不可变引用，则原变量可读但不可写。如果变量有可变引用，则原变量不可读写。如果变量有一个可变引用，则该变量不能有其他引用，不论是否可变。以上机制可以保证在编译时就避免数据竞争（data race），因为最多有一个线程可以修改变量，而且此时其他线程都无法读取该变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用的作用域从声明的地方开始直到最后一次使用为止，下面的不可变引用 <code>r1</code> 和 <code>r2</code> 的最后一次使用，发生在 <code>r3</code> 的声明之前，所以不会发生编译错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125; and &#123;r2&#125;&quot;</span>);</span><br><span class="line"><span class="comment">// Variables r1 and r2 will not be used after this point.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// no problem</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;r3&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Rust 编译器保证数据不会在其引用之前离开作用域，即不允许悬垂引用，否则会发生编译错误。在其他语言中，C++ 存在悬垂引用，Java 中没有原始指针类型不存在这个问题，Go 中的变量生命周期由可达性决定而不是作用域，通过逃逸分析局部变量会在堆上分配，所以也可以避免悬垂引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// error[E0106]: missing lifetime specifier</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// error[E0515]: cannot return reference to local variable `s`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Slice-Type">The Slice Type</h3>
<p>切片（slice）是引用类型，不拥有值的所有权。切片仅由指向数据的指针和长度组成，不像 Go 中还包含容量字段。字符串切片的索引必须位于有效的 UTF-8 字符边界上，如果从多字节字符的中间位置创建切片，则会产生运行时错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>
<p>字符串切片的类型有 <code>&amp;str</code> 和 <code>&amp;mut str</code>，区别在于指向的数据是否可变。使用 <code>let mut</code> 声明变量，只是表示可以修改变量绑定的切片，和切片数据是否可变无关。字符串字面量的类型是 <code>&amp;str</code>，所以是不可变的，如果想要获取可变字符串切片，需要使用 <code>String</code> 结合 <code>mut</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;<span class="keyword">mut</span> s[..];</span><br></pre></td></tr></table></figure>
<h2 id="Using-Structs-to-Structure-Related-Data">Using Structs to Structure Related Data</h2>
<h3 id="Defining-and-Instantiating-Structs">Defining and Instantiating Structs</h3>
<p>在初始化结构体时，如果字段名称和初始化参数相同，则可以省略。如果要使用旧实例的大部分值创建新实例，可以使用结构体更新语法（struct update syntax），<code>..</code> 表示剩余未显式设置的字段和给定旧实例具有相同的值。该语法类似使用 <code>=</code> 进行赋值，所以未实现 <code>Copy</code> 特征的类型会被转移所有权，旧实例的相应字段会失效。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以定义元组结构体（tuple struct），元组结构体的字段没有名称只有类型。即使两个元组结构体有相同类型的字段，它们也是不同的类型。可以解构元组结构体，但是需要指定结构体的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span>(x, y, z) = origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有任何字段的结构体被称为类单元结构体（unit-like struct）。如果在结构体中存储引用类型 <code>&amp;str</code>，而不是自身拥有所有权的 <code>String</code> 类型，就需要使用生命周期，否则会发生编译错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>, <span class="comment">// error[E0106]: missing lifetime specifier</span></span><br><span class="line">    email: &amp;<span class="type">str</span>, <span class="comment">// error[E0106]: missing lifetime specifier</span></span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Method-Syntax">Method Syntax</h3>
<p>方法的第一个参数必须是 <code>self</code>，表示调用该方法的结构体实例，<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写。在 <code>impl</code> 块中，<code>Self</code> 类型是 <code>impl</code> 块类型的别名，在下面就是 <code>Rectangle</code>。方法可以选择不可变借用 <code>&amp;self</code>、可变借用 <code>&amp;mut self</code> 或获取所有权 <code>self</code>。方法的名称可以和结构体的字段相同（Java 中也可以，Go 中不行）。当调用方法时，Rust 会自动根据方法签名添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code>，所以不需要显式转换。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>impl</code> 中定义的函数被称为关联函数（associated function），其第一个参数不是 <code>self</code>（类似 Java 中的静态方法）。调用关联函数需要使用 <code>Rectangle::square(x)</code> 形式，表示函数 <code>square</code> 位于结构体 <code>Rectangle</code> 的命名空间中。每个结构体可以有多个 <code>impl</code> 块，不过必须和结构体在相同的 crate 中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enums-and-Pattern-Matching">Enums and Pattern Matching</h2>
<h3 id="Defining-an-Enum">Defining an Enum</h3>
<p>枚举类型的字段被称为变体（variant），可以将数据附加到变体上。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>每个变体附加数据的类型和数量可以不同，可以使用 <code>impl</code> 为枚举类型定义方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// method body would be defined here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>
<h3 id="The-match-Control-Flow-Construct">The match Control Flow Construct</h3>
<p>可以使用变量名称之后跟 <code>=&gt;</code> 表示通配模式，放在最后以匹配其他情况，如果不使用变量则可以使用 <code>_ =&gt;</code> 形式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Concise-Control-Flow-with-if-let-and-let-else">Concise Control Flow with if let and let else</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;max&#125;&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;max&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is pretty old, for America!&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;state:?&#125; is relatively new.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Common-Collections">Common Collections</h2>
<h3 id="Storing-Lists-of-Values-with-Vectors">Storing Lists of Values with Vectors</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">match</span> third &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;third&#125;&quot;</span>),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Storing-UTF-8-Encoded-Text-with-Strings">Storing UTF-8 Encoded Text with Strings</h3>
<p>Rust 中有两种字符串，字符串切片 <code>str</code> 和字符串 <code>String</code>，它们使用的都是 UTF-8 编码，<code>String</code> 是对 <code>Vec&lt;u8&gt;</code> 的封装。使用 <code>+</code> 运算符拼接 <code>String</code> 字符串，会获取第一个参数的所有权，以及第二个参数的引用，类似下面的 <code>add</code> 函数。</p>
<p>实际上，<code>&amp;s2</code> 会被转换为 <code>&amp;s2[..]</code>，从而满足 <code>add</code> 函数的 <code>&amp;str</code> 参数类型，该技术被称为 dref coercion。<code>s3</code> 会获取 <code>s1</code> 的所有权，然后将 <code>s2</code> 复制到其末尾。也可以使用 <code>format!</code> 宏执行字符串拼接，该宏不会获取任何参数的所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// note s1 has been moved here and can no longer be used</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s1&#125;-&#123;s2&#125;-&#123;s3&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>由于字符串使用 UTF-8 编码，所以不支持使用索引访问，字符串的长度是其包含的字节数而不是字符数。在 Go 语言中，可以直接使用索引，访问的就是对应的字节。在 Rust 中，虽然不能使用索引访问字符串，但是可以使用范围获取字符串切片，前提是范围位于有效的 UTF-8 字符边界上。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>]; <span class="comment">// error[E0277]: the type `str` cannot be indexed by `&#123;integer&#125;`</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>使用 <code>chars()</code> 方法遍历字符，<code>bytes</code> 方法遍历字节。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;Зд&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;c&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;Зд&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;b&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Storing-Keys-with-Associated-Values-in-Hash-Maps">Storing Keys with Associated Values in Hash Maps</h3>
<p>在使用 <code>insert</code> 时，对于实现 <code>Copy</code> 特征的类型，其值会复制到哈希表中，而拥有所有权的类型，其值会被移动到哈希表中。如果将引用插入哈希表，则引用指向的值，必须至少和哈希表的生命周期一样长（避免悬垂引用）。哈希表使用 SipHash 哈希函数，可以抵御涉及哈希表的拒绝服务攻击，允许用户指定其他哈希函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name).<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">unwrap_or</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;key&#125;: &#123;value&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Error-Handling">Error Handling</h2>
<h3 id="Unrecoverable-Errors-with-panic">Unrecoverable Errors with panic!</h3>
<p>panic 表示不可恢复的错误，在遇到 BUG 或显示调用 <code>panic!</code> 宏时产生。当出现 panic 时，程序默认会执行展开（unwinding），这意味着 Rust 会回溯函数栈并清理函数的数据。另一种选择是直接终止（abort），不清理数据就退出程序，此时程序所使用的内存由操作系统清理。</p>
<h3 id="Recoverable-Errors-with-Result">Recoverable Errors with Result</h3>
<p>可以使用闭包和 <code>unwrap_or_else</code> 方法替代 <code>match</code> 来简化代码。使用 <code>unwrap</code> 方法，如果 <code>Result</code> 值是 <code>Ok</code>，则返回其中的值，否则会调用 <code>panic!</code>。<code>expect</code> 方法类似，只是可以自定义 <code>panic!</code> 的错误信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;error:?&#125;&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Generic-Types-Traits-and-Lifetimes">Generic Types, Traits, and Lifetimes</h2>
<p>Rust 在编译时对泛型代码单态化（monomorphization）来保证效率，即为使用的具体类型生成对应类型的代码。在其他语言中，C++ 的做法类似，而 Java 执行类型擦除。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; &#123;</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Traits-Defining-Shared-Behavior">Traits: Defining Shared Behavior</h3>
<p>孤儿规则（orphan rule）：只有在特征或类型至少有一个属于当前 crate 时，才能对类型实现特征。也就是说，可以为内部类型实现外部特征、为外部类型实现内部特征，但是不能为外部类型实现外部特征。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SocialPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> repost: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">SocialPost</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<h3 id="Validating-References-with-Lifetimes">Validating References with Lifetimes</h3>
<p>Rust 中每个引用都有生命周期（lifetime），通常生命周期可以被隐式地推断出来，否则需要显式写出。生命周期的主要目标是避免悬垂引用，Rust 编译器使用借用检查器（borrow checker）比较作用域，确保所有的借用都是有效的。<code>r</code> 和 <code>x</code> 的生命周期分别被标记为 <code>'a</code> 和 <code>'b</code>，编译器会发现 <code>r</code> 引用的变量 <code>x</code> 的生命周期比自身更小，这会导致悬垂引用，所以编译器会报错。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; <span class="comment">// error[E0597]: `x` does not live long enough</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;r&#125;&quot;</span>);   <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// a reference</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// a reference with an explicit lifetime</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// a mutable reference with an explicit lifetime</span></span><br></pre></td></tr></table></figure>
<p>生命周期注解语法用于将函数参数和返回值的生命周期相关联，生命周期也是泛型。以下函数签名表示，泛型生命周期参数 <code>'a</code> 的具体生命周期是 <code>x</code> 和 <code>y</code> 中生命周期的较小者，返回值不能在生命周期 <code>'a</code> 结束之后使用。由于下面的 <code>result</code> 在 <code>y</code> 生命周期结束之后访问，所以会引发编译错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>()); <span class="comment">// error[E0597]: `string2` does not live long enough</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体可以存储引用类型，不过此时需要使用生命周期注解。下面注解意味着，<code>ImportantExcerpt</code> 实例不能在其字段 <code>part</code> 的生命周期结束之后使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生命周期省略规则（lifetime elision rules）：① 为每个引用参数分配不同的生命周期；② 如果只有一个输入生命周期参数，则将其生命周期赋给所有输出生命周期参数；③ 如果输入生命周期参数有 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则将 <code>self</code> 的生命周期赋给所有输出生命周期参数。如果应用规则之后，仍没有计算出引用的生命周期，则会引发编译错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;announcement&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态生命周期 <code>'static</code> 表示能够在程序运行期间存活，所有字符串字面量都具有静态生命周期。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;ann&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functional-Language-Features-Iterators-and-Closures">Functional Language Features: Iterators and Closures</h2>
<h3 id="Closures-Anonymous-Functions-That-Capture-Their-Environment">Closures: Anonymous Functions That Capture Their Environment</h3>
<p>闭包（closures）是可以保存在变量中或作为参数传递给其他函数的匿名函数，和函数不同，它允许捕获其被定义时所在作用域中的值。通常不需要为闭包的参数和返回值声明类型注解，编译器可以推断出类型。必须调用 <code>add_one_v3</code> 和 <code>add_one_v4</code> 闭包才能通过编译，编译器会根据调用上下文推断类型，对相同闭包使用不同的类型会引发编译错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>
<p>闭包有三种捕获变量的方式：不可变借用、可变借用和获取所有权。前两种方式是隐式推断的，获取所有权使用 <code>move</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Before defining closure: &#123;list:?&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;From thread: &#123;list:?&#125;&quot;</span>))</span><br><span class="line">        .<span class="title function_ invoke__">join</span>()</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包可以执行：将捕获的值移出闭包、既不移动也不修改值、</p>
<p>闭包捕获和处理值的方式会影响闭包实现哪些特征：<code>FnOnce</code>、<code>FnMut</code> 和 <code>Fn</code> 特征分别在获取所有权、可变借用和不可变借用时实现。它们之间是父子关系（和继承无关，只是指定依赖关系），<code>FnOnce &lt;- FnMut &lt;- Fn</code>。如果闭包不需要从环境中捕获值，可以直接使用函数而不是闭包，例如在 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 值上调用 <code>unwrap_or_else(Vec::new)</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap_or_else</span>&lt;F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> T</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> T</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(x) =&gt; x,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="title function_ invoke__">f</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; [T] &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sort_by_key</span>&lt;K, F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> K,</span><br><span class="line">        K: <span class="built_in">Ord</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">stable_sort</span>(<span class="keyword">self</span>, |a, b| <span class="title function_ invoke__">f</span>(a).<span class="title function_ invoke__">lt</span>(&amp;<span class="title function_ invoke__">f</span>(b)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Processing-a-Series-of-Items-with-Iterators">Processing a Series of Items with Iterators</h3>
<p><code>iter</code> 方法生成不可变引用的迭代器，<code>iter_mut</code> 生成可变引用的迭代器，<code>into_iter</code> 生成获取所有权的迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods with default implementations elided</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-31T16:00:00.000Z" title="2024/1/1 00:00:00">2024-01-01</time>发表</span><span class="level-item"><time dateTime="2025-06-13T02:05:45.865Z" title="2025/6/13 10:05:45">2025-06-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Python/">Python</a></span><span class="level-item">20 分钟读完 (大约3008个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/01/Python%20%E5%9F%BA%E7%A1%80/">Python 基础</a></p><div class="content"><p>参考<a target="_blank" rel="noopener" href="https://www.python.org/">官方文档</a>，<a target="_blank" rel="noopener" href="https://docs.python.org/3/tutorial/index.html">The Python Tutorial</a>。</p>
<h2 id="An-Informal-Introduction-to-Python">An Informal Introduction to Python</h2>
<p>除法运算 <code>/</code> 总是返回浮点数，使用 <code>//</code> 向下取整，Java 中的整数除法是向零取整。使用 <code>**</code> 计算幂，<code>**</code> 的优先级比 <code>-</code> 更高。交互模式下，上次输出的表达式值被赋给变量 <code>_</code>，最好将其视为只读类型，显式为其赋值会创建同名的局部变量，屏蔽内置变量的行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> / <span class="number">3</span>, <span class="number">11</span> / <span class="number">4</span>, <span class="number">11</span> // <span class="number">4</span>, -(<span class="number">3</span>**<span class="number">2</span>), (-<span class="number">3</span>) ** <span class="number">2</span></span><br><span class="line">(<span class="number">5.0</span>, <span class="number">2.75</span>, <span class="number">2</span>, -<span class="number">9</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>字符串使用单引号 <code>'...'</code> 或双引号 <code>&quot;...&quot;</code> 表示，两者没有区别。可以使用三重引号跨行编写字符串，换行符会被包含在字符串中，可以在行尾添加 <code>\</code> 避免该行为。字符串可以使用 <code>+</code> 合并，也可以使用 <code>*</code> 重复，相邻字符串字面量会自动合并。字符串可以使用索引访问，索引越界会报错，但是切片会自动处理索引越界。字符串是不可变的，要生成不同的字符串应该创建字符串。使用内置函数 <code>len()</code> 获取字符串的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times &#x27;un&#x27;, followed by &#x27;ium&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">&#x27;un&#x27;</span> + <span class="string">&#x27;ium&#x27;</span></span><br><span class="line"><span class="string">&#x27;unununium&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Py&#x27;</span> <span class="string">&#x27;thon&#x27;</span></span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">&#x27;Put several strings within parentheses &#x27;</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;to have them joined together.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;Put several strings within parentheses to have them joined together.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:<span class="number">42</span>]</span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;J&#x27;</span> + word[<span class="number">1</span>:]</span><br><span class="line"><span class="string">&#x27;Jython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(word)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>列表可以使用 <code>+</code> 合并，列表是可变的可以使用 <code>list.append()</code> 方法添加元素。使用 <code>=</code> 将列表赋值给变量是浅拷贝，该变量引用该列表。列表允许包含不同类型的元素，且可以相互嵌套。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares + [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rgb = [<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rgba = rgb</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(rgb) == <span class="built_in">id</span>(rgba)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [a, n]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
<p>Python 使用缩进组织语句，同一块语句要使用相同大小的缩进，可以使用空格或制表符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> a &lt; <span class="number">1000</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a, end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    a, b = b, a+b</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,<span class="number">987</span>,</span><br></pre></td></tr></table></figure>
<h2 id="More-Control-Flow-Tools">More Control Flow Tools</h2>
<p><code>if</code> 语句由 <code>if</code>、<code>elif</code> 和 <code>else</code> 组成。<code>for</code> 语句由 <code>for</code> 和 <code>in</code> 组成，使用 <code>range()</code> 函数生成等差数列。组合使用 <code>range()</code> 和 <code>len()</code> 实现按索引迭代序列，或者使用 <code>enumerate()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a sample collection</span></span><br><span class="line">users = &#123;<span class="string">&#x27;Hans&#x27;</span>: <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;Éléonore&#x27;</span>: <span class="string">&#x27;inactive&#x27;</span>, <span class="string">&#x27;景太郎&#x27;</span>: <span class="string">&#x27;active&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Iterate over a copy</span></span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;inactive&#x27;</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Create a new collection</span></span><br><span class="line">active_users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;active&#x27;</span>:</span><br><span class="line">        active_users[user] = status</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(-<span class="number">10</span>, -<span class="number">100</span>, -<span class="number">30</span>))</span><br><span class="line">[-<span class="number">10</span>, -<span class="number">40</span>, -<span class="number">70</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;had&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;little&#x27;</span>, <span class="string">&#x27;lamb&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, a[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure>
<p><code>for</code> 和 <code>while</code> 循环可以有对应的 <code>else</code> 子句，如果循环在未执行 <code>break</code> 的情况下结束，则会执行该 <code>else</code> 子句。<code>pass</code> 语句不执行任何操作，当语法上需要一个语句，而程序不需要执行任何操作时，可以使用该语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(n, <span class="string">&#x27;equals&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(n, <span class="string">&#x27;is a prime number&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>match</code> 语句用于模式匹配，使用 <code>_</code> 通配符匹配剩余情况，使用 <code>|</code> 将多个字面值组合到一个模式中。模式之后可以使用 <code>if</code> 子句，如果判断结果为假，则 <code>match</code> 会继续尝试匹配下一个 <code>case</code> 块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    __match_args__ = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> points:</span><br><span class="line">    <span class="keyword">case</span> []:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No points&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(<span class="number">0</span>, <span class="number">0</span>)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The origin&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(x, y)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Single point <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(<span class="number">0</span>, y1), Point(<span class="number">0</span>, y2)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Two on the Y axis at <span class="subst">&#123;y1&#125;</span>, <span class="subst">&#123;y2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something else&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> point:</span><br><span class="line">    <span class="keyword">case</span> Point(x, y) <span class="keyword">if</span> x == y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Y=X at <span class="subst">&#123;x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> Point(x, y):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Not on the diagonal&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>def</code> 定义函数，如果函数内第一个语句是字符串，则该字符串是文档字符串。函数中的所有变量赋值，都会将值存储在局部符号表中。函数中查找变量引用的顺序依次是，当前函数的局部符号表，外层函数的局部符号表，全局符号表，内置名称表。所以尽管可以引用全局变量和外层函数变量，但是赋值会创建本地变量，除非使用 <code>global</code>/<code>nonlocal</code> 语句定义该变量。函数参数是值传递的，值是对象的引用（地址）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># write Fibonacci series less than n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Print a Fibonacci series less than n.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>()</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span><span class="comment"># Now call the function we just defined:</span></span><br><span class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure>
<p>函数定义将函数名和函数对象关联，存储在当前符号表中。可以使用其他名称指向相同函数对象。没有 <code>return</code> 语句的函数返回 <code>None</code>，通常解释器会隐藏单个 <code>None</code> 值，可以使用 <code>print()</code> 函数打印。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib</span><br><span class="line">&lt;function fib at <span class="number">0x000001B7F0AA1120</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">100</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(fib(<span class="number">0</span>))</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>可以为函数参数指定默认值，默认值在函数定义时求值。默认值只计算一次，当默认值是对象时，多次调用之间会共享该对象。如果是可变对象，则之后的调用会被之前的影响，如果不想共享默认值则需要显式处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg=i</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>i = <span class="number">6</span></span><br><span class="line"><span class="meta">... </span>f()</span><br><span class="line">...</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=[]</span>):</span><br><span class="line"><span class="meta">... </span>    L.append(a)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> L</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br><span class="line">...</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=<span class="literal">None</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        L = []</span><br><span class="line"><span class="meta">... </span>    L.append(a)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> L</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br><span class="line">...</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>*args</code> 表示可变参数，该参数是元组类型。可以使用 <code>*</code> 和 <code>**</code> 执行解包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>, <span class="number">6</span>))            <span class="comment"># normal call with separate arguments</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(*args))            <span class="comment"># call with arguments unpacked from a list</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">parrot</span>(<span class="params">voltage, state=<span class="string">&#x27;a stiff&#x27;</span>, action=<span class="string">&#x27;voom&#x27;</span></span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;-- This parrot wouldn&#x27;t&quot;</span>, action, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;if you put&quot;</span>, voltage, <span class="string">&quot;volts through it.&quot;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;E&#x27;s&quot;</span>, state, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>d = &#123;<span class="string">&quot;voltage&quot;</span>: <span class="string">&quot;four million&quot;</span>, <span class="string">&quot;state&quot;</span>: <span class="string">&quot;bleedin&#x27; demised&quot;</span>, <span class="string">&quot;action&quot;</span>: <span class="string">&quot;VOOM&quot;</span>&#125;</span><br><span class="line"><span class="meta">... </span>parrot(**d)</span><br><span class="line">...</span><br><span class="line">-- This parrot wouldn<span class="string">&#x27;t VOOM if you put four million volts through it. E&#x27;</span>s bleedin<span class="string">&#x27; demised !</span></span><br></pre></td></tr></table></figure>
<p>使用 lambda 表达式创建匿名函数。可以为函数添加注解，注解被存储在函数的 <code>__annotations__</code> 属性中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">make_incrementor</span>(<span class="params">n</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [(<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;four&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs</span><br><span class="line">[(<span class="number">4</span>, <span class="string">&#x27;four&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">ham: <span class="built_in">str</span>, eggs: <span class="built_in">str</span> = <span class="string">&#x27;eggs&#x27;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Annotations:&quot;</span>, f.__annotations__)</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;Arguments:&quot;</span>, ham, eggs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> ham + <span class="string">&#x27; and &#x27;</span> + eggs</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>f(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">Annotations: &#123;<span class="string">&#x27;ham&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;eggs&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, <span class="string">&#x27;return&#x27;</span>: &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br><span class="line">Arguments: spam eggs</span><br><span class="line"><span class="string">&#x27;spam and eggs&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="Data-Structures">Data Structures</h2>
<p>列表推导式的方括号 <code>[]</code> 中包含以下内容：一个表达式，一个 <code>for</code> 子句，之后是零个或多个 <code>for</code>/<code>if</code> 子句。使用 <code>zip()</code> 函数在多个迭代器上并行迭代，每个迭代器返回一个元素组成元组。使用 <code>del</code> 语句删除列表元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combs = []</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> x != y:</span><br><span class="line"><span class="meta">... </span>            combs.append((x, y))</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>combs</span><br><span class="line">...</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [</span><br><span class="line"><span class="meta">... </span>    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line"><span class="meta">... </span>    [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>), (<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>), (<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>), (<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>
<p>元组由逗号分隔的值组成，元组是不可变的，但可以包含可变对象，此时可以修改该可变对象。空元组使用 <code>()</code> 创建，单元素元组使用该元素之后跟 <code>,</code> 逗号创建。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples may be nested:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&#x27;hello!&#x27;</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples are immutable:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>] = <span class="number">88888</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># but they can contain mutable objects:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>singleton = <span class="string">&#x27;hello&#x27;</span>,    <span class="comment"># &lt;-- note trailing comma</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(empty)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(singleton)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>singleton</span><br><span class="line">(<span class="string">&#x27;hello&#x27;</span>,)</span><br></pre></td></tr></table></figure>
<p>可以使用花括号或 <code>set()</code> 函数创建集合，创建空集合只能使用 <code>set()</code> 而不能使用 <code>&#123;&#125;</code>，<code>&#123;&#125;</code> 创建的是空字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># show that duplicates have been removed</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># fast membership testing</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Demonstrate set operations on unique letters from two words</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># unique letters in a</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># letters in a but not in b</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># letters in a or b or both</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># letters in both a and b</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># letters in a or b but not both</span></span><br><span class="line">&#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>字典的键必须是不可变类型，使用 <code>&#123;&#125;</code> 创建空字典，获取不存在键的值会报错。使用 <code>list(d)</code> 获取键列表，使用 <code>sorted(d)</code> 获取排序之后的键列表，使用 <code>in</code> 或 <code>not in</code> 判断键是否存在，使用 <code>dict()</code> 函数创建字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;guido&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="number">4098</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> tel[<span class="string">&#x27;sape&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">&#x27;irv&#x27;</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;guido&#x27;</span>: <span class="number">4127</span>, <span class="string">&#x27;irv&#x27;</span>: <span class="number">4127</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(tel)</span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(tel)</span><br><span class="line">[<span class="string">&#x27;guido&#x27;</span>, <span class="string">&#x27;irv&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;jack&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>遍历字典的键值对使用 <code>items()</code> 方法，遍历序列的索引和元素使用 <code>enumerate()</code> 函数，并行遍历使用 <code>zip()</code> 函数，反向遍历使用 <code>reversed()</code> 函数，排序遍历使用 <code>sorted()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">&#x27;gallahad&#x27;</span>: <span class="string">&#x27;the pure&#x27;</span>, <span class="string">&#x27;robin&#x27;</span>: <span class="string">&#x27;the brave&#x27;</span>&#125;</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;tic&#x27;</span>, <span class="string">&#x27;tac&#x27;</span>, <span class="string">&#x27;toe&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line"><span class="meta">... </span>answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br><span class="line">...</span><br><span class="line">What <span class="keyword">is</span> your name?  It <span class="keyword">is</span> lancelot.</span><br><span class="line">What <span class="keyword">is</span> your quest?  It <span class="keyword">is</span> the holy grail.</span><br><span class="line">What <span class="keyword">is</span> your favorite color?  It <span class="keyword">is</span> blue.</span><br></pre></td></tr></table></figure>
<p>使用 <code>is</code> 或 <code>is not</code> 比较两个对象是否是同一个对象。比较运算支持链式操作，<code>a &lt; b == c</code> 和 <code>a &lt; b and b == c</code> 等价。<code>and</code>、<code>or</code> 和 <code>not</code> 表示与或非，相当于 Java 中的 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code>。布尔值有 <code>True</code> 和 <code>False</code>，使用大写字母开头。在表达式内部赋值需要使用 <code>:=</code>，避免误用 <code>=</code>。布尔运算中使用普通值而不是布尔值时，短路运算的返回值是最后一个已求值的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string1, string2, string3 = <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;Trondheim&#x27;</span>, <span class="string">&#x27;Hammer Dance&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>non_null = string1 <span class="keyword">or</span> string2 <span class="keyword">or</span> string3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>non_null</span><br><span class="line"><span class="string">&#x27;Trondheim&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="Classes">Classes</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">scope_test</span>():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">do_local</span>():</span><br><span class="line"><span class="meta">... </span>        spam = <span class="string">&quot;local spam&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">do_nonlocal</span>():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">nonlocal</span> spam</span><br><span class="line"><span class="meta">... </span>        spam = <span class="string">&quot;nonlocal spam&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">do_global</span>():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">global</span> spam</span><br><span class="line"><span class="meta">... </span>        spam = <span class="string">&quot;global spam&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    spam = <span class="string">&quot;test spam&quot;</span></span><br><span class="line"><span class="meta">... </span>    do_local()</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;After local assignment:&quot;</span>, spam)</span><br><span class="line"><span class="meta">... </span>    do_nonlocal()</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;After nonlocal assignment:&quot;</span>, spam)</span><br><span class="line"><span class="meta">... </span>    do_global()</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;After global assignment:&quot;</span>, spam)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>scope_test()</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&quot;In global scope:&quot;</span>, spam)</span><br><span class="line">...</span><br><span class="line">After local assignment: test spam</span><br><span class="line">After <span class="keyword">nonlocal</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">After <span class="keyword">global</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">In <span class="keyword">global</span> scope: <span class="keyword">global</span> spam</span><br></pre></td></tr></table></figure>
<p>可以为类定义 <code>__init__()</code> 方法，在创建对象之后自动执行。实例对象作为第一个参数隐式传递给方法，<code>obj_name.foo()</code> 相当于 <code>ClassName.foo(obj_name)</code>，该参数通常被命名为 <code>self</code>，也可以被命名为其他名称，<code>self</code> 没有特殊含义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line"></span><br><span class="line">    kind = <span class="string">&#x27;canine&#x27;</span>         <span class="comment"># class variable shared by all instances</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name    <span class="comment"># instance variable unique to each instance</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">&#x27;Fido&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">&#x27;Buddy&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.kind                  <span class="comment"># shared by all dogs</span></span><br><span class="line"><span class="string">&#x27;canine&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.kind                  <span class="comment"># shared by all dogs</span></span><br><span class="line"><span class="string">&#x27;canine&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.name                  <span class="comment"># unique to d</span></span><br><span class="line"><span class="string">&#x27;Fido&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name                  <span class="comment"># unique to e</span></span><br><span class="line"><span class="string">&#x27;Buddy&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以动态给对象添加属性或方法，可以在类之外定义函数，然后将其赋值给类属性，毕竟 <code>self</code> 没有特殊含义。在 Python 中，所有值都是对象，都有相应的类型，类型信息存储在 <code>object.__class__</code> 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Warehouse</span>:</span><br><span class="line"><span class="meta">... </span>   purpose = <span class="string">&#x27;storage&#x27;</span></span><br><span class="line"><span class="meta">... </span>   region = <span class="string">&#x27;west&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w1 = Warehouse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(w1.purpose, w1.region)</span><br><span class="line">storage west</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w2 = Warehouse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w2.region = <span class="string">&#x27;east&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(w2.purpose, w2.region)</span><br><span class="line">storage east</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function defined outside the class</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">self, x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(x, x+y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    f = f1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line">    h = g</span><br></pre></td></tr></table></figure>
<p>Python 中的方法都是 <code>virtual</code> 方法（动态绑定），属性默认是公有的。不存在私有变量，不过约定以单下划线 <code>_</code> 开头的变量应该被视为私有的，不论是函数、方法或属性。在类定义中，名称改写（name mangling）会将至少带有两个前缀下划线的标识符 <code>__update</code> 替换为 <code>_Mapping_update</code>，避免子类重写方法影响父类中相应方法的使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mapping</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self.items_list = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update = update   <span class="comment"># private copy of original update() method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingSubclass</span>(<span class="title class_ inherited__">Mapping</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, keys, values</span>):</span><br><span class="line">        <span class="comment"># provides new signature for update()</span></span><br><span class="line">        <span class="comment"># but does not break __init__()</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%E8%AF%AD%E8%A8%80/page/2/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%AF%AD%E8%A8%80/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/">1</a></li><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/page/2/">2</a></li><li><a class="pagination-link is-current" href="/categories/%E8%AF%AD%E8%A8%80/page/3/">3</a></li><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/page/4/">4</a></li><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">155</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-26T00:11:50.404Z">2025-04-26</time></p><p class="title"><a href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> / <a href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-18T10:01:46.499Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-17T16:42:59.185Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/CMU%2015-445645%20%E2%80%94%20Fall%202024%20Projects/">CMU 15-445/645 — Fall 2024 Projects</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-26T13:03:18.733Z">2025-03-26</time></p><p class="title"><a href="/2025/03/26/Kafka/">Kafka 4.0（草稿）</a></p><p class="categories"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a> / <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/">Kafka</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">100</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>