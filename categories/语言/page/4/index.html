<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 语言 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">语言</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-12T10:25:04.923Z" title="2023/8/12 18:25:04">2023-08-12</time>发表</span><span class="level-item"><time dateTime="2023-08-12T10:26:16.247Z" title="2023/8/12 18:26:16">2023-08-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/C/">C++</a></span><span class="level-item">几秒读完 (大约66个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/">禁用编译器扩展以确保程序符合 C++ 标准</a></p><div class="content"><p>g++ 编译器可以通过添加 <code>-pedantic-errors</code> 选项来禁用扩展：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -pedantic-errors</span><br></pre></td></tr></table></figure>

<p>程序示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 禁用前正常运行</span><br><span class="line">error: ISO C++ forbids variable length array &#x27;a&#x27; // 禁用后报错</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-07-30T08:59:36.355Z" title="2023/7/30 16:59:36">2023-07-30</time>发表</span><span class="level-item"><time dateTime="2024-09-02T13:47:28.174Z" title="2024/9/2 21:47:28">2024-09-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></span><span class="level-item">1 分钟读完 (大约166个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">Java 快速输入输出</a></p><div class="content"><h2 id="输入">输入</h2>
<p><code>Scanner</code> 会使用正则表达式解析输入，而 <code>BufferedReader</code> 直接读取输入，所以 <code>Scanner</code> 更慢。</p>
<h2 id="输出">输出</h2>
<p><code>System.out</code>（类型为 <code>PrintStream</code>）的 <code>autoFlush</code> 属性默认为 True，所以 <code>System.out</code> 更慢。</p>
<h2 id="模板">模板</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FastIO</span> <span class="keyword">extends</span> <span class="title class_">PrintWriter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">private</span> StringTokenizer st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastIO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(System.in, System.out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastIO</span><span class="params">(InputStream in, OutputStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastIO</span><span class="params">(String input, String output)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(output);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(input));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (st == <span class="literal">null</span> || !st.hasMoreTokens())</span><br><span class="line">                st = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(br.readLine());</span><br><span class="line">            <span class="keyword">return</span> st.nextToken();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p><a target="_blank" rel="noopener" href="https://www.spoj.com/problems/INOUTEST/">INOUTEST - Enormous Input and Output Test</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-31T16:00:00.000Z" title="2023/1/1 00:00:00">2023-01-01</time>发表</span><span class="level-item"><time dateTime="2025-04-19T07:29:59.040Z" title="2025/4/19 15:29:59">2025-04-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></span><span class="level-item">1 小时读完 (大约11877个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/01/Java%20%E5%9F%BA%E7%A1%80/">Java 基础</a></p><div class="content"><h2 id="基本类型">基本类型</h2>
<h3 id="整数类型">整数类型</h3>
<p>整数进行除法运算，商向零取整。</p>
<p>整数被 0 除将会产生一个异常，而浮点数被 0 除将会得到无穷大或 NaN。</p>
<p><strong>思考：进行取模运算时，数值的正负对结果有什么影响？</strong></p>
<p>取模的定义：<code>(a / b) * b + a % b = a</code>。根据定义算就行，或者记住取模的结果和左边的数（被除数）符号相同，但是结果本质上依赖于除法的舍入规则，所以最好还是按定义算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span> % <span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">3</span> % <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span> % -<span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">3</span> % -<span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%d %d %d %d&quot;</span>,a, b, c, d);</span><br></pre></td></tr></table></figure>
<h3 id="浮点类型">浮点类型</h3>
<p><strong>思考：double 类型的取值范围和精度是多少？（float 类型同理）</strong></p>
<p>double 类型的表示使用 IEEE 754 标准，以 \(V=(-1)^{s}\times M\times 2^{E}\) 的形式来表示浮点数。其中，\(s,M,E\) 分别表示符号、尾数和阶码，分别使用 1、11 和 52 位进行编码。根据标准定义，能够表示的最大/最小规格化值是 \(\pm (1+1-2^{-52})\times2^{(2^{11}-2-1023)}\approx\pm 1.79769313486231570e+308\)。</p>
<p>通常，会说 double 的精度是 15，计算方式为 \(\log{2^{-52}}\) 或者 \(\log{2^{-53}}\)（由于隐含的 \(1\)）。但是，这里所说的精度都是仅从尾数层面计算的，而没有涉及阶码（或者部分涉及）。在十进制表示中，由于阶码的影响（以及科学记数法表示），说精度是 15 没有什么意义。而在二进制表示中，直接说精度是 52 比较合理。</p>
<p><strong>思考：为什么浮点运算可能产生误差？是否所有浮点运算都会产生误差？BigDecimal 是如何避免误差的？</strong></p>
<p>声明：这里所讨论的误差是指运算过程中的舍入误差，不包括由于不能准确表示而产生的舍入误差，例如浮点数 0.1 只是实数 0.1 的近似，也不包括输出产生的舍入误差，例如虽然浮点数能够精确表示 <code>Double.MAX_VALUE</code>，但是输出会得到近似值 1.7976931348623157E308。</p>
<p>（1）发生误差的根本原因是，IEEE 754 标准不能准确表示所有小数（由于范围和精度限制），所以浮点运算只能近似地表示实数运算。标准定义了四种不同的舍入（rounding）方式，默认是将计算结果向偶数舍入（round-to-even）。向偶数舍入是指，将非中间值向最接近的数舍入，将中间值向偶数舍入。</p>
<p><img src="/img/Java.assets/1739349047502.png" alt=""></p>
<p>为什么选择向偶数舍入？如果计算一组数的平均数：向上/下舍入会使结果偏大/小；向零舍入在统计数据都是正/负数时，会使结果偏小/大；而向偶数舍入大概率可以避免这种统计偏差，因为此时向上和向下舍入的概率各占一半。</p>
<p>（2）并非所有浮点运算都会产生误差。首先，<code>0.5 + 0.25</code> 不会产生误差。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 01111111110 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.5</span>)));</span><br><span class="line"><span class="comment">// 0 01111111101 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.25</span>)));</span><br><span class="line">System.out.println(<span class="number">0.5</span> + <span class="number">0.25</span> == <span class="number">0.75</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么，是否可以猜测，能够被 IEEE 754 标准精确表示的数，浮点运算就不会产生误差？然而不是，只要运算结果超出浮点数能够表示的范围或者精度，那么运算就会产生误差。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 01111111111 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">1.0</span>)));</span><br><span class="line"><span class="comment">// 0 10000110100 0000000000000000000000000000000000000000000000000000</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">9007199254740992.0</span>)));</span><br><span class="line">System.out.println(<span class="number">1.0</span> + <span class="number">9007199254740992.0</span>); <span class="comment">// 9.007199254740992E15</span></span><br></pre></td></tr></table></figure>
<p>那么，不能被 IEEE 754 标准精确表示的数，浮点运算是否总会产生误差？也不是，例如 <code>0.1 + 0.1</code> 就没有误差，而 <code>0.1 + 0.2</code> 就会有误差，可以使用这个<a target="_blank" rel="noopener" href="https://numeral-systems.com/ieee-754-add/">网站</a>查看计算过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 01111111011 1001100110011001100110011001100110011001100110011010</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.1</span>)));</span><br><span class="line"><span class="comment">// 0 01111111100 1001100110011001100110011001100110011001100110011010</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.2</span>)));</span><br><span class="line"><span class="comment">// 0 01111111101 0011001100110011001100110011001100110011001100110011</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.3</span>)));</span><br><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">0.2</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>（3）BigDecimal 表示不可变的任意精度的小数，可以将其视为由任意精度的未缩放值 \(x\)，以及 32 位的缩放值 \(k\) 组成，最终表示的数就是 \(x\times 10^{-k}\)。如果未缩放值 \(x\) 非常大，则会使用 BigInteger 来表示。BigInteger 表示不可变的任意精度的整数，内部使用 int 类型的数组存储整数的补码表示的各个部分。例如，\(9\times 10^{9}\) 会被存储为 \([2,410065408]\)，对应补码表示 \(01000011000011100010001101000000000\) 的 \(010\) 和 \(00011000011100010001101000000000\) 两部分。</p>
<p><strong>思考：double 类型不能准确表示的最小正整数是多少？（CSAPP 练习题 2.49）</strong></p>
<p>假设阶码位数足够大，对于有 \(n\) 位尾数的浮点数，不能准确表示的最小正整数是 \(2^{n+1}+1\)。所以，double 类型不能准确表示的最小正整数是 \(2^{53}+1=9007199254740993\)。示例如下，最低位的 1 被舍掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9007199254740993.</span>); <span class="comment">// 9.007199254740992E15</span></span><br></pre></td></tr></table></figure>
<p>需要注意，不能根据上述结论推断出，能够准确表示的最大正整数是 \(2^{n+1}\)。反例是，\(2^{n+1}+2\) 可以被准确表示，更简单的反例是 \(2^{n+2}\)。总的来说，能转换为 \((-1)^{s}\times M\times 2^{E}\) 形式的数都可以被准确表示。</p>
<p><strong>思考：将三个 int 类型的整数转换为 double 类型（假设为 \(x,y,z\)），问 \((xy)z=x(yz)\) 是否总是成立？如果不是，反例是什么？（<a target="_blank" rel="noopener" href="https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.89/">CSAPP 2.89 D</a>）</strong></p>
<p>反例如下，简单来说乘法可能存在舍入误差，不同的结合方式可能会有不同的舍入形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">23</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + <span class="number">1</span>;</span><br><span class="line">System.out.println((x * y) * z == x * (y * z)); <span class="comment">// false</span></span><br><span class="line">z = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line">System.out.println((x * y) * z == x * (y * z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可以根据乘法结果能否转换为标准定义的浮点形式，来判断是否存在舍入误差。首先 \((2^{30}+1)\times(2^{23}+1)=(1+2^{-23}+2^{-30}+2^{-53})\times 2^{53}\)，由于尾数能表示的最小值是 \(2^{-52}\)，所以最后 \(1\) 位会被舍掉，得到 \(xy=(1+2^{-23}+2^{-30})\times 2^{53}\)。然后 \((1+2^{-23}+2^{-30})\times 2^{53}\times(2^{24}+1)=(1+2^{-23}+2^{-30}+2^{-24}+2^{-47}+2^{-54})\times 2^{77}\)，所以最后 \(2\) 位会被舍掉，得到 \((xy)z=(1+2^{-23}+2^{-30}+2^{-24}+2^{-47})\times 2^{77}=151115754614164973158400\)。</p>
<h3 id="字符类型">字符类型</h3>
<p>Java 的 char 类型占用两个字节，使用 Unicode 字符集，并且采用 UTF-16 编码方式。</p>
<p>一个 Unicode 字符在 UTF-16 编码中由 1 ~ 2 个代码单元组成，一个 char 值表示 UTF-16 编码中的一个代码单元。</p>
<p>char 类型可以使用转义序列 \u 表示，例如 \u0061 表示字符 a。\u 转义序列与其他转义序列不同，它可以出现在加引号的字符常量或字符串之外。如下所示，第一行代码中的 \u005B 和 \u005D 分别是 [ 和 ] 的编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String\u005B\u005D args)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是 Unicode 转义序列会在解析代码前进行处理。例如，下面的代码看上去是没有问题，但是有两个语法错误，因为 \u000A 会被替换为一个换行符，而 \user 会被视为非法的 Unicode 转义，因为 \u 后面没有跟着 4 个十六进制数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u000A is a newline</span></span><br><span class="line"><span class="comment">// look inside c:\user</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\u0022+\u0022&quot;</span>; <span class="comment">// 表示一个空串</span></span><br></pre></td></tr></table></figure>
<p><strong>思考：能否使用 <code>Character.isDigit</code> 方法判断字符是 0~9？能否使用 <code>Character.isLetter</code> 方法判断字符是 a~z 或 A~Z？</strong></p>
<p>在 Unicode 字符集中，数字和字母的范围更大。例如，\u0669 表示 Arabic-Indic 数字中的 9，但是不能将其和字符 9 等同，字符 9 的 Unicode 表示为 \u0039。同理，\u03c0 表示希腊字母 π，<code>Character.isLetter</code> 也会返回 <code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u0669&#x27;</span>;</span><br><span class="line">System.out.println(c); <span class="comment">// ٩</span></span><br><span class="line">System.out.println(Character.getNumericValue(c)); <span class="comment">// 9</span></span><br><span class="line">System.out.println(Character.isDigit(c)); <span class="comment">// true</span></span><br><span class="line">System.out.println(c == <span class="string">&#x27;9&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换">类型转换</h3>
<p><strong>思考：自动类型转换是否可能损失精度？什么情况下需要强制类型转换？</strong></p>
<p>（1）自动类型转换可能损失精度，例如之前提到 double 不能准确表示的最小正整数是 9007199254740993。支持的自动类型转换如下（图片参考《Java 核心技术 卷一》），损失精度一般都涉及到浮点数。</p>
<p><img src="/img/Java.assets/1665313955255.png" alt=""></p>
<p>（2）简单来说，将大范围类型转换为小范围类型，需要强制类型转换，反之则不需要。或者按照书中的表述，可能损失信息的转换，需要强制类型转换。</p>
<p><strong>思考：以下代码会发生几次类型转换？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>; <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>; x += y;</span><br></pre></td></tr></table></figure>
<p>使用 <code>javap -v</code> 反编译字节码，部分输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0: lconst_1</span><br><span class="line">1: lstore_1</span><br><span class="line">2: dconst_1</span><br><span class="line">3: dstore_3</span><br><span class="line">4: lload_1</span><br><span class="line">5: l2d</span><br><span class="line">6: dload_3</span><br><span class="line">7: dadd</span><br><span class="line">8: d2l</span><br><span class="line">9: lstore_1</span><br><span class="line">10: return</span><br></pre></td></tr></table></figure>
<p>可以发现，字面量 1 直接使用 lconst_1 和 dconst_1 获取，不会发生类型转换。而 <code>x += y</code> 相当于 <code>x = (long) (x + y)</code>，所以发生两次类型转换。</p>
<h2 id="类与接口">类与接口</h2>
<h3 id="包">包</h3>
<p>通常使用逆序的因特网域名作为包名，然后对不同工程使用不同的子包，以防止相同名字的类产生冲突。可以使用<strong>完全限定名</strong>访问其他包中的类，也可以使用 import 语句（位于 package 语句的后面）导入其他包中的类，然后就可以直接使用类名。当导入的包存在命名冲突时，仍然需要使用完全限定名。编译器将 java 文件编译为 class 文件后，class 文件中的字节码使用的都是完全限定名。</p>
<p>使用星号可以导入其他包中的所有类，但是不能使用星号导入多个包，例如 <code>import java.*</code> 或 <code>import java.*.*</code> 是不允许的。嵌套的包之间没有任何关系，每一个包都是独立的类集合。用星号导入某个包中的所有类后，使用其子包仍然需要显示导入。使用 import static 可以导入静态方法/静态字段。</p>
<h3 id="访问修饰符">访问修饰符</h3>
<p>常规类（非内部类）可以被 public 修饰或者无修饰符，字段和方法可以被所有修饰符修饰或者无修饰符。不同修饰符的访问级别如下（图片源自 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">Controlling Access to Members of a Class</a>）。</p>
<p><img src="/img/Java.assets/1739514664938.png" alt=""></p>
<ul>
<li>public：被修饰的类/字段/方法可以被任意类访问。特别的，一个源文件只能有一个 public 类，并且文件名必须和该类名相同。</li>
<li>protected：被修饰的字段/方法可以被所有子类和相同包中的类访问。需要注意，在不同包中，子类可以访问的是自身继承的 protected 字段/方法，而不能访问父类对象的（或者其他子类继承的） protected 字段/方法。（避免滥用保护机制，不能通过派生子类来访问父类对象的 protected 字段/方法）</li>
<li><em>no modifier</em>：无修饰符，类/字段/方法可以被相同包中的类访问。</li>
<li>private：被修饰的字段/方法可以被所属的类访问。</li>
</ul>
<p><strong>思考：private 字段一定不会被其他类访问到吗？（不使用反射）</strong></p>
<p>虽然 private 字段不能通过 <code>obj.field</code> 形式访问，但是如果 private 字段从某个方法暴露出去，则会被其他类访问到。</p>
<h3 id="对象与对象变量">对象与对象变量</h3>
<p>以下代码使用 new 关键字构造 Date 类型的对象，然后将该对象的引用（地址）赋值给 <code>deadline</code>，这个 <code>deadline</code> 就是对象变量（可以看作指针）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">deadline</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<h3 id="字段的初始化顺序">字段的初始化顺序</h3>
<p>静态字段：在类加载时，按照类中出现的顺序执行显式初始化和静态初始化块。</p>
<p>实例字段：首先执行默认初始化，然后按照类中出现的顺序执行显式初始化和初始化块，最后执行构造器代码。</p>
<p>父类字段：父类静态字段的初始化在子类静态字段之前，父类实例字段的初始化在子类实例字段之前。</p>
<h3 id="方法的重载和重写">方法的重载和重写</h3>
<p>重载方法是指在相同类中，方法名相同但参数类型不同的方法（返回值类型不重要）。方法名 + 参数类型被称为方法的签名。在进行方法调用时，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个匹配的方法，编译器就会报错。</p>
<p>重写方法是指子类重写（覆盖）父类的方法，重写方法通常会加上 @Override 注解。方法重写遵循以下规则：</p>
<ul>
<li>重写方法的可见性不能低于原方法。</li>
<li>重写方法的返回值类型可以改为原返回类型的子类型。</li>
<li>重写方法声明的异常不能比原方法声明的异常更通用。</li>
<li>父类的 static 方法不能被子类重写，但是可以被子类中相同签名的 static 方法隐藏。</li>
<li>参数数量可变的形参换成数组类型构成重写。</li>
</ul>
<p>如果重写方法的返回值类型是原返回类型的子类型，此时编译器会在子类中生成一个桥方法，该桥方法的返回值类型和原方法相同，并且桥方法会调用重写的方法。</p>
<p><strong>思考：方法参数是值传递还是引用传递？</strong></p>
<p>方法参数总是值传递，即方法得到的是参数的副本。对于基本类型，肯定是值传递。对于引用类型，只要明白对象和对象变量的区别，就可以知道引用类型也是值传递，因为对象变量（指针）的值就是对象的引用（地址）。</p>
<h3 id="继承和多态（向上转型）">继承和多态（向上转型）</h3>
<p>在 Java 中，类之间只支持单继承，而接口之间支持多继承。在子类的构造器中，可以使用 super 语句调用父类的构造器，该语句必须是子类构造器的第一条语句。如果子类的构造器没有显式地调用父类的构造器，将自动地调用父类的无参数构造器。如果父类没有无参数构造器，并且在子类的构造器中又没有显式地调用父类的其他构造器，Java 编译器就会报错。</p>
<p>一个对象变量可以指示多种实际类型的现象称为多态，在运行时能够自动地选择适当的方法，称为动态绑定。在将父类强制类型转换成子类之前，应该使用 instanceof 进行检查。否则，如果类型不符，将会产生类型转换异常。</p>
<p><strong>思考：方法调用的原理？解析和分派？字段没有多态性？（详细分析见《深入理解 Java 虚拟机》第 8 章）</strong></p>
<p>所有方法调用的目标方法在 Class 文件中都是一个常量池中的符号引用。在类加载的解析阶段就可以将符号引用解析为直接引用的方法被称为非虚方法，包括静态方法、私有方法、实例构造器、父类方法以及 final 方法。这类方法的调用被称为解析。</p>
<p>虚方法是指除非虚方法以外的方法，需要通过分派确定调用目标。重载方法是静态分派（重载解析）的，依据对象的外观类型（Apparent Type）来选择调用的方法。重写方法是动态分派的，依据对象的运行时类型（Runtime Type）来选择调用的方法。</p>
<p>字段没有多态性，访问字段依据的是当前方法所属的类或者外观类型。</p>
<h3 id="接口">接口</h3>
<ul>
<li>方法默认被 public abstract 修饰，字段默认且必须被 public static final 修饰。</li>
<li>可以使用 default 修饰符声明默认方法（必须是非静态的）。</li>
<li>在 Java 8 中，可以声明静态方法，静态方法只能通过接口调用，不能通过实现类及其对象调用。</li>
<li>在 Java 9 中，可以声明私有方法（用作其他方法的辅助方法），私有方法可以是静态方法或实例方法。</li>
</ul>
<p>在继承关系中，接口的默认方法有时会和其他类/接口的方法冲突，解决规则如下：</p>
<ul>
<li><strong>父类与接口冲突，父类优先。</strong> 如果父类的方法和接口的默认方法有相同签名，则接口中的默认方法会被忽略。</li>
<li><strong>接口与接口冲突，覆盖方法。</strong> 如果两个接口有相同签名的方法，并且其中一个接口的方法是默认方法，则必须覆盖这个方法来解决冲突。</li>
</ul>
<p>如果想要在实现类中显示调用接口中的默认方法，可以使用 <code>interfaceName.super.methodName(xxx)</code>。</p>
<h2 id="常用关键字">常用关键字</h2>
<h3 id="this">this</h3>
<p>每个实例方法都会有一个隐含的参数 this，表示当前对象的引用。在字节码中，实例方法的 args_size 至少是 1，就是因为 this 作为隐含的参数。</p>
<p>可以使用 this 调用当前对象的构造器、字段/方法。特别的，可以在内部类中使用 <code>OuterClass.this</code> 表示外部类的引用；在 lambda 表达式中，this 表示创建这个表达式的对象的引用（类似事实最终变量）。</p>
<h3 id="super">super</h3>
<ul>
<li>调用父类的构造器/方法，获取父类的字段。</li>
<li>调用接口的默认方法，<code>interfaceName.super.xxx()</code>。</li>
</ul>
<p>与 this 不同，super 不是对象的引用，不能将 super 赋给另一个对象变量。</p>
<h3 id="final">final</h3>
<ul>
<li>修饰类时，类不能被继承。</li>
<li>修饰方法时，方法不能被重写。</li>
<li>修饰字段/变量时，字段/变量必须被初始化。</li>
</ul>
<h3 id="static">static</h3>
<p>可以修饰字段/方法/初始化块/内部类，它们在类加载时被创建。当 static 修饰方法时，该方法不能访问实例字段、不能使用 this 和 super 关键字。import static 表示静态导入。</p>
<h3 id="abstract">abstract</h3>
<p>可以使用 abstract 关键字来声明抽象类/方法。abstract 不能修饰私有/静态方法，以及 final 方法/类。包含抽象方法的类必须被声明为抽象类，但是抽象类可以不包含抽象方法。</p>
<h2 id="常用类与接口">常用类与接口</h2>
<h3 id="Object">Object</h3>
<p>Object 类是 Java 中所有类的父类，可以使用 Object 类型的变量引用任何类型的对象。在 Java 中，只有基本类型不是对象，基本类型由于自动装箱可以赋值给 Object 类型的变量。数组类型没有重写 equals、hashcode 和 toString 方法，通常会借助 Arrays 工具类来执行这些操作。</p>
<h4 id="equals-方法">equals 方法</h4>
<p>Object 类中的 equals 方法比较两个对象的引用是否相等，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要比较两个对象的内容是否相等，需要覆盖 equals 方法，通用的实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断对象的引用是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断 otherObject 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断 this 与 otherObject 的类型是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将 otherObject 强制类型转换为相应的类型</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.使用 == 比较基本类型</span></span><br><span class="line">        <span class="comment">// 使用 Object.equals 比较除数组之外的引用类型</span></span><br><span class="line">        <span class="comment">// 使用 Arrays.equals 比较数组类型</span></span><br><span class="line">        <span class="comment">// 不使用 name.equals(other.name) 比较是为了避免空指针异常</span></span><br><span class="line">        <span class="comment">// 如果当前类的直接父类不是 Object，还需要调用 super.equals(other) 比较父类中的字段</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">                &amp;&amp; salary == other.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashCode-方法">hashCode 方法</h4>
<p>Object 类中的 hashCode 方法是本地方法，它根据对象的存储地址计算得出散列码。如果重新定义 equals 方法，那么就要为可能插入散列表的对象重新定义 hashCode 方法。且 equals 与 hashCode 的定义必须相容：如果 <code>x.equals(y)</code> 返回 true，那么 <code>x.hashCode()</code> 就必须与 <code>y.hashCode()</code> 相等。</p>
<h4 id="clone-方法">clone 方法</h4>
<p>Object 类中的 clone 方法为 protected 修饰的本地方法，执行的是浅拷贝。如果要使用 clone 方法，需要在类上实现 Cloneable 标记接口，同时指定 public 修饰符。</p>
<h3 id="String">String</h3>
<p>String 类对象是不可变的，我们只能改变 String 类型的对象变量的值（指针的指向），而不能改变对象本身。</p>
<p>字符串字面量是共享的，存储在常量池中。拼接两个非 final 的 String 对象变量以及执行 <code>substring</code> 操作得到的字符串不是共享的（存储在堆中）。拼接两个 final 的 String 对象变量，编译器会执行常量折叠优化，直接从常量池中获取字符串对象。</p>
<p><strong>思考：为什么说 String 类对象是不可变的？</strong></p>
<p>因为 String 类被 final 修饰不可继承，String 类的 <code>value</code> 字段被 private final 修饰且没有逸出，也没有提供修改该字段的方法（不论方法被什么访问修饰符修饰），String 类对象的 this 引用不会在构造器中逸出。</p>
<p><strong>思考：字符串拼接会有什么性能问题？编译器是如何优化字符串拼接 <code>+</code> 操作的？</strong></p>
<p>如果不优化，每次拼接都会创建一个新的 String 对象。在拼接多次的场景下，拼接产生的中间对象在拼接之后就不会使用，这会浪费创建对象的时间和空间。例如，在循环中拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;7&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s += s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果优化，很容想到使用 StringBuilder 类，在 Java 8 中编译器也是这么做的。但是，不推荐在循环中使用 <code>+</code> 拼接，因为编译器会在循环中创建 StringBuilder 对象。而在 Java 9 之后编译器会使用 invokedynamic 指令，优点是可以动态地选择拼接策略。（或许可以看下这篇<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-string-concatenation-invoke-dynamic">文章</a>）</p>
<h3 id="包装类">包装类</h3>
<p>所有的基本类型都有一个对应的包装类（不可变的）。在使用包装类时，可以直接当作基本类型操作，编译器在编译时会自动地插入装箱和拆箱指令。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y = <span class="number">2</span>, z = x + y;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1</span><br><span class="line">1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">4: astore_1</span><br><span class="line">5: iconst_2</span><br><span class="line">6: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">9: astore_2</span><br><span class="line">10: aload_1</span><br><span class="line">11: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">14: aload_2</span><br><span class="line">15: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">18: iadd</span><br><span class="line">19: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">22: astore_3</span><br><span class="line">23: return</span><br></pre></td></tr></table></figure>
<p>可以看到，编译器会调用 <code>Integer.valueOf</code> 装箱，调用 <code>obj.intValue()</code> 拆箱。似乎对包装类进行运算总是会拆箱转换为基本类型，然后将运算结果装箱，所以效率不是很高。为了提高性能，包装类会在静态初始化块中创建常用对象缓存池，缓存对象的范围如下：Boolean（true 和 false）、Byte | Short | Int | Long（-128 ~ 127）、Character（0 ~ 127），Float 和 Long 类不会缓存对象。</p>
<h3 id="比较器">比较器</h3>
<h4 id="Comparable-接口">Comparable 接口</h4>
<p>实现 Comparable 接口的类可以进行自然排序，该接口在 java.lang 包下。所谓自然排序，就是指排序时，默认会使用 Comparable 接口的 compareTo 方法排序，而定制排序需要在排序时需要显示传入实现 Comparator 接口的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>compareTo</code> 方法较当前对象与指定对象的大小关系，当前对象小于/等于/大于指定对象时，返回负整数/零/正整数。注意，返回值是 int 类型的整数。</p>
<p>文档建议 <code>CompareTo</code> 方法应当与 <code>equals</code> 方法兼容，即当 <code>x.equals(y) == true</code> 时，<code>x.compareTo(y)  ==  0</code>。特别的，BigDecimal 类不遵循该建议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.compareTo(y)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="Comparator-接口">Comparator 接口</h4>
<p>如果类的自然排序与需求不匹配，可以定义Comparator 接口的实现类，然后将类对象作为参数传入排序方法中，执行定制排序。Comparator 接口在 java.util 包下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类">枚举类</h3>
<p>可以使用 enum 关键字创建枚举类，枚举类的构造器默认且必须是私有的，所以在比较时可以直接使用 <code>==</code> 运算符。枚举类实例的定义必须在字段/方法的定义之前。枚举类默认是 Enum 类的子类，所以枚举类型不能显示继承其他类。源代码和反编译得到的字节码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Size</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;Size&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size SMALL;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size MEDIUM;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size LARGE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Size EXTRA_LARGE;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String abbreviation;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Size[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Size <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.String <span class="title function_">getAbbreviation</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常">异常</h2>
<p>异常层次结构如下，异常被分为检查型异常和非检查型异常。非检查型异常：派生于 Error 类或 RuntimeException 类的所有异常。检查型异常：除非检查型异常以外的所有异常。</p>
<p><img src="/img/Java.assets/1665803216018.png" alt=""></p>
<p>一个方法必须声明（throws）或捕获（catch）所有可能抛出的检查型异常，而非检查型异常要么在控制之外（Error），要么从一开始就应该避免（RuntimeException），所以不应该声明。</p>
<p>处理异常的一般经验是，捕获知道如何处理的异常，而继续传播（throw）不知道怎样处理的异常。</p>
<h3 id="try-catch-finally">try-catch-finally</h3>
<p>使用规则：</p>
<ul>
<li>当 catch 捕获多个异常时，异常变量隐含为 final 变量。</li>
<li>可以在 catch 中使用 initCause 方法将原异常设置为新异常的原因，当捕获到新异常时，可以使用 getCause 方法获取原异常。</li>
<li>不论是否有异常被捕获，finally 中的代码都会在方法返回之前执行执行。</li>
<li>finally 用于清理资源，不要把改变控制流的语句（return，throw， break，continue）放在 finally 中。如果在 finally 中包含 return 语句，则 finally 中的 return 会在 try/catch 中的 return 或者 throw 之前执行，有可能会丢失异常。</li>
</ul>
<p><strong>思考：以下代码在未发生异常和发生异常情况下的返回值分别是多少？（示例源自《深入理解 Java 虚拟机》第 6 章）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果未发生异常，由于 try 在 finally 之前执行，所以返回值已经确定是 1。如果在 try 中发生 Exception 及其子类的异常，由于 catch 也在 finally 之前执行，所以返回值已经确定是 2。如果在 try 中发生其他异常，或者在 catch/finally 中发生任意异常，则方法非正常退出，没有返回值。</p>
<h3 id="try-with-resources">try-with-resources</h3>
<p>在 Java 7 中，如果资源实现了 AutoCloseable 接口，就可以使用 try-with-resources 语句处理资源。当 try 块退出时，会自动调用资源的 close 方法关闭资源。</p>
<p>使用规则：</p>
<ul>
<li>catch 和 finally 在资源关闭之后执行。</li>
<li>在 Java 9 中，允许在 try 首部中使用之前声明的 final 或 effective final 变量。</li>
<li>如果 try 和 close 都抛出异常，则 close 方法抛出的异常会被抑制，并由 addSuppressed 方法添加到 try 的抛出的异常对象中。如果想查看被抑制的异常，可以使用 getSuppressed 方法获取被抑制的异常数组。</li>
</ul>
<h2 id="泛型">泛型</h2>
<h3 id="基本概念">基本概念</h3>
<p>使用泛型的目的是什么？如果不使用泛型，可以向集合类中添加任何类型的对象，并且读取时需要类型判断和强制类型转换。所以，使用泛型的目的是允许编译器进行类型检查，以及避免频繁地强制类型转换。</p>
<p>定义泛型类 <code>class C&lt;T&gt;</code>，定义泛型方法 <code>public static &lt;T&gt; void m(T x)</code>。</p>
<p>Java 库使用参数 E 表示集合的元素类型，K 和 V 分别表示表的键和值的类型，T（或者 U 和 S）表示任意类型。</p>
<p>可以使用 extends 关键字对类型参数进行限定 <code>&lt;T extends BoundingType&gt;</code>，表示 T 是限定类型（bounding type）的子类型（subtype），T 和限定类型可以是类或接口。</p>
<p>一个类型参数或通配符可以有多个限定，限定类型用 &amp; 分隔，而类型参数用逗号分隔。如果有一个类作为限定，它必须是限定列表中的第一个限定。</p>
<h3 id="类型擦除">类型擦除</h3>
<p>在虚拟机中没有泛型类型，所有对象都属于普通类。无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，这个原始类型的名字就是去掉类型参数后的泛型类型名。类型参数会在编译时被擦除，替换为第一个限定类型，对于无限定的类型参数则替换为 Object 类型。</p>
<p>需要注意，如果将限定 &lt;T extends Comparable &amp; Serializable&gt; 换为 &lt;T extends Serializable &amp; Comparable&gt;，会用 Serializable 替换 T，而这会导致在调用 compareTo 方法时进行额外的强制类型转换。为了提高效率，应该将标记接口放在限定列表的末尾。</p>
<p>（1）当调用的泛型方法的返回类型被擦除，编译器会插入强制类型转换（checkcast 指令）。</p>
<p>（2）编译器会生成桥方法，来避免类型擦除和多态之间的冲突。假设泛型类 <code>Class A&lt;T&gt;</code> 有个方法 <code>public void m(T x)</code>，那么它的子类在继承时指定 <code>Class B extends A&lt;Integer&gt;</code>，对应的重写方法是 <code>public void m(Integer x)</code>。类型擦除之后，两个方法的签名不同不构成重写，所以编译器会在子类中生成 <code>public void m(Object x)</code> 方法作为代理（构成重写），从而解决冲突。</p>
<h3 id="泛型的限制和继承规则">泛型的限制和继承规则</h3>
<p>使用限制：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html">Restrictions on Generics</a>。</p>
<p>继承规则：无论 S 与 T 有什么关系，通常 <code>Pair&lt;S&gt;</code> 与 <code>Pair&lt;T&gt;</code> 都没有任何关系（偏序）。</p>
<p><img src="/img/Java.assets/1665996674774.png" alt=""></p>
<h3 id="通配符的限定">通配符的限定</h3>
<p>子类限定 <code>&lt;? extends Type&gt;</code>，将泛型对象的类型参数限制为 Type 类型或其子类型。此时，如果类型参数作为方法参数，只能传入 null，因为不知道该传入具体哪个子类。如果类型参数作为返回值，只能将返回值赋值给 Type 类型或其父类型的变量（向上转型）。</p>
<p>父类限定 <code>&lt;? super Type&gt;</code>，将泛型对象的类型参数限制为 Type 类型或其父类型。此时，如果类型参数作为方法参数，只能传入 Type 类型或其子类型的变量（向上转型）。如果类型参数作为返回值，只能将返回值赋值给 Object 类型的变量，因为只有 Object 必定是该类型参数的父类。</p>
<p>无限定 <code>&lt;?&gt;</code>，不限制泛型对象的类型参数。此时，如果类型参数作为方法参数，只能传入 null，因为不知道该传入具体哪个类。如果类型参数作为返回值，只能将返回值赋值给 Object 类型的变量，因为只有 Object 必定是该类型参数的父类。</p>
<p>PECS（Producer Extends，Consumer Super）原则：读取数据使用子类限定，写入数据使用父类限定。</p>
<p>自限定的类型 <code>class SelfBound&lt;T extends SelfBound&lt;T&gt;&gt;</code>，SelfBound 的类型参数 T 限定为 <code>SelfBound&lt;T&gt;</code> 的子类。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;A&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;A&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;B&gt; &#123;...&#125; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，A 继承 <code>SelfBound&lt;A&gt;</code> ，使得 A 可以作为 SelfBound 的类型参数。而 B 没有继承 <code>SelfBound&lt;B&gt;</code>，所以不能将 B 作为 SelfBound 的类型参数。使用自限定的类型，目的是保证 SelfBound 类的类型参数为当前定义的类（例如 A）。虽然 B 继承的 SelfBound 类的类型参数是 A 而不是当前定义的 B，但是一般情况下并不会这样使用。</p>
<p>如果看不懂，可以考虑没有自限定类型的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfBound</span>&lt;T&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;Any-Type&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果 SelfBound 没有自限定，A 类在继承 SelfBound 时，类型参数可以是任意类型。</p>
<h2 id="反射">反射</h2>
<p>反射是 Java 中的一项功能，允许程序在运行时分析类，并且操纵其内部属性。（<a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/javareflection.html">Using Java Reflection</a>）</p>
<p>一个 Class 对象表示一个类型，包括类类型（包括数组类型）、接口类型、基本类型和 void。每个类型的 Class 对象是唯一的，所以可以直接使用 <code>==</code> 运算符比较。</p>
<p>获取 Class 对象的方式如下：使用 <code>obj.getClass()</code> 方法获取对象运行时类型的 Class 对象，使用 <code>Class.forName(xxx)</code> 方法获取指定类的 Class 对象。如果 T 是任意的 Java 类型或 void 关键字，<code>T.class</code> 将代表对应的 Class 对象。特别的，使用 <code>.class</code> 获取 Class 对象的引用时，不会初始化该 Class 对象表示的类，而前两种方式会进行初始化。（类加载的过程：加载、链接和初始化）</p>
<h2 id="注解">注解</h2>
<p>可以使用注解（也被称为元数据）在代码中提供额外的信息，然后这些信息可以在编译时解析或运行时利用反射获取。</p>
<h3 id="定义注解">定义注解</h3>
<p>注解的定义类似接口，区别在于需要再 interface 关键字之前加上 @ 符号。声明元素需要在元素名之后加上 <code>()</code>，可以使用 default 关键字为元素指定默认值。注解元素的类型限制：基本类型、String、Class、枚举类型、注解类型，以及由这些类型组成的一维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Demo &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的注解都隐式的继承自 java.lang.annotation.Annotation 接口。如果反编译上述注解的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，注解就是接口，默认继承自 Annotation 接口。而且在其中定义的元素实际上是接口中的抽象方法，只是可以使用 default 指定默认值。</p>
<h3 id="使用注解">使用注解</h3>
<p>在定义注解时，如果没有为元素指定默认值，则在使用时需要显示的赋值；否则，可以不显示赋值，自动使用默认值。注解元素的值必须是编译期常量，并且不能设置为 null。如果元素值是一个数组，那么要将它的值用 <code>&#123;&#125;</code> 括起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationName(elementName1 = value1, elementName2 = value2, ...)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标记注解：如果注解没有任何元素或者所有元素都提供了默认值，则在使用注解时可以不需要括号。</li>
<li>单值注解：如果注解只有一个名为 <code>value</code> 的元素，则在指定该元素的值时，可以忽略元素名以及赋值运算符。</li>
</ul>
<h3 id="内置注解">内置注解</h3>
<h4 id="元注解">元注解</h4>
<p>@Target：指定注解适用的上下文。@Retention：指示注解的保留时长，默认的保留策略为 <code>CLASS</code>。SOURCE 注解将被编译器丢弃。CLASS 注解将由编译器记录在类文件中，但会被 VM 丢弃。RUNTIME 注解将在运行时由 VM 保留，可以使用反射机制读取注解信息。</p>
<p>@Documented：指示将注解包含在 Java 文档中。@Inherited：允许子类继承父类中的注解，当被修饰的注解作用于类时，该元注解才有效。@repeatable：指示注解可以在同一上下文重复使用。</p>
<ul>
<li>字段和方法上的注解只要没有被覆盖，就会被继承（前提是字段和方法会被继承）。</li>
<li>接口上的注解永远都不会被继承，类上的注解只有在使用 @Inherited 时才会被继承。</li>
</ul>
<h4 id="标准注解">标准注解</h4>
<p>@Overried：指示当前方法将覆盖父类中的方法或实现接口中的方法。@Deprecated：指示目标被弃用。@SuppressWarnings：抑制目标中给定类型的编译器警告。@SafeVarargs：指示将会安全地操作可变参数。@FunctionalInterface：指示接口为函数式接口。</p>
<h2 id="I-O-流">I/O 流</h2>
<h3 id="字节流">字节流</h3>
<p>所有字节流都继承自 InputStream/OutputStream 抽象类，FileInputStream/FileOutputStream 是基本的字节流。FilterInputStream/FilterOutputStream 内部使用其他字节流对象作为数据来源，没有提供额外的功能，但是其子类会通过重写方法来提供额外的功能。</p>
<p>BufferedInputStream/BufferedOutputStream 对流使用缓冲区技术，每次向流读取/写入时，不必每次都进行实际的物理读取/写入操作。DataInputStream/DataOutputStream 允许从流读取/写入基本数据类型。PrintStream 支持格式化输出。</p>
<p><img src="/img/Java.assets/1666426524566.png" alt=""></p>
<p><img src="/img/Java.assets/1666426696517.png" alt=""></p>
<p>ByteArrayInputStream/ByteArrayOutputStream 对字节数组进行读取/写入，由于没有使用到文件，所以不需要对该流执行关闭操作。ObjectInputStream/ObjectOutputStream 见序列化。</p>
<h3 id="字符流">字符流</h3>
<p>所有字符流都继承自 Reader/Writer 抽象类，字符流内部都是基于字节流的。在使用字符流时，注意保证字符的编码和解码方式的一致性。InputStreamReader/OutputStreamWriter 是字节流和字符流之间的桥梁。FileReader/FileWriter 内部使用 FileInputStream，是使用 InputStreamReader/OutputStreamWriter 的快捷方式。</p>
<p><img src="/img/Java.assets/1666427056449.png" alt=""></p>
<p>BufferedReader/BufferedWriter 对流使用缓冲区技术，每次向流读取/写入时，不必每次都进行实际的物理读取/写入操作。PrintWriter 是使用 BufferedWriter 的快捷方式，并且支持格式化输出。</p>
<h3 id="标准-I-O-和-NIO">标准 I/O 和 NIO</h3>
<p><a target="_blank" rel="noopener" href="http://System.in">System.in</a> 的类型是 InputStream，System.out 和 System.err 的类型是 PrintStream。可以使用 System 中的 setIn、setOut 和 setErr，对标准 I/O 进行重定向。</p>
<h3 id="对象序列化">对象序列化</h3>
<p>序列化就是将对象转换为字节序列的形式，在通过网络传输对象或者将对象存储到磁盘时会进行序列化操作，反序列化同理。需要实现 Serializable 接口以支持对象序列化，可以使用 transient 关键字关闭某个字段的序列化。</p>
<p>在序列化时，会生成对象的序列号（单个序列化流中使用）和类的序列化版本号（serialVersionUID）。如果在相同序列化流中将一个对象序列化两次，那么反序列化将得到两个相同的对象。生成的序列化版本号是类的指纹，使用 SHA 计算结果的前 8 个字节表示。在反序列化时，会比较存储的指纹和当前指纹，如果不匹配就说明对象所属类的定义在序列化该对象后修改过，从而会产生 InvalidClassException 异常。此时，如果想要反序列化成功，就需要在类的定义中添加旧版本类的指纹，以此表明它对旧版本兼容。</p>
<p>使用 ObjectOutputStream 的 writeObject 方法将对象序列化，ObjectInputStream 的 readObject 方法将对象反序列化。反序列化时，要保证序列化对象所属的类在类路径中，否则在类型转换时会抛出 ClassNotFoundException 异常。</p>
<p>可以实现 Externalizable 接口对序列化的过程进行控制，该接口继承自 Serializable 接口。</p>
<ul>
<li>Serializable：将对象完全序列化，并且反序列化时不会调用构造器。</li>
<li>Externalizable：序列化时调用 writeExternal 方法序列化字段，反序列化时首先调用公共的无参构造器，然后调用 readExternal 方法反序列化字段。</li>
</ul>
<p>如果不想实现 Externalizable 接口，还可以在类中定义 writeObject/readObject 方法，方法会在序列化/反序列化时自动调用。方法需要按照如下格式定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果想在 writeObject/readObject 方法中使用默认的序列化/反序列化机制，可以在其中调用 ObjectOutputStream/ObjectInputStream 的 defaultWriteObject/defaultReadObject 方法。</p>
<p><strong>思考：序列化单例有什么问题？如何解决？</strong></p>
<p>如果将单例序列化，在反序列化时将得到不同的对象。解决方案是，在 readResolve 方法中返回单例对象，该方法会在反序列化时被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器">容器</h2>
<p>集合类会以内部类的形式实现 Iterator 接口。Collection 接口继承自 Iterable 接口，所以可以使用 Iterable 接口中的 iterator 方法获取 Iterator 对象来遍历集合。Map 接口的 entrySet 方法会返回 Collection 类型的对象，所以也支持迭代器遍历。</p>
<p><img src="/img/Java.assets/1666684482708.png" alt=""></p>
<p><img src="/img/Java.assets/1666684780700.png" alt=""></p>
<h3 id="Collection">Collection</h3>
<h4 id="List">List</h4>
<p>List 表示有序集合，可以存储重复的元素。</p>
<h5 id="ArrayList">ArrayList</h5>
<p>ArrayList 是支持动态扩容的数组，它的底层是一个 Object 类型的数组，所以可以存放任何类型的元素。</p>
<p>虽然底层数组的默认初始容量是 10，但是如果在创建时没有指定容量，并不会立即创建容量为 10 的数组，而是将创建数组的操作延迟到添加元素时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 transient 关键字修饰数组字段，表示不自动序列化，而是在 writeObject 方法中自定义序列化方式。因为数组元素数量小于等于数组容量，只序列化有效元素可以减少空间占用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
<h5 id="LinkedList">LinkedList</h5>
<p>LinkedList 的底层是一个双向链表，实现自 List 和 Deque 接口。</p>
<p>使用 get 方法获取指定索引的值时，会根据索引是否小于链表长度的一半，来决定正序或倒序遍历。如果使用默认序列化，则会丢失头节点和尾节点之间的所有节点，所以使用 transient 修饰相关字段，然后手动序列化链表元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h4 id="Set">Set</h4>
<p>Set 表示没有重复元素的集合。HashSet 的底层是 HashMap，只是所有的 value 都是相同的单例对象。LinkedHashSet 的底层是 LinkedHashMap，TreeSet 的底层是 TreeMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Map">Map</h3>
<h4 id="HashMap">HashMap</h4>
<p>HashMap 的底层是数组 + 链表/红黑树，不能保证迭代的顺序，遍历的时间与哈希表的容量和元素数量成正比。</p>
<p>默认容量是 16，负载因子是 0.75。在构造器中，不会创建底层数组，只会将负载因子和阈值初始化，数组的创建延迟到添加元素时。在源代码中，threshold 不只是存储阈值，在构造器中还会临时存储容量，该值会在初始扩容时使用。</p>
<p>当桶中的节点数量大于等于 8 时，如果哈希表的容量小于 64，会执行扩容操作，否则会将链表转为红黑树（树化）。当桶中的节点数量小于等于 6 时，会将红黑树转为链表（取消树化）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>计算哈希值时会将高位和低位异或，因为哈希表的容量总是 2 的幂，计算索引值时高位变化不会引起索引变化，从而会产生严重的哈希冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当元素数量大于扩容阈值时（容量和负载因子的乘积），会将容量扩容为原来的 2 倍。由于容量是 2 倍的关系，所以元素的索引值要么不变，要么加上旧容量的大小，取决于 <code>e.hash &amp; oldCap</code> 的值。</p>
<h4 id="LinkedHashMap">LinkedHashMap</h4>
<p>LinkedHashMap 具有确定的迭代顺序，默认是按插入顺序遍历。底层是哈希表 + 双向链表，遍历的时间只与元素数量成正比（通过双向链表遍历）。双向链表使用尾插法，头节点表示最早插入/访问的节点，尾节点表示最近插入/访问的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表的元素排列方式</span></span><br><span class="line"><span class="comment">// false 按插入顺序排列（默认）</span></span><br><span class="line"><span class="comment">// true 按访问顺序排列（实现 LRU 算法）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap 添加元素的方法继承自 HashMap，但是以下方法被重写，用于实现双向链表的排列和淘汰策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是按访问顺序排列，则将访问的结点移动到链表尾部</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在插入元素后调用，内部调用 removeEldestEntry 方法，用于实现淘汰策略</span></span><br><span class="line"><span class="comment">// removeEldestEntry 方法默认返回 false，即不会进行淘汰</span></span><br><span class="line"><span class="comment">// 可以重写该方法结合 accessOrder = true，来实现 LRU 淘汰策略</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span></span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%E8%AF%AD%E8%A8%80/page/3/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%AF%AD%E8%A8%80/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/">1</a></li><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/page/3/">3</a></li><li><a class="pagination-link is-current" href="/categories/%E8%AF%AD%E8%A8%80/page/4/">4</a></li><li><a class="pagination-link" href="/categories/%E8%AF%AD%E8%A8%80/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">153</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-26T00:11:50.404Z">2025-04-26</time></p><p class="title"><a href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> / <a href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-18T10:01:46.499Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-17T16:42:59.185Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/CMU%2015-445645%20%E2%80%94%20Fall%202024%20Projects/">CMU 15-445/645 — Fall 2024 Projects</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-26T13:03:18.733Z">2025-03-26</time></p><p class="title"><a href="/2025/03/26/Kafka/">Kafka 4.0（草稿）</a></p><p class="categories"><a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a> / <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/">Kafka</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">43</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">99</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>