<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 算法 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">算法</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-18T09:39:58.364Z" title="2023/12/18 下午5:39:58">2023-12-18</time>发表</span><span class="level-item"><time dateTime="2023-12-18T09:41:08.759Z" title="2023/12/18 下午5:41:08">2023-12-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">8 分钟读完 (大约1259个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/18/%E7%AC%AC%20376%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 376 场力扣周赛</a></p><div class="content"><h2 id="使数组成为等数数组的最小代价"><a href="#使数组成为等数数组的最小代价" class="headerlink" title="使数组成为等数数组的最小代价"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/">使数组成为等数数组的最小代价</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入长度为 \(n\) 的整数数组 \(a\)，输出执行任意次操作后使得数组中的数全部相等并且是回文数的最小代价（要求该回文数小于 \(10^{9}\)）。每次操作可以将数组中的某个数（假设为 \(a_{i}\)）修改为任意正整数（假设为 \(x\)），对应的代价为 \(|a_{i}-x|\)。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)，\(1\leq a_{i}\leq10^{9}\)。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果没有限制是回文数，那么将数组排序之后按如下方式修改，代价是最小的（假设有序数组中的元素为 \(a_{0},a_{1},\dots,a_{n-1}\)）：</p>
<ul>
<li>当 \(n\) 为奇数时，将所有数修改为中位数 \(a_{\lfloor\frac{n}{2}\rfloor}\)。</li>
<li>当 \(n\) 为偶数时，将所有数修改为区间 \([a_{\lfloor\frac{n-1}{2}\rfloor},a_{\lfloor\frac{n}{2}\rfloor}]\) 内的某个数。</li>
</ul>
<p>首先使用反证法证明，最小代价可以通过将所有数修改为数组中的某个数取到。</p>
<ul>
<li>假设将所有数修改为 \(x\)，\(x\) 在区间 \((a_{i},a_{i+1})\) 范围内，其中 \(a_{i}\) 和 \(a_{i+1}\) 表示数组中相邻的两个数。此时 \(x\) 左边有 \(i+1\) 个元素，右边有 \(n-i\) 个元素。将 \(x\) 修改为 \(a_{i+1}\) 会使代价增加 \((i+1)\times (a_{i+1}-x)\)，并且使代价减少 \((n-i)\times(a_{i+1}-x)\)。将 \(x\) 修改为 \(a_{i}\) 会使代价减少 \((i+1)\times (x-a_{i})\)，并且使代价增加 \((n-i)\times(x-a_{i})\)。</li>
<li>当 \(i+1&lt;n-i\) 时，将 \(x\) 修改为 \(a_{i+1}\) 会使代价减少；当 \(i+1&gt;n-i\) 时，将 \(x\) 修改为 \(a_{i}\) 会使代价减少；当 \(i+1&#x3D;n-i\) 时，将 \(x\) 修改为 \(a_{i}\) 或者 \(a_{i+1}\) 代价不变。</li>
<li>特别的，\(x\) 在区间 \([1,a_{0})\) 或者 \((a_{n-1},+\infty]\) 范围内时，同理。</li>
</ul>
<p>然后再使用反证法证明上述结论：</p>
<ul>
<li>假设将数组中的数都修改为 \(a_{i}\) 时，代价最小，\(a_{i}\) 不满足上述条件。</li>
<li>当 \(n\) 为奇数时，由于 \(a_{i}\) 不是中位数：<ul>
<li>当 \(i&lt;\lfloor\frac{n}{2}\rfloor\) 时，有 \(i+1&lt;n-1-i\)，此时 \(i\) 每向中位数移动一位，代价都会减少 \((n-1-i)-(i+1)&gt;0\)。</li>
<li>反之亦然。</li>
</ul>
</li>
<li>当 \(n\) 为偶数时，同理。</li>
</ul>
<p>综上，得出按照上述方式修改代价最少，即 \(x\) 越靠近中位数代价越小。所以，如果需要将所有数修改为某个回文数，那么该回文数一定是最靠近中位数的回文数。PS：还是灵神的<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/solutions/2569308/yu-chu-li-hui-wen-shu-zhong-wei-shu-tan-7j0zy/">证明</a>更简单。</p>
<p>该题有两种方法可以找到距离 \(x\) 的最近回文数：</p>
<ul>
<li>方法一：将 \(x\) 的前半部分作为回文根，对称之后得到回文数 \(y\)。如果 \(y&lt;x\)，则将回文根加一再做对称得到回文数 \(z\)，然后取 \(y\) 和 \(z\) 中距离最近者；如果 \(y&gt;x\)，则将回文根减一再做对称得到回文数 \(z\)，然后取 \(y\) 和 \(z\) 中距离最近者；否则，\(x\) 本身就是回文数。注意，排除大于等于 \(10^{9}\) 的回文数，以及做加减法时可能会遇到回文根为 \(100\dots0\) 或 \(99\dots9\) 的特殊情况，此时做对称会得到错误答案，我们应该直接根据长度构造回文数。（这个<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-closest-palindrome/solutions/1300885/xun-zhao-zui-jin-de-hui-wen-shu-by-leetc-biyt/">代码</a>还挺好看，把所有情况都直接循环枚举，就可以不用写那么多判断语句）</li>
<li>方法二：枚举出 \([1,10^{9}]\) 范围内的所有回文数，然后二分找到距离 \(x\) 最近的回文数。</li>
</ul>
<h2 id="执行操作使频率分数最大"><a href="#执行操作使频率分数最大" class="headerlink" title="执行操作使频率分数最大"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/">执行操作使频率分数最大</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>输入长度为 \(n\) 的整数数组 \(a\) 和一个整数 \(k\)，输出经过至多 \(k\) 次操作之后，数组中众数的最大频率。每次操作可以选择数组中的某个数 \(a_{i}\)，将其增加或者减少 \(1\)。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)，\(1\leq a_{i}\leq 10^{9}\)，\(0\leq k\leq 10^{14}\)。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>排序 + 前缀和 + 滑动窗口。要使众数尽可能多，可以首先对数组排序，假设最终众数有 \(x\) 个，那么这 \(x\) 个数一定是在某个子数组中。使用滑动窗口，将尽可能多的数包含在窗口内，同时满足操作次数小于等于 \(k\)，如果大于 \(k\) 则将左端点右移。类似上一题，将窗口内的所有数都修改为窗口的中位数，所需的操作次数最少。窗口的操作次数可以使用前缀和 \(O(1)\) 的计算出来，假设窗口的左右端点的下标分别为 \(i\) 和 \(j\)，中位数的下标为 \(k\)，则窗口的操作次数为：\((a_{k}\times (k-i)-(s[k]-s[i]))+((s[j+1]-s[k+1])-a_{k}\times (j-k))\)。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-18T09:37:47.409Z" title="2023/12/18 下午5:37:47">2023-12-18</time>发表</span><span class="level-item"><time dateTime="2023-12-18T09:39:10.173Z" title="2023/12/18 下午5:39:10">2023-12-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/">Codeforces</a></span><span class="level-item">5 分钟读完 (大约741个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/18/Codeforces%20Round%20915%20(Div.%202)/">Codeforces Round 915 (Div. 2)</a></p><div class="content"><h2 id="Begginer’s-Zelda"><a href="#Begginer’s-Zelda" class="headerlink" title="Begginer’s Zelda"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1905/problem/B">Begginer’s Zelda</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一颗树，输出执行的最少操作次数，使得该树只有一个节点。每次操作可以选择树中的两个节点，将它们之间的路径压缩为一个节点，所有连接路径上节点的边都会连向新节点。</p>
<p>数据范围：\(2\leq n\leq 10^{5}\)，\(1\leq u_{i},v_{i}\leq n\)，\(u_{i}\neq v_{i}\)。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次操作贪心的选择两个叶子节点（度数为 \(1\) 的节点都看作叶子），根据叶子节点的数量 \(x\) 的奇偶性分类讨论：</p>
<ul>
<li>如果 \(x\) 为奇数，\(x&#x3D;1\) 需要 \(0\) 次操作，\(x&#x3D;3\) 需要 \(2\) 次操作，之后每增加两个叶子，都会使操作次数加 \(1\)，由于数据范围限制初始时叶子至少有 \(2\) 个，所以操作次数为 \(\frac{x+1}{2}\)。</li>
<li>如果 \(x\) 为偶数，\(x&#x3D;2\) 需要 \(1\) 次操作，\(x&#x3D;4\) 需要 \(2\) 次操作，之后每增加两个叶子，都会使操作次数加 \(1\)，所以操作次数为 \(\frac{x}{2}\)。</li>
<li>最后，可以将两种情况的公式合并为 \(\lfloor\frac{x+1}{2}\rfloor\)。</li>
</ul>
<h2 id="Largest-Subsequence"><a href="#Largest-Subsequence" class="headerlink" title="Largest Subsequence"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1905/problem/C">Largest Subsequence</a></h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>输入长度为 \(n\) 的字符串 \(s\)，输出执行的最少操作次数，使得字符串有序。每次操作可以将字符串中字典序最大的子序列循环右移一位。</p>
<p>数据范围：\(1\leq n\leq 2\cdot 10^{5}\)。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先使用单调栈求出字典序最大的子序列（非严格单调递减），然后通过观察可以发现，执行多次操作最终会将该子序列反转。相当于求最少右移次数，使得子序列反转，该次数等于子序列长度减去子序列中最大字符的数量。其次，还需要判断子序列反转之后，字符串是否有序。</p>
<h2 id="Cyclic-MEX"><a href="#Cyclic-MEX" class="headerlink" title="Cyclic MEX"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1905/problem/D">Cyclic MEX</a></h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>输入一个包含 \({0,1,2,\dots,n-1}\) 的排列 \(p\)，输出排列 \(p\) 的所有循环移动的最大代价。对于数组 \(a\)，它的代价为 \(\sum_{i&#x3D;1}^{n}{\operatorname{mex}([a_{1},a_{2},\dots,a_{i}])}\)。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>观察每循环左移一次，代价是如何变化的：</p>
<p>排列 \(2,3,6,7,0,1,4,5\) 对应的代价为 \(0,0,0,0,1,4,5,8\)；</p>
<p>排列 \(3,6,7,0,1,4,5,2\) 对应的代价为 \(0,0,0,1,2,2,2,8\)；</p>
<p>排列 \(6,7,0,1,4,5,2,3\) 对应的代价为 \(0,0,1,2,2,2,3,8\)。</p>
<p>可以发现每当将数 \(x\) 移动到排列末尾，所有大于 \(x\) 的 \(\operatorname{mex}\) 值都会变为 \(x\)，然后 \(x\) 位置对应的 \(\operatorname{mex}\) 值为 \(n\)。</p>
<p>我们可以首先将排列移动为 \(1,4,5,2,3,6,7,0\) 形式，对应的代价为 \(0,0,0,0,0,0,0,8\)。然后使用单调递增栈维护左移的数构成的递增序列，栈中存储数的下标，模拟上述过程并维护最大代价。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-10T07:16:56.632Z" title="2023/12/10 下午3:16:56">2023-12-10</time>发表</span><span class="level-item"><time dateTime="2023-12-10T07:19:39.139Z" title="2023/12/10 下午3:19:39">2023-12-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">4 分钟读完 (大约546个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/10/%E7%AC%AC%20375%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 375 场力扣周赛</a></p><div class="content"><h2 id="统计最大元素出现至少-K-次的子数组"><a href="#统计最大元素出现至少-K-次的子数组" class="headerlink" title="统计最大元素出现至少 K 次的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/">统计最大元素出现至少 K 次的子数组</a></h2><p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的数组 \(a\) 和整数 \(k\)，输出满足 \(\max(a)\) 至少出现 \(k\) 次的子数组的数目。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)，\(1\leq k\leq 10^{5}\)。</p>
<p><strong>思路</strong></p>
<p>首先计算出最大值，然后将所有最大值的下标放入列表 \(l\) 中，最后枚举右端点即可。假设列表的长度为 \(m\)，当前枚举到 \(i\)，当 \(i&lt;m-1\) 时，区间 \([l[i],l[i+1]-1]\) 范围内的右端点都对应 \(l[i-k+1]+1\) 数量的左端点，将它们相乘加入答案。特别的，当 \(i&#x3D;m-1\) 时，取区间 \([l[i],n-1]\)。PS：也可以滑动窗口，使窗口内只包含 \(k-1\) 个最大值，这样计算答案的空间复杂度为 \(O(1)\)。</p>
<h2 id="统计好分割方案的数目"><a href="#统计好分割方案的数目" class="headerlink" title="统计好分割方案的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-good-partitions/">统计好分割方案的数目</a></h2><p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的数组 \(a\)，输出将数组分割为若干不相交子数组的方案数。不相交表示子数组之间没有相同的元素，答案对 \(10^{9}+7\) 取余。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)。</p>
<p><strong>思路</strong></p>
<p>因为要求子数组之间没有相同元素，那么相同元素必定只会出现在一个子数组中，首先统计每个元素的最小和最大下标，这两个下标构成的区间是不可分割的。然后将所有不可分割的区间进行合并，最后剩余的区间数假设为 \(m\)，那么就会有 \(2^{m-1}\) 种分割方案（因为 \(m\) 个区间有 \(m-1\) 个分割位置，每个分割位置有分割或者不分割两种状态）。PS：① 可以边计数边做乘法，不使用快速幂；② 可以只统计最大下标，然后遍历数组时维护最大下标的最大值，如果当前下标等于该值，那么就可以做一次分割。（<a target="_blank" rel="noopener" href="https://leetcode.cn/submissions/detail/487973037/">代码</a>）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-10T07:12:26.467Z" title="2023/12/10 下午3:12:26">2023-12-10</time>发表</span><span class="level-item"><time dateTime="2023-12-10T07:15:23.954Z" title="2023/12/10 下午3:15:23">2023-12-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">3 分钟读完 (大约464个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/10/%E7%AC%AC%20119%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/">第 119 场力扣夜喵双周赛</a></p><div class="content"><h2 id="消除相邻近似相等字符"><a href="#消除相邻近似相等字符" class="headerlink" title="消除相邻近似相等字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-adjacent-almost-equal-characters/">消除相邻近似相等字符</a></h2><p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的字符串 \(s\)，输出所需的最少操作次数，使得字符串 \(s\) 中的相邻字符在字母表中的距离大于 \(1\)。每次操作可以将字符串 \(s\) 中的某个字符修改为任意字符。</p>
<p>数据范围：\(1\leq n\leq 100\)。</p>
<p><strong>思路</strong></p>
<p>思路一：距离大于 \(1\) 的相邻字符可以将字符串 \(s\) 分割为若干子串，每个子串所需的最少操作次数为 \(\lfloor\frac{l}{2}\rfloor\)，其中 \(l\) 表示子串的长度。</p>
<p>思路二：如果相邻字符距离小于等于 \(1\)，那么贪心的修改右边的字符即可。</p>
<p>两种思路原理是一样的，只是实现时略有不同。</p>
<h2 id="关闭分部的可行集合数目"><a href="#关闭分部的可行集合数目" class="headerlink" title="关闭分部的可行集合数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/">关闭分部的可行集合数目</a></h2><p><strong>题目</strong></p>
<p>输入整数 \(n\) 表示有 \(n\) 个节点，长度为 \(m\) 表示无向边的数组 \(e\)（包含重边），以及整数 \(d\)。输出删除节点的方案数，使得剩余节点两两之间的最短路不超过 \(d\)。</p>
<p>数据范围：\(1\leq n\leq 10\)，\(0\leq m\leq 1000\)。其他数据不会影响时间复杂度，所以不列出。</p>
<p><strong>思路</strong></p>
<p>题目要求满足条件的方案数，首先想到枚举所有方案，总共有 \(2^{n}\) 个方案，然后对每个方案求删除节点后的多源最短路（Floyd 算法），如果剩余节点两两之间的最短路都不超过 \(d\)，那么答案就加一，总时间复杂度为 \(O(m+2^{n}n^{3})\)。因为是求最短路，所以重边可以只保留最小的那条边。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-05T03:28:53.458Z" title="2023/12/5 上午11:28:53">2023-12-05</time>发表</span><span class="level-item"><time dateTime="2023-12-05T03:31:20.901Z" title="2023/12/5 上午11:31:20">2023-12-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">6 分钟读完 (大约867个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/05/%E7%AC%AC%20374%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 374 场力扣周赛</a></p><div class="content"><h2 id="需要添加的硬币的最小数量"><a href="#需要添加的硬币的最小数量" class="headerlink" title="需要添加的硬币的最小数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/">需要添加的硬币的最小数量</a></h2><p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的数组 \(a\) 和整数 \(k\)，输出需要向数组插入多少个数，使得数组的子序列能够表示 \([1,k]\) 范围内的所有整数。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)，\(1\leq a_{i}\leq k\leq 10^{5}\)。</p>
<p><strong>思路</strong></p>
<p>从小到大遍历数组，假设当前能够表示的区间为 \([0,s]\)，此时遍历到数组中的数 \(a_{i}\)，我们可以表示区间 \([a_{i},s+a_{i}]\)。</p>
<ul>
<li>如果 \(a_{i}\leq s+1\)，那么就可以合并两个区间，得到 \([0,s+a_{i}]\)，然后继续遍历 \(a_{i+1}\)。</li>
<li>否则，需要向数组插入数 \(s+1\) 来保证区间连续，得到 \([0,2s+1]\)，然后再次遍历 \(a_{i}\)。</li>
<li>不断重复上述过程直到能够表示区间 \([1,k]\)。</li>
</ul>
<p>排序数组的时间复杂度为 \(O(n\log{n})\)，插入操作最多执行 \(O(\log{k})\) 次。</p>
<h2 id="统计完全子字符串"><a href="#统计完全子字符串" class="headerlink" title="统计完全子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-substrings/">统计完全子字符串</a></h2><p><strong>题目</strong></p>
<p>输入长度为 \(n\) 的由小写英文字母组成的字符串 \(s\) 和整数 \(k\)，输出满足以下两个条件的子字符串的个数。</p>
<ul>
<li>每个字符恰好出现 \(k\) 次。</li>
<li>相邻字符在字母表中的距离小于等于 \(2\)。</li>
</ul>
<p>数据范围：\(1\leq k\leq n\leq 10^{5}\)。</p>
<p><strong>思路</strong></p>
<p>距离大于 \(2\) 的相邻字符可以将字符串分割成若干子串，对于每个子串 \(t\) 考虑满足条件一的子串 \(t_{i}\) 个数即可。我们可以枚举 \(t_{i}\) 包含多少个不同的字符（设为 \(x\)），对于每个 \(x\) 使用滑动窗口可以得到 \(t\) 中满足条件一的长度为 \(kx\) 的子串个数。时间复杂度为 \(O(|\Sigma| n)\)，外层循环执行 \(O(|\Sigma|)\) 次，内层循环滑窗执行 \(O(n)\) 次，滑窗的同时使用计数数组统计有多少个字符恰好出现 \(k\) 次，判断的时间复杂度为 \(O(1)\)。</p>
<h2 id="统计感冒序列的数目"><a href="#统计感冒序列的数目" class="headerlink" title="统计感冒序列的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-infection-sequences/">统计感冒序列的数目</a></h2><p><strong>题目</strong></p>
<p>输入整数 \(n\) 和长度为 \(m\) 的按照升序排列的数组 \(a\)，数组 \(a\) 存储下标 \([0,n-1]\) 的子序列，输出所有不在数组 \(a\) 中的下标被选择的方案数，答案对 \(10^{9}+7\) 取余。下标 \(i\) 可以被选择，当且仅当下标 \(i-1\) 或者 \(i+1\) 被选择，数组 \(a\) 中的下标可以看作是被选择的。</p>
<p>数据范围：\(2\leq n\leq 10^{5}\)，\(1\leq m\leq n-1\)，\(0\leq a_{i}\leq n-1\)。</p>
<p><strong>思路</strong></p>
<p>数组 \(a\) 中的下标将 \([0,n-1]\) 划分为多个子数组，首先考虑每个子数组内部的方案数：最左和最右的子数组只存在一种选择方案，其他子数组存在 \(2^{x_{i}-1}\) 种选择方案，\(x_{i}\) 为该子数组的长度。然后考虑子数组之间的方案数，最初我们有 \(n-m\) 个位置可以放置下标，假设各个子数组的长度分别为 \(x_{0},x_{1},\dots,x_{k}\)，那么总共有 \(\prod_{i&#x3D;0}^{k}{C(n-m-\sum_{j&#x3D;0}^{i-1}{x_{j}},x_{i})}&#x3D;\frac{(n-m)!}{\prod_{i&#x3D;0}^{k}{x_{i}!}}\) 种放置方案。将两者相乘即可得到答案，计算过程需要使用逆元和快速幂。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-27T03:49:05.298Z" title="2023/11/27 上午11:49:05">2023-11-27</time>发表</span><span class="level-item"><time dateTime="2023-11-27T03:51:08.910Z" title="2023/11/27 上午11:51:08">2023-11-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/">Codeforces</a></span><span class="level-item">5 分钟读完 (大约766个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/27/Codeforces%20Round%20911%20(Div.%202)/">Codeforces Round 911 (Div. 2)</a></p><div class="content"><h2 id="Cover-in-Water"><a href="#Cover-in-Water" class="headerlink" title="Cover in Water"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1900/problem/A">Cover in Water</a></h2><p>只要存在三个连续的空格，就可以执行两次操作一，再多次执行操作二，来装满所有空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> io.next();</span><br><span class="line">    String[] arr = s.split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String t : arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length();</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            io.println(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += m;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Laura-and-Operations"><a href="#Laura-and-Operations" class="headerlink" title="Laura and Operations"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1900/problem/B">Laura and Operations</a></h2><p>注意题目说的是剩下一种类型的数字，而不是一个数字。如果剩下数字 \(1\)，那么首先将 \(2\) 和 \(3\) 抵消，如果 \(2\) 多于 \(3\)，那么多出的数量如果是偶数，就可以将该数量的一半执行操作，再做一次抵消，最后就只剩下 \(1\)；反之亦然。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> io.nextInt(), b = io.nextInt(), c = io.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(b - c) % <span class="number">2</span> == <span class="number">0</span>) io.print(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> io.print(<span class="number">0</span>);</span><br><span class="line">    io.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(a - c) % <span class="number">2</span> == <span class="number">0</span>) io.print(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> io.print(<span class="number">0</span>);</span><br><span class="line">    io.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(a - b) % <span class="number">2</span> == <span class="number">0</span>) io.print(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> io.print(<span class="number">0</span>);</span><br><span class="line">    io.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Anji’s-Binary-Tree"><a href="#Anji’s-Binary-Tree" class="headerlink" title="Anji’s Binary Tree"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1900/problem/C">Anji’s Binary Tree</a></h2><p>做一次后序遍历即可。题目说的是选择任意字母替换，而不是选择其他节点上的字母替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> io.next();</span><br><span class="line">    <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> io.nextInt() - <span class="number">1</span>, r = io.nextInt() - <span class="number">1</span>;</span><br><span class="line">        g[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(dfs(<span class="number">0</span>, g, s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>[][] g, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g[x][<span class="number">0</span>] == -<span class="number">1</span> &amp;&amp; g[x][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (g[x][<span class="number">0</span>] != -<span class="number">1</span>) &#123;</span><br><span class="line">        res = Math.min(res, dfs(g[x][<span class="number">0</span>],g, s) + (s.charAt(x) != <span class="string">&#x27;L&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g[x][<span class="number">1</span>] != -<span class="number">1</span>) &#123;</span><br><span class="line">        res = Math.min(res, dfs(g[x][<span class="number">1</span>],g, s) + (s.charAt(x) != <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Small-GCD"><a href="#Small-GCD" class="headerlink" title="Small GCD"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1900/problem/D">Small GCD</a></h2><p>\(f(a,b,c)\) 表示 \(a,b,c\) 中最小的两个数的 \(\gcd\)，而我们要求出给定数组的所有不同下标构成的三元组的 \(f\) 之和。暴力的想法是枚举中间值，然后计算以该值为中心构成的三元组的 \(\gcd\) 之和，时间复杂度为 \(O(n^{2})\)。正确的做法：由于数据范围比较小，我们可以首先计算出 \([1,N]\) 范围内每个数的所有约数，然后排序数组，对数组中的每个数枚举它的约数，从而计算出以该约数的倍数作为最大公约数的三元组的个数，然后利用容斥原理得到以该约数作为最大公约数的三元组的个数，最后可以计算出答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt;[] aux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="title class_">List</span>[N + <span class="number">1</span>];</span><br><span class="line">    Arrays.setAll(aux, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= N; j += i) &#123;</span><br><span class="line">            aux[j].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = io.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="type">long</span>[] f = <span class="keyword">new</span> <span class="title class_">long</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : aux[a[i]]) &#123;</span><br><span class="line">            f[x] += (<span class="type">long</span>) c[x] * (n - i - <span class="number">1</span>);</span><br><span class="line">            c[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + i; j &lt;= N; j += i) &#123;</span><br><span class="line">            f[i] -= f[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += f[i] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Transitive-Graph"><a href="#Transitive-Graph" class="headerlink" title="Transitive Graph"></a><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1900/problem/E">Transitive Graph</a></h2><p>似乎是和强连通分量相关的题目，有空可以补一下。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-26T12:20:16.313Z" title="2023/11/26 下午8:20:16">2023-11-26</time>发表</span><span class="level-item"><time dateTime="2023-11-26T12:20:52.243Z" title="2023/11/26 下午8:20:52">2023-11-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">5 分钟读完 (大约724个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/26/%E7%AC%AC%20373%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 373 场力扣周赛</a></p><div class="content"><h2 id="循环移位后的矩阵相似检查"><a href="#循环移位后的矩阵相似检查" class="headerlink" title="循环移位后的矩阵相似检查"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/matrix-similarity-after-cyclic-shifts/">循环移位后的矩阵相似检查</a></h2><p>模拟。有个性质，如果左移 \(k\) 位之后相等，则右移 \(k\) 位也必定相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSimilar</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] != mat[i][((j + (i % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>) * k) % n + n) % n]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统计美丽子字符串-I"><a href="#统计美丽子字符串-I" class="headerlink" title="统计美丽子字符串 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-beautiful-substrings-i/">统计美丽子字符串 I</a></h2><p>将元音字母看作 \(1\)，非元音字母看作 \(-1\)，使用前缀和 + 哈希表的技巧，可以得到若干个分组，每组中任意两个下标构成的子数组都满足条件一。然后我们可以暴力判断所有满足条件一的子数组的长度是否满足条件二，时间复杂度为 \(O(n^{2})\)。（补充：可以纯暴力做，不需要分组。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beautifulSubstrings</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), sum = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = Set.of(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.computeIfAbsent(<span class="number">0</span>, t -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += set.contains(s.charAt(i)) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            map.computeIfAbsent(sum, t -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> list : map.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size() ; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (list.get(j) - list.get(i)) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (len * len % k == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交换得到字典序最小的数组"><a href="#交换得到字典序最小的数组" class="headerlink" title="交换得到字典序最小的数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/">交换得到字典序最小的数组</a></h2><p>如果 \(|nums[i]-nums[j]|&lt;&#x3D;limit\)，那么就可以交换 \(nums[i]\) 和 \(nums[j]\)，该交换的性质具有传递性，所以我们可以对原数组进行排序，只要相邻元素的差值小于等于 \(limit\)，它们就在同一个可交换集合中。这样可以将原数组划分为若干可交换集合，然后对每个集合排序，从小到大排列即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] lexicographicallySmallestArray(<span class="type">int</span>[] nums, <span class="type">int</span> limit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">var</span> <span class="variable">aux</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            aux[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(aux, (i, j) -&gt; nums[i] - nums[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -limit;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : aux) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - pre &gt; limit) &#123;</span><br><span class="line">                buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            buckets.get(buckets.size() - <span class="number">1</span>).add(i);</span><br><span class="line">            pre = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> bucket : buckets) &#123;</span><br><span class="line">            List&lt;Integer&gt; pos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            pos.addAll(bucket);</span><br><span class="line">            Collections.sort(pos);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">                ans[pos.get(i)] = nums[bucket.get(i)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="统计美丽子字符串-II"><a href="#统计美丽子字符串-II" class="headerlink" title="统计美丽子字符串 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-beautiful-substrings-ii/">统计美丽子字符串 II</a></h2><p>朴素做法的瓶颈在 \((\frac{L}{2})^{2}\bmod{k}&#x3D;0\) 的判断上，可以通过将条件二变换为 \(L\bmod{k^{\prime}}&#x3D;0\)，然后使用前缀和以及下标模 \(k^{\prime}\) 的值来分组，这样同组内的下标两两组合得到的必定是满足两个条件的子数组。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-beautiful-substrings-ii/solutions/2542274/fen-jie-zhi-yin-zi-qian-zhui-he-ha-xi-bi-ceil/">灵神题解</a>，时间复杂度 \(O(n+\sqrt{k})\)。还有另一种枚举的做法，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-beautiful-substrings-ii/solutions/2542302/mei-ju-by-tsreaper-1fi2/">题解</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-26T12:18:27.238Z" title="2023/11/26 下午8:18:27">2023-11-26</time>发表</span><span class="level-item"><time dateTime="2023-11-26T12:19:19.792Z" title="2023/11/26 下午8:19:19">2023-11-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">3 分钟读完 (大约435个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/26/%E7%AC%AC%20118%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/">第 118 场力扣夜喵双周赛</a></p><div class="content"><h2 id="查找包含给定字符的单词"><a href="#查找包含给定字符的单词" class="headerlink" title="查找包含给定字符的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-words-containing-character/">查找包含给定字符的单词</a></h2><p>模拟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findWordsContaining</span><span class="params">(String[] words, <span class="type">char</span> x)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].contains(x + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大化网格图中正方形空洞的面积"><a href="#最大化网格图中正方形空洞的面积" class="headerlink" title="最大化网格图中正方形空洞的面积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/">最大化网格图中正方形空洞的面积</a></h2><p>分别求出行和列的最长连续线段，然后最大正方形面积就是两者最小值加一的平方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximizeSquareHoleArea</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] hBars, <span class="type">int</span>[] vBars)</span> &#123;</span><br><span class="line">        Arrays.sort(hBars);</span><br><span class="line">        Arrays.sort(vBars);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxH</span> <span class="operator">=</span> <span class="number">0</span>, maxV = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; j &lt; hBars.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hBars[j] - hBars[i] == j - i) &#123;</span><br><span class="line">                maxH = Math.max(maxH, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; j &lt; vBars.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vBars[j] - vBars[i] == j - i) &#123;</span><br><span class="line">                maxV = Math.max(maxV, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(maxH, maxV) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> len * len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="购买水果需要的最少金币数"><a href="#购买水果需要的最少金币数" class="headerlink" title="购买水果需要的最少金币数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/">购买水果需要的最少金币数</a></h2><p>动态规划，\(dp[i]\) 表示获取 \([i,n]\) 范围内所有水果所需的最少金币数，有 \(dp[i]&#x3D;prices[i]+\min_{j&#x3D;i+1}^{2i+1}{dp[j]}\)，时间复杂度 \(O(n^{2})\)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCoins</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= <span class="number">2</span> * i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                min = Math.min(min, prices[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            prices[i - <span class="number">1</span>] += min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prices[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单调队列优化，时间复杂度 \(O(n)\)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCoins</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peekFirst() &gt; <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">                q.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= (n + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                prices[i - <span class="number">1</span>] += prices[q.peekFirst() - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; prices[q.peekLast() - <span class="number">1</span>] &gt;= prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                q.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prices[q.peekLast() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到最大非递减数组的长度"><a href="#找到最大非递减数组的长度" class="headerlink" title="找到最大非递减数组的长度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/">找到最大非递减数组的长度</a></h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/solutions/2542102/dan-diao-dui-lie-you-hua-dp-by-endlessch-j5qd/">单调队列优化 DP</a>，随缘补题。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-26T12:16:14.894Z" title="2023/11/26 下午8:16:14">2023-11-26</time>发表</span><span class="level-item"><time dateTime="2023-11-26T12:17:19.771Z" title="2023/11/26 下午8:17:19">2023-11-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/">AtCoder</a></span><span class="level-item">4 分钟读完 (大约558个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/26/AtCoder%20Beginner%20Contest%20330/">AtCoder Beginner Contest 330</a></p><div class="content"><h2 id="Counting-Passes"><a href="#Counting-Passes" class="headerlink" title="Counting Passes"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc330/tasks/abc330_a">Counting Passes</a></h2><p>模拟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt(), l = io.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (io.nextInt() &gt;= l) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimize-Abs-1"><a href="#Minimize-Abs-1" class="headerlink" title="Minimize Abs 1"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc330/tasks/abc330_b">Minimize Abs 1</a></h2><p>等价于求 \(y&#x3D;|x-a_{i}|\) 在区间 \([L,R]\) 内的最小值对应的 \(x\)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt(), l = io.nextInt(), r = io.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= a &amp;&amp; a &lt;= r) &#123;</span><br><span class="line">            io.print(a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; l) &#123;</span><br><span class="line">            io.print(l + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            io.print(r + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Minimize-Abs-2"><a href="#Minimize-Abs-2" class="headerlink" title="Minimize Abs 2"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc330/tasks/abc330_c">Minimize Abs 2</a></h2><p>对于每个固定的 \(x\)，可以在 \(O(1)\) 时间内求出 \(|y^{2}+(x^{2}-D)|\) 的最小值（也可以二分），我们枚举 \([0,\lceil\sqrt{D}\rceil]\) 范围内的所有 \(x\)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> io.nextLong();</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="type">long</span> <span class="variable">up</span> <span class="operator">=</span> (<span class="type">long</span>) Math.sqrt(d) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt;= up; x++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> x * x - d;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans = Math.min(ans, t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">long</span>) Math.sqrt(-t);</span><br><span class="line">            ans = Math.min(ans, Math.abs(y * y + x * x - d));</span><br><span class="line">            ans = Math.min(ans, Math.abs((y + <span class="number">1</span>) * (y + <span class="number">1</span>) + x * x - d));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Counting-Ls"><a href="#Counting-Ls" class="headerlink" title="Counting Ls"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc330/tasks/abc330_d">Counting Ls</a></h2><p>对行列计数，然后枚举交叉点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">    <span class="type">char</span>[][] s = <span class="keyword">new</span> <span class="title class_">char</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s[i] = io.next().toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] col = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">                row[i]++;</span><br><span class="line">                col[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; col[j] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans += (<span class="type">long</span>) (col[j] - <span class="number">1</span>) * (row[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mex-and-Update"><a href="#Mex-and-Update" class="headerlink" title="Mex and Update"></a><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc330/tasks/abc330_e">Mex and Update</a></h2><p>因为只有 \(n\) 个数，所以只需要考虑 \([0,n]\) 范围的数的增删，这样集合就可以存储单个数。比赛时没注意，使用的是区间，然后删除区间中的数，需要进行分裂，会麻烦很多，还需要排序以及考虑最左和最右的特殊区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt(), q = io.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = io.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= n) &#123;</span><br><span class="line">            cnt[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q-- != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> io.nextInt() - <span class="number">1</span>, x = io.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= n &amp;&amp; --cnt[a[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            set.add(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= n &amp;&amp; cnt[a[i]]++ == <span class="number">0</span>) &#123;</span><br><span class="line">            set.remove(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        io.println(set.first());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-20T02:26:32.183Z" title="2023/11/20 上午10:26:32">2023-11-20</time>发表</span><span class="level-item"><time dateTime="2023-11-20T02:28:20.156Z" title="2023/11/20 上午10:28:20">2023-11-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">3 分钟读完 (大约429个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/20/%E7%AC%AC%20372%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 372 场力扣周赛</a></p><div class="content"><h2 id="使三个字符串相等"><a href="#使三个字符串相等" class="headerlink" title="使三个字符串相等"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-three-strings-equal/">使三个字符串相等</a></h2><p>等价于求字符串的最长公共前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinimumOperations</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.min(s1.length(), Math.min(s2.length(), s3.length()));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; s1.charAt(i) == s2.charAt(i) &amp;&amp; s2.charAt(i) == s3.charAt(i)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? -<span class="number">1</span> : s1.length() + s2.length() + s3.length() - <span class="number">3</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区分黑球与白球"><a href="#区分黑球与白球" class="headerlink" title="区分黑球与白球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/separate-black-and-white-balls/">区分黑球与白球</a></h2><p>将每个 \(1\) 右边 \(0\) 的个数累加就是需要交换的次数，或者累加每个 \(0\) 左边 \(1\) 的个数也行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumSteps</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;0&#x27;</span>) cnt++;</span><br><span class="line">            <span class="keyword">else</span> ans += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大异或乘积"><a href="#最大异或乘积" class="headerlink" title="最大异或乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-product/">最大异或乘积</a></h2><p>要求 \(\max((a\oplus x)\times(b\oplus x))\)，可以得出异或只会在两者都为 \(0\) 的位上补 \(1\)，或者交换两者某位上的 \(0\) 和 \(1\)。此时 \((a\oplus x)+(b\oplus x)&#x3D;c\)，\(c\) 为某个定值，从而问题可以转化为求函数 \(y&#x3D;x(c-x)\) 的最大值，可以知道当 \(x&#x3D;\frac{c}{2}\) 时取到最大值，即我们需要让 \((a\oplus x)\) 和 \((b\oplus x)\) 尽可能相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumXorProduct</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">p</span> <span class="operator">=</span> a &gt;&gt; n &lt;&lt; n, q = b &gt;&gt; n &lt;&lt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a &gt;&gt; i &amp; <span class="number">1</span>) == (b &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                p |= <span class="number">1L</span> &lt;&lt; i;</span><br><span class="line">                q |= <span class="number">1L</span> &lt;&lt; i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; q) &#123;</span><br><span class="line">                p |= <span class="number">1L</span> &lt;&lt; i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q |= <span class="number">1L</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (p % MOD * (q % MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到-Alice-和-Bob-可以相遇的建筑"><a href="#找到-Alice-和-Bob-可以相遇的建筑" class="headerlink" title="找到 Alice 和 Bob 可以相遇的建筑"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/">找到 Alice 和 Bob 可以相遇的建筑</a></h2><p>离线查询，可以预处理查询序列，然后使用单调栈 + 二分，或者使用最小堆；在线查询，可以使用线段树（暂时不学）。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E7%AE%97%E6%B3%95/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E7%AE%97%E6%B3%95/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E7%AE%97%E6%B3%95/">1</a></li><li><a class="pagination-link" href="/categories/%E7%AE%97%E6%B3%95/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/%E7%AE%97%E6%B3%95/page/8/">8</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">85</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">73</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">基础知识</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-18T09:39:58.364Z">2023-12-18</time></p><p class="title"><a href="/2023/12/18/%E7%AC%AC%20376%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 376 场力扣周赛</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-18T09:37:47.409Z">2023-12-18</time></p><p class="title"><a href="/2023/12/18/Codeforces%20Round%20915%20(Div.%202)/">Codeforces Round 915 (Div. 2)</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Codeforces/">Codeforces</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-10T07:16:56.632Z">2023-12-10</time></p><p class="title"><a href="/2023/12/10/%E7%AC%AC%20375%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 375 场力扣周赛</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-10T07:12:26.467Z">2023-12-10</time></p><p class="title"><a href="/2023/12/10/%E7%AC%AC%20119%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/">第 119 场力扣夜喵双周赛</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-05T03:28:53.458Z">2023-12-05</time></p><p class="title"><a href="/2023/12/05/%E7%AC%AC%20374%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 374 场力扣周赛</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">85</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/I-O/"><span class="tag">I/O</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CLIST</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">阮一峰的网络日志</span></span><span class="level-right"><span class="level-item tag">www.ruanyifeng.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>