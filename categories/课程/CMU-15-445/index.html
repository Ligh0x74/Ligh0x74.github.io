<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: CMU 15-445 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a></li><li class="is-active"><a href="#" aria-current="page">CMU 15-445</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-15T04:04:29.235Z" title="2023/11/15 下午12:04:29">2023-11-15</time>发表</span><span class="level-item"><time dateTime="2023-11-30T02:27:03.478Z" title="2023/11/30 上午10:27:03">2023-11-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">1 分钟读完 (大约217个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/15/CUM%2015-445%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">CUM 15-445 课程总结</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">幻灯片和笔记</a>，<a target="_blank" rel="noopener" href="https://zhenghe.gitbook.io/open-courses/">其他同学整理的笔记</a>，<a target="_blank" rel="noopener" href="https://discord.com/channels/724929902075445281/752529819148877904">Discord 讨论</a>。</p>
<p>本来想做个课程总结和项目总结的，但是有点没心情做，排行榜优化也暂时搁置吧。:(</p>
<hr>
<h2 id="Advanced-SQL"><a href="#Advanced-SQL" class="headerlink" title="Advanced SQL"></a>Advanced SQL</h2><p>查询满足某个条件的记录数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM t WHERE xx;</span><br><span class="line">SELECT SUM(IF(xx, 1, 0)) FROM t;</span><br></pre></td></tr></table></figure>

<p>查询满足某个条件的记录百分率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ROUND(AVG(IFNULL(xx, 0)), 2) FROM t;</span><br></pre></td></tr></table></figure>

<p>窗口函数（文档：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/window-functions.html">12.20 Window Functions</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ROW_NUMBER() OVER(PARTITION BY xx ORDER BY xx) FROM t;</span><br><span class="line">SELECT AVG(xx) OVER (PARTITION BY xx ORDER BY xx ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)</span><br></pre></td></tr></table></figure>

<p>日期和时间函数（文档：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html">12.7 Date and Time Functions</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_FORMAT(xx, xx);</span><br><span class="line">SELECT DATEDIFF(xx, xx);</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-14T02:57:33.978Z" title="2023/11/14 上午10:57:33">2023-11-14</time>发表</span><span class="level-item"><time dateTime="2023-11-14T03:01:15.042Z" title="2023/11/14 上午11:01:15">2023-11-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">15 分钟读完 (大约2187个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/14/Project%204%20-%20Concurrency%20Control/">Project #4 - Concurrency Control</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project4/">Project #4 - Concurrency Control</a>。</p>
<p>准备工作：阅读 <strong>Chapter 18 19</strong>，学习 <strong>Lecture #15 #16 #17 #18 #19 #20</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>项目的注释中有锁升级的矩阵图，但是没有兼容性的矩阵图，这里贴一下。</p>
<p><img src="/img/CMU_15-445.assets/1699929922561.png"></p>
<h2 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task #1 - Lock Manager"></a>Task #1 - Lock Manager</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 比较关键的一个问题是，<code>LockRequestQueue</code> 里面存什么。我之前漏掉 <code>granted_</code> 成员，导致整个项目理解都有问题。一个请求会经历未获取锁、已获取锁，已释放锁三个过程，<code>LockRequestQueue</code> 存储所有没有被释放的锁请求，即前两个过程。因为之后能否获取锁，需要和之前已经获取的锁做兼容性判断。</p>
<p>② 加锁阶段：</p>
<ul>
<li>代码组织：我们可以根据请求的锁模式来分类讨论，也可以根据事务的锁模式来分类讨论，也可以根据事务是否有锁进行分类讨论。我最后是选择最后一种方式，这样写起来真的简洁。如果当前事务没有该资源的锁，则将请求入队，并且根据该资源是否被其他事务上锁，从而直接拿锁或者进行等待；否则，判断能否进行锁升级。</li>
<li>锁升级：<ul>
<li>根据提示，首先判断请求的锁模式是否和事务的锁模式是否相同，如果相同则直接返回 <code>true</code>。我在这里有个比较疑惑的点，如果请求锁模式的级别低于当前持有的锁模式，应该也可以直接返回 <code>true</code>，但是注释中并没有提及，并且线上测试结果告诉我不行，必须抛出异常。似乎是设计的问题，<a target="_blank" rel="noopener" href="https://discord.com/channels/724929902075445281/1063892798471946301/1146089754471972884">讨论在此</a>，而且这个讨论似乎说的也不完整。</li>
<li>然后判断是否可以锁升级，如果可以，我们需要释放之前的锁，并等待获取升级的锁。这两个步骤可以通过修改队列中的 <code>LockRequest</code> 实现，将锁模式修改为新的锁模式，将 <code>granted_</code> 修改为 <code>false</code>，然后 <code>cv_.wait()</code> 即可。关键是条件变量的获取锁的条件如何编写。注意，一定要在等待之前从当前事务的锁集中移除原来的锁，因为线上测试会在等待时检查锁集。</li>
</ul>
</li>
<li>获取锁：如何以 FIFO 的方式获取锁，并且使兼容的锁可以同时获取，以及使锁升级的优先级最高。遍历请求队列，如果当前事务是锁升级请求，则只需判断当前请求是否和已 <code>granted_</code> 的请求兼容。如果当前事务不是锁升级请求，并且存在其他事务的锁升级请求，则直接返回 <code>false</code>，否则不仅需要判断当前请求是否和已 <code>granted_</code> 的请求兼容，还需要判断当前请求是否和在该请求之前的未 <code>granted_</code> 的请求兼容。</li>
</ul>
<p>③ 解锁阶段：按照注释模拟，需要注意从队列中移除完成的锁请求，并在最后执行 <code>cv_.notify_all()</code>。</p>
<p>④ 事务的 <code>ABORTED</code> 状态：如果事务被中止，那么应该取消该事务所做的操作，事务中止之后会自动调用 <code>TransactionManager::Abort</code> 函数来进行解锁和还原所有写操作。但是如果事务在等待锁的过程中被中止，那么就需要我们手动重置，因为 <code>Abort</code> 函数不会清除未获取锁的请求。步骤如下：在使用条件变量时，额外判断当前事务的状态是否是 <code>ABORTED</code>，如果是则直接退出等待，并从队列中移除该请求，如果是锁升级还要记得重置 <code>upgrading_</code>，最后调用 <code>cv_.notify_all()</code> 并返回 <code>false</code>。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 一个细节问题，在获取 <code>map</code> 中的 <code>LockRequestQueue</code> 时，我依赖 C++ 在使用 <code>[]</code> 访问会自动创建对象的特性，没有注意到 <code>map</code> 中存的是智能指针，这样默认是创建空指针，结果就会报各种奇怪的错误。</p>
<p>② 表解锁同样需要改变事务的状态，一开始我天真的以为只需要在行解锁的时候改变就行，因为我以为加表锁必定会加行锁，但是不是这样的，可以只加表锁（或许全表扫描就是只加表锁而不加行锁）。</p>
<p>③ 线上测试遇到神奇的错误，pthread_mutex_lock.c:94: _pthread_mutex_lock: Assertion ‘mutex-&gt;data.__owner &#x3D;&#x3D; 0’ failed，而且不是每次测试都会发生。经过排查，发现又是自动补全的锅，导致重复执行 <code>unlock()</code> 操作，有关该错误的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9239999/pthread-mutex-lock-c62-pthread-mutex-lock-assertion-mutex-data-owner/9240466#9240466">讨论在此</a>。</p>
<p>④ 目前似乎不需要使用事务锁，单个事务加锁&#x2F;解锁是单线程的。</p>
<h2 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task #2 - Deadlock Detection"></a>Task #2 - Deadlock Detection</h2><p>① 构建等待图，使用二重循环遍历 <code>table_lock_map_</code> 和 <code>row_lock_map_</code> 来向 <code>waits_for_</code> 添加从 <code>granted_ == false</code> 请求到 <code>granted_ == true</code> 请求的边。其实这样单纯的加边是比较简单的，但是可能存在锁兼容的情况，这样构成的环是不会造成死锁的，导致误杀事务，不过测试能过就不改代码了。记得加锁。</p>
<p>② 因为可以存在很多环，如果检测顺序不一样，中止的事务可能完全不同，所以 NOTES 中要求我们从最小的事务开始做 DFS，按照从小到大的顺序遍历相邻节点，如果找到环，则中止环中最大的事务。如果事务被中止，则应该从图中删掉连接该事务的边，或者也可以打标记。有坑！！！<code>HasCycle</code> 应该包含什么代码，之前我是把最小事务编号作为参数传递，然后从该事务开始做 DFS 来检测环。但是线上 GraphTest 测试会调用 <code>HasCycle</code>，按照线上测试代码的逻辑，<code>HashCycle</code> 应该包含整个环检测代码，包括排序 <code>waits_for_</code>，排序 <code>GetEdgeList</code> 得到的边集，以及 DFS。特别注意，不要在 <code>HashCycle</code> 中调用 <code>txn_manager_</code> 的任何方法，因为 GraphTest 测试根本就没创建事务！！！我是调试半天找不到错，才反应过来，非常无语。</p>
<p>③ 最后，从 <code>HasCycle</code> 返回时，删除中止事务的边，然后调用 <code>TransactionManager::Abort</code> 函数中止事务。在消除所有环之后清空 <code>waits_for_</code>。</p>
<h2 id="Task-3-Concurrent-Query-Execution"><a href="#Task-3-Concurrent-Query-Execution" class="headerlink" title="Task #3 - Concurrent Query Execution"></a>Task #3 - Concurrent Query Execution</h2><p>① 非常非常无语！！！就是我在 Task#1 中提到的，高级锁可以包含低级锁的需求，不应该抛出异常，结果测试不给过，Task#3 又需要我兼容这种情况，那么只能在 <code>Executor</code> 代码中特判了。</p>
<p>② 根据提示，should not acquire S&#x2F;X table lock, grab IS&#x2F;IX instead，只为表加 IS&#x2F;IX 锁。</p>
<p>③ 细节问题：行加锁之后再判断行是否删除，这个错误找很长时间才发现；死锁检测在调用 <code>Abort</code> 函数之前，先将事务状态设置为 <code>ABORTED</code>，否则当前事务可能会在之后的解锁过程中被唤醒，触发 <code>LOCK_ON_SHRINKING</code> 异常；实现 <code>Abort</code> 函数时，将恢复阶段放在解锁阶段之前，不然可能会有并发问题。</p>
<h2 id="Leaderboard-Task-Optional"><a href="#Leaderboard-Task-Optional" class="headerlink" title="Leaderboard Task (Optional)"></a>Leaderboard Task (Optional)</h2><p>① 初次提交。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>Update QPS</th>
<th>Count QPS</th>
<th>Weighted QPS</th>
</tr>
</thead>
<tbody><tr>
<td>59</td>
<td>ALEX</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/img/CMU_15-445.assets/1699929198875.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make lock_manager_test -j$(nproc)</span><br><span class="line">make deadlock_detection_test -j`nproc`</span><br><span class="line">make txn_integration_test -j`nproc`</span><br><span class="line">make -j`nproc` terrier-bench </span><br><span class="line">./test/lock_manager_test</span><br><span class="line">./test/deadlock_detection_test</span><br><span class="line">./test/txn_integration_test</span><br><span class="line">./bin/bustub-terrier-bench --duration 30000</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p4</span><br><span class="line">make submit-p4</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>难点就在项目理解以及代码细节上，Task#1 和 Task#2 被队列和 <code>HashCycle</code> 的理解整晕了，然后要使代码能够在多线程情况下正常运行，一定要注意代码中逻辑的先后顺序！！！实现过程部分参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/592700870">做个数据库：2022 CMU15-445 Project4 Concurrency Control</a>，Task#1 的解释帮助很大。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-03T03:14:10.601Z" title="2023/11/3 上午11:14:10">2023-11-03</time>发表</span><span class="level-item"><time dateTime="2023-11-03T03:22:00.817Z" title="2023/11/3 上午11:22:00">2023-11-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">20 分钟读完 (大约3011个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/03/Project%203%20-%20Query%20Execution/">Project #3 - Query Execution</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project3/">Project #3 - Query Execution</a>。</p>
<p>准备工作：阅读 <strong>Chapter 15 16 22</strong>，学习 <strong>Lecture #10 #11 #12 #13 #14</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>通过查看 <code>sqllogictest.cpp</code>，可以知道 SQL 语句的整个执行流程。首先调用 <code>SQLLogicTestParser::Parse</code> 将测试文件解析为多个测试记录，然后根据记录的类型分别处理。目前我们主要关注查询语句，只需查看 <code>BustubInstance::ExecuteSqlTxn</code> 函数的代码。如项目介绍描述的那样，代码分别执行 <code>Binder,Planner,Optimize,ExecutionEngine</code>。然后，本来想详细分析一下整个流程，但是由于时间原因，以及项目确实比较复杂，所以暂时搁置。</p>
<h2 id="Task-1-Access-Method-Executors"><a href="#Task-1-Access-Method-Executors" class="headerlink" title="Task #1 - Access Method Executors"></a>Task #1 - Access Method Executors</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 遇到第一个问题，如何在 <code>SeqScanExecutor</code> 中遍历表，可以发现 <code>exec_ctx</code> 成员所属的类 <code>ExecutorContext</code> 中有一个 <code>GetCatalog</code> 方法，只要拿到 <code>Catalog</code> 就可以根据 <code>plan_</code> 中的信息拿到 <code>TableHeap</code> 的迭代器 <code>TableIterator</code>。然后第二个问题就是如何存储迭代器，<code>TableIterator</code> 是不可复制的，我们可以使用 <code>unique_ptr</code> 来存储迭代器，并使用 <code>make_unique</code> 初始化。（注意，不能在构造函数初始化，一定要在 <code>Init</code> 函数中初始化，不然多次全表扫描会出问题！）</p>
<p>② 实现 <code>Insert</code> 时报错 “The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table”，并且可以看到 <code>Next</code> 函数的注释中表示 “tuple The integer tuple indicating the number of rows inserted into the table”。说实话有点难以理解，我一开始以为每次调用 <code>Next</code> 会像迭代器模式一样，只执行一次插入，但是这样实现就会报上面的错误。然后通过查看 Discord 的讨论，发现是一次性插入所有记录，因为只要返回 <code>true</code> 就会打印插入的行数，返回 <code>false</code> 就不会打印。当插入零行时，还必须打印一个零，这说明，<code>Next</code> 必定要先返回 <code>true</code>，再返回 <code>false</code>。并且在构造 <code>tuple</code> 时需要使用 <code>BIGINT</code> 类型，不然会报其他错误（明明注释说的是 <code>INTEGER</code> 额）。</p>
<p>③ 在 <code>Insert</code> 的同时需要更新索引，一开始我是直接用普通的 <code>tuple</code> 作为 <code>InsertEntry</code> 的参数，结果在测试 <code>p3.05-index-scan.slt</code> 时报 <code>stack buffer overflow</code> 错误。通过 Debug 发现，在 <code>InsertEntry</code> 时会调用 <code>GenericKey</code> 类的 <code>SetFromKey</code> 函数，该函数会将 <code>tuple</code> 的数据拷贝到该类的 <code>data_</code> 成员中，作为索引的 key 使用。所以传入的 <code>tuple</code> 必须只包含 <code>key</code>，那么如何确定 <code>tuple</code> 中的哪个数据是 <code>key</code> 呢。可以发现 <code>Tuple</code> 类中有 <code>KeyFromTuple</code> 函数，它的会生成只包含 <code>key</code> 的 <code>tuple</code>，因为需要的索引的 <code>key</code>，那么该函数必定需要传入和索引相关的模式，以及 <code>key</code> 所在列的下标，这些信息可以在 <code>IndexInfo</code> 中找到。（之前我有点迷糊，当成 MySQL 默认使用主键索引了，BusTub 使用的是 <code>TableHeap</code>，也就是说表默认是没有索引的）</p>
<p>④ 实现时不要使用 <code>GetTableOid</code> 函数，因为线上测试的函数名是 <code>TableOid</code>，可能是因为我 <code>fork</code> 的版本太新了，仓库的代码和测试代码不一样，所以只能直接使用 <code>table_oid_</code> 成员。</p>
<p>⑤ 实现 <code>update</code> 时要注意，在创建新 <code>tuple</code> 时，使用的是 <code>child_executor_-&gt;GetOutputSchema()</code>，而不是 <code>GetOutputSchema()</code>。</p>
<p>⑥ 实现 <code>index_scan</code> 时，会使用到 <code>b_plus_tree_index.h</code> 中定义的别名，如 <code>BPlusTreeIndexIteratorForTwoIntegerColumn</code>。</p>
<p>⑧ 在 <code>IndexScan</code> 的提示中有这么一句话，“do not emit tuples that are deleted”，但是当从表中删除 <code>tuple</code> 时，也会从索引中删除对应的 <code>key</code>，所以应该不会遍历到已经删除的 <code>key</code> 才对，也就是说此时应该不用特判 <code>TupleMeta</code> 中的 <code>is_deleted_</code> 成员。</p>
<p>⑨ 测试 p3.06-empty-table.slt 时，遇到 B+Tree 迭代器实现问题。当 B+Tree 的为 <code>empty</code> 时，获取迭代器我原来是抛出异常，现在改为返回一个默认构造的迭代器。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 当没有显示声明复制&#x2F;移动构造函数或复制&#x2F;移动运算符，以及析构函数时，编译器才会隐式生成这些函数（其他更复杂的情况可以查看 cppreference.com）。</p>
<p>② 创建 <code>TupleMeta</code> 时，会将 <code>insertion_txn</code> 和 <code>deletion_txn_</code> 都初始化为 <code>INVALID_TXN_ID</code>，提示表示这些成员会在以后切换到 MVCC 存储时使用，有点遗憾没能体验一下。</p>
<p>③ <code>vector</code> 的 <code>reserve</code> 只会影响 <code>capacity</code> 的大小，而不会影响 <code>size</code>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7397768/choice-between-vectorresize-and-vectorreserve">讨论在此</a>。</p>
<p>④ 重载前置和后置 <code>++</code> 的区别，前置 <code>++</code> 的重载声明为 <code>operator++()</code>，后置 <code>++</code> 的重载声明为 <code>operator++(int)</code>。</p>
<p>⑤ 为什么应该将移动构造声明为 <code>noexcept</code>，可以阅读 <a target="_blank" rel="noopener" href="https://gieseanw.wordpress.com/2020/08/28/friendly-reminder-to-mark-your-move-constructors-noexcept/">Friendly reminder to mark your move constructors noexcept</a>。</p>
<h2 id="Task-2-Aggregation-amp-Join-Executors"><a href="#Task-2-Aggregation-amp-Join-Executors" class="headerlink" title="Task #2 - Aggregation &amp; Join Executors"></a>Task #2 - Aggregation &amp; Join Executors</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① 一开始实现真摸不着头脑，<code>AggregationPlanNode</code> 里面怎么这么多东西。<code>group_bys</code> 是指 <code>GROUP BY</code> 时对列的求值表达式，<code>aggregates</code> 是指使用聚合函数时对列的求值表达式，<code>agg_types</code> 是指聚合函数的类型。例如：<code>GROUP BY DAY(col)</code>、<code>MIN(col1 + col2)</code>。我们使用 <code>InsertCombine</code> 函数向哈希表插入值，参数可以使用 <code>MakeAggregateKey</code> 和 <code>MakeAggregateValue</code> 函数获得。</p>
<p>② 根据项目介绍，<code>AggregationExecutor::Next</code> 返回的 <code>tuple</code> 应该包含 <code>key</code> 和 <code>value</code>（我没看到，找错好难）。特别需要注意，当哈希表为空时，应该返回什么：如果是对某列进行 <code>GROUP BY</code> 操作，那么就返回 <code>false</code>，因为有个测试用例有注释 <code>no groups, no output</code>；否则，返回 <code>true</code>，并且 <code>tuple</code> 存储聚合函数的默认值。（可以通过判断 <code>key</code> 模式的列数是否为零，或者 <code>value</code> 模式的列数是否等于 <code>plan_</code> 输出模式的列数，来判断当前是否对某列进行 <code>GROUP BY</code> 操作）</p>
<p>③ 实现 <code>NestedLoopJoinExecutor</code>：外层循环遍历左表，内层循环遍历右表，只有当右表遍历完，才会获取下一个左表中的元组。但是，因为每找到一个匹配就会返回，所以我们应该将左表的元组作为数据成员，并且添加一个标志表示右表是否遍历完。每当右表遍历完成，都需要重置标志，获取左表中的下一个元组，并且重新 <code>Init</code> 右表。我们调用 <code>EvaluateJoin</code> 判断元组是否匹配，如果匹配，就将两个元组合并为一个元组。特别注意，如果当前是左连接，并且左元组没有匹配任何右元组，仍然需要返回一个为右元组填充 <code>null</code> 值的合并元组。比较迷惑的是怎么表示 <code>null</code>，我的想法是根据列类型获取对应的 <code>null</code> 值，<del>但是找不到这样的函数，所以我就直接返回 <code>BUSTUB_INT32_NULL</code> 了</del>。突然看到聚合执行器里用到 <code>ValueFactory::GetNullValueByType</code> 函数，太久没写项目给忘了。我还遇到一个 BUG，调试半天，发现我没有在 <code>Init</code> 函数中初始化 <code>SeqScanExecutor</code> 的迭代器，导致重复调用 <code>Init</code> 时不会重置迭代器。</p>
<p>④ 实现 <code>HashJoin</code>：根据提示我们可以参考 <code>SimpleAggregationHashTable</code> 的实现建立一个哈希表，我们创建一个 <code>JoinKey</code> 类作为键，然后创建一个 <code>hash&lt;bustub::JoinKey&gt;</code> 类，直接复制 <code>aggregation_plan.h</code> 中的代码改个名字就行（不然 C++ 真不熟，又要搞半天）。在哈希表中，将 <code>vector&lt;Tuple&gt;</code> 作为值以处理哈希冲突。搞定哈希的方式之后，我们可以像 <code>aggregation_executor.h</code> 一样添加两个辅助函数 <code>MakeLeftJoinKey</code> 和 <code>MakeRightJoinKey</code>。然后直接在 <code>Init</code> 中对左表建立哈希表，在 <code>Next</code> 中遍历右表，类似 <code>NestedLoopJoinExecutor</code> 的实现，只不过此时需要维护更多的数据成员。特别需要注意如何处理左连接，因为我们是将左表建为哈希表，那么在遍历完右表后，还需要处理没有任何匹配的左表中的元组。这可以在匹配时将元组的地址存储在 <code>unordered_set</code> 中，然后在遍历完右表后再遍历一次左表，并检查 <code>unordered_set</code> 来判断是否输出。（之前我是将元组的 <code>RID</code> 存储到集合中作为标识，但是这是错误的，因为左表可能是临时表，其中元组的 <code>RID</code> 是无效的内容；我们也可以为右表建立哈希表而不是左表，这样对于左连接来说，更好处理）</p>
<p>⑤ 实现 <code>Optimizing NestedLoopJoin to HashJoin</code>：非常的神奇，参考 <code>nlj_as_index_join.cpp</code> 瞎改，感觉代码是一坨，但是竟然没有任何错误，直接通过测试（激动半天）。具体实现的话，一开始我以为传入的参数就是 <code>NestedLoopJoin</code> 计划节点，但是似乎不是，所以我们需要遍历当前计划的子节点，递归的进行优化。之前比较令我迷惑的一点，怎么判断表达式是否是某个类型，我查找很久 API 都没有找到类似的函数，然后想到 <code>Project #0</code> 中好像是直接做 <code>dynamic_cast</code> 转换，如果返回值为 <code>nullptr</code> 就表示类型不匹配，查看 <code>nlj_as_index_join.cpp</code> 发现果然是这样。搞定表达式类型判断之后，就可以根据 <code>ColumnValueExpression::GetTupleIdx</code> 值来交换左右表达式，并返回转换后的节点。</p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task #3 - Sort + Limit Executors and Top-N Optimization"></a>Task #3 - Sort + Limit Executors and Top-N Optimization</h2><p>Easy！只有两点需要注意：一个是每次调用 <code>Init</code> 时都要初始化所有数据成员，不然下次调用会包含上次调用的数据；第二个是 C++ 的 <code>priority_queue</code> 默认是大顶堆，并且比较器和 Java 中的用法完全相反。</p>
<h2 id="Optional-Leaderboard-Tasks"><a href="#Optional-Leaderboard-Tasks" class="headerlink" title="Optional Leaderboard Tasks"></a>Optional Leaderboard Tasks</h2><p>① 初次提交。</p>
<p>② 之后优化。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>Q1</th>
<th>Q2</th>
<th>Q3</th>
<th>Time</th>
</tr>
</thead>
<tbody><tr>
<td>123</td>
<td>ALEX</td>
<td>740</td>
<td>30000</td>
<td>4839</td>
<td>4754</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/img/CMU_15-445.assets/1698937838632.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make sqllogictest -j$(nproc)</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.00-primer.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.01-seqscan.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.02-insert.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.04-delete.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.03-update.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.05-index-scan.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.06-empty-table.slt --verbose</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.07-simple-agg.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.08-group-agg-1.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.09-group-agg-2.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.10-simple-join.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.11-multi-way-join.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.12-repeat-execute.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.14-hash-join.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.15-multi-way-hash-join.slt --verbose</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.16-sort-limit.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.17-topn.slt --verbose</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.18-integration-1.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.19-integration-2.slt --verbose</span><br><span class="line"></span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p3</span><br><span class="line">make submit-p3</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>项目难度主要在项目理解上，常常是不理解某些变量的实际含义，或者知道该怎么做，却找不到对应的 API，或者对返回值理解有错误，而函数文档也不清晰。最后，看到实现的代码能够执行各种 SQL 语句，感觉还是很不错的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-29T10:46:57.093Z" title="2023/9/29 下午6:46:57">2023-09-29</time>发表</span><span class="level-item"><time dateTime="2023-09-29T10:51:10.491Z" title="2023/9/29 下午6:51:10">2023-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">22 分钟读完 (大约3298个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/29/Project%202%20-%20B+Tree/">Project #2 - B+Tree</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project2/">Project #2 - B+Tree</a></p>
<p>准备工作：阅读 <strong>Chapter 14.5 24.5 14.1-14.4 18.10.2</strong>，学习 <strong>Lecture #07 #08 #09</strong>，以及阅读课堂笔记。</p>
<h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 - B+Tree Pages"></a>Task #1 - B+Tree Pages</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 第一个比较迷惑的点就是 <code>max_size_</code> 的含义，对官方提供的<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/">B+Tree</a>进行插入操作，发现叶子节点的 <code>size_</code> 不会到达 <code>max_size_</code>。难道叶子节点实际只能包含 <code>max_size_ - 1</code> 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 <code>max_size_</code> 时，进行分裂，内部节点在插入前大小达到 <code>max_size_</code> 时进行分裂。所以对于内部节点，<code>max_size_</code> 表示它能包含的指针数量；对于叶子节点，<code>max_size_</code> 表示它能包含的键值对数量。</p>
<p>② <code>GetMinSize</code> 的实现，同样参考官方示例，对于非叶子节点，返回 <code>(max_size_ + 1) / 2</code>；对于叶子节点，返回 <code>max_size_ / 2</code>。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 如何理解 <code>MappingType array_[0]</code>，注释表示它是 Flexible array member for page data，参见维基百科<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flexible_array_member">Flexible array member</a>。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。</p>
<p>② 在内部节点和叶子节点中，<code>array_</code> 的唯一区别就是在搜索内部节点时不能使用 <code>array[0]_.first</code>，因为它并不能准确表示 <code>array_[0].second</code> 中 key 的范围（向 <code>array_[0].second</code> 中插入一个更小的 key，它就失效了）。</p>
<h2 id="Task-2a-B-Tree-Insertion-and-Search-for-Single-Values"><a href="#Task-2a-B-Tree-Insertion-and-Search-for-Single-Values" class="headerlink" title="Task #2a - B+Tree Insertion and Search for Single Values"></a>Task #2a - B+Tree Insertion and Search for Single Values</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \(O(n)\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。</p>
<p>② 可以在 <code>BPlusTreeInternalPage</code> 和 <code>BPlusTreeLeafPage</code> 中添加 <code>Search</code> 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 <code>-index - 1</code>（方便之后插入，类似 Java 中的 <a href="file:///D:/Java/javadoc17/api/java.base/java/util/Arrays.html#binarySearch(int[],int)">BinarySearch</a>）。具体的实现逻辑：</p>
<ul>
<li>内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 <code>index - 1</code>。</li>
<li>叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 <code>-index - 1</code>，否则返回 <code>index</code>。</li>
</ul>
<p>③ 特别注意 <code>PageGuard</code> 的使用，只有当操作完页面之后，才对其进行 <code>Drop</code> 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 <code>Drop</code>，这样可以尽早释放页面的锁以及 <code>Unpin</code> 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 <code>Drop</code> 上个页面（使用 <code>Context</code>）。注意拿锁和 <code>Drop</code> 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。</p>
<p>④ 获取页面需要进行类型转换，如果只读不写就使用 <code>page_guard.h</code> 中提供的 <code>As</code> 函数，只有需要写页面时才使用 <code>AsMut</code> 函数，因为该函数会将页面置为脏页。先将其转换为 <code>BPlusTreePage</code>，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 <code>BPlusTree</code> 类中已经为我们提供了别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> InternalPage = BPlusTreeInternalPage&lt;KeyType, <span class="type">page_id_t</span>, KeyComparator&gt;;</span><br><span class="line"><span class="keyword">using</span> LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;;</span><br></pre></td></tr></table></figure>

<p>一开始我没有注意，在对内部节点转换时，误将其 <code>page_id_t</code> 转为 <code>ValueType</code>，导致完全误解了整个项目的结构。</p>
<p>⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 <code>BPlusTreeInternalPage</code> 和 <code>BPlusTreeLeafPage</code> 中添加 <code>Split</code> 函数，来实现分裂。</p>
<p>叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（<code>BufferPoolManager</code>，<code>Context</code>），我将分裂函数的参数设计为 <code>BPlusTreeInternalPage &amp;new_page</code>，它会返回将插入到上层的 key，即新节点的第一个 key。</p>
<p>内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 <code>array_[GetMinSize() - 1]</code> 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 <code>array_[0].first</code>，因为分裂的时候复制了）。</p>
<p>⑥ 同理，在内部页面和叶子页面类中可以添加 <code>Insert</code> 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 <code>page_id</code> 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为  <code>const std::optional&lt;KeyType&gt; &amp;opt</code> 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 <code>Search</code> 的实现，当 <code>index ≥ 0</code> 时返回 <code>false</code>，否则继续插入。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试时可以先使用<a target="_blank" rel="noopener" href="http://dreampuf.github.io/GraphvizOnline/">可视化网站</a>查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/64000750/running-program-and-providing-input-from-shell-script">解决方案</a>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make b_plus_tree_printer -j$(nproc)</span><br><span class="line">&#123; echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; &#125; | ./bin/b_plus_tree_printer</span><br></pre></td></tr></table></figure>

<p>在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN  - Drawing an empty tree 错误，原因是我们没有实现 <code>b_plus_tree.cpp</code> 中的 <code>IsEmpty</code> 函数。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 如何使用 <code>upper_bound</code> 和 <code>lower_bound</code>（Java 选手表示踩了很多坑），可以看看 cppreference 的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">示例代码</a>，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。</p>
<p>② 测试时忽略 iterators 的测试。</p>
<p>③ <code>GetValue</code> 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 <code>BufferPoolManager</code> 的实现）。</p>
<h2 id="Task-2b-B-Tree-Deletions"><a href="#Task-2b-B-Tree-Deletions" class="headerlink" title="Task #2b - B+Tree Deletions"></a>Task #2b - B+Tree Deletions</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 <code>page_id</code>。</p>
<p>② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。</p>
<p>③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 <code>next_page_id_</code>。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 <code>DeletePage</code> 操作，在 <code>DeletePage</code> 之前需要 <code>Drop/Unpin</code> 页面。有个疑问，<code>DeletePage</code> 之前 <code>Drop</code> 之后，如果有线程 <code>Fetch</code>，那么删除页面的操作就会失败。）</p>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 <code>pop_back()</code> 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。</p>
<h2 id="Task-3-An-Iterator-for-Leaf-Scans"><a href="#Task-3-An-Iterator-for-Leaf-Scans" class="headerlink" title="Task #3 - An Iterator for Leaf Scans"></a>Task #3 - An Iterator for Leaf Scans</h2><p>基本上没有难度，遇到唯一的错误就是把 <code>GetSize</code> 打成了 <code>GetMaxSize</code>（因为用的自动补全）。</p>
<h2 id="Task-4-Concurrent-Index"><a href="#Task-4-Concurrent-Index" class="headerlink" title="Task #4 - Concurrent Index"></a>Task #4 - Concurrent Index</h2><p>① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 <code>MixTest2</code>，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 <code>2 3</code>，将 <code>total_keys</code> 修改为 <code>1000</code>，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。</p>
<p>② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN  - page not exist，发现是 <code>BufferPoolManager</code> 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 <code>FetchPageBasic/Read/Write</code> 返回 <code>nullptr</code> 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（<del>但是重构了个寂寞，效率没变，难受啊</del>）</p>
<p>③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 <code>Fetch</code> 和 <code>Drop</code> 的顺序就 OK。</p>
<h2 id="Optional-Leaderboard-Task"><a href="#Optional-Leaderboard-Task" class="headerlink" title="(Optional) Leaderboard Task"></a>(Optional) Leaderboard Task</h2><p>① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。</p>
<p>② 优化暂时搁置。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>read_qps</th>
<th>write_qps</th>
<th>total_qps</th>
</tr>
</thead>
<tbody><tr>
<td>36</td>
<td>ALEX</td>
<td>200376</td>
<td>603</td>
<td>200980</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。</p>
<p><img src="/img/CMU_15-445.assets/1695198575752.png"></p>
<p>Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。</p>
<p><img src="/img/CMU_15-445.assets/1695380469970.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)</span><br><span class="line">./test/b_plus_tree_insert_test</span><br><span class="line">./test/b_plus_tree_sequential_scale_test</span><br><span class="line">./test/b_plus_tree_delete_test</span><br><span class="line">./test/b_plus_tree_concurrent_test</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p2</span><br><span class="line">make submit-p2</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 <code>MaxSize</code> 和 <code>MinSize</code>，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 <code>key</code>。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（<del>做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧</del>）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-12T11:11:04.126Z" title="2023/9/12 下午7:11:04">2023-09-12</time>发表</span><span class="level-item"><time dateTime="2023-09-29T10:10:43.206Z" title="2023/9/29 下午6:10:43">2023-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">39 分钟读完 (大约5917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/12/Project%201%20-%20Buffer%20Pool/">Project #1 - Buffer Pool</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project1/">Project #1 - Buffer Pool</a></p>
<p>准备工作：阅读 <strong>Chapter 12.1-12.4 13.2-13.3 24.2</strong>，学习 <strong>Lecture #03 #04</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><strong>buffer_pool_manager</strong></p>
<p><code>pages_</code> 数组相当于缓冲池，<code>frame_id</code> 是该数组的下标，也就唯一标识一个 <code>Page</code>，即标识一个缓冲页面。一个 <code>Page</code> 可以存储不同的物理页面，<code>Page</code> 的数据成员 <code>page_id_</code> 唯一标识一个物理页面。因为不管是 <code>FetchPage</code>，还是 <code>DeletePage</code> 等函数，我们都是针对实际的物理页面做操作，所以 <code>buffer_pool_manager</code> 中的函数的形参都是提供 <code>page_id</code>。</p>
<p><strong>lru_k_replacer</strong></p>
<p>该类提供缓冲页面的淘汰策略，即淘汰某个 <code>fram_id</code> 对应的缓冲页面。一个缓冲页面会有一个对应的 <code>LRUKNode</code>，它负责记录该缓冲页面的访问历史。</p>
<p><strong>page_guard</strong></p>
<p>主要有三个类：<code>BasicPageGuard</code>，<code>ReadPageGuard</code> 和 <code>WritePageGuard</code>。<code>BasicPageGuard</code> 的作用是保证缓冲页面在使用完后会进行 <code>UnpinPage</code> 操作。而 <code>ReadPageGuard</code> 和 <code>WritePageGuard</code>，它们和 <code>BasicPageGuard</code> 是组合关系，它们的作用在 <code>BasicPageGuard</code> 的基础上保证页面在使用完后会解除读写锁。</p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 一开始以为 <code>current_timestamp_</code> 自动就是当前时间戳，调试时发现一直是 \(0\)，我真笨。可以直接从 \(0\) 开始手动模拟时间戳，调用 <code>RecordAccess</code> 时，让当前时间戳加 \(1\) 即可。</p>
<p>② 在 <code>Evict</code> 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 <code>frame</code>，结果淘汰的是第一次访问时间最早的 <code>frame</code>。</p>
<p>③ 在 <code>ListNode</code> 中使 <code> history_</code> 的长度不超过 <code>k_</code>，如果超过就调用 <code>pop_front()</code>，这样每次获取之前第 <code>k_</code> 个访问记录只需要调用 <code>front()</code> 函数。</p>
<p>④ 在 <code>RecordAccess</code> 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 <code>BufferPoolManager</code> 构造函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we allocate a consecutive memory space for the buffer pool</span></span><br><span class="line">pages_ = <span class="keyword">new</span> Page[pool_size_];</span><br><span class="line">replacer_ = std::<span class="built_in">make_unique</span>&lt;LRUKReplacer&gt;(pool_size, replacer_k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initially, every page is in the free list.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    free_list_.<span class="built_in">emplace_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码说明 <code>frame_id</code> 是小于 <code>pool_size</code> 的，所以大于等于 <code>pool_size</code> 的 <code>fram_id</code> 都应该抛出异常。（或许小于零的也应该抛出异常）</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 测试时将 <code>DISABLED_SampleTest</code> 改为 <code>SampleTest</code>。</p>
<p>② 忘记 C++ 的 <code>=</code> 是拷贝，传引用加上 <code>&amp;</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = node_store_.<span class="built_in">at</span>(frame_id); <span class="comment">// 错误：拷贝</span></span><br></pre></td></tr></table></figure>

<p>③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。</p>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① <code>NewPage</code> 和 <code>FetchPage</code> 有很多逻辑相同的部分，可以加个辅助函数来获取 <code>frame_id</code>。</p>
<p>② 注意，在 <code>FetchPage</code> 时，如果页面在内存中并且 <code>pin_count_ = 0</code>，则需要将其设置为不可淘汰的。</p>
<p>③ 在 <code>UnpinPage</code> 中，更新 <code>is_dirty</code> 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。</p>
<p>④ 在 <code>FlushPage</code> 中，注释表示 <code>REGARDLESS of the dirty flag</code>，应该说的是函数调用者，我们在实现时可以根据 <code>is_dirty</code> 来判断是否实际刷盘。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。</p>
<p>② 实现 <code>FetchPage</code> 时，有个情况我忘记调用 <code>RecordAccess</code>，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。</p>
<h2 id="Task-3-Read-x2F-Write-Page-Guards"><a href="#Task-3-Read-x2F-Write-Page-Guards" class="headerlink" title="Task #3 - Read&#x2F;Write Page Guards"></a>Task #3 - Read&#x2F;Write Page Guards</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>① 使用移动构造和移动赋值后，需要清除 <code>that</code> 的元数据。</p>
<p>② 移动赋值的调用者，也就是 <code>this</code>，如果其 <code>page_ != nullptr</code>，那么需要先将其 <code>Drop</code>，再进行赋值操作。</p>
<p>③ 实现读写页面守卫的移动构造函数，可以直接赋值 <code>std::move(that.guard_)</code>，相当于调用之前实现的 <code>BasicPageGuard</code> 的移动赋值运算符。</p>
<p>④ 实现读写页面守卫的 <code>Drop</code> 时，需要注意在调用 <code>guard_.Drop()</code> 之后再解锁页面，所以在 <code>Drop</code> 之前需要保存一下指向页面的指针。</p>
<p>⑤ 在实现 <code>BufferPoolManager</code> 中的 <code>FetchPageRead</code> 和 <code>FetchPageWrite</code> 时，为页面加读写锁。</p>
<p>⑥ 和 <code>PageGuard</code> 有关的 <code>FetchPage</code> 函数会返回一个 <code>PageGuard</code> 对象，但是如果所有缓存页已经被 <code>pin</code>，那么该返回什么。一开始我是直接拿 <code>nullptr</code> 构造 <code>PageGuard</code>，但是发现不对，因为 <code>PageGuard</code> 对象并没有检查 <code>page_ == nullptr</code> 的函数，所以页面必须被 <code>Fetch</code> 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（<del>不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管</del>）</p>
<h2 id="Leaderboard-Task-Optional"><a href="#Leaderboard-Task-Optional" class="headerlink" title="Leaderboard Task (Optional)"></a>Leaderboard Task (Optional)</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>性能分析</strong></p>
<p>看到<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略</a>中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 <code>perf</code> 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.brendangregg.com/overview.html">Brendan Gregg’s Homepage</a></li>
<li><a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/runbooks/-/blob/v2.220.2/docs/tutorials/how_to_use_flamegraphs_for_perf_profiling.md">How to use flamegraphs for performance profiling</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362575905">profiling 与性能优化总结</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jlfwong/speedscope">speedscope</a></li>
</ul>
<p><strong>LRU-K（对优化似乎没有帮助）</strong></p>
<p>关于 LRU-K 的论文：<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf">The LRU-K Page Replacement Algorithm For Database Disk Buffering</a>。</p>
<p>LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析）</p>
<p>解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂）</p>
<p>LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。</p>
<p>LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\(K\geq 2\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>更新：以下内容存在一些错误，将会在下一节纠正。</p>
<p>① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。</p>
<p>② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 <code>frame_id</code>，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我）</p>
<p>③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 <code>bpm-bench</code> 测试），结果发现是我理解有问题。尝试使用读写锁在 <code>BufferPoolManager</code> 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 <code>Unknown</code> 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 <code>FetchPage</code> 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。</p>
<p>④ 参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略</a>，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 <code>ResetMemory</code> 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。</p>
<p>⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 <code>BufferPoolManager</code> 之前析构 <code>DiskManager</code>，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。</p>
<p>⑥ <del>本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。</del>突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 <code>LRUKNode</code> 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 <code>Evict</code> 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性）</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_0ms</th>
<th>get_qps_0ms</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody><tr>
<td>61</td>
<td>ALEX</td>
<td>111924</td>
<td>104867</td>
<td>261</td>
<td>484</td>
<td>5123</td>
</tr>
<tr>
<td>32</td>
<td>ALEX</td>
<td>102401</td>
<td>96293</td>
<td>4886</td>
<td>5221</td>
<td>57123</td>
</tr>
<tr>
<td>2</td>
<td>ALEX</td>
<td>120664</td>
<td>123402</td>
<td>182590</td>
<td>248050</td>
<td>2663116</td>
</tr>
<tr>
<td>12</td>
<td>ALEX</td>
<td>143562</td>
<td>133514</td>
<td>3813</td>
<td>8132</td>
<td>85169</td>
</tr>
</tbody></table>
<h3 id="重做"><a href="#重做" class="headerlink" title="重做"></a>重做</h3><p><strong>实现纠错</strong></p>
<p>在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 <code>page_table_</code>），<strong>但是，如果在刷盘过程中，有另一个线程读取该页面，它在 <code>page_table_</code> 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误</strong>，错误在 <code>disk_manager_memory.h</code> 中被检测：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data_.<span class="built_in">size</span>()) || page_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_WARN</span>(<span class="string">&quot;page not exist&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 <code>page_id</code> 和 <code>frame_id</code>，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 <code>page_table_</code> 的锁，以确保在其他线程 <code>FetchPage</code> 时，表中已有该 <code>page_id</code>）。这时如果有其他线程 <code>Fetch</code> 该 <code>page_id</code>，不会直接从磁盘读，而是读这个表拿到之前的 <code>frame_id</code>，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 <code>FetchPage</code> 该 <code>page_id</code> 时，会发生已淘汰又被 <code>pin</code> 的情况，还会发生其他很复杂的情况）</p>
<p><strong>如何优化</strong></p>
<p>既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 <a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a>（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）：</p>
<p>① 缓存页面的访问规则</p>
<ul>
<li>读写页面时必须 <code>pin</code> 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 <code>pin</code>）</li>
<li>在读页面时，可以释放页面的读锁，因为已经拿到页面的 <code>pin</code>。</li>
<li>在写页面时，必须拿到 <code>pin</code> 和写锁，并且需要检查 <code>pincount_ == 1</code>，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 <code>unpin</code>，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 <code>pin</code>，但是没有关系，因为当前线程拿到写锁，其他线程 <code>pin</code> 之后还需要拿锁才能读写页面。</li>
</ul>
<p>我们的项目和上面的描述不一样，但是无伤大雅，基本上 <code>PageGuard</code> 和 <code>FetchPage</code> 等函数已经提供了这些功能。</p>
<p>② 缓冲池管理器的内部锁定</p>
<ul>
<li>访问 <code>page_table_</code> 前需要拿到 <code>page_table</code> 的读写锁（文中称作 <code>BufMappingLock</code>）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 <code>pin</code>。在修改 <code>page_table_</code>，或者修改缓存页面头部字段（应该是指 <code>Page</code> 的除 <code>data_</code> 以外的成员变量，在本项目中就是 <code>page_id_</code>、<code>pin_count_</code> 和 <code>is_dirty_</code>），或者从磁盘读物理页面到缓存页面时，需要拿到 <code>page_table_</code> 的写锁。</li>
<li>可以将 <code>BufMappingLock</code> 拆分为 <code>NUM_BUFFER_PARTITIONS</code> 个锁，每个锁负责映射的一部分。每个 <code>page_id_</code> 属于哪个分区，由 <code>page_id_</code> 的哈希值的低比特位决定（其实就是有多个 <code>page_table_</code>，每个 <code>page_id</code> 会根据哈希函数来确定存放在哪个 <code>page_table_</code> 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。</li>
<li>为空闲列表和页面替换提供独占的自旋锁 <code>buffer_strategy_lock</code> ，当拿到该锁时，不应该去获取任何其他锁。</li>
<li>每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 <code>BufMappingLock</code> 锁）。</li>
<li><code>BM_IO_IN_PROGRESS</code> 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 <code>BufMappingLock</code> 锁吧）。</li>
</ul>
<p>缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。</p>
<p>③ 后台线程刷盘</p>
<ul>
<li>按照淘汰顺序扫描页面，选择 <code>is_dirty_ == true &amp;&amp; pin_count_ == 0</code> 的页面，然后 <code>pin</code> 该页面并刷盘，最后回收到空闲列表。</li>
<li>还有一些优化方式，没看懂就不翻译了。</li>
</ul>
<p>总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。</p>
<p><strong>尝试实现</strong></p>
<p>重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。</p>
<p>① <code>FetchPage</code> 在判断 <code>page_id</code> 是否在 <code>page_table_</code> 时，需要使用 <code>page_table_</code> 的独占锁。并且如果页面不在 <code>page_table_</code> 中，则在函数返回 <code>nullptr</code> 或修改 <code>page_table_</code> 之前不能释放该锁，以防止多次 <code>FetchPage</code> 同一个 <code>page_id</code> 时，多次从 <code>free_list_</code> 中获取页面或者多次淘汰页面。</p>
<p>② 因为在 <code>FetchPage</code> 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 <code>pin</code> 的，所以之后设置 <code>pin_count_</code> 时，不能直接设置为 <code>1</code>，而是进行 <code>++</code> 操作。</p>
<p>第一次重构没有拆分 <code>BufMappingLock</code>，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 <code>unique_lock</code> 作为参数，并且 <code>atomic_flag</code> 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。<del>不搞了，像个小丑，没意思。</del></p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_0ms</th>
<th>get_qps_0ms</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody><tr>
<td>26</td>
<td>ALEX</td>
<td>92024</td>
<td>80293</td>
<td>5082</td>
<td>5287</td>
<td>57971</td>
</tr>
</tbody></table>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。</p>
<p>② 优化时容易出问题的点就是 <code>NewPage</code> 和 <code>FetchPage</code>，以及 <code>UnpinPage</code>。像是 <code>FlushPage</code>、<code>FlushAllPage</code> 以及 <code>DeletePage</code> 都可以暂时不管（可以直接 <code>return</code>），这样比较方便调试。</p>
<h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><p>① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。</p>
<p>② 遇到 Reference to non-static member function must be called 问题，解决方案<a target="_blank" rel="noopener" href="https://thispointer.com/c11-start-thread-by-member-function-with-arguments/">在此</a>。</p>
<p>③ MySQL Buffer Pool 的实现 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">15.5.1 Buffer Pool</a>。</p>
<p>④ Linus Torvalds 发表的一篇<a target="_blank" rel="noopener" href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189723">评论</a>：do not use spinlocks in user space, unless you actually know what you’re doing。</p>
<p>⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。</p>
<p>⑥ 发现一个感觉不错的博客：<a target="_blank" rel="noopener" href="https://www.modernescpp.com/">MC++</a>。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。</p>
<p><img src="/img/CMU_15-445.assets/1693653679462.png"></p>
<p>优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。</p>
<p><img src="/img/CMU_15-445.assets/1694514338965.png"></p>
<p>每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)</span><br><span class="line">./test/lru_k_replacer_test</span><br><span class="line">./test/buffer_pool_manager_test</span><br><span class="line">./test/page_guard_test</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p1</span><br><span class="line">make submit-p1</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。</p>
<p>② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，<code>bpm</code> 优化也就是简单减少锁的粒度，<code>lru</code> 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。</p>
<p>③ <del>我好菜啊！！！</del>前三个任务花了两天，优化花了好几天。</p>
<hr>
<p>更新：发现 <strong>Lecture #06</strong> 就是讲 BufferPool 优化的（<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/notes/06-bufferpool.pdf">课堂笔记</a>），不知道能不能在这用上，等做完所有 Project 再来试试。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-29T15:51:15.836Z" title="2023/8/29 下午11:51:15">2023-08-29</time>发表</span><span class="level-item"><time dateTime="2023-08-29T16:01:06.457Z" title="2023/8/30 上午12:01:06">2023-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">6 分钟读完 (大约917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/29/Homework%201%20-%20SQL/">Homework #1 - SQL</a></p><div class="content"><h2 id="作业准备"><a href="#作业准备" class="headerlink" title="作业准备"></a>作业准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/homework1/">Homework #1 - SQL</a>。</p>
<p>准备工作：阅读 <strong>Chapters 1-2 27 3-5</strong>，学习 <strong>Lecture #01 #02</strong>，以及阅读课堂笔记。</p>
<h2 id="Q1-0-points-q1-sample"><a href="#Q1-0-points-q1-sample" class="headerlink" title="Q1 [0 points] (q1_sample):"></a>Q1 [0 points] (q1_sample):</h2><p>Ctrl + C，Ctrl +V。</p>
<h2 id="Q2-5-points-q2-not-the-same-title"><a href="#Q2-5-points-q2-not-the-same-title" class="headerlink" title="Q2 [5 points] (q2_not_the_same_title):"></a>Q2 [5 points] (q2_not_the_same_title):</h2><p>查询只涉及 <code>titles</code> 表，比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	premiered,</span><br><span class="line">	primary_title || &#x27; (&#x27; || original_title || &#x27;)&#x27;</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">WHERE</span><br><span class="line">	primary_title != original_title</span><br><span class="line">	AND type = &#x27;movie&#x27;</span><br><span class="line">	AND genres LIKE &#x27;%Action%&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">	premiered DESC,</span><br><span class="line">	primary_title</span><br><span class="line">LIMIT</span><br><span class="line">	10;</span><br></pre></td></tr></table></figure>

<h2 id="Q3-5-points-q3-longest-running-tv"><a href="#Q3-5-points-q3-longest-running-tv" class="headerlink" title="Q3 [5 points] (q3_longest_running_tv):"></a>Q3 [5 points] (q3_longest_running_tv):</h2><p>题目描述很不清晰啊，类型都不知道具体是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	primary_title,</span><br><span class="line">	IIF(ended IS NULL, 2023, ended) - premiered AS runtime</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">WHERE</span><br><span class="line">	primary_title IS NOT NULL</span><br><span class="line">	AND type = &#x27;tvSeries&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">	runtime DESC,</span><br><span class="line">	primary_title</span><br><span class="line">LIMIT</span><br><span class="line">	20;</span><br></pre></td></tr></table></figure>

<h2 id="Q4-10-points-q4-directors-in-each-decade"><a href="#Q4-10-points-q4-directors-in-each-decade" class="headerlink" title="Q4 [10 points] (q4_directors_in_each_decade):"></a>Q4 [10 points] (q4_directors_in_each_decade):</h2><p>唯一要注意的就是使用 <code>DISTINCT</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	CAST(born / 10 * 10 AS TEXT) || &#x27;s&#x27; AS decade,</span><br><span class="line">	COUNT(DISTINCT(people.person_id)) AS num_directors</span><br><span class="line">FROM</span><br><span class="line">	people</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	category = &#x27;director&#x27;</span><br><span class="line">	AND born &gt;= 1900</span><br><span class="line">GROUP BY</span><br><span class="line">	decade</span><br><span class="line">ORDER BY</span><br><span class="line">	decade;</span><br></pre></td></tr></table></figure>

<h2 id="Q5-10-points-q5-german-type-ratings"><a href="#Q5-10-points-q5-german-type-ratings" class="headerlink" title="Q5 [10 points] (q5_german_type_ratings):"></a>Q5 [10 points] (q5_german_type_ratings):</h2><p>德语的缩写是 <code>de</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t.type,</span><br><span class="line">	ROUND(AVG(r.rating), 2) AS avg_rating,</span><br><span class="line">	MIN(r.rating),</span><br><span class="line">	MAX(r.rating)</span><br><span class="line">FROM</span><br><span class="line">	akas as a</span><br><span class="line">	INNER JOIN ratings as r USING(title_id)</span><br><span class="line">	INNER JOIN titles as t USING(title_id)</span><br><span class="line">WHERE</span><br><span class="line">	a.language = &#x27;de&#x27;</span><br><span class="line">	AND a.types IN (&#x27;imdbDisplay&#x27;, &#x27;original&#x27;)</span><br><span class="line">GROUP BY</span><br><span class="line">	t.type</span><br><span class="line">ORDER BY</span><br><span class="line">	avg_rating;</span><br></pre></td></tr></table></figure>

<h2 id="Q6-10-points-q6-who-played-a-batman"><a href="#Q6-10-points-q6-who-played-a-batman" class="headerlink" title="Q6 [10 points] (q6_who_played_a_batman):"></a>Q6 [10 points] (q6_who_played_a_batman):</h2><p>坑点就是模糊查询时 <code>Batman</code> 两边要加上双引号，即 <code>&quot;Batman&quot;</code>。以及在连接 <code>people</code> 和 <code>crew</code> 表时，顺序很重要，如果使用 <code>crew INNRE JOIN people USING(person_id)</code> 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">crew INNER JOIN people USING(person_id)</span><br><span class="line"></span><br><span class="line">QUERY PLAN</span><br><span class="line">|--SCAN crew USING INDEX ix_crew_person_id</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--USE TEMP B-TREE FOR DISTINCT</span><br><span class="line"></span><br><span class="line">people INNER JOIN crew USING(person_id)</span><br><span class="line"></span><br><span class="line">QUERY PLAN</span><br><span class="line">|--SCAN crew</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--USE TEMP B-TREE FOR DISTINCT</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">	SELECT</span><br><span class="line">		DISTINCT(person_id),</span><br><span class="line">		name</span><br><span class="line">	FROM</span><br><span class="line">		people</span><br><span class="line">		INNER JOIN crew USING(person_id)</span><br><span class="line">	WHERE</span><br><span class="line">		category = &#x27;actor&#x27;</span><br><span class="line">		AND characters LIKE &#x27;%&quot;Batman&quot;%&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	name,</span><br><span class="line">	ROUND(AVG(rating), 2) AS avg_rating</span><br><span class="line">FROM</span><br><span class="line">	t</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">	INNER JOIN ratings USING(title_id)</span><br><span class="line">GROUP BY</span><br><span class="line">	person_id</span><br><span class="line">ORDER BY</span><br><span class="line">	avg_rating DESC</span><br><span class="line">LIMIT</span><br><span class="line">	10;</span><br></pre></td></tr></table></figure>

<h2 id="Q7-15-points-q7-born-with-prestige"><a href="#Q7-15-points-q7-born-with-prestige" class="headerlink" title="Q7 [15 points] (q7_born_with_prestige):"></a>Q7 [15 points] (q7_born_with_prestige):</h2><p>SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	COUNT(DISTINCT(person_id))</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">	INNER JOIN people ON titles.premiered = people.born</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	primary_title = &#x27;The Prestige&#x27;</span><br><span class="line">	AND category IN (&#x27;actor&#x27;, &#x27;actress&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QUERY PLAN</span><br><span class="line">|--USE TEMP B-TREE FOR count(DISTINCT)</span><br><span class="line">|--SCAN crew</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?)</span><br></pre></td></tr></table></figure>

<h2 id="Q8-15-points-q8-directing-rose-sql"><a href="#Q8-15-points-q8-directing-rose-sql" class="headerlink" title="Q8 [15 points] (q8_directing_rose.sql):"></a>Q8 [15 points] (q8_directing_rose.sql):</h2><p>比官解快一秒。注意使用 <code>Rose%</code> 而不是 <code>Rose %</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	DISTINCT(name)</span><br><span class="line">FROM</span><br><span class="line">	crew</span><br><span class="line">	INNER JOIN people USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	category = &#x27;director&#x27;</span><br><span class="line">	AND title_id IN (</span><br><span class="line">		SELECT</span><br><span class="line">			title_id</span><br><span class="line">		FROM</span><br><span class="line">			crew</span><br><span class="line">			INNER JOIN people USING(person_id)</span><br><span class="line">		WHERE</span><br><span class="line">			category = &#x27;actress&#x27;</span><br><span class="line">			AND name LIKE &#x27;Rose%&#x27;</span><br><span class="line">	)</span><br><span class="line">ORDER BY</span><br><span class="line">	name;</span><br></pre></td></tr></table></figure>

<h2 id="Q9-15-points-q9-ode-to-the-dead"><a href="#Q9-15-points-q9-ode-to-the-dead" class="headerlink" title="Q9 [15 points] (q9_ode_to_the_dead):"></a>Q9 [15 points] (q9_ode_to_the_dead):</h2><p>这就是窗口函数么，学习了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">	SELECT</span><br><span class="line">		category,</span><br><span class="line">		name,</span><br><span class="line">		died,</span><br><span class="line">		primary_title,</span><br><span class="line">		runtime_minutes,</span><br><span class="line">		DENSE_RANK() OVER(</span><br><span class="line">			PARTITION BY category</span><br><span class="line">			ORDER BY died, name</span><br><span class="line">		) AS rank_died_name,</span><br><span class="line">		DENSE_RANK() OVER(</span><br><span class="line">			PARTITION BY category, person_id</span><br><span class="line">			ORDER BY runtime_minutes DESC, title_id</span><br><span class="line">		) AS rank_runtime_title</span><br><span class="line">	FROM</span><br><span class="line">		crew</span><br><span class="line">		INNER JOIN people USING(person_id)</span><br><span class="line">		INNER JOIN titles USING(title_id)</span><br><span class="line">	WHERE</span><br><span class="line">		died IS NOT NULL</span><br><span class="line">		AND runtime_minutes IS NOT NULL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	category,</span><br><span class="line">	name,</span><br><span class="line">	died,</span><br><span class="line">	primary_title,</span><br><span class="line">	runtime_minutes,</span><br><span class="line">	rank_died_name</span><br><span class="line">FROM</span><br><span class="line">	t</span><br><span class="line">WHERE</span><br><span class="line">	rank_died_name &lt;= 5</span><br><span class="line">	AND rank_runtime_title = 1</span><br><span class="line">ORDER BY</span><br><span class="line">	category,</span><br><span class="line">	rank_died_name;</span><br></pre></td></tr></table></figure>

<h2 id="Q10-15-points-q10-all-played-by-leo"><a href="#Q10-15-points-q10-all-played-by-leo" class="headerlink" title="Q10 [15 points] (q10_all_played_by_leo):"></a>Q10 [15 points] (q10_all_played_by_leo):</h2><p>不会。。<code>json_each</code> 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">WITH t1(characters) AS (</span><br><span class="line">	SELECT</span><br><span class="line">		characters</span><br><span class="line">	FROM</span><br><span class="line">		people</span><br><span class="line">		INNER JOIN crew USING(person_id)</span><br><span class="line">	WHERE</span><br><span class="line">		name = &#x27;Leonardo DiCaprio&#x27;</span><br><span class="line">		AND born = 1974</span><br><span class="line">),</span><br><span class="line">t2(value) AS (</span><br><span class="line">	SELECT</span><br><span class="line">		DISTINCT(value)</span><br><span class="line">	FROM</span><br><span class="line">		t1,</span><br><span class="line">		json_each(t1.characters)</span><br><span class="line">	WHERE</span><br><span class="line">		value != &#x27;&#x27;</span><br><span class="line">		AND value NOT LIKE &#x27;%SELF%&#x27;</span><br><span class="line">	ORDER BY</span><br><span class="line">		value</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	GROUP_CONCAT(value)</span><br><span class="line">FROM</span><br><span class="line">	t2;</span><br></pre></td></tr></table></figure>

<h2 id="作业小结"><a href="#作业小结" class="headerlink" title="作业小结"></a>作业小结</h2><p>最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-26T07:03:34.193Z" title="2023/8/26 下午3:03:34">2023-08-26</time>发表</span><span class="level-item"><time dateTime="2023-08-31T07:51:08.876Z" title="2023/8/31 下午3:51:08">2023-08-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">13 分钟读完 (大约1935个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/26/Project%200%20-%20C++%20Primer/">Project #0 - C++ Primer</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project0/">Project #0 - C++ Primer</a>。</p>
<p>准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。</p>
<h2 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task #1 - Copy-On-Write Trie"></a>Task #1 - Copy-On-Write Trie</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>Get 函数</strong></p>
<p>没有什么特别需要注意的，实现比较简单。</p>
<p>实现逻辑：</p>
<ul>
<li>如果 <code>root_ == nullptr</code> 为真，则返回 <code>nullptr</code>。</li>
<li>沿着 Trie 树遍历，如果节点不存在，则返回 <code>nullptr</code>。</li>
<li>如果目标节点不是 <code>TrieNodeWithValue</code> 类型，则返回 <code>nullptr</code>。</li>
<li>否则，返回目标节点的值。</li>
</ul>
<p><strong>Put 函数</strong></p>
<p>一开始比较疑惑的点是，智能指针存储的都是 <code>const</code> 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？</p>
<p>其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 <code>const</code> 指针就能做到。</p>
<p>本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 <code>key.empty()</code> 和 <code>root_ == nullptr</code>。</p>
<p>实现逻辑：</p>
<ul>
<li>如果 <code>key.empty()</code> 为真：<ul>
<li>如果 <code>root_ == nullptr</code> 为真，则使用 <code>value​</code> 构造 Trie 树并返回。</li>
<li>否则，使用 <code>root_-&gt;children_</code> 和 <code>value</code> 构造 Trie 树并返回。</li>
</ul>
</li>
<li>根据 <code>root_ == nullptr</code> 条件初始化新 Trie 树的 <code>root</code>。</li>
<li>沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）：<ul>
<li>如果克隆完所有字符，则返回新 Trie 树。</li>
<li>否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。</li>
</ul>
</li>
</ul>
<p><strong>Remove 函数</strong></p>
<p>需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意：</p>
<p>① 节点不包含值需要转换为 <code>TrieNode</code> 类型，也就是说拷贝的时候需要调用 <code>TrieNode::Clone()</code>。</p>
<p>② 如果节点满足 <code>children_.empty() &amp;&amp; !is_value_node_</code> 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 <code>erase</code> 父节点中 <code>map</code> 的 <code>key</code>。</p>
<p>实现逻辑：</p>
<ul>
<li>如果 <code>root_ == nullptr</code> 为真，则返回 <code>*this</code>。</li>
<li>如果 <code>key.empty()</code> 为真，则调用 <code>root_-&gt;TrieNode::Clone()</code> 克隆，并返回新 Trie 树。</li>
<li>沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 <code>*this</code>。</li>
<li>将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。</li>
<li>否则，依次克隆栈中的元素，然后返回新 Trie 树。</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>C++</strong></p>
<p>因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。</p>
<p>① 使用 <code>at</code> 访问 <code>const map</code> 对象，因为 <code>[]</code> 运算符可能会自动添加键值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">cout &lt;&lt; m[<span class="number">1024</span>]; <span class="comment">// 错误，No viable overloaded operator[] for type &#x27;const map&lt;int, int&gt;&#x27;</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">at</span>(<span class="number">1024</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>② <code>=</code> 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="number">1024</span>] = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">auto</span> n = m;</span><br><span class="line">n[<span class="number">1024</span>] = <span class="number">2048</span>;</span><br><span class="line">cout &lt;&lt; m[<span class="number">1024</span>]; <span class="comment">// 输出：1024</span></span><br></pre></td></tr></table></figure>

<p>③ 在 Java 中只要是对象就可以和 <code>null</code> 比较，而 C++ 中只有指针可以和 <code>nullptr</code> 比较。</p>
<p><strong>GDB</strong></p>
<p>① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击<a target="_blank" rel="noopener" href="https://bugs.llvm.org/show_bug.cgi?id=24202">此处</a>产生该问题的原因，以及相应的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/55718257/using-standard-c-library-debug-symbols-ubuntu-linux-libstdc6-8-dbg">解决方案</a>告诉我下载 <code>libstdc++6-dbgsym</code>，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。</p>
<p>② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">在此</a>查看该课程提供的 GDB 教程。以及可以阅读：<a target="_blank" rel="noopener" href="https://discover.cs.ucsb.edu/commonerrors/tutorial/gdbtutorial.html">GDB Tutorial: Finding Segmentation Faults</a>。</p>
<p>③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。</p>
<p><strong>CMake</strong></p>
<p>项目推荐使用 clang-14 作为编译器，解决方案<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7031126/switching-between-gcc-and-clang-llvm-using-cmake">在此</a>。</p>
<h2 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task #2 - Concurrent Key-Value Store"></a>Task #2 - Concurrent Key-Value Store</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 <code>std::mutex</code> 即可。读操作在获取 <code>root_</code> 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 <code>write_lock_</code> 上锁。<code>Put</code> 时记得使用 <code>std::move()</code>，因为值可能是不可复制的。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 关于线程和锁的知识，推荐阅读 <a target="_blank" rel="noopener" href="https://web.stanford.edu/class/archive/cs/cs110/cs110.1204/static/lectures/10-threads-and-mutexes.pdf">CS110 Lecture 10: Threads and Mutexes</a>。</p>
<p>② C++ 有个<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">复制省略</a>（Copy elision）的优化。</p>
<p>③ 关于 C++ <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl">模板</a>的 FAQ、<code>template</code> 关键字的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords">讨论</a> 和 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name">Dependent names</a> 的定义。（<del>好复杂啊</del>）之所以查这些内容，是因为 CLion 给我生成了不同的表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> value = root.<span class="keyword">template</span> <span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line">root = root.<span class="keyword">template</span> <span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line">root = root.<span class="built_in">Remove</span>(key);</span><br></pre></td></tr></table></figure>

<p>以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 <code>&lt;&gt;</code> 来指定类型。然后何时使用 <code>template</code> 没怎么弄明白。</p>
<h2 id="Task-3-Debugging"><a href="#Task-3-Debugging" class="headerlink" title="Task #3 - Debugging"></a>Task #3 - Debugging</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 <code>Put</code> 时打断点调试的，应该差不多吧。</p>
<h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><p>无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74543715/usr-bin-ld-cannot-find-lstdc-no-such-file-or-directory-on-running-flutte">在此</a>。</p>
<h2 id="Task-4-SQL-String-Functions"><a href="#Task-4-SQL-String-Functions" class="headerlink" title="Task #4 - SQL String Functions"></a>Task #4 - SQL String Functions</h2><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>文件的路径：.&#x2F;src&#x2F;include&#x2F;execution&#x2F;expressions 和 .&#x2F;src&#x2F;planner&#x2F;plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 <code>std::tolower</code> 或许有一些<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/byte/tolower">注意事项</a>。注册函数时，需要保证参数是有效的，即参数只有一个并且是 <code>VARCHAR</code> 类型。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord <a target="_blank" rel="noopener" href="https://discord.com/channels/724929902075445281/1063892636504698880/1075438934240268358">讨论</a>。</p>
<p><img src="/img/CMU_15-445.assets/1692961316812.png"></p>
<p>修改之后通过！</p>
<p><img src="/img/CMU_15-445.assets/1692965202906.png"></p>
<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 <code>key</code> 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">109</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">79</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-14T16:17:28.224Z">2024-02-15</time></p><p class="title"><a href="/2024/02/15/Frangipani%20A%20Scalable%20Distributed%20File%20System/">Frangipani: A Scalable Distributed File System</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-12T10:36:07.604Z">2024-02-12</time></p><p class="title"><a href="/2024/02/12/Codeforces%20Round%20924%20(Div.%202)/">Codeforces Round 924 (Div. 2)</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Codeforces/">Codeforces</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-10T10:15:42.288Z">2024-02-10</time></p><p class="title"><a href="/2024/02/10/Chain%20Replication%20for%20Supporting%20High%20Throughput%20and%20Availability/">Chain Replication for Supporting High Throughput and Availability</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-05T00:49:58.762Z">2024-02-05</time></p><p class="title"><a href="/2024/02/05/ZooKeeper%20Wait-free%20coordination%20for%20Internet-scale%20systems/">ZooKeeper: Wait-free coordination for Internet-scale systems</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-29T14:24:44.457Z">2024-01-29</time></p><p class="title"><a href="/2024/01/29/In%20Search%20of%20an%20Understandable%20Consensus%20Algorithm%20(Extended%20Version)/">In Search of an Understandable Consensus Algorithm (Extended Version)</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">95</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/I-O/"><span class="tag">I/O</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CLIST</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">阮一峰的网络日志</span></span><span class="level-right"><span class="level-item tag">www.ruanyifeng.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>