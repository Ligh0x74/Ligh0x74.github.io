<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 课程 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">课程</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-14T02:57:33.978Z" title="2023/11/14 10:57:33">2023-11-14</time>发表</span><span class="level-item"><time dateTime="2023-11-14T03:01:15.042Z" title="2023/11/14 11:01:15">2023-11-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">15 分钟读完 (大约2187个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/14/Project%204%20-%20Concurrency%20Control/">Project #4 - Concurrency Control</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project4/">Project #4 - Concurrency Control</a>。</p>
<p>准备工作：阅读 <strong>Chapter 18 19</strong>，学习 <strong>Lecture #15 #16 #17 #18 #19 #20</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>项目的注释中有锁升级的矩阵图，但是没有兼容性的矩阵图，这里贴一下。</p>
<p><img src="/img/CMU_15-445.assets/1699929922561.png"></p>
<h2 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task #1 - Lock Manager"></a>Task #1 - Lock Manager</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 比较关键的一个问题是，<code>LockRequestQueue</code> 里面存什么。我之前漏掉 <code>granted_</code> 成员，导致整个项目理解都有问题。一个请求会经历未获取锁、已获取锁，已释放锁三个过程，<code>LockRequestQueue</code> 存储所有没有被释放的锁请求，即前两个过程。因为之后能否获取锁，需要和之前已经获取的锁做兼容性判断。</p>
<p>② 加锁阶段：</p>
<ul>
<li>代码组织：我们可以根据请求的锁模式来分类讨论，也可以根据事务的锁模式来分类讨论，也可以根据事务是否有锁进行分类讨论。我最后是选择最后一种方式，这样写起来真的简洁。如果当前事务没有该资源的锁，则将请求入队，并且根据该资源是否被其他事务上锁，从而直接拿锁或者进行等待；否则，判断能否进行锁升级。</li>
<li>锁升级：<ul>
<li>根据提示，首先判断请求的锁模式是否和事务的锁模式是否相同，如果相同则直接返回 <code>true</code>。我在这里有个比较疑惑的点，如果请求锁模式的级别低于当前持有的锁模式，应该也可以直接返回 <code>true</code>，但是注释中并没有提及，并且线上测试结果告诉我不行，必须抛出异常。似乎是设计的问题，<a target="_blank" rel="noopener" href="https://discord.com/channels/724929902075445281/1063892798471946301/1146089754471972884">讨论在此</a>，而且这个讨论似乎说的也不完整。</li>
<li>然后判断是否可以锁升级，如果可以，我们需要释放之前的锁，并等待获取升级的锁。这两个步骤可以通过修改队列中的 <code>LockRequest</code> 实现，将锁模式修改为新的锁模式，将 <code>granted_</code> 修改为 <code>false</code>，然后 <code>cv_.wait()</code> 即可。关键是条件变量的获取锁的条件如何编写。注意，一定要在等待之前从当前事务的锁集中移除原来的锁，因为线上测试会在等待时检查锁集。</li>
</ul>
</li>
<li>获取锁：如何以 FIFO 的方式获取锁，并且使兼容的锁可以同时获取，以及使锁升级的优先级最高。遍历请求队列，如果当前事务是锁升级请求，则只需判断当前请求是否和已 <code>granted_</code> 的请求兼容。如果当前事务不是锁升级请求，并且存在其他事务的锁升级请求，则直接返回 <code>false</code>，否则不仅需要判断当前请求是否和已 <code>granted_</code> 的请求兼容，还需要判断当前请求是否和在该请求之前的未 <code>granted_</code> 的请求兼容。</li>
</ul>
<p>③ 解锁阶段：按照注释模拟，需要注意从队列中移除完成的锁请求，并在最后执行 <code>cv_.notify_all()</code>。</p>
<p>④ 事务的 <code>ABORTED</code> 状态：如果事务被中止，那么应该取消该事务所做的操作，事务中止之后会自动调用 <code>TransactionManager::Abort</code> 函数来进行解锁和还原所有写操作。但是如果事务在等待锁的过程中被中止，那么就需要我们手动重置，因为 <code>Abort</code> 函数不会清除未获取锁的请求。步骤如下：在使用条件变量时，额外判断当前事务的状态是否是 <code>ABORTED</code>，如果是则直接退出等待，并从队列中移除该请求，如果是锁升级还要记得重置 <code>upgrading_</code>，最后调用 <code>cv_.notify_all()</code> 并返回 <code>false</code>。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 一个细节问题，在获取 <code>map</code> 中的 <code>LockRequestQueue</code> 时，我依赖 C++ 在使用 <code>[]</code> 访问会自动创建对象的特性，没有注意到 <code>map</code> 中存的是智能指针，这样默认是创建空指针，结果就会报各种奇怪的错误。</p>
<p>② 表解锁同样需要改变事务的状态，一开始我天真的以为只需要在行解锁的时候改变就行，因为我以为加表锁必定会加行锁，但是不是这样的，可以只加表锁（或许全表扫描就是只加表锁而不加行锁）。</p>
<p>③ 线上测试遇到神奇的错误，pthread_mutex_lock.c:94: _pthread_mutex_lock: Assertion ‘mutex-&gt;data.__owner &#x3D;&#x3D; 0’ failed，而且不是每次测试都会发生。经过排查，发现又是自动补全的锅，导致重复执行 <code>unlock()</code> 操作，有关该错误的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9239999/pthread-mutex-lock-c62-pthread-mutex-lock-assertion-mutex-data-owner/9240466#9240466">讨论在此</a>。</p>
<p>④ 目前似乎不需要使用事务锁，单个事务加锁&#x2F;解锁是单线程的。</p>
<h2 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task #2 - Deadlock Detection"></a>Task #2 - Deadlock Detection</h2><p>① 构建等待图，使用二重循环遍历 <code>table_lock_map_</code> 和 <code>row_lock_map_</code> 来向 <code>waits_for_</code> 添加从 <code>granted_ == false</code> 请求到 <code>granted_ == true</code> 请求的边。其实这样单纯的加边是比较简单的，但是可能存在锁兼容的情况，这样构成的环是不会造成死锁的，导致误杀事务，不过测试能过就不改代码了。记得加锁。</p>
<p>② 因为可以存在很多环，如果检测顺序不一样，中止的事务可能完全不同，所以 NOTES 中要求我们从最小的事务开始做 DFS，按照从小到大的顺序遍历相邻节点，如果找到环，则中止环中最大的事务。如果事务被中止，则应该从图中删掉连接该事务的边，或者也可以打标记。有坑！！！<code>HasCycle</code> 应该包含什么代码，之前我是把最小事务编号作为参数传递，然后从该事务开始做 DFS 来检测环。但是线上 GraphTest 测试会调用 <code>HasCycle</code>，按照线上测试代码的逻辑，<code>HashCycle</code> 应该包含整个环检测代码，包括排序 <code>waits_for_</code>，排序 <code>GetEdgeList</code> 得到的边集，以及 DFS。特别注意，不要在 <code>HashCycle</code> 中调用 <code>txn_manager_</code> 的任何方法，因为 GraphTest 测试根本就没创建事务！！！我是调试半天找不到错，才反应过来，非常无语。</p>
<p>③ 最后，从 <code>HasCycle</code> 返回时，删除中止事务的边，然后调用 <code>TransactionManager::Abort</code> 函数中止事务。在消除所有环之后清空 <code>waits_for_</code>。</p>
<h2 id="Task-3-Concurrent-Query-Execution"><a href="#Task-3-Concurrent-Query-Execution" class="headerlink" title="Task #3 - Concurrent Query Execution"></a>Task #3 - Concurrent Query Execution</h2><p>① 非常非常无语！！！就是我在 Task#1 中提到的，高级锁可以包含低级锁的需求，不应该抛出异常，结果测试不给过，Task#3 又需要我兼容这种情况，那么只能在 <code>Executor</code> 代码中特判了。</p>
<p>② 根据提示，should not acquire S&#x2F;X table lock, grab IS&#x2F;IX instead，只为表加 IS&#x2F;IX 锁。</p>
<p>③ 细节问题：行加锁之后再判断行是否删除，这个错误找很长时间才发现；死锁检测在调用 <code>Abort</code> 函数之前，先将事务状态设置为 <code>ABORTED</code>，否则当前事务可能会在之后的解锁过程中被唤醒，触发 <code>LOCK_ON_SHRINKING</code> 异常；实现 <code>Abort</code> 函数时，将恢复阶段放在解锁阶段之前，不然可能会有并发问题。</p>
<h2 id="Leaderboard-Task-Optional"><a href="#Leaderboard-Task-Optional" class="headerlink" title="Leaderboard Task (Optional)"></a>Leaderboard Task (Optional)</h2><p>① 初次提交。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>Update QPS</th>
<th>Count QPS</th>
<th>Weighted QPS</th>
</tr>
</thead>
<tbody><tr>
<td>59</td>
<td>ALEX</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/img/CMU_15-445.assets/1699929198875.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make lock_manager_test -j$(nproc)</span><br><span class="line">make deadlock_detection_test -j`nproc`</span><br><span class="line">make txn_integration_test -j`nproc`</span><br><span class="line">make -j`nproc` terrier-bench </span><br><span class="line">./test/lock_manager_test</span><br><span class="line">./test/deadlock_detection_test</span><br><span class="line">./test/txn_integration_test</span><br><span class="line">./bin/bustub-terrier-bench --duration 30000</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p4</span><br><span class="line">make submit-p4</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>难点就在项目理解以及代码细节上，Task#1 和 Task#2 被队列和 <code>HashCycle</code> 的理解整晕了，然后要使代码能够在多线程情况下正常运行，一定要注意代码中逻辑的先后顺序！！！实现过程部分参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/592700870">做个数据库：2022 CMU15-445 Project4 Concurrency Control</a>，Task#1 的解释帮助很大。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-03T03:14:10.601Z" title="2023/11/3 11:14:10">2023-11-03</time>发表</span><span class="level-item"><time dateTime="2023-11-03T03:22:00.817Z" title="2023/11/3 11:22:00">2023-11-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">20 分钟读完 (大约3011个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/03/Project%203%20-%20Query%20Execution/">Project #3 - Query Execution</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project3/">Project #3 - Query Execution</a>。</p>
<p>准备工作：阅读 <strong>Chapter 15 16 22</strong>，学习 <strong>Lecture #10 #11 #12 #13 #14</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>通过查看 <code>sqllogictest.cpp</code>，可以知道 SQL 语句的整个执行流程。首先调用 <code>SQLLogicTestParser::Parse</code> 将测试文件解析为多个测试记录，然后根据记录的类型分别处理。目前我们主要关注查询语句，只需查看 <code>BustubInstance::ExecuteSqlTxn</code> 函数的代码。如项目介绍描述的那样，代码分别执行 <code>Binder,Planner,Optimize,ExecutionEngine</code>。然后，本来想详细分析一下整个流程，但是由于时间原因，以及项目确实比较复杂，所以暂时搁置。</p>
<h2 id="Task-1-Access-Method-Executors"><a href="#Task-1-Access-Method-Executors" class="headerlink" title="Task #1 - Access Method Executors"></a>Task #1 - Access Method Executors</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 遇到第一个问题，如何在 <code>SeqScanExecutor</code> 中遍历表，可以发现 <code>exec_ctx</code> 成员所属的类 <code>ExecutorContext</code> 中有一个 <code>GetCatalog</code> 方法，只要拿到 <code>Catalog</code> 就可以根据 <code>plan_</code> 中的信息拿到 <code>TableHeap</code> 的迭代器 <code>TableIterator</code>。然后第二个问题就是如何存储迭代器，<code>TableIterator</code> 是不可复制的，我们可以使用 <code>unique_ptr</code> 来存储迭代器，并使用 <code>make_unique</code> 初始化。（注意，不能在构造函数初始化，一定要在 <code>Init</code> 函数中初始化，不然多次全表扫描会出问题！）</p>
<p>② 实现 <code>Insert</code> 时报错 “The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table”，并且可以看到 <code>Next</code> 函数的注释中表示 “tuple The integer tuple indicating the number of rows inserted into the table”。说实话有点难以理解，我一开始以为每次调用 <code>Next</code> 会像迭代器模式一样，只执行一次插入，但是这样实现就会报上面的错误。然后通过查看 Discord 的讨论，发现是一次性插入所有记录，因为只要返回 <code>true</code> 就会打印插入的行数，返回 <code>false</code> 就不会打印。当插入零行时，还必须打印一个零，这说明，<code>Next</code> 必定要先返回 <code>true</code>，再返回 <code>false</code>。并且在构造 <code>tuple</code> 时需要使用 <code>BIGINT</code> 类型，不然会报其他错误（明明注释说的是 <code>INTEGER</code> 额）。</p>
<p>③ 在 <code>Insert</code> 的同时需要更新索引，一开始我是直接用普通的 <code>tuple</code> 作为 <code>InsertEntry</code> 的参数，结果在测试 <code>p3.05-index-scan.slt</code> 时报 <code>stack buffer overflow</code> 错误。通过 Debug 发现，在 <code>InsertEntry</code> 时会调用 <code>GenericKey</code> 类的 <code>SetFromKey</code> 函数，该函数会将 <code>tuple</code> 的数据拷贝到该类的 <code>data_</code> 成员中，作为索引的 key 使用。所以传入的 <code>tuple</code> 必须只包含 <code>key</code>，那么如何确定 <code>tuple</code> 中的哪个数据是 <code>key</code> 呢。可以发现 <code>Tuple</code> 类中有 <code>KeyFromTuple</code> 函数，它的会生成只包含 <code>key</code> 的 <code>tuple</code>，因为需要的索引的 <code>key</code>，那么该函数必定需要传入和索引相关的模式，以及 <code>key</code> 所在列的下标，这些信息可以在 <code>IndexInfo</code> 中找到。（之前我有点迷糊，当成 MySQL 默认使用主键索引了，BusTub 使用的是 <code>TableHeap</code>，也就是说表默认是没有索引的）</p>
<p>④ 实现时不要使用 <code>GetTableOid</code> 函数，因为线上测试的函数名是 <code>TableOid</code>，可能是因为我 <code>fork</code> 的版本太新了，仓库的代码和测试代码不一样，所以只能直接使用 <code>table_oid_</code> 成员。</p>
<p>⑤ 实现 <code>update</code> 时要注意，在创建新 <code>tuple</code> 时，使用的是 <code>child_executor_-&gt;GetOutputSchema()</code>，而不是 <code>GetOutputSchema()</code>。</p>
<p>⑥ 实现 <code>index_scan</code> 时，会使用到 <code>b_plus_tree_index.h</code> 中定义的别名，如 <code>BPlusTreeIndexIteratorForTwoIntegerColumn</code>。</p>
<p>⑧ 在 <code>IndexScan</code> 的提示中有这么一句话，“do not emit tuples that are deleted”，但是当从表中删除 <code>tuple</code> 时，也会从索引中删除对应的 <code>key</code>，所以应该不会遍历到已经删除的 <code>key</code> 才对，也就是说此时应该不用特判 <code>TupleMeta</code> 中的 <code>is_deleted_</code> 成员。</p>
<p>⑨ 测试 p3.06-empty-table.slt 时，遇到 B+Tree 迭代器实现问题。当 B+Tree 的为 <code>empty</code> 时，获取迭代器我原来是抛出异常，现在改为返回一个默认构造的迭代器。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 当没有显示声明复制&#x2F;移动构造函数或复制&#x2F;移动运算符，以及析构函数时，编译器才会隐式生成这些函数（其他更复杂的情况可以查看 cppreference.com）。</p>
<p>② 创建 <code>TupleMeta</code> 时，会将 <code>insertion_txn</code> 和 <code>deletion_txn_</code> 都初始化为 <code>INVALID_TXN_ID</code>，提示表示这些成员会在以后切换到 MVCC 存储时使用，有点遗憾没能体验一下。</p>
<p>③ <code>vector</code> 的 <code>reserve</code> 只会影响 <code>capacity</code> 的大小，而不会影响 <code>size</code>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7397768/choice-between-vectorresize-and-vectorreserve">讨论在此</a>。</p>
<p>④ 重载前置和后置 <code>++</code> 的区别，前置 <code>++</code> 的重载声明为 <code>operator++()</code>，后置 <code>++</code> 的重载声明为 <code>operator++(int)</code>。</p>
<p>⑤ 为什么应该将移动构造声明为 <code>noexcept</code>，可以阅读 <a target="_blank" rel="noopener" href="https://gieseanw.wordpress.com/2020/08/28/friendly-reminder-to-mark-your-move-constructors-noexcept/">Friendly reminder to mark your move constructors noexcept</a>。</p>
<h2 id="Task-2-Aggregation-amp-Join-Executors"><a href="#Task-2-Aggregation-amp-Join-Executors" class="headerlink" title="Task #2 - Aggregation &amp; Join Executors"></a>Task #2 - Aggregation &amp; Join Executors</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① 一开始实现真摸不着头脑，<code>AggregationPlanNode</code> 里面怎么这么多东西。<code>group_bys</code> 是指 <code>GROUP BY</code> 时对列的求值表达式，<code>aggregates</code> 是指使用聚合函数时对列的求值表达式，<code>agg_types</code> 是指聚合函数的类型。例如：<code>GROUP BY DAY(col)</code>、<code>MIN(col1 + col2)</code>。我们使用 <code>InsertCombine</code> 函数向哈希表插入值，参数可以使用 <code>MakeAggregateKey</code> 和 <code>MakeAggregateValue</code> 函数获得。</p>
<p>② 根据项目介绍，<code>AggregationExecutor::Next</code> 返回的 <code>tuple</code> 应该包含 <code>key</code> 和 <code>value</code>（我没看到，找错好难）。特别需要注意，当哈希表为空时，应该返回什么：如果是对某列进行 <code>GROUP BY</code> 操作，那么就返回 <code>false</code>，因为有个测试用例有注释 <code>no groups, no output</code>；否则，返回 <code>true</code>，并且 <code>tuple</code> 存储聚合函数的默认值。（可以通过判断 <code>key</code> 模式的列数是否为零，或者 <code>value</code> 模式的列数是否等于 <code>plan_</code> 输出模式的列数，来判断当前是否对某列进行 <code>GROUP BY</code> 操作）</p>
<p>③ 实现 <code>NestedLoopJoinExecutor</code>：外层循环遍历左表，内层循环遍历右表，只有当右表遍历完，才会获取下一个左表中的元组。但是，因为每找到一个匹配就会返回，所以我们应该将左表的元组作为数据成员，并且添加一个标志表示右表是否遍历完。每当右表遍历完成，都需要重置标志，获取左表中的下一个元组，并且重新 <code>Init</code> 右表。我们调用 <code>EvaluateJoin</code> 判断元组是否匹配，如果匹配，就将两个元组合并为一个元组。特别注意，如果当前是左连接，并且左元组没有匹配任何右元组，仍然需要返回一个为右元组填充 <code>null</code> 值的合并元组。比较迷惑的是怎么表示 <code>null</code>，我的想法是根据列类型获取对应的 <code>null</code> 值，<del>但是找不到这样的函数，所以我就直接返回 <code>BUSTUB_INT32_NULL</code> 了</del>。突然看到聚合执行器里用到 <code>ValueFactory::GetNullValueByType</code> 函数，太久没写项目给忘了。我还遇到一个 BUG，调试半天，发现我没有在 <code>Init</code> 函数中初始化 <code>SeqScanExecutor</code> 的迭代器，导致重复调用 <code>Init</code> 时不会重置迭代器。</p>
<p>④ 实现 <code>HashJoin</code>：根据提示我们可以参考 <code>SimpleAggregationHashTable</code> 的实现建立一个哈希表，我们创建一个 <code>JoinKey</code> 类作为键，然后创建一个 <code>hash&lt;bustub::JoinKey&gt;</code> 类，直接复制 <code>aggregation_plan.h</code> 中的代码改个名字就行（不然 C++ 真不熟，又要搞半天）。在哈希表中，将 <code>vector&lt;Tuple&gt;</code> 作为值以处理哈希冲突。搞定哈希的方式之后，我们可以像 <code>aggregation_executor.h</code> 一样添加两个辅助函数 <code>MakeLeftJoinKey</code> 和 <code>MakeRightJoinKey</code>。然后直接在 <code>Init</code> 中对左表建立哈希表，在 <code>Next</code> 中遍历右表，类似 <code>NestedLoopJoinExecutor</code> 的实现，只不过此时需要维护更多的数据成员。特别需要注意如何处理左连接，因为我们是将左表建为哈希表，那么在遍历完右表后，还需要处理没有任何匹配的左表中的元组。这可以在匹配时将元组的地址存储在 <code>unordered_set</code> 中，然后在遍历完右表后再遍历一次左表，并检查 <code>unordered_set</code> 来判断是否输出。（之前我是将元组的 <code>RID</code> 存储到集合中作为标识，但是这是错误的，因为左表可能是临时表，其中元组的 <code>RID</code> 是无效的内容；我们也可以为右表建立哈希表而不是左表，这样对于左连接来说，更好处理）</p>
<p>⑤ 实现 <code>Optimizing NestedLoopJoin to HashJoin</code>：非常的神奇，参考 <code>nlj_as_index_join.cpp</code> 瞎改，感觉代码是一坨，但是竟然没有任何错误，直接通过测试（激动半天）。具体实现的话，一开始我以为传入的参数就是 <code>NestedLoopJoin</code> 计划节点，但是似乎不是，所以我们需要遍历当前计划的子节点，递归的进行优化。之前比较令我迷惑的一点，怎么判断表达式是否是某个类型，我查找很久 API 都没有找到类似的函数，然后想到 <code>Project #0</code> 中好像是直接做 <code>dynamic_cast</code> 转换，如果返回值为 <code>nullptr</code> 就表示类型不匹配，查看 <code>nlj_as_index_join.cpp</code> 发现果然是这样。搞定表达式类型判断之后，就可以根据 <code>ColumnValueExpression::GetTupleIdx</code> 值来交换左右表达式，并返回转换后的节点。</p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task-3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task #3 - Sort + Limit Executors and Top-N Optimization"></a>Task #3 - Sort + Limit Executors and Top-N Optimization</h2><p>Easy！只有两点需要注意：一个是每次调用 <code>Init</code> 时都要初始化所有数据成员，不然下次调用会包含上次调用的数据；第二个是 C++ 的 <code>priority_queue</code> 默认是大顶堆，并且比较器和 Java 中的用法完全相反。</p>
<h2 id="Optional-Leaderboard-Tasks"><a href="#Optional-Leaderboard-Tasks" class="headerlink" title="Optional Leaderboard Tasks"></a>Optional Leaderboard Tasks</h2><p>① 初次提交。</p>
<p>② 之后优化。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>Q1</th>
<th>Q2</th>
<th>Q3</th>
<th>Time</th>
</tr>
</thead>
<tbody><tr>
<td>123</td>
<td>ALEX</td>
<td>740</td>
<td>30000</td>
<td>4839</td>
<td>4754</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="/img/CMU_15-445.assets/1698937838632.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make sqllogictest -j$(nproc)</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.00-primer.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.01-seqscan.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.02-insert.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.04-delete.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.03-update.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.05-index-scan.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.06-empty-table.slt --verbose</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.07-simple-agg.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.08-group-agg-1.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.09-group-agg-2.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.10-simple-join.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.11-multi-way-join.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.12-repeat-execute.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.14-hash-join.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.15-multi-way-hash-join.slt --verbose</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.16-sort-limit.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.17-topn.slt --verbose</span><br><span class="line"></span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.18-integration-1.slt --verbose</span><br><span class="line">./bin/bustub-sqllogictest ../test/sql/p3.19-integration-2.slt --verbose</span><br><span class="line"></span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p3</span><br><span class="line">make submit-p3</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>项目难度主要在项目理解上，常常是不理解某些变量的实际含义，或者知道该怎么做，却找不到对应的 API，或者对返回值理解有错误，而函数文档也不清晰。最后，看到实现的代码能够执行各种 SQL 语句，感觉还是很不错的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-29T10:46:57.093Z" title="2023/9/29 18:46:57">2023-09-29</time>发表</span><span class="level-item"><time dateTime="2023-09-29T10:51:10.491Z" title="2023/9/29 18:51:10">2023-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">22 分钟读完 (大约3298个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/29/Project%202%20-%20B+Tree/">Project #2 - B+Tree</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project2/">Project #2 - B+Tree</a></p>
<p>准备工作：阅读 <strong>Chapter 14.5 24.5 14.1-14.4 18.10.2</strong>，学习 <strong>Lecture #07 #08 #09</strong>，以及阅读课堂笔记。</p>
<h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 - B+Tree Pages"></a>Task #1 - B+Tree Pages</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 第一个比较迷惑的点就是 <code>max_size_</code> 的含义，对官方提供的<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/">B+Tree</a>进行插入操作，发现叶子节点的 <code>size_</code> 不会到达 <code>max_size_</code>。难道叶子节点实际只能包含 <code>max_size_ - 1</code> 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 <code>max_size_</code> 时，进行分裂，内部节点在插入前大小达到 <code>max_size_</code> 时进行分裂。所以对于内部节点，<code>max_size_</code> 表示它能包含的指针数量；对于叶子节点，<code>max_size_</code> 表示它能包含的键值对数量。</p>
<p>② <code>GetMinSize</code> 的实现，同样参考官方示例，对于非叶子节点，返回 <code>(max_size_ + 1) / 2</code>；对于叶子节点，返回 <code>max_size_ / 2</code>。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 如何理解 <code>MappingType array_[0]</code>，注释表示它是 Flexible array member for page data，参见维基百科<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flexible_array_member">Flexible array member</a>。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。</p>
<p>② 在内部节点和叶子节点中，<code>array_</code> 的唯一区别就是在搜索内部节点时不能使用 <code>array[0]_.first</code>，因为它并不能准确表示 <code>array_[0].second</code> 中 key 的范围（向 <code>array_[0].second</code> 中插入一个更小的 key，它就失效了）。</p>
<h2 id="Task-2a-B-Tree-Insertion-and-Search-for-Single-Values"><a href="#Task-2a-B-Tree-Insertion-and-Search-for-Single-Values" class="headerlink" title="Task #2a - B+Tree Insertion and Search for Single Values"></a>Task #2a - B+Tree Insertion and Search for Single Values</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \(O(n)\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。</p>
<p>② 可以在 <code>BPlusTreeInternalPage</code> 和 <code>BPlusTreeLeafPage</code> 中添加 <code>Search</code> 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 <code>-index - 1</code>（方便之后插入，类似 Java 中的 <a href="file:///D:/Java/javadoc17/api/java.base/java/util/Arrays.html#binarySearch(int[],int)">BinarySearch</a>）。具体的实现逻辑：</p>
<ul>
<li>内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 <code>index - 1</code>。</li>
<li>叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 <code>-index - 1</code>，否则返回 <code>index</code>。</li>
</ul>
<p>③ 特别注意 <code>PageGuard</code> 的使用，只有当操作完页面之后，才对其进行 <code>Drop</code> 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 <code>Drop</code>，这样可以尽早释放页面的锁以及 <code>Unpin</code> 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 <code>Drop</code> 上个页面（使用 <code>Context</code>）。注意拿锁和 <code>Drop</code> 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。</p>
<p>④ 获取页面需要进行类型转换，如果只读不写就使用 <code>page_guard.h</code> 中提供的 <code>As</code> 函数，只有需要写页面时才使用 <code>AsMut</code> 函数，因为该函数会将页面置为脏页。先将其转换为 <code>BPlusTreePage</code>，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 <code>BPlusTree</code> 类中已经为我们提供了别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> InternalPage = BPlusTreeInternalPage&lt;KeyType, <span class="type">page_id_t</span>, KeyComparator&gt;;</span><br><span class="line"><span class="keyword">using</span> LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;;</span><br></pre></td></tr></table></figure>

<p>一开始我没有注意，在对内部节点转换时，误将其 <code>page_id_t</code> 转为 <code>ValueType</code>，导致完全误解了整个项目的结构。</p>
<p>⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 <code>BPlusTreeInternalPage</code> 和 <code>BPlusTreeLeafPage</code> 中添加 <code>Split</code> 函数，来实现分裂。</p>
<p>叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（<code>BufferPoolManager</code>，<code>Context</code>），我将分裂函数的参数设计为 <code>BPlusTreeInternalPage &amp;new_page</code>，它会返回将插入到上层的 key，即新节点的第一个 key。</p>
<p>内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 <code>array_[GetMinSize() - 1]</code> 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 <code>array_[0].first</code>，因为分裂的时候复制了）。</p>
<p>⑥ 同理，在内部页面和叶子页面类中可以添加 <code>Insert</code> 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 <code>page_id</code> 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为  <code>const std::optional&lt;KeyType&gt; &amp;opt</code> 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 <code>Search</code> 的实现，当 <code>index ≥ 0</code> 时返回 <code>false</code>，否则继续插入。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试时可以先使用<a target="_blank" rel="noopener" href="http://dreampuf.github.io/GraphvizOnline/">可视化网站</a>查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/64000750/running-program-and-providing-input-from-shell-script">解决方案</a>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make b_plus_tree_printer -j$(nproc)</span><br><span class="line">&#123; echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; &#125; | ./bin/b_plus_tree_printer</span><br></pre></td></tr></table></figure>

<p>在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN  - Drawing an empty tree 错误，原因是我们没有实现 <code>b_plus_tree.cpp</code> 中的 <code>IsEmpty</code> 函数。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 如何使用 <code>upper_bound</code> 和 <code>lower_bound</code>（Java 选手表示踩了很多坑），可以看看 cppreference 的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">示例代码</a>，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。</p>
<p>② 测试时忽略 iterators 的测试。</p>
<p>③ <code>GetValue</code> 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 <code>BufferPoolManager</code> 的实现）。</p>
<h2 id="Task-2b-B-Tree-Deletions"><a href="#Task-2b-B-Tree-Deletions" class="headerlink" title="Task #2b - B+Tree Deletions"></a>Task #2b - B+Tree Deletions</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 <code>page_id</code>。</p>
<p>② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。</p>
<p>③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 <code>next_page_id_</code>。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 <code>DeletePage</code> 操作，在 <code>DeletePage</code> 之前需要 <code>Drop/Unpin</code> 页面。有个疑问，<code>DeletePage</code> 之前 <code>Drop</code> 之后，如果有线程 <code>Fetch</code>，那么删除页面的操作就会失败。）</p>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 <code>pop_back()</code> 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。</p>
<h2 id="Task-3-An-Iterator-for-Leaf-Scans"><a href="#Task-3-An-Iterator-for-Leaf-Scans" class="headerlink" title="Task #3 - An Iterator for Leaf Scans"></a>Task #3 - An Iterator for Leaf Scans</h2><p>基本上没有难度，遇到唯一的错误就是把 <code>GetSize</code> 打成了 <code>GetMaxSize</code>（因为用的自动补全）。</p>
<h2 id="Task-4-Concurrent-Index"><a href="#Task-4-Concurrent-Index" class="headerlink" title="Task #4 - Concurrent Index"></a>Task #4 - Concurrent Index</h2><p>① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 <code>MixTest2</code>，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 <code>2 3</code>，将 <code>total_keys</code> 修改为 <code>1000</code>，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。</p>
<p>② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN  - page not exist，发现是 <code>BufferPoolManager</code> 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 <code>FetchPageBasic/Read/Write</code> 返回 <code>nullptr</code> 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（<del>但是重构了个寂寞，效率没变，难受啊</del>）</p>
<p>③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 <code>Fetch</code> 和 <code>Drop</code> 的顺序就 OK。</p>
<h2 id="Optional-Leaderboard-Task"><a href="#Optional-Leaderboard-Task" class="headerlink" title="(Optional) Leaderboard Task"></a>(Optional) Leaderboard Task</h2><p>① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。</p>
<p>② 优化暂时搁置。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>read_qps</th>
<th>write_qps</th>
<th>total_qps</th>
</tr>
</thead>
<tbody><tr>
<td>36</td>
<td>ALEX</td>
<td>200376</td>
<td>603</td>
<td>200980</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。</p>
<p><img src="/img/CMU_15-445.assets/1695198575752.png"></p>
<p>Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。</p>
<p><img src="/img/CMU_15-445.assets/1695380469970.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)</span><br><span class="line">./test/b_plus_tree_insert_test</span><br><span class="line">./test/b_plus_tree_sequential_scale_test</span><br><span class="line">./test/b_plus_tree_delete_test</span><br><span class="line">./test/b_plus_tree_concurrent_test</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p2</span><br><span class="line">make submit-p2</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 <code>MaxSize</code> 和 <code>MinSize</code>，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 <code>key</code>。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（<del>做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧</del>）</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%E8%AF%BE%E7%A8%8B/page/7/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%AF%BE%E7%A8%8B/page/9/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/page/7/">7</a></li><li><a class="pagination-link is-current" href="/categories/%E8%AF%BE%E7%A8%8B/page/8/">8</a></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">144</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-08T03:04:39.393Z">2025-02-08</time></p><p class="title"><a href="/2025/02/08/Lockfree%20Algorithms/">Lockfree Algorithms</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-26T03:23:01.559Z">2025-01-26</time></p><p class="title"><a href="/2025/01/26/Volatile%20&amp;%20%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/">Volatile &amp; 内存一致性模型</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-15T11:49:59.962Z">2025-01-15</time></p><p class="title"><a href="/2025/01/15/Reflections%20on%20Trusting%20Trust/">Reflections on Trusting Trust</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-03T14:56:46.460Z">2025-01-03</time></p><p class="title"><a href="/2025/01/03/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89/">快速傅里叶变换（FFT）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/">模板</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-03T11:38:56.638Z">2024-10-03</time></p><p class="title"><a href="/2024/10/03/Coroutines%20for%20Go/">Coroutines for Go（草稿）</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Go/">Go</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">41</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">99</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>