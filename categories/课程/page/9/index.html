<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 课程 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">课程</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-29T10:46:57.093Z" title="2023/9/29 18:46:57">2023-09-29</time>发表</span><span class="level-item"><time dateTime="2023-09-29T10:51:10.491Z" title="2023/9/29 18:51:10">2023-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">22 分钟读完 (大约3298个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/29/Project%202%20-%20B+Tree/">Project #2 - B+Tree</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project2/">Project #2 - B+Tree</a></p>
<p>准备工作：阅读 <strong>Chapter 14.5 24.5 14.1-14.4 18.10.2</strong>，学习 <strong>Lecture #07 #08 #09</strong>，以及阅读课堂笔记。</p>
<h2 id="Task-1-B-Tree-Pages"><a href="#Task-1-B-Tree-Pages" class="headerlink" title="Task #1 - B+Tree Pages"></a>Task #1 - B+Tree Pages</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 第一个比较迷惑的点就是 <code>max_size_</code> 的含义，对官方提供的<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/">B+Tree</a>进行插入操作，发现叶子节点的 <code>size_</code> 不会到达 <code>max_size_</code>。难道叶子节点实际只能包含 <code>max_size_ - 1</code> 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 <code>max_size_</code> 时，进行分裂，内部节点在插入前大小达到 <code>max_size_</code> 时进行分裂。所以对于内部节点，<code>max_size_</code> 表示它能包含的指针数量；对于叶子节点，<code>max_size_</code> 表示它能包含的键值对数量。</p>
<p>② <code>GetMinSize</code> 的实现，同样参考官方示例，对于非叶子节点，返回 <code>(max_size_ + 1) / 2</code>；对于叶子节点，返回 <code>max_size_ / 2</code>。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 如何理解 <code>MappingType array_[0]</code>，注释表示它是 Flexible array member for page data，参见维基百科<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flexible_array_member">Flexible array member</a>。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。</p>
<p>② 在内部节点和叶子节点中，<code>array_</code> 的唯一区别就是在搜索内部节点时不能使用 <code>array[0]_.first</code>，因为它并不能准确表示 <code>array_[0].second</code> 中 key 的范围（向 <code>array_[0].second</code> 中插入一个更小的 key，它就失效了）。</p>
<h2 id="Task-2a-B-Tree-Insertion-and-Search-for-Single-Values"><a href="#Task-2a-B-Tree-Insertion-and-Search-for-Single-Values" class="headerlink" title="Task #2a - B+Tree Insertion and Search for Single Values"></a>Task #2a - B+Tree Insertion and Search for Single Values</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \(O(n)\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。</p>
<p>② 可以在 <code>BPlusTreeInternalPage</code> 和 <code>BPlusTreeLeafPage</code> 中添加 <code>Search</code> 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 <code>-index - 1</code>（方便之后插入，类似 Java 中的 <a href="file:///D:/Java/javadoc17/api/java.base/java/util/Arrays.html#binarySearch(int[],int)">BinarySearch</a>）。具体的实现逻辑：</p>
<ul>
<li>内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 <code>index - 1</code>。</li>
<li>叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 <code>-index - 1</code>，否则返回 <code>index</code>。</li>
</ul>
<p>③ 特别注意 <code>PageGuard</code> 的使用，只有当操作完页面之后，才对其进行 <code>Drop</code> 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 <code>Drop</code>，这样可以尽早释放页面的锁以及 <code>Unpin</code> 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 <code>Drop</code> 上个页面（使用 <code>Context</code>）。注意拿锁和 <code>Drop</code> 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。</p>
<p>④ 获取页面需要进行类型转换，如果只读不写就使用 <code>page_guard.h</code> 中提供的 <code>As</code> 函数，只有需要写页面时才使用 <code>AsMut</code> 函数，因为该函数会将页面置为脏页。先将其转换为 <code>BPlusTreePage</code>，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 <code>BPlusTree</code> 类中已经为我们提供了别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> InternalPage = BPlusTreeInternalPage&lt;KeyType, <span class="type">page_id_t</span>, KeyComparator&gt;;</span><br><span class="line"><span class="keyword">using</span> LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;;</span><br></pre></td></tr></table></figure>

<p>一开始我没有注意，在对内部节点转换时，误将其 <code>page_id_t</code> 转为 <code>ValueType</code>，导致完全误解了整个项目的结构。</p>
<p>⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 <code>BPlusTreeInternalPage</code> 和 <code>BPlusTreeLeafPage</code> 中添加 <code>Split</code> 函数，来实现分裂。</p>
<p>叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（<code>BufferPoolManager</code>，<code>Context</code>），我将分裂函数的参数设计为 <code>BPlusTreeInternalPage &amp;new_page</code>，它会返回将插入到上层的 key，即新节点的第一个 key。</p>
<p>内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 <code>array_[GetMinSize() - 1]</code> 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 <code>array_[0].first</code>，因为分裂的时候复制了）。</p>
<p>⑥ 同理，在内部页面和叶子页面类中可以添加 <code>Insert</code> 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 <code>page_id</code> 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为  <code>const std::optional&lt;KeyType&gt; &amp;opt</code> 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 <code>Search</code> 的实现，当 <code>index ≥ 0</code> 时返回 <code>false</code>，否则继续插入。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>调试时可以先使用<a target="_blank" rel="noopener" href="http://dreampuf.github.io/GraphvizOnline/">可视化网站</a>查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/64000750/running-program-and-providing-input-from-shell-script">解决方案</a>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make b_plus_tree_printer -j$(nproc)</span><br><span class="line">&#123; echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; &#125; | ./bin/b_plus_tree_printer</span><br></pre></td></tr></table></figure>

<p>在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN  - Drawing an empty tree 错误，原因是我们没有实现 <code>b_plus_tree.cpp</code> 中的 <code>IsEmpty</code> 函数。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 如何使用 <code>upper_bound</code> 和 <code>lower_bound</code>（Java 选手表示踩了很多坑），可以看看 cppreference 的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">示例代码</a>，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。</p>
<p>② 测试时忽略 iterators 的测试。</p>
<p>③ <code>GetValue</code> 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 <code>BufferPoolManager</code> 的实现）。</p>
<h2 id="Task-2b-B-Tree-Deletions"><a href="#Task-2b-B-Tree-Deletions" class="headerlink" title="Task #2b - B+Tree Deletions"></a>Task #2b - B+Tree Deletions</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 <code>page_id</code>。</p>
<p>② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。</p>
<p>③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 <code>next_page_id_</code>。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 <code>DeletePage</code> 操作，在 <code>DeletePage</code> 之前需要 <code>Drop/Unpin</code> 页面。有个疑问，<code>DeletePage</code> 之前 <code>Drop</code> 之后，如果有线程 <code>Fetch</code>，那么删除页面的操作就会失败。）</p>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 <code>pop_back()</code> 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。</p>
<h2 id="Task-3-An-Iterator-for-Leaf-Scans"><a href="#Task-3-An-Iterator-for-Leaf-Scans" class="headerlink" title="Task #3 - An Iterator for Leaf Scans"></a>Task #3 - An Iterator for Leaf Scans</h2><p>基本上没有难度，遇到唯一的错误就是把 <code>GetSize</code> 打成了 <code>GetMaxSize</code>（因为用的自动补全）。</p>
<h2 id="Task-4-Concurrent-Index"><a href="#Task-4-Concurrent-Index" class="headerlink" title="Task #4 - Concurrent Index"></a>Task #4 - Concurrent Index</h2><p>① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 <code>MixTest2</code>，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 <code>2 3</code>，将 <code>total_keys</code> 修改为 <code>1000</code>，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。</p>
<p>② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN  - page not exist，发现是 <code>BufferPoolManager</code> 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 <code>FetchPageBasic/Read/Write</code> 返回 <code>nullptr</code> 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（<del>但是重构了个寂寞，效率没变，难受啊</del>）</p>
<p>③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 <code>Fetch</code> 和 <code>Drop</code> 的顺序就 OK。</p>
<h2 id="Optional-Leaderboard-Task"><a href="#Optional-Leaderboard-Task" class="headerlink" title="(Optional) Leaderboard Task"></a>(Optional) Leaderboard Task</h2><p>① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。</p>
<p>② 优化暂时搁置。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>read_qps</th>
<th>write_qps</th>
<th>total_qps</th>
</tr>
</thead>
<tbody><tr>
<td>36</td>
<td>ALEX</td>
<td>200376</td>
<td>603</td>
<td>200980</td>
</tr>
</tbody></table>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。</p>
<p><img src="/img/CMU_15-445.assets/1695198575752.png"></p>
<p>Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。</p>
<p><img src="/img/CMU_15-445.assets/1695380469970.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)</span><br><span class="line">./test/b_plus_tree_insert_test</span><br><span class="line">./test/b_plus_tree_sequential_scale_test</span><br><span class="line">./test/b_plus_tree_delete_test</span><br><span class="line">./test/b_plus_tree_concurrent_test</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p2</span><br><span class="line">make submit-p2</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 <code>MaxSize</code> 和 <code>MinSize</code>，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 <code>key</code>。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（<del>做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧</del>）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-12T11:11:04.126Z" title="2023/9/12 19:11:04">2023-09-12</time>发表</span><span class="level-item"><time dateTime="2023-09-29T10:10:43.206Z" title="2023/9/29 18:10:43">2023-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">39 分钟读完 (大约5917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/12/Project%201%20-%20Buffer%20Pool/">Project #1 - Buffer Pool</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project1/">Project #1 - Buffer Pool</a></p>
<p>准备工作：阅读 <strong>Chapter 12.1-12.4 13.2-13.3 24.2</strong>，学习 <strong>Lecture #03 #04</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><strong>buffer_pool_manager</strong></p>
<p><code>pages_</code> 数组相当于缓冲池，<code>frame_id</code> 是该数组的下标，也就唯一标识一个 <code>Page</code>，即标识一个缓冲页面。一个 <code>Page</code> 可以存储不同的物理页面，<code>Page</code> 的数据成员 <code>page_id_</code> 唯一标识一个物理页面。因为不管是 <code>FetchPage</code>，还是 <code>DeletePage</code> 等函数，我们都是针对实际的物理页面做操作，所以 <code>buffer_pool_manager</code> 中的函数的形参都是提供 <code>page_id</code>。</p>
<p><strong>lru_k_replacer</strong></p>
<p>该类提供缓冲页面的淘汰策略，即淘汰某个 <code>fram_id</code> 对应的缓冲页面。一个缓冲页面会有一个对应的 <code>LRUKNode</code>，它负责记录该缓冲页面的访问历史。</p>
<p><strong>page_guard</strong></p>
<p>主要有三个类：<code>BasicPageGuard</code>，<code>ReadPageGuard</code> 和 <code>WritePageGuard</code>。<code>BasicPageGuard</code> 的作用是保证缓冲页面在使用完后会进行 <code>UnpinPage</code> 操作。而 <code>ReadPageGuard</code> 和 <code>WritePageGuard</code>，它们和 <code>BasicPageGuard</code> 是组合关系，它们的作用在 <code>BasicPageGuard</code> 的基础上保证页面在使用完后会解除读写锁。</p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 一开始以为 <code>current_timestamp_</code> 自动就是当前时间戳，调试时发现一直是 \(0\)，我真笨。可以直接从 \(0\) 开始手动模拟时间戳，调用 <code>RecordAccess</code> 时，让当前时间戳加 \(1\) 即可。</p>
<p>② 在 <code>Evict</code> 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 <code>frame</code>，结果淘汰的是第一次访问时间最早的 <code>frame</code>。</p>
<p>③ 在 <code>ListNode</code> 中使 <code> history_</code> 的长度不超过 <code>k_</code>，如果超过就调用 <code>pop_front()</code>，这样每次获取之前第 <code>k_</code> 个访问记录只需要调用 <code>front()</code> 函数。</p>
<p>④ 在 <code>RecordAccess</code> 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 <code>BufferPoolManager</code> 构造函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we allocate a consecutive memory space for the buffer pool</span></span><br><span class="line">pages_ = <span class="keyword">new</span> Page[pool_size_];</span><br><span class="line">replacer_ = std::<span class="built_in">make_unique</span>&lt;LRUKReplacer&gt;(pool_size, replacer_k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initially, every page is in the free list.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    free_list_.<span class="built_in">emplace_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码说明 <code>frame_id</code> 是小于 <code>pool_size</code> 的，所以大于等于 <code>pool_size</code> 的 <code>fram_id</code> 都应该抛出异常。（或许小于零的也应该抛出异常）</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 测试时将 <code>DISABLED_SampleTest</code> 改为 <code>SampleTest</code>。</p>
<p>② 忘记 C++ 的 <code>=</code> 是拷贝，传引用加上 <code>&amp;</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = node_store_.<span class="built_in">at</span>(frame_id); <span class="comment">// 错误：拷贝</span></span><br></pre></td></tr></table></figure>

<p>③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。</p>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① <code>NewPage</code> 和 <code>FetchPage</code> 有很多逻辑相同的部分，可以加个辅助函数来获取 <code>frame_id</code>。</p>
<p>② 注意，在 <code>FetchPage</code> 时，如果页面在内存中并且 <code>pin_count_ = 0</code>，则需要将其设置为不可淘汰的。</p>
<p>③ 在 <code>UnpinPage</code> 中，更新 <code>is_dirty</code> 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。</p>
<p>④ 在 <code>FlushPage</code> 中，注释表示 <code>REGARDLESS of the dirty flag</code>，应该说的是函数调用者，我们在实现时可以根据 <code>is_dirty</code> 来判断是否实际刷盘。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。</p>
<p>② 实现 <code>FetchPage</code> 时，有个情况我忘记调用 <code>RecordAccess</code>，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。</p>
<h2 id="Task-3-Read-x2F-Write-Page-Guards"><a href="#Task-3-Read-x2F-Write-Page-Guards" class="headerlink" title="Task #3 - Read&#x2F;Write Page Guards"></a>Task #3 - Read&#x2F;Write Page Guards</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>① 使用移动构造和移动赋值后，需要清除 <code>that</code> 的元数据。</p>
<p>② 移动赋值的调用者，也就是 <code>this</code>，如果其 <code>page_ != nullptr</code>，那么需要先将其 <code>Drop</code>，再进行赋值操作。</p>
<p>③ 实现读写页面守卫的移动构造函数，可以直接赋值 <code>std::move(that.guard_)</code>，相当于调用之前实现的 <code>BasicPageGuard</code> 的移动赋值运算符。</p>
<p>④ 实现读写页面守卫的 <code>Drop</code> 时，需要注意在调用 <code>guard_.Drop()</code> 之后再解锁页面，所以在 <code>Drop</code> 之前需要保存一下指向页面的指针。</p>
<p>⑤ 在实现 <code>BufferPoolManager</code> 中的 <code>FetchPageRead</code> 和 <code>FetchPageWrite</code> 时，为页面加读写锁。</p>
<p>⑥ 和 <code>PageGuard</code> 有关的 <code>FetchPage</code> 函数会返回一个 <code>PageGuard</code> 对象，但是如果所有缓存页已经被 <code>pin</code>，那么该返回什么。一开始我是直接拿 <code>nullptr</code> 构造 <code>PageGuard</code>，但是发现不对，因为 <code>PageGuard</code> 对象并没有检查 <code>page_ == nullptr</code> 的函数，所以页面必须被 <code>Fetch</code> 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（<del>不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管</del>）</p>
<h2 id="Leaderboard-Task-Optional"><a href="#Leaderboard-Task-Optional" class="headerlink" title="Leaderboard Task (Optional)"></a>Leaderboard Task (Optional)</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>性能分析</strong></p>
<p>看到<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略</a>中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 <code>perf</code> 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.brendangregg.com/overview.html">Brendan Gregg’s Homepage</a></li>
<li><a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/runbooks/-/blob/v2.220.2/docs/tutorials/how_to_use_flamegraphs_for_perf_profiling.md">How to use flamegraphs for performance profiling</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362575905">profiling 与性能优化总结</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jlfwong/speedscope">speedscope</a></li>
</ul>
<p><strong>LRU-K（对优化似乎没有帮助）</strong></p>
<p>关于 LRU-K 的论文：<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf">The LRU-K Page Replacement Algorithm For Database Disk Buffering</a>。</p>
<p>LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析）</p>
<p>解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂）</p>
<p>LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。</p>
<p>LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\(K\geq 2\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>更新：以下内容存在一些错误，将会在下一节纠正。</p>
<p>① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。</p>
<p>② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 <code>frame_id</code>，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我）</p>
<p>③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 <code>bpm-bench</code> 测试），结果发现是我理解有问题。尝试使用读写锁在 <code>BufferPoolManager</code> 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 <code>Unknown</code> 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 <code>FetchPage</code> 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。</p>
<p>④ 参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略</a>，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 <code>ResetMemory</code> 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。</p>
<p>⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 <code>BufferPoolManager</code> 之前析构 <code>DiskManager</code>，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。</p>
<p>⑥ <del>本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。</del>突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 <code>LRUKNode</code> 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 <code>Evict</code> 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性）</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_0ms</th>
<th>get_qps_0ms</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody><tr>
<td>61</td>
<td>ALEX</td>
<td>111924</td>
<td>104867</td>
<td>261</td>
<td>484</td>
<td>5123</td>
</tr>
<tr>
<td>32</td>
<td>ALEX</td>
<td>102401</td>
<td>96293</td>
<td>4886</td>
<td>5221</td>
<td>57123</td>
</tr>
<tr>
<td>2</td>
<td>ALEX</td>
<td>120664</td>
<td>123402</td>
<td>182590</td>
<td>248050</td>
<td>2663116</td>
</tr>
<tr>
<td>12</td>
<td>ALEX</td>
<td>143562</td>
<td>133514</td>
<td>3813</td>
<td>8132</td>
<td>85169</td>
</tr>
</tbody></table>
<h3 id="重做"><a href="#重做" class="headerlink" title="重做"></a>重做</h3><p><strong>实现纠错</strong></p>
<p>在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 <code>page_table_</code>），<strong>但是，如果在刷盘过程中，有另一个线程读取该页面，它在 <code>page_table_</code> 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误</strong>，错误在 <code>disk_manager_memory.h</code> 中被检测：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data_.<span class="built_in">size</span>()) || page_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_WARN</span>(<span class="string">&quot;page not exist&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 <code>page_id</code> 和 <code>frame_id</code>，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 <code>page_table_</code> 的锁，以确保在其他线程 <code>FetchPage</code> 时，表中已有该 <code>page_id</code>）。这时如果有其他线程 <code>Fetch</code> 该 <code>page_id</code>，不会直接从磁盘读，而是读这个表拿到之前的 <code>frame_id</code>，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 <code>FetchPage</code> 该 <code>page_id</code> 时，会发生已淘汰又被 <code>pin</code> 的情况，还会发生其他很复杂的情况）</p>
<p><strong>如何优化</strong></p>
<p>既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 <a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a>（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）：</p>
<p>① 缓存页面的访问规则</p>
<ul>
<li>读写页面时必须 <code>pin</code> 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 <code>pin</code>）</li>
<li>在读页面时，可以释放页面的读锁，因为已经拿到页面的 <code>pin</code>。</li>
<li>在写页面时，必须拿到 <code>pin</code> 和写锁，并且需要检查 <code>pincount_ == 1</code>，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 <code>unpin</code>，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 <code>pin</code>，但是没有关系，因为当前线程拿到写锁，其他线程 <code>pin</code> 之后还需要拿锁才能读写页面。</li>
</ul>
<p>我们的项目和上面的描述不一样，但是无伤大雅，基本上 <code>PageGuard</code> 和 <code>FetchPage</code> 等函数已经提供了这些功能。</p>
<p>② 缓冲池管理器的内部锁定</p>
<ul>
<li>访问 <code>page_table_</code> 前需要拿到 <code>page_table</code> 的读写锁（文中称作 <code>BufMappingLock</code>）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 <code>pin</code>。在修改 <code>page_table_</code>，或者修改缓存页面头部字段（应该是指 <code>Page</code> 的除 <code>data_</code> 以外的成员变量，在本项目中就是 <code>page_id_</code>、<code>pin_count_</code> 和 <code>is_dirty_</code>），或者从磁盘读物理页面到缓存页面时，需要拿到 <code>page_table_</code> 的写锁。</li>
<li>可以将 <code>BufMappingLock</code> 拆分为 <code>NUM_BUFFER_PARTITIONS</code> 个锁，每个锁负责映射的一部分。每个 <code>page_id_</code> 属于哪个分区，由 <code>page_id_</code> 的哈希值的低比特位决定（其实就是有多个 <code>page_table_</code>，每个 <code>page_id</code> 会根据哈希函数来确定存放在哪个 <code>page_table_</code> 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。</li>
<li>为空闲列表和页面替换提供独占的自旋锁 <code>buffer_strategy_lock</code> ，当拿到该锁时，不应该去获取任何其他锁。</li>
<li>每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 <code>BufMappingLock</code> 锁）。</li>
<li><code>BM_IO_IN_PROGRESS</code> 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 <code>BufMappingLock</code> 锁吧）。</li>
</ul>
<p>缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。</p>
<p>③ 后台线程刷盘</p>
<ul>
<li>按照淘汰顺序扫描页面，选择 <code>is_dirty_ == true &amp;&amp; pin_count_ == 0</code> 的页面，然后 <code>pin</code> 该页面并刷盘，最后回收到空闲列表。</li>
<li>还有一些优化方式，没看懂就不翻译了。</li>
</ul>
<p>总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。</p>
<p><strong>尝试实现</strong></p>
<p>重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。</p>
<p>① <code>FetchPage</code> 在判断 <code>page_id</code> 是否在 <code>page_table_</code> 时，需要使用 <code>page_table_</code> 的独占锁。并且如果页面不在 <code>page_table_</code> 中，则在函数返回 <code>nullptr</code> 或修改 <code>page_table_</code> 之前不能释放该锁，以防止多次 <code>FetchPage</code> 同一个 <code>page_id</code> 时，多次从 <code>free_list_</code> 中获取页面或者多次淘汰页面。</p>
<p>② 因为在 <code>FetchPage</code> 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 <code>pin</code> 的，所以之后设置 <code>pin_count_</code> 时，不能直接设置为 <code>1</code>，而是进行 <code>++</code> 操作。</p>
<p>第一次重构没有拆分 <code>BufMappingLock</code>，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 <code>unique_lock</code> 作为参数，并且 <code>atomic_flag</code> 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。<del>不搞了，像个小丑，没意思。</del></p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_0ms</th>
<th>get_qps_0ms</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody><tr>
<td>26</td>
<td>ALEX</td>
<td>92024</td>
<td>80293</td>
<td>5082</td>
<td>5287</td>
<td>57971</td>
</tr>
</tbody></table>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。</p>
<p>② 优化时容易出问题的点就是 <code>NewPage</code> 和 <code>FetchPage</code>，以及 <code>UnpinPage</code>。像是 <code>FlushPage</code>、<code>FlushAllPage</code> 以及 <code>DeletePage</code> 都可以暂时不管（可以直接 <code>return</code>），这样比较方便调试。</p>
<h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><p>① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。</p>
<p>② 遇到 Reference to non-static member function must be called 问题，解决方案<a target="_blank" rel="noopener" href="https://thispointer.com/c11-start-thread-by-member-function-with-arguments/">在此</a>。</p>
<p>③ MySQL Buffer Pool 的实现 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">15.5.1 Buffer Pool</a>。</p>
<p>④ Linus Torvalds 发表的一篇<a target="_blank" rel="noopener" href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189723">评论</a>：do not use spinlocks in user space, unless you actually know what you’re doing。</p>
<p>⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。</p>
<p>⑥ 发现一个感觉不错的博客：<a target="_blank" rel="noopener" href="https://www.modernescpp.com/">MC++</a>。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。</p>
<p><img src="/img/CMU_15-445.assets/1693653679462.png"></p>
<p>优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。</p>
<p><img src="/img/CMU_15-445.assets/1694514338965.png"></p>
<p>每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)</span><br><span class="line">./test/lru_k_replacer_test</span><br><span class="line">./test/buffer_pool_manager_test</span><br><span class="line">./test/page_guard_test</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p1</span><br><span class="line">make submit-p1</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。</p>
<p>② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，<code>bpm</code> 优化也就是简单减少锁的粒度，<code>lru</code> 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。</p>
<p>③ <del>我好菜啊！！！</del>前三个任务花了两天，优化花了好几天。</p>
<hr>
<p>更新：发现 <strong>Lecture #06</strong> 就是讲 BufferPool 优化的（<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/notes/06-bufferpool.pdf">课堂笔记</a>），不知道能不能在这用上，等做完所有 Project 再来试试。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-29T15:51:15.836Z" title="2023/8/29 23:51:15">2023-08-29</time>发表</span><span class="level-item"><time dateTime="2023-08-29T16:01:06.457Z" title="2023/8/30 00:01:06">2023-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">6 分钟读完 (大约917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/29/Homework%201%20-%20SQL/">Homework #1 - SQL</a></p><div class="content"><h2 id="作业准备"><a href="#作业准备" class="headerlink" title="作业准备"></a>作业准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/homework1/">Homework #1 - SQL</a>。</p>
<p>准备工作：阅读 <strong>Chapters 1-2 27 3-5</strong>，学习 <strong>Lecture #01 #02</strong>，以及阅读课堂笔记。</p>
<h2 id="Q1-0-points-q1-sample"><a href="#Q1-0-points-q1-sample" class="headerlink" title="Q1 [0 points] (q1_sample):"></a>Q1 [0 points] (q1_sample):</h2><p>Ctrl + C，Ctrl +V。</p>
<h2 id="Q2-5-points-q2-not-the-same-title"><a href="#Q2-5-points-q2-not-the-same-title" class="headerlink" title="Q2 [5 points] (q2_not_the_same_title):"></a>Q2 [5 points] (q2_not_the_same_title):</h2><p>查询只涉及 <code>titles</code> 表，比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	premiered,</span><br><span class="line">	primary_title || &#x27; (&#x27; || original_title || &#x27;)&#x27;</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">WHERE</span><br><span class="line">	primary_title != original_title</span><br><span class="line">	AND type = &#x27;movie&#x27;</span><br><span class="line">	AND genres LIKE &#x27;%Action%&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">	premiered DESC,</span><br><span class="line">	primary_title</span><br><span class="line">LIMIT</span><br><span class="line">	10;</span><br></pre></td></tr></table></figure>

<h2 id="Q3-5-points-q3-longest-running-tv"><a href="#Q3-5-points-q3-longest-running-tv" class="headerlink" title="Q3 [5 points] (q3_longest_running_tv):"></a>Q3 [5 points] (q3_longest_running_tv):</h2><p>题目描述很不清晰啊，类型都不知道具体是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	primary_title,</span><br><span class="line">	IIF(ended IS NULL, 2023, ended) - premiered AS runtime</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">WHERE</span><br><span class="line">	primary_title IS NOT NULL</span><br><span class="line">	AND type = &#x27;tvSeries&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">	runtime DESC,</span><br><span class="line">	primary_title</span><br><span class="line">LIMIT</span><br><span class="line">	20;</span><br></pre></td></tr></table></figure>

<h2 id="Q4-10-points-q4-directors-in-each-decade"><a href="#Q4-10-points-q4-directors-in-each-decade" class="headerlink" title="Q4 [10 points] (q4_directors_in_each_decade):"></a>Q4 [10 points] (q4_directors_in_each_decade):</h2><p>唯一要注意的就是使用 <code>DISTINCT</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	CAST(born / 10 * 10 AS TEXT) || &#x27;s&#x27; AS decade,</span><br><span class="line">	COUNT(DISTINCT(people.person_id)) AS num_directors</span><br><span class="line">FROM</span><br><span class="line">	people</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	category = &#x27;director&#x27;</span><br><span class="line">	AND born &gt;= 1900</span><br><span class="line">GROUP BY</span><br><span class="line">	decade</span><br><span class="line">ORDER BY</span><br><span class="line">	decade;</span><br></pre></td></tr></table></figure>

<h2 id="Q5-10-points-q5-german-type-ratings"><a href="#Q5-10-points-q5-german-type-ratings" class="headerlink" title="Q5 [10 points] (q5_german_type_ratings):"></a>Q5 [10 points] (q5_german_type_ratings):</h2><p>德语的缩写是 <code>de</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t.type,</span><br><span class="line">	ROUND(AVG(r.rating), 2) AS avg_rating,</span><br><span class="line">	MIN(r.rating),</span><br><span class="line">	MAX(r.rating)</span><br><span class="line">FROM</span><br><span class="line">	akas as a</span><br><span class="line">	INNER JOIN ratings as r USING(title_id)</span><br><span class="line">	INNER JOIN titles as t USING(title_id)</span><br><span class="line">WHERE</span><br><span class="line">	a.language = &#x27;de&#x27;</span><br><span class="line">	AND a.types IN (&#x27;imdbDisplay&#x27;, &#x27;original&#x27;)</span><br><span class="line">GROUP BY</span><br><span class="line">	t.type</span><br><span class="line">ORDER BY</span><br><span class="line">	avg_rating;</span><br></pre></td></tr></table></figure>

<h2 id="Q6-10-points-q6-who-played-a-batman"><a href="#Q6-10-points-q6-who-played-a-batman" class="headerlink" title="Q6 [10 points] (q6_who_played_a_batman):"></a>Q6 [10 points] (q6_who_played_a_batman):</h2><p>坑点就是模糊查询时 <code>Batman</code> 两边要加上双引号，即 <code>&quot;Batman&quot;</code>。以及在连接 <code>people</code> 和 <code>crew</code> 表时，顺序很重要，如果使用 <code>crew INNRE JOIN people USING(person_id)</code> 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">crew INNER JOIN people USING(person_id)</span><br><span class="line"></span><br><span class="line">QUERY PLAN</span><br><span class="line">|--SCAN crew USING INDEX ix_crew_person_id</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--USE TEMP B-TREE FOR DISTINCT</span><br><span class="line"></span><br><span class="line">people INNER JOIN crew USING(person_id)</span><br><span class="line"></span><br><span class="line">QUERY PLAN</span><br><span class="line">|--SCAN crew</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--USE TEMP B-TREE FOR DISTINCT</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">	SELECT</span><br><span class="line">		DISTINCT(person_id),</span><br><span class="line">		name</span><br><span class="line">	FROM</span><br><span class="line">		people</span><br><span class="line">		INNER JOIN crew USING(person_id)</span><br><span class="line">	WHERE</span><br><span class="line">		category = &#x27;actor&#x27;</span><br><span class="line">		AND characters LIKE &#x27;%&quot;Batman&quot;%&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	name,</span><br><span class="line">	ROUND(AVG(rating), 2) AS avg_rating</span><br><span class="line">FROM</span><br><span class="line">	t</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">	INNER JOIN ratings USING(title_id)</span><br><span class="line">GROUP BY</span><br><span class="line">	person_id</span><br><span class="line">ORDER BY</span><br><span class="line">	avg_rating DESC</span><br><span class="line">LIMIT</span><br><span class="line">	10;</span><br></pre></td></tr></table></figure>

<h2 id="Q7-15-points-q7-born-with-prestige"><a href="#Q7-15-points-q7-born-with-prestige" class="headerlink" title="Q7 [15 points] (q7_born_with_prestige):"></a>Q7 [15 points] (q7_born_with_prestige):</h2><p>SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	COUNT(DISTINCT(person_id))</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">	INNER JOIN people ON titles.premiered = people.born</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	primary_title = &#x27;The Prestige&#x27;</span><br><span class="line">	AND category IN (&#x27;actor&#x27;, &#x27;actress&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QUERY PLAN</span><br><span class="line">|--USE TEMP B-TREE FOR count(DISTINCT)</span><br><span class="line">|--SCAN crew</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?)</span><br></pre></td></tr></table></figure>

<h2 id="Q8-15-points-q8-directing-rose-sql"><a href="#Q8-15-points-q8-directing-rose-sql" class="headerlink" title="Q8 [15 points] (q8_directing_rose.sql):"></a>Q8 [15 points] (q8_directing_rose.sql):</h2><p>比官解快一秒。注意使用 <code>Rose%</code> 而不是 <code>Rose %</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	DISTINCT(name)</span><br><span class="line">FROM</span><br><span class="line">	crew</span><br><span class="line">	INNER JOIN people USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	category = &#x27;director&#x27;</span><br><span class="line">	AND title_id IN (</span><br><span class="line">		SELECT</span><br><span class="line">			title_id</span><br><span class="line">		FROM</span><br><span class="line">			crew</span><br><span class="line">			INNER JOIN people USING(person_id)</span><br><span class="line">		WHERE</span><br><span class="line">			category = &#x27;actress&#x27;</span><br><span class="line">			AND name LIKE &#x27;Rose%&#x27;</span><br><span class="line">	)</span><br><span class="line">ORDER BY</span><br><span class="line">	name;</span><br></pre></td></tr></table></figure>

<h2 id="Q9-15-points-q9-ode-to-the-dead"><a href="#Q9-15-points-q9-ode-to-the-dead" class="headerlink" title="Q9 [15 points] (q9_ode_to_the_dead):"></a>Q9 [15 points] (q9_ode_to_the_dead):</h2><p>这就是窗口函数么，学习了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">	SELECT</span><br><span class="line">		category,</span><br><span class="line">		name,</span><br><span class="line">		died,</span><br><span class="line">		primary_title,</span><br><span class="line">		runtime_minutes,</span><br><span class="line">		DENSE_RANK() OVER(</span><br><span class="line">			PARTITION BY category</span><br><span class="line">			ORDER BY died, name</span><br><span class="line">		) AS rank_died_name,</span><br><span class="line">		DENSE_RANK() OVER(</span><br><span class="line">			PARTITION BY category, person_id</span><br><span class="line">			ORDER BY runtime_minutes DESC, title_id</span><br><span class="line">		) AS rank_runtime_title</span><br><span class="line">	FROM</span><br><span class="line">		crew</span><br><span class="line">		INNER JOIN people USING(person_id)</span><br><span class="line">		INNER JOIN titles USING(title_id)</span><br><span class="line">	WHERE</span><br><span class="line">		died IS NOT NULL</span><br><span class="line">		AND runtime_minutes IS NOT NULL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	category,</span><br><span class="line">	name,</span><br><span class="line">	died,</span><br><span class="line">	primary_title,</span><br><span class="line">	runtime_minutes,</span><br><span class="line">	rank_died_name</span><br><span class="line">FROM</span><br><span class="line">	t</span><br><span class="line">WHERE</span><br><span class="line">	rank_died_name &lt;= 5</span><br><span class="line">	AND rank_runtime_title = 1</span><br><span class="line">ORDER BY</span><br><span class="line">	category,</span><br><span class="line">	rank_died_name;</span><br></pre></td></tr></table></figure>

<h2 id="Q10-15-points-q10-all-played-by-leo"><a href="#Q10-15-points-q10-all-played-by-leo" class="headerlink" title="Q10 [15 points] (q10_all_played_by_leo):"></a>Q10 [15 points] (q10_all_played_by_leo):</h2><p>不会。。<code>json_each</code> 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">WITH t1(characters) AS (</span><br><span class="line">	SELECT</span><br><span class="line">		characters</span><br><span class="line">	FROM</span><br><span class="line">		people</span><br><span class="line">		INNER JOIN crew USING(person_id)</span><br><span class="line">	WHERE</span><br><span class="line">		name = &#x27;Leonardo DiCaprio&#x27;</span><br><span class="line">		AND born = 1974</span><br><span class="line">),</span><br><span class="line">t2(value) AS (</span><br><span class="line">	SELECT</span><br><span class="line">		DISTINCT(value)</span><br><span class="line">	FROM</span><br><span class="line">		t1,</span><br><span class="line">		json_each(t1.characters)</span><br><span class="line">	WHERE</span><br><span class="line">		value != &#x27;&#x27;</span><br><span class="line">		AND value NOT LIKE &#x27;%SELF%&#x27;</span><br><span class="line">	ORDER BY</span><br><span class="line">		value</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	GROUP_CONCAT(value)</span><br><span class="line">FROM</span><br><span class="line">	t2;</span><br></pre></td></tr></table></figure>

<h2 id="作业小结"><a href="#作业小结" class="headerlink" title="作业小结"></a>作业小结</h2><p>最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%E8%AF%BE%E7%A8%8B/page/8/">上一页</a></div><div class="pagination-next"><a href="/categories/%E8%AF%BE%E7%A8%8B/page/10/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/page/8/">8</a></li><li><a class="pagination-link is-current" href="/categories/%E8%AF%BE%E7%A8%8B/page/9/">9</a></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/page/10/">10</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">158</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-13T01:09:43.306Z">2025-07-13</time></p><p class="title"><a href="/2025/07/13/CS229%20Machine%20Learning/">CS229: Machine Learning</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-26T00:11:50.404Z">2025-04-26</time></p><p class="title"><a href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> / <a href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-18T10:01:46.499Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-17T16:42:59.185Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/CMU%2015-445645%20%E2%80%94%20Fall%202024%20Projects/">CMU 15-445/645 — Fall 2024 Projects</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">102</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>