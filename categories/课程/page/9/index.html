<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 课程 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">课程</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-12T11:11:04.126Z" title="2023/9/12 19:11:04">2023-09-12</time>发表</span><span class="level-item"><time dateTime="2023-09-29T10:10:43.206Z" title="2023/9/29 18:10:43">2023-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">39 分钟读完 (大约5917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/12/Project%201%20-%20Buffer%20Pool/">Project #1 - Buffer Pool</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project1/">Project #1 - Buffer Pool</a></p>
<p>准备工作：阅读 <strong>Chapter 12.1-12.4 13.2-13.3 24.2</strong>，学习 <strong>Lecture #03 #04</strong>，以及阅读课堂笔记。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><strong>buffer_pool_manager</strong></p>
<p><code>pages_</code> 数组相当于缓冲池，<code>frame_id</code> 是该数组的下标，也就唯一标识一个 <code>Page</code>，即标识一个缓冲页面。一个 <code>Page</code> 可以存储不同的物理页面，<code>Page</code> 的数据成员 <code>page_id_</code> 唯一标识一个物理页面。因为不管是 <code>FetchPage</code>，还是 <code>DeletePage</code> 等函数，我们都是针对实际的物理页面做操作，所以 <code>buffer_pool_manager</code> 中的函数的形参都是提供 <code>page_id</code>。</p>
<p><strong>lru_k_replacer</strong></p>
<p>该类提供缓冲页面的淘汰策略，即淘汰某个 <code>fram_id</code> 对应的缓冲页面。一个缓冲页面会有一个对应的 <code>LRUKNode</code>，它负责记录该缓冲页面的访问历史。</p>
<p><strong>page_guard</strong></p>
<p>主要有三个类：<code>BasicPageGuard</code>，<code>ReadPageGuard</code> 和 <code>WritePageGuard</code>。<code>BasicPageGuard</code> 的作用是保证缓冲页面在使用完后会进行 <code>UnpinPage</code> 操作。而 <code>ReadPageGuard</code> 和 <code>WritePageGuard</code>，它们和 <code>BasicPageGuard</code> 是组合关系，它们的作用在 <code>BasicPageGuard</code> 的基础上保证页面在使用完后会解除读写锁。</p>
<h2 id="Task-1-LRU-K-Replacement-Policy"><a href="#Task-1-LRU-K-Replacement-Policy" class="headerlink" title="Task #1 - LRU-K Replacement Policy"></a>Task #1 - LRU-K Replacement Policy</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>① 一开始以为 <code>current_timestamp_</code> 自动就是当前时间戳，调试时发现一直是 \(0\)，我真笨。可以直接从 \(0\) 开始手动模拟时间戳，调用 <code>RecordAccess</code> 时，让当前时间戳加 \(1\) 即可。</p>
<p>② 在 <code>Evict</code> 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 <code>frame</code>，结果淘汰的是第一次访问时间最早的 <code>frame</code>。</p>
<p>③ 在 <code>ListNode</code> 中使 <code> history_</code> 的长度不超过 <code>k_</code>，如果超过就调用 <code>pop_front()</code>，这样每次获取之前第 <code>k_</code> 个访问记录只需要调用 <code>front()</code> 函数。</p>
<p>④ 在 <code>RecordAccess</code> 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 <code>BufferPoolManager</code> 构造函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we allocate a consecutive memory space for the buffer pool</span></span><br><span class="line">pages_ = <span class="keyword">new</span> Page[pool_size_];</span><br><span class="line">replacer_ = std::<span class="built_in">make_unique</span>&lt;LRUKReplacer&gt;(pool_size, replacer_k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initially, every page is in the free list.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    free_list_.<span class="built_in">emplace_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码说明 <code>frame_id</code> 是小于 <code>pool_size</code> 的，所以大于等于 <code>pool_size</code> 的 <code>fram_id</code> 都应该抛出异常。（或许小于零的也应该抛出异常）</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>① 测试时将 <code>DISABLED_SampleTest</code> 改为 <code>SampleTest</code>。</p>
<p>② 忘记 C++ 的 <code>=</code> 是拷贝，传引用加上 <code>&amp;</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> node = node_store_.<span class="built_in">at</span>(frame_id); <span class="comment">// 错误：拷贝</span></span><br></pre></td></tr></table></figure>

<p>③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。</p>
<h2 id="Task-2-Buffer-Pool-Manager"><a href="#Task-2-Buffer-Pool-Manager" class="headerlink" title="Task #2 - Buffer Pool Manager"></a>Task #2 - Buffer Pool Manager</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>① <code>NewPage</code> 和 <code>FetchPage</code> 有很多逻辑相同的部分，可以加个辅助函数来获取 <code>frame_id</code>。</p>
<p>② 注意，在 <code>FetchPage</code> 时，如果页面在内存中并且 <code>pin_count_ = 0</code>，则需要将其设置为不可淘汰的。</p>
<p>③ 在 <code>UnpinPage</code> 中，更新 <code>is_dirty</code> 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。</p>
<p>④ 在 <code>FlushPage</code> 中，注释表示 <code>REGARDLESS of the dirty flag</code>，应该说的是函数调用者，我们在实现时可以根据 <code>is_dirty</code> 来判断是否实际刷盘。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。</p>
<p>② 实现 <code>FetchPage</code> 时，有个情况我忘记调用 <code>RecordAccess</code>，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。</p>
<h2 id="Task-3-Read-x2F-Write-Page-Guards"><a href="#Task-3-Read-x2F-Write-Page-Guards" class="headerlink" title="Task #3 - Read&#x2F;Write Page Guards"></a>Task #3 - Read&#x2F;Write Page Guards</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>① 使用移动构造和移动赋值后，需要清除 <code>that</code> 的元数据。</p>
<p>② 移动赋值的调用者，也就是 <code>this</code>，如果其 <code>page_ != nullptr</code>，那么需要先将其 <code>Drop</code>，再进行赋值操作。</p>
<p>③ 实现读写页面守卫的移动构造函数，可以直接赋值 <code>std::move(that.guard_)</code>，相当于调用之前实现的 <code>BasicPageGuard</code> 的移动赋值运算符。</p>
<p>④ 实现读写页面守卫的 <code>Drop</code> 时，需要注意在调用 <code>guard_.Drop()</code> 之后再解锁页面，所以在 <code>Drop</code> 之前需要保存一下指向页面的指针。</p>
<p>⑤ 在实现 <code>BufferPoolManager</code> 中的 <code>FetchPageRead</code> 和 <code>FetchPageWrite</code> 时，为页面加读写锁。</p>
<p>⑥ 和 <code>PageGuard</code> 有关的 <code>FetchPage</code> 函数会返回一个 <code>PageGuard</code> 对象，但是如果所有缓存页已经被 <code>pin</code>，那么该返回什么。一开始我是直接拿 <code>nullptr</code> 构造 <code>PageGuard</code>，但是发现不对，因为 <code>PageGuard</code> 对象并没有检查 <code>page_ == nullptr</code> 的函数，所以页面必须被 <code>Fetch</code> 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（<del>不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管</del>）</p>
<h2 id="Leaderboard-Task-Optional"><a href="#Leaderboard-Task-Optional" class="headerlink" title="Leaderboard Task (Optional)"></a>Leaderboard Task (Optional)</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>性能分析</strong></p>
<p>看到<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略</a>中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 <code>perf</code> 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.brendangregg.com/overview.html">Brendan Gregg’s Homepage</a></li>
<li><a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/runbooks/-/blob/v2.220.2/docs/tutorials/how_to_use_flamegraphs_for_perf_profiling.md">How to use flamegraphs for performance profiling</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362575905">profiling 与性能优化总结</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jlfwong/speedscope">speedscope</a></li>
</ul>
<p><strong>LRU-K（对优化似乎没有帮助）</strong></p>
<p>关于 LRU-K 的论文：<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf">The LRU-K Page Replacement Algorithm For Database Disk Buffering</a>。</p>
<p>LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析）</p>
<p>解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂）</p>
<p>LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。</p>
<p>LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\(K\geq 2\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>更新：以下内容存在一些错误，将会在下一节纠正。</p>
<p>① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。</p>
<p>② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 <code>frame_id</code>，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我）</p>
<p>③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 <code>bpm-bench</code> 测试），结果发现是我理解有问题。尝试使用读写锁在 <code>BufferPoolManager</code> 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 <code>Unknown</code> 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 <code>FetchPage</code> 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。</p>
<p>④ 参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/644160340">CMU 15-445 2023 P1 优化攻略</a>，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 <code>ResetMemory</code> 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。</p>
<p>⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 <code>BufferPoolManager</code> 之前析构 <code>DiskManager</code>，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。</p>
<p>⑥ <del>本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。</del>突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 <code>LRUKNode</code> 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 <code>Evict</code> 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性）</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_0ms</th>
<th>get_qps_0ms</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody><tr>
<td>61</td>
<td>ALEX</td>
<td>111924</td>
<td>104867</td>
<td>261</td>
<td>484</td>
<td>5123</td>
</tr>
<tr>
<td>32</td>
<td>ALEX</td>
<td>102401</td>
<td>96293</td>
<td>4886</td>
<td>5221</td>
<td>57123</td>
</tr>
<tr>
<td>2</td>
<td>ALEX</td>
<td>120664</td>
<td>123402</td>
<td>182590</td>
<td>248050</td>
<td>2663116</td>
</tr>
<tr>
<td>12</td>
<td>ALEX</td>
<td>143562</td>
<td>133514</td>
<td>3813</td>
<td>8132</td>
<td>85169</td>
</tr>
</tbody></table>
<h3 id="重做"><a href="#重做" class="headerlink" title="重做"></a>重做</h3><p><strong>实现纠错</strong></p>
<p>在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 <code>page_table_</code>），<strong>但是，如果在刷盘过程中，有另一个线程读取该页面，它在 <code>page_table_</code> 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误</strong>，错误在 <code>disk_manager_memory.h</code> 中被检测：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data_.<span class="built_in">size</span>()) || page_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_WARN</span>(<span class="string">&quot;page not exist&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 <code>page_id</code> 和 <code>frame_id</code>，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 <code>page_table_</code> 的锁，以确保在其他线程 <code>FetchPage</code> 时，表中已有该 <code>page_id</code>）。这时如果有其他线程 <code>Fetch</code> 该 <code>page_id</code>，不会直接从磁盘读，而是读这个表拿到之前的 <code>frame_id</code>，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 <code>FetchPage</code> 该 <code>page_id</code> 时，会发生已淘汰又被 <code>pin</code> 的情况，还会发生其他很复杂的情况）</p>
<p><strong>如何优化</strong></p>
<p>既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 <a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a>（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）：</p>
<p>① 缓存页面的访问规则</p>
<ul>
<li>读写页面时必须 <code>pin</code> 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 <code>pin</code>）</li>
<li>在读页面时，可以释放页面的读锁，因为已经拿到页面的 <code>pin</code>。</li>
<li>在写页面时，必须拿到 <code>pin</code> 和写锁，并且需要检查 <code>pincount_ == 1</code>，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 <code>unpin</code>，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 <code>pin</code>，但是没有关系，因为当前线程拿到写锁，其他线程 <code>pin</code> 之后还需要拿锁才能读写页面。</li>
</ul>
<p>我们的项目和上面的描述不一样，但是无伤大雅，基本上 <code>PageGuard</code> 和 <code>FetchPage</code> 等函数已经提供了这些功能。</p>
<p>② 缓冲池管理器的内部锁定</p>
<ul>
<li>访问 <code>page_table_</code> 前需要拿到 <code>page_table</code> 的读写锁（文中称作 <code>BufMappingLock</code>）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 <code>pin</code>。在修改 <code>page_table_</code>，或者修改缓存页面头部字段（应该是指 <code>Page</code> 的除 <code>data_</code> 以外的成员变量，在本项目中就是 <code>page_id_</code>、<code>pin_count_</code> 和 <code>is_dirty_</code>），或者从磁盘读物理页面到缓存页面时，需要拿到 <code>page_table_</code> 的写锁。</li>
<li>可以将 <code>BufMappingLock</code> 拆分为 <code>NUM_BUFFER_PARTITIONS</code> 个锁，每个锁负责映射的一部分。每个 <code>page_id_</code> 属于哪个分区，由 <code>page_id_</code> 的哈希值的低比特位决定（其实就是有多个 <code>page_table_</code>，每个 <code>page_id</code> 会根据哈希函数来确定存放在哪个 <code>page_table_</code> 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。</li>
<li>为空闲列表和页面替换提供独占的自旋锁 <code>buffer_strategy_lock</code> ，当拿到该锁时，不应该去获取任何其他锁。</li>
<li>每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 <code>BufMappingLock</code> 锁）。</li>
<li><code>BM_IO_IN_PROGRESS</code> 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 <code>BufMappingLock</code> 锁吧）。</li>
</ul>
<p>缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。</p>
<p>③ 后台线程刷盘</p>
<ul>
<li>按照淘汰顺序扫描页面，选择 <code>is_dirty_ == true &amp;&amp; pin_count_ == 0</code> 的页面，然后 <code>pin</code> 该页面并刷盘，最后回收到空闲列表。</li>
<li>还有一些优化方式，没看懂就不翻译了。</li>
</ul>
<p>总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。</p>
<p><strong>尝试实现</strong></p>
<p>重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。</p>
<p>① <code>FetchPage</code> 在判断 <code>page_id</code> 是否在 <code>page_table_</code> 时，需要使用 <code>page_table_</code> 的独占锁。并且如果页面不在 <code>page_table_</code> 中，则在函数返回 <code>nullptr</code> 或修改 <code>page_table_</code> 之前不能释放该锁，以防止多次 <code>FetchPage</code> 同一个 <code>page_id</code> 时，多次从 <code>free_list_</code> 中获取页面或者多次淘汰页面。</p>
<p>② 因为在 <code>FetchPage</code> 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 <code>pin</code> 的，所以之后设置 <code>pin_count_</code> 时，不能直接设置为 <code>1</code>，而是进行 <code>++</code> 操作。</p>
<p>第一次重构没有拆分 <code>BufMappingLock</code>，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 <code>unique_lock</code> 作为参数，并且 <code>atomic_flag</code> 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。<del>不搞了，像个小丑，没意思。</del></p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Submission Name</th>
<th>scan_qps_0ms</th>
<th>get_qps_0ms</th>
<th>scan_qps_1ms</th>
<th>get_qps_1ms</th>
<th>QPS</th>
</tr>
</thead>
<tbody><tr>
<td>26</td>
<td>ALEX</td>
<td>92024</td>
<td>80293</td>
<td>5082</td>
<td>5287</td>
<td>57971</td>
</tr>
</tbody></table>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。</p>
<p>② 优化时容易出问题的点就是 <code>NewPage</code> 和 <code>FetchPage</code>，以及 <code>UnpinPage</code>。像是 <code>FlushPage</code>、<code>FlushAllPage</code> 以及 <code>DeletePage</code> 都可以暂时不管（可以直接 <code>return</code>），这样比较方便调试。</p>
<h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><p>① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。</p>
<p>② 遇到 Reference to non-static member function must be called 问题，解决方案<a target="_blank" rel="noopener" href="https://thispointer.com/c11-start-thread-by-member-function-with-arguments/">在此</a>。</p>
<p>③ MySQL Buffer Pool 的实现 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">15.5.1 Buffer Pool</a>。</p>
<p>④ Linus Torvalds 发表的一篇<a target="_blank" rel="noopener" href="https://www.realworldtech.com/forum/?threadid=189711&curpostid=189723">评论</a>：do not use spinlocks in user space, unless you actually know what you’re doing。</p>
<p>⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。</p>
<p>⑥ 发现一个感觉不错的博客：<a target="_blank" rel="noopener" href="https://www.modernescpp.com/">MC++</a>。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。</p>
<p><img src="/img/CMU_15-445.assets/1693653679462.png"></p>
<p>优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。</p>
<p><img src="/img/CMU_15-445.assets/1694514338965.png"></p>
<p>每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)</span><br><span class="line">./test/lru_k_replacer_test</span><br><span class="line">./test/buffer_pool_manager_test</span><br><span class="line">./test/page_guard_test</span><br><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p1</span><br><span class="line">make submit-p1</span><br></pre></td></tr></table></figure>

<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。</p>
<p>② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，<code>bpm</code> 优化也就是简单减少锁的粒度，<code>lru</code> 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。</p>
<p>③ <del>我好菜啊！！！</del>前三个任务花了两天，优化花了好几天。</p>
<hr>
<p>更新：发现 <strong>Lecture #06</strong> 就是讲 BufferPool 优化的（<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/notes/06-bufferpool.pdf">课堂笔记</a>），不知道能不能在这用上，等做完所有 Project 再来试试。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-29T15:51:15.836Z" title="2023/8/29 23:51:15">2023-08-29</time>发表</span><span class="level-item"><time dateTime="2023-08-29T16:01:06.457Z" title="2023/8/30 00:01:06">2023-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">6 分钟读完 (大约917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/29/Homework%201%20-%20SQL/">Homework #1 - SQL</a></p><div class="content"><h2 id="作业准备"><a href="#作业准备" class="headerlink" title="作业准备"></a>作业准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/homework1/">Homework #1 - SQL</a>。</p>
<p>准备工作：阅读 <strong>Chapters 1-2 27 3-5</strong>，学习 <strong>Lecture #01 #02</strong>，以及阅读课堂笔记。</p>
<h2 id="Q1-0-points-q1-sample"><a href="#Q1-0-points-q1-sample" class="headerlink" title="Q1 [0 points] (q1_sample):"></a>Q1 [0 points] (q1_sample):</h2><p>Ctrl + C，Ctrl +V。</p>
<h2 id="Q2-5-points-q2-not-the-same-title"><a href="#Q2-5-points-q2-not-the-same-title" class="headerlink" title="Q2 [5 points] (q2_not_the_same_title):"></a>Q2 [5 points] (q2_not_the_same_title):</h2><p>查询只涉及 <code>titles</code> 表，比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	premiered,</span><br><span class="line">	primary_title || &#x27; (&#x27; || original_title || &#x27;)&#x27;</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">WHERE</span><br><span class="line">	primary_title != original_title</span><br><span class="line">	AND type = &#x27;movie&#x27;</span><br><span class="line">	AND genres LIKE &#x27;%Action%&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">	premiered DESC,</span><br><span class="line">	primary_title</span><br><span class="line">LIMIT</span><br><span class="line">	10;</span><br></pre></td></tr></table></figure>

<h2 id="Q3-5-points-q3-longest-running-tv"><a href="#Q3-5-points-q3-longest-running-tv" class="headerlink" title="Q3 [5 points] (q3_longest_running_tv):"></a>Q3 [5 points] (q3_longest_running_tv):</h2><p>题目描述很不清晰啊，类型都不知道具体是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	primary_title,</span><br><span class="line">	IIF(ended IS NULL, 2023, ended) - premiered AS runtime</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">WHERE</span><br><span class="line">	primary_title IS NOT NULL</span><br><span class="line">	AND type = &#x27;tvSeries&#x27;</span><br><span class="line">ORDER BY</span><br><span class="line">	runtime DESC,</span><br><span class="line">	primary_title</span><br><span class="line">LIMIT</span><br><span class="line">	20;</span><br></pre></td></tr></table></figure>

<h2 id="Q4-10-points-q4-directors-in-each-decade"><a href="#Q4-10-points-q4-directors-in-each-decade" class="headerlink" title="Q4 [10 points] (q4_directors_in_each_decade):"></a>Q4 [10 points] (q4_directors_in_each_decade):</h2><p>唯一要注意的就是使用 <code>DISTINCT</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	CAST(born / 10 * 10 AS TEXT) || &#x27;s&#x27; AS decade,</span><br><span class="line">	COUNT(DISTINCT(people.person_id)) AS num_directors</span><br><span class="line">FROM</span><br><span class="line">	people</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	category = &#x27;director&#x27;</span><br><span class="line">	AND born &gt;= 1900</span><br><span class="line">GROUP BY</span><br><span class="line">	decade</span><br><span class="line">ORDER BY</span><br><span class="line">	decade;</span><br></pre></td></tr></table></figure>

<h2 id="Q5-10-points-q5-german-type-ratings"><a href="#Q5-10-points-q5-german-type-ratings" class="headerlink" title="Q5 [10 points] (q5_german_type_ratings):"></a>Q5 [10 points] (q5_german_type_ratings):</h2><p>德语的缩写是 <code>de</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	t.type,</span><br><span class="line">	ROUND(AVG(r.rating), 2) AS avg_rating,</span><br><span class="line">	MIN(r.rating),</span><br><span class="line">	MAX(r.rating)</span><br><span class="line">FROM</span><br><span class="line">	akas as a</span><br><span class="line">	INNER JOIN ratings as r USING(title_id)</span><br><span class="line">	INNER JOIN titles as t USING(title_id)</span><br><span class="line">WHERE</span><br><span class="line">	a.language = &#x27;de&#x27;</span><br><span class="line">	AND a.types IN (&#x27;imdbDisplay&#x27;, &#x27;original&#x27;)</span><br><span class="line">GROUP BY</span><br><span class="line">	t.type</span><br><span class="line">ORDER BY</span><br><span class="line">	avg_rating;</span><br></pre></td></tr></table></figure>

<h2 id="Q6-10-points-q6-who-played-a-batman"><a href="#Q6-10-points-q6-who-played-a-batman" class="headerlink" title="Q6 [10 points] (q6_who_played_a_batman):"></a>Q6 [10 points] (q6_who_played_a_batman):</h2><p>坑点就是模糊查询时 <code>Batman</code> 两边要加上双引号，即 <code>&quot;Batman&quot;</code>。以及在连接 <code>people</code> 和 <code>crew</code> 表时，顺序很重要，如果使用 <code>crew INNRE JOIN people USING(person_id)</code> 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">crew INNER JOIN people USING(person_id)</span><br><span class="line"></span><br><span class="line">QUERY PLAN</span><br><span class="line">|--SCAN crew USING INDEX ix_crew_person_id</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--USE TEMP B-TREE FOR DISTINCT</span><br><span class="line"></span><br><span class="line">people INNER JOIN crew USING(person_id)</span><br><span class="line"></span><br><span class="line">QUERY PLAN</span><br><span class="line">|--SCAN crew</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--USE TEMP B-TREE FOR DISTINCT</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">	SELECT</span><br><span class="line">		DISTINCT(person_id),</span><br><span class="line">		name</span><br><span class="line">	FROM</span><br><span class="line">		people</span><br><span class="line">		INNER JOIN crew USING(person_id)</span><br><span class="line">	WHERE</span><br><span class="line">		category = &#x27;actor&#x27;</span><br><span class="line">		AND characters LIKE &#x27;%&quot;Batman&quot;%&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	name,</span><br><span class="line">	ROUND(AVG(rating), 2) AS avg_rating</span><br><span class="line">FROM</span><br><span class="line">	t</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">	INNER JOIN ratings USING(title_id)</span><br><span class="line">GROUP BY</span><br><span class="line">	person_id</span><br><span class="line">ORDER BY</span><br><span class="line">	avg_rating DESC</span><br><span class="line">LIMIT</span><br><span class="line">	10;</span><br></pre></td></tr></table></figure>

<h2 id="Q7-15-points-q7-born-with-prestige"><a href="#Q7-15-points-q7-born-with-prestige" class="headerlink" title="Q7 [15 points] (q7_born_with_prestige):"></a>Q7 [15 points] (q7_born_with_prestige):</h2><p>SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	COUNT(DISTINCT(person_id))</span><br><span class="line">FROM</span><br><span class="line">	titles</span><br><span class="line">	INNER JOIN people ON titles.premiered = people.born</span><br><span class="line">	INNER JOIN crew USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	primary_title = &#x27;The Prestige&#x27;</span><br><span class="line">	AND category IN (&#x27;actor&#x27;, &#x27;actress&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QUERY PLAN</span><br><span class="line">|--USE TEMP B-TREE FOR count(DISTINCT)</span><br><span class="line">|--SCAN crew</span><br><span class="line">|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)</span><br><span class="line">`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?)</span><br></pre></td></tr></table></figure>

<h2 id="Q8-15-points-q8-directing-rose-sql"><a href="#Q8-15-points-q8-directing-rose-sql" class="headerlink" title="Q8 [15 points] (q8_directing_rose.sql):"></a>Q8 [15 points] (q8_directing_rose.sql):</h2><p>比官解快一秒。注意使用 <code>Rose%</code> 而不是 <code>Rose %</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	DISTINCT(name)</span><br><span class="line">FROM</span><br><span class="line">	crew</span><br><span class="line">	INNER JOIN people USING(person_id)</span><br><span class="line">WHERE</span><br><span class="line">	category = &#x27;director&#x27;</span><br><span class="line">	AND title_id IN (</span><br><span class="line">		SELECT</span><br><span class="line">			title_id</span><br><span class="line">		FROM</span><br><span class="line">			crew</span><br><span class="line">			INNER JOIN people USING(person_id)</span><br><span class="line">		WHERE</span><br><span class="line">			category = &#x27;actress&#x27;</span><br><span class="line">			AND name LIKE &#x27;Rose%&#x27;</span><br><span class="line">	)</span><br><span class="line">ORDER BY</span><br><span class="line">	name;</span><br></pre></td></tr></table></figure>

<h2 id="Q9-15-points-q9-ode-to-the-dead"><a href="#Q9-15-points-q9-ode-to-the-dead" class="headerlink" title="Q9 [15 points] (q9_ode_to_the_dead):"></a>Q9 [15 points] (q9_ode_to_the_dead):</h2><p>这就是窗口函数么，学习了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">	SELECT</span><br><span class="line">		category,</span><br><span class="line">		name,</span><br><span class="line">		died,</span><br><span class="line">		primary_title,</span><br><span class="line">		runtime_minutes,</span><br><span class="line">		DENSE_RANK() OVER(</span><br><span class="line">			PARTITION BY category</span><br><span class="line">			ORDER BY died, name</span><br><span class="line">		) AS rank_died_name,</span><br><span class="line">		DENSE_RANK() OVER(</span><br><span class="line">			PARTITION BY category, person_id</span><br><span class="line">			ORDER BY runtime_minutes DESC, title_id</span><br><span class="line">		) AS rank_runtime_title</span><br><span class="line">	FROM</span><br><span class="line">		crew</span><br><span class="line">		INNER JOIN people USING(person_id)</span><br><span class="line">		INNER JOIN titles USING(title_id)</span><br><span class="line">	WHERE</span><br><span class="line">		died IS NOT NULL</span><br><span class="line">		AND runtime_minutes IS NOT NULL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	category,</span><br><span class="line">	name,</span><br><span class="line">	died,</span><br><span class="line">	primary_title,</span><br><span class="line">	runtime_minutes,</span><br><span class="line">	rank_died_name</span><br><span class="line">FROM</span><br><span class="line">	t</span><br><span class="line">WHERE</span><br><span class="line">	rank_died_name &lt;= 5</span><br><span class="line">	AND rank_runtime_title = 1</span><br><span class="line">ORDER BY</span><br><span class="line">	category,</span><br><span class="line">	rank_died_name;</span><br></pre></td></tr></table></figure>

<h2 id="Q10-15-points-q10-all-played-by-leo"><a href="#Q10-15-points-q10-all-played-by-leo" class="headerlink" title="Q10 [15 points] (q10_all_played_by_leo):"></a>Q10 [15 points] (q10_all_played_by_leo):</h2><p>不会。。<code>json_each</code> 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">WITH t1(characters) AS (</span><br><span class="line">	SELECT</span><br><span class="line">		characters</span><br><span class="line">	FROM</span><br><span class="line">		people</span><br><span class="line">		INNER JOIN crew USING(person_id)</span><br><span class="line">	WHERE</span><br><span class="line">		name = &#x27;Leonardo DiCaprio&#x27;</span><br><span class="line">		AND born = 1974</span><br><span class="line">),</span><br><span class="line">t2(value) AS (</span><br><span class="line">	SELECT</span><br><span class="line">		DISTINCT(value)</span><br><span class="line">	FROM</span><br><span class="line">		t1,</span><br><span class="line">		json_each(t1.characters)</span><br><span class="line">	WHERE</span><br><span class="line">		value != &#x27;&#x27;</span><br><span class="line">		AND value NOT LIKE &#x27;%SELF%&#x27;</span><br><span class="line">	ORDER BY</span><br><span class="line">		value</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	GROUP_CONCAT(value)</span><br><span class="line">FROM</span><br><span class="line">	t2;</span><br></pre></td></tr></table></figure>

<h2 id="作业小结"><a href="#作业小结" class="headerlink" title="作业小结"></a>作业小结</h2><p>最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-26T07:03:34.193Z" title="2023/8/26 15:03:34">2023-08-26</time>发表</span><span class="level-item"><time dateTime="2023-08-31T07:51:08.876Z" title="2023/8/31 15:51:08">2023-08-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></span><span class="level-item">13 分钟读完 (大约1935个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/26/Project%200%20-%20C++%20Primer/">Project #0 - C++ Primer</a></p><div class="content"><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/spring2023/project0/">Project #0 - C++ Primer</a>。</p>
<p>准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。</p>
<h2 id="Task-1-Copy-On-Write-Trie"><a href="#Task-1-Copy-On-Write-Trie" class="headerlink" title="Task #1 - Copy-On-Write Trie"></a>Task #1 - Copy-On-Write Trie</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>Get 函数</strong></p>
<p>没有什么特别需要注意的，实现比较简单。</p>
<p>实现逻辑：</p>
<ul>
<li>如果 <code>root_ == nullptr</code> 为真，则返回 <code>nullptr</code>。</li>
<li>沿着 Trie 树遍历，如果节点不存在，则返回 <code>nullptr</code>。</li>
<li>如果目标节点不是 <code>TrieNodeWithValue</code> 类型，则返回 <code>nullptr</code>。</li>
<li>否则，返回目标节点的值。</li>
</ul>
<p><strong>Put 函数</strong></p>
<p>一开始比较疑惑的点是，智能指针存储的都是 <code>const</code> 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？</p>
<p>其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 <code>const</code> 指针就能做到。</p>
<p>本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 <code>key.empty()</code> 和 <code>root_ == nullptr</code>。</p>
<p>实现逻辑：</p>
<ul>
<li>如果 <code>key.empty()</code> 为真：<ul>
<li>如果 <code>root_ == nullptr</code> 为真，则使用 <code>value​</code> 构造 Trie 树并返回。</li>
<li>否则，使用 <code>root_-&gt;children_</code> 和 <code>value</code> 构造 Trie 树并返回。</li>
</ul>
</li>
<li>根据 <code>root_ == nullptr</code> 条件初始化新 Trie 树的 <code>root</code>。</li>
<li>沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）：<ul>
<li>如果克隆完所有字符，则返回新 Trie 树。</li>
<li>否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。</li>
</ul>
</li>
</ul>
<p><strong>Remove 函数</strong></p>
<p>需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意：</p>
<p>① 节点不包含值需要转换为 <code>TrieNode</code> 类型，也就是说拷贝的时候需要调用 <code>TrieNode::Clone()</code>。</p>
<p>② 如果节点满足 <code>children_.empty() &amp;&amp; !is_value_node_</code> 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 <code>erase</code> 父节点中 <code>map</code> 的 <code>key</code>。</p>
<p>实现逻辑：</p>
<ul>
<li>如果 <code>root_ == nullptr</code> 为真，则返回 <code>*this</code>。</li>
<li>如果 <code>key.empty()</code> 为真，则调用 <code>root_-&gt;TrieNode::Clone()</code> 克隆，并返回新 Trie 树。</li>
<li>沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 <code>*this</code>。</li>
<li>将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。</li>
<li>否则，依次克隆栈中的元素，然后返回新 Trie 树。</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>C++</strong></p>
<p>因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。</p>
<p>① 使用 <code>at</code> 访问 <code>const map</code> 对象，因为 <code>[]</code> 运算符可能会自动添加键值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">cout &lt;&lt; m[<span class="number">1024</span>]; <span class="comment">// 错误，No viable overloaded operator[] for type &#x27;const map&lt;int, int&gt;&#x27;</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">at</span>(<span class="number">1024</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>② <code>=</code> 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="number">1024</span>] = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">auto</span> n = m;</span><br><span class="line">n[<span class="number">1024</span>] = <span class="number">2048</span>;</span><br><span class="line">cout &lt;&lt; m[<span class="number">1024</span>]; <span class="comment">// 输出：1024</span></span><br></pre></td></tr></table></figure>

<p>③ 在 Java 中只要是对象就可以和 <code>null</code> 比较，而 C++ 中只有指针可以和 <code>nullptr</code> 比较。</p>
<p><strong>GDB</strong></p>
<p>① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击<a target="_blank" rel="noopener" href="https://bugs.llvm.org/show_bug.cgi?id=24202">此处</a>产生该问题的原因，以及相应的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/55718257/using-standard-c-library-debug-symbols-ubuntu-linux-libstdc6-8-dbg">解决方案</a>告诉我下载 <code>libstdc++6-dbgsym</code>，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。</p>
<p>② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">在此</a>查看该课程提供的 GDB 教程。以及可以阅读：<a target="_blank" rel="noopener" href="https://discover.cs.ucsb.edu/commonerrors/tutorial/gdbtutorial.html">GDB Tutorial: Finding Segmentation Faults</a>。</p>
<p>③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。</p>
<p><strong>CMake</strong></p>
<p>项目推荐使用 clang-14 作为编译器，解决方案<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7031126/switching-between-gcc-and-clang-llvm-using-cmake">在此</a>。</p>
<h2 id="Task-2-Concurrent-Key-Value-Store"><a href="#Task-2-Concurrent-Key-Value-Store" class="headerlink" title="Task #2 - Concurrent Key-Value Store"></a>Task #2 - Concurrent Key-Value Store</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 <code>std::mutex</code> 即可。读操作在获取 <code>root_</code> 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 <code>write_lock_</code> 上锁。<code>Put</code> 时记得使用 <code>std::move()</code>，因为值可能是不可复制的。</p>
<h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>① 关于线程和锁的知识，推荐阅读 <a target="_blank" rel="noopener" href="https://web.stanford.edu/class/archive/cs/cs110/cs110.1204/static/lectures/10-threads-and-mutexes.pdf">CS110 Lecture 10: Threads and Mutexes</a>。</p>
<p>② C++ 有个<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">复制省略</a>（Copy elision）的优化。</p>
<p>③ 关于 C++ <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl">模板</a>的 FAQ、<code>template</code> 关键字的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords">讨论</a> 和 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name">Dependent names</a> 的定义。（<del>好复杂啊</del>）之所以查这些内容，是因为 CLion 给我生成了不同的表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> value = root.<span class="keyword">template</span> <span class="built_in">Get</span>&lt;T&gt;(key);</span><br><span class="line">root = root.<span class="keyword">template</span> <span class="built_in">Put</span>(key, std::<span class="built_in">move</span>(value));</span><br><span class="line">root = root.<span class="built_in">Remove</span>(key);</span><br></pre></td></tr></table></figure>

<p>以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 <code>&lt;&gt;</code> 来指定类型。然后何时使用 <code>template</code> 没怎么弄明白。</p>
<h2 id="Task-3-Debugging"><a href="#Task-3-Debugging" class="headerlink" title="Task #3 - Debugging"></a>Task #3 - Debugging</h2><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 <code>Put</code> 时打断点调试的，应该差不多吧。</p>
<h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><p>无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74543715/usr-bin-ld-cannot-find-lstdc-no-such-file-or-directory-on-running-flutte">在此</a>。</p>
<h2 id="Task-4-SQL-String-Functions"><a href="#Task-4-SQL-String-Functions" class="headerlink" title="Task #4 - SQL String Functions"></a>Task #4 - SQL String Functions</h2><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>文件的路径：.&#x2F;src&#x2F;include&#x2F;execution&#x2F;expressions 和 .&#x2F;src&#x2F;planner&#x2F;plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 <code>std::tolower</code> 或许有一些<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/byte/tolower">注意事项</a>。注册函数时，需要保证参数是有效的，即参数只有一个并且是 <code>VARCHAR</code> 类型。</p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord <a target="_blank" rel="noopener" href="https://discord.com/channels/724929902075445281/1063892636504698880/1075438934240268358">讨论</a>。</p>
<p><img src="/img/CMU_15-445.assets/1692961316812.png"></p>
<p>修改之后通过！</p>
<p><img src="/img/CMU_15-445.assets/1692965202906.png"></p>
<h2 id="项目小结"><a href="#项目小结" class="headerlink" title="项目小结"></a>项目小结</h2><p>任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 <code>key</code> 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%E8%AF%BE%E7%A8%8B/page/8/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/%E8%AF%BE%E7%A8%8B/page/10/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/%E8%AF%BE%E7%A8%8B/page/8/">8</a></li><li><a class="pagination-link is-current" href="/categories/%E8%AF%BE%E7%A8%8B/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">137</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-03T14:56:46.460Z">2025-01-03</time></p><p class="title"><a href="/2025/01/03/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89/">快速傅里叶变换（FFT）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/">模板</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-03T11:38:56.638Z">2024-10-03</time></p><p class="title"><a href="/2024/10/03/Coroutines%20for%20Go/">Coroutines for Go（草稿）</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Go/">Go</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-19T10:38:59.955Z">2024-09-19</time></p><p class="title"><a href="/2024/09/19/Lab%205%20Sharded%20Key%20Value%20Service/">Lab 5: Sharded Key/Value Service</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-12T13:18:26.149Z">2024-09-12</time></p><p class="title"><a href="/2024/09/12/Lab%204%20Fault-tolerant%20Key%20Value%20Service/">Lab 4: Fault-tolerant Key/Value Service</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-07T09:38:46.241Z">2024-09-07</time></p><p class="title"><a href="/2024/09/07/Lab%203%20Raft/">Lab 3: Raft</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/">MIT 6.824</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">41</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">95</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>