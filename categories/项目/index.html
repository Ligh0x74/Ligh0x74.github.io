<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 项目 - Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/links">Links</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">项目</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-04-26T00:11:50.404Z" title="2025/4/26 08:11:50">2025-04-26</time>发表</span><span class="level-item"><time dateTime="2025-05-07T02:27:15.451Z" title="2025/5/7 10:27:15">2025-05-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span> / </span><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></span><span class="level-item">43 分钟读完 (大约6438个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><div class="content"><p>参考 <a target="_blank" rel="noopener" href="https://skyzh.github.io/mini-lsm/">mini-lsm</a>，<a target="_blank" rel="noopener" href="https://discord.com/channels/1197355762297610260/1197435686370947112">Discord</a>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/">Rust Documentation</a>，<a target="_blank" rel="noopener" href="https://tourofrust.com/">Tour of Rust</a>。</p>
<h2 id="Week-1-Overview-Mini-LSM">Week 1 Overview: Mini-LSM</h2>
<h3 id="Memtables">Memtables</h3>
<p>如果要在内存中存储键值对，可以简单的使用哈希表，但是如果要支持顺序遍历以及范围查询，要使用特殊的数据结构，例如跳表、B/B+ 树、红黑树、AVL树等。<strong>为什么 LSM 实现使用跳表（<a target="_blank" rel="noopener" href="https://docs.rs/crossbeam-skiplist/latest/crossbeam_skiplist/">crossbeam_skiplist</a>）作为内存表的数据结构？</strong> B/B+ 树主要是针对磁盘 I/O 做优化，插入/删除会涉及页分裂和合并，在纯内存的场景下不太适用。红黑树是近似平衡的，AVL 树是严格平衡的，所以红黑树的插入/删除效率更好，而 AVL 树的查找效率更好。跳表的实现更加简单，而且并发友好，只需要锁定局部数据。不过跳表是基于链表实现的，数据局部性可能较差，而且概率数据结构稳定性也会差点。</p>
<p><strong>为什么内存表在 delete 时只是将值置为空，而不是删除整个键值对？</strong> 因为如果当前内存表找不到指定的 Key，那么会继续在已经冻结的内存表中找，如果删除整个键值对，则会丢失该删除操作。<strong>为什么要有多个内存表呢？</strong> 当前内存表执行 get/put 操作的同时，可以基于冻结的内存表构建 SST，然后刷到磁盘中，而不会 STW 阻塞整个 LSM。</p>
<p><strong>何时使用 <code>state</code> 读写锁和 <code>state_lock</code> 独占锁？</strong> 由于使用的跳表是支持无锁并发的，读写跳表只需要加 <code>state</code> 读锁，但是判断是否冻结以及整个冻结操作都需要加 <code>state_lock</code> 独占锁来保证原子性，可以使用双重检查加锁来优化性能。然后冻结操作内会加 <code>state</code> 写锁，将当前内存表加入冻结列表，然后创建一个新的内存表。<strong>在内存表超出限制大小需要冻结时，将 <code>state</code> 读锁释放再加写锁，与直接将读锁升级为写锁有什么区别？</strong> 在释放读锁之后，依然允许其他线程执行 get/put 操作，此时当前冻结线程可以执行昂贵的磁盘 I/O 而不会影响整体的性能。</p>
<p><img src="/img/DB.assets/1745494765832.png" alt=""></p>
<h3 id="Merge-Iterator">Merge Iterator</h3>
<p>可以构建迭代器来遍历内存表，像是 Java 中的迭代器通常会有 <code>hasNext()</code> 和 <code>next()</code> 方法来判断迭代器的有效性以及获取下一个元素。<code>StorageIterator</code> 迭代器的设计有点不同，<code>next()</code> 只会移动内部的跳表迭代器而不会返回元素，获取元素是通过 <code>key()</code> 和 <code>value()</code> 方法实现的。<strong>为什么 <code>StorageIterator</code> 迭代器的设计和 Rust 风格的迭代器不同？为什么 <code>MemTableIterator</code> 需要自引用？</strong> 因为 <code>StorageIterator</code> 迭代器可能需要多次获取当前 Key 而不移动到下一个元素，所以将移动操作和取值操作分离是比较好的选择。使用自引用结构的目的是避免编写 Rust 的生命周期代码的复杂性。</p>
<p>实现单个内存表迭代器之后，因为除当前内存表外还有多个冻结内存表，所以需要一个合并迭代器，将所有内存表迭代器合并，从而实现顺序遍历。如果有多个内存表包含相同的键，需要返回该键的最新值，以及跳过其他包含旧值的键。可以使用堆来对多个迭代器排序，首先按照键的大小排序，然后按照内存表的新旧编号排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter1: b-&gt;del, c-&gt;4, d-&gt;5</span><br><span class="line">iter2: a-&gt;1, b-&gt;2, c-&gt;3</span><br><span class="line">iter3: e-&gt;4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;1, b-&gt;del, c-&gt;4, d-&gt;5, e-&gt;4</span><br></pre></td></tr></table></figure>
<p>Rust 的 <code>BinaryHeap</code> 在修改堆中元素之后，会自动排序保证堆的有效性。如果在修改之后迭代器报错，不能直接返回错误信息，而要首先从堆中移除失效的迭代器，从而避免访问失效的迭代器（会调用其方法获取 Key）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let Some(mut inner_iter) = self.iters.peek_mut() &#123;</span><br><span class="line">    inner_iter.next()?; // &lt;- will cause problem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现合并迭代器 <code>MergeIterator</code> 之后，外部还有一个 <code>LsmIterator</code> 做包装，用来过滤被逻辑删除的键，也就是在遍历时会自动跳过值为空的键。然后 <code>LsmIterator</code> 外部又有一个 <code>FusedIterator</code> 做包装，在底层迭代器报错之后，会避免再次访问底层迭代器。<strong>为什么不直接在 <code>MemTableIterator</code> 中过滤被逻辑删除的键？</strong> 在合并迭代器时需要知道该键在新内存表被删除避免读取到旧内存表的值。</p>
<h3 id="Block">Block</h3>
<p>当内存表数量超过系统限制时，会将内存表作为 SST 刷新到磁盘，一个 SST 由多个块组成，单个块的大小通常是 4KB。编码方式如下：键值对是变长编码，作为 Entry 存储在 Data Section，同时维护每个 Entry 的偏移量来支持二分查找，最后存储总的 Entry 数量从而支持定位 Offset Section 的起始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">|             Data Section             |              Offset Section             |      Extra      |</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">| Entry #1 | Entry #2 | ... | Entry #N | Offset #1 | Offset #2 | ... | Offset #N | num_of_elements |</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------</span><br><span class="line">|                           Entry #1                            | ... |</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">| key_len (2B) | key (keylen) | value_len (2B) | value (varlen) | ... |</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="Sorted-String-Table-SST">Sorted String Table (SST)</h3>
<p>SST 由存储在磁盘上的数据块和索引块组成，数据块是按需加载的，只有在用户请求时才会加载到内存中。索引块也可以按需加载，但在本项目中假设所有 SST 索引块（元数据块）都能装入内存。<strong>一个 SST 文件的大小通常是 256MB，在构建 SST 时最好预分配 <code>Vec</code> 的空间，避免频繁动态扩容的开销。</strong> 如果单个数据块的大小超出限制，会自动创建一个新块存储数据。SST 的元数据包括，每个数据块的第一个和最后一个键以及该数据块的偏移量。最后存储元数据的偏移量从而支持定位元数据的起始位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">|         Block Section         |          Meta Section         |          Extra          |</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line">| data block | ... | data block |            metadata           | meta block offset (u32) |</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>在实现 <code>SsTableIterator</code> 的 <code>seek_to_key</code> 方法时（找到第一个 <code>? &gt;= x</code> 的键），可以根据数据块的第一个键使用二分查找来快速定位目标数据块。需要注意的是，如果目标 Key 是 <code>x</code>，要找的是最后一个满足 <code>first_key &lt;= x</code> 的数据块，而且在调用该 <code>BlockIterator</code> 的 <code>seek_to_key</code> 方法之后，还要额外判断该 <code>BlockIterator</code> 是否失效。例如，查找 <code>b</code> 会定位到第一个数据块（正确），而查找 <code>d</code> 也会定位到第一个数据块（错误），然后在 <code>BlockIterator</code> 上调用 <code>seek_to_key</code> 会导致迭代器失效，此时需要跳到下一个块上，也就是说第二个数据块才是目标块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------</span><br><span class="line">| block 1 | block 2 |   block meta   |</span><br><span class="line">--------------------------------------</span><br><span class="line">| a, b, c | e, f, g | 1: a/c, 2: e/g |</span><br><span class="line">--------------------------------------</span><br></pre></td></tr></table></figure>
<p>可以使用缓存来加速数据块的访问，项目使用 <a target="_blank" rel="noopener" href="https://github.com/moka-rs/moka">moka-rs</a> 作为缓存库来实现块缓存，块由 <code>(sst_id, block_id)</code> 唯一标识。</p>
<h3 id="Read-Path-Write-Path">Read Path &amp; Write Path</h3>
<p>实现完成内存表和 SST 结构之后，可以实现 <code>TwoMergeIterator</code> 来合并两者的迭代器，理论上可以直接使用之前实现的 <code>MergeIterator</code>，不过这里只有两个迭代器需要合并，所以这里使用一个更简单的实现。然后可以修改 <code>LsmStorageInner</code> 的 <code>scan</code> 和 <code>get</code> 方法的实现，将 SST 添加到读取路径中。由于创建 SST 的迭代器会比较耗时（涉及磁盘 I/O），所以不要在整个过程持有 <code>state</code> 读锁，而是创建一个 <code>state</code> 快照，然后基于快照创建迭代器来访问数据。</p>
<p>创建 SST 的合并迭代器需要加载所有底层 SST 的第一个块，优化方式是并行创建迭代器。在 <code>LsmStorageInner::scan</code> 方法中，实际上可以利用参数 <code>lower</code> 和 <code>upper</code>，以及 SST 的 <code>first_key</code> 和 <code>last_key</code> 来过滤 SST，避免不必要的磁盘 I/O。当内存表的数量达到上限时，需要将最旧的冻结内存表以 SST 文件的形式刷到磁盘，刷新工作主要由后台线程负责。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">snapshot</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">read</span>();</span><br><span class="line">    Arc::<span class="title function_ invoke__">clone</span>(&amp;guard)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Snack-Time-SST-Optimizations">Snack Time: SST Optimizations</h3>
<p>可以在读取路径上集成<a target="_blank" rel="noopener" href="https://samwho.dev/bloom-filters/">布隆过滤器</a>来过滤 SST，布隆过滤器基于 SST 包含的数据创建，每个 SST 都包含一个持久化的布隆过滤器数据。由于数据块中的键是有序存储的，可以对键进行前缀压缩。<strong>根据相邻键进行键前缀压缩而不是根据块中的第一个键进行压缩有哪些优点/缺点？</strong> 项目中是根据数据块的 <code>first_key</code> 的前缀进行压缩，这样可以在查找时快速复原当前 Key。如果是根据相邻键压缩，那么压缩比例会更高，但是压缩和复原最坏需要遍历所有前缀数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">|         Block Section         |                            Meta Section                           |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line">| data block | ... | data block | metadata | meta block offset | bloom filter | bloom filter offset |</span><br><span class="line">|                               |  varlen  |         u32       |    varlen    |        u32          |</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_overlap_len (u16) | rest_key_len (u16) | key (rest_key_len)</span><br></pre></td></tr></table></figure>
<h2 id="Week-2-Overview-Compaction-and-Persistence">Week 2 Overview: Compaction and Persistence</h2>
<h3 id="Compaction-Implementation">Compaction Implementation</h3>
<p>可以对 L0 SST 文件进行压缩，避免读放大，由于各个 SST 之间的键范围存在重叠。最简单的方式是进行 Full Compaction，将所有键按顺序排序存储到一组新的 SST 中（被称为 sorted run）。压缩时允许并行执行读写操作，所以不持有 <code>state</code> 的读写锁，依然复制状态快照（不会复制 SST，只是复制状态），然后基于快照创建 L0 和 L1（之前压缩的 L1 需要和 L0 再次整合）的合并迭代器。</p>
<p>使用 <code>SsTableBuilder</code> 构建 SST，如果超出大小限制则拆分文件，在迭代时过滤已经被删除的键，重复的键已经在合并迭代器内部过滤。替换状态时只需要持有 <code>state_lock</code> 独占锁，<code>state</code> 读写锁依然只在复制状态快照时持有，允许并行执行读写内存表的操作。替换状态不会丢失内存表的修改，因为状态只包含内存表的指针。</p>
<p>由于在压缩时也会产生 L0 SST 文件，所以在替换状态时只删除被压缩的 L0 SST 文件、以及所有 L1 SST 文件。<strong>在 macOS/Linux 操作系统上，直接删除文件不会有问题，即使可能存在并行读取，因为操作系统只有在没有文件句柄被持有时才会真正删除该文件。在 Windows 上似乎会直接报错。</strong> 删除文件操作在解锁 <code>state_lock</code> 之后执行。</p>
<p><img src="/img/DB.assets/1745716942378.png" alt=""></p>
<h3 id="Simple-Compaction-Strategy">Simple Compaction Strategy</h3>
<p>实现 Simple Leveled Compaction 策略，基本想法是指定一个最大层数 <code>max_levels</code>（不包括 L0），然后在 L0 SST 文件数量达到阈值，或者下层文件数量和上层（&gt;= L1）文件数量的比值小于阈值时执行相邻层级之间的压缩。<strong>是否可以像 Full Compaction 一样直接过滤已经被删除的键？</strong> 只有当压缩 Level 是最底层时，才能过滤掉已经被删除的键，否则可能读取到下层 Level 的旧值。<strong>主动选择旧 Level 进行压缩，即使其没有达到指定阈值，是否是一个好主意？</strong> 参考 <a target="_blank" rel="noopener" href="https://disc-projects.bu.edu/lethe/">Lethe</a> 文章，定期压缩可以减少无效键导致的空间放大、压缩无效键导致的写放大、无效键占用布隆过滤器导致误报率提升。</p>
<h3 id="Tiered-Compaction-Strategy">Tiered Compaction Strategy</h3>
<p>实现 Tiered Compaction 策略（RocksDB 的 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/universal-compaction">Universal Compaction</a>），该压缩不会使用 L0，所有 SST 都直接存放到 <code>levels</code> 中，压缩过程中生成的 SST 总是会占据一个 tier，tier 的编号就是该 tier 包含的第一个 SST ID。</p>
<p>首先，只有当 tier 的数量超过阈值才会触发压缩。当估计的空间放大率 <code>all levels except last level size / last level size</code> 超过阈值会触发 Full Compaction，或者 <code>this tier size / sum of all previous tiers size</code> 超过阈值会触发前缀压缩。如果没有触发上述压缩，则会直接触发前缀压缩，压缩的最大层数由参数限制。由于压缩过程中也会生成 SST，所以修改状态时替换的是 <code>levels</code> 的中间部分而不一定是前缀。</p>
<h3 id="Leveled-Compaction-Strategy">Leveled Compaction Strategy</h3>
<p>实现 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Leveled-Compaction">Leveled Compaction</a> 策略，相当于对 Simple Leveled Compaction 的优化。之前的策略会在相邻层级之间压缩数据，初始时会反复地将上层数据压缩到下面的空层中，更好的策略是跳过中间的空层，直接和有数据的低层进行压缩。在数据量不是很大的时候，没有必要分层压缩产生读放大，所以给最底层设置一个阈值 <code>base_level_size_mb</code>，在最底层的文件大小超过该阈值之前总是将数据压缩到最底层。</p>
<p>然后使用 <code>level_size_multiplier</code> 来确定各个层级的 <code>target size</code>，只允许有一个小于 <code>base_level_size_mb</code> 的正 <code>target size</code>，该层记作 <code>base level</code>。每次压缩 L0 的数据都直接压缩到 <code>base level</code>，这样可以确保在数据量比较小时使用较少的层级（后缀层级），避免较多层级产生读放大、以及反复压缩相邻空层产生写放大。</p>
<p>优先将满足 <code>current_size / target_size &gt; 1.0</code> 的比值最大的层级压缩到下层中，尽量减少空间放大。之前的策略总是将上层所有 SST 和下层做压缩，这样压缩过程中的空间放大会比较多。可以实现部分压缩，从上层选择最旧的 SST，然后和下层键范围重叠的 SST 做压缩。对于 L0 可以计算整个 L0 的最小最大键，然后和下层范围重叠的 SST 做压缩。<strong>需要考虑没有重叠的情况，此时压缩结果需要放在 Level 的开头或者末尾，比较简单的实现方式就是根据 SST 的 <code>first_key</code> 排序。</strong></p>
<h3 id="Manifest">Manifest</h3>
<p>可以持久化 LSM 存储引擎的状态，从而允许重启时恢复。简单的方法是，在状态被修改时将所有状态持久化，但是这样磁盘 I/O 开销较大，特别是修改操作比较频繁时。该项目使用 Manifest 文件维护 SST Flush 和 Compaction 操作记录，SST Flush 操作记录该 SST 的 <code>sst_id</code>，Compaction 操作记录压缩任务 <code>task</code> 和压缩结果 <code>output</code>。在不持有 <code>state</code> 读写锁时追加 Manifest 文件，允许并行读写内存表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| JSON record | JSON record | JSON record | JSON record |</span><br></pre></td></tr></table></figure>
<p>由于记录的信息有限，在重启恢复时只能先构建 <code>L0</code> 和 <code>levels</code> 元数据，然后根据这些元数据读取磁盘上的 SST 来构建 <code>sstables</code> 哈希表。如果在压缩过程中使用到 <code>sstables</code> 中 SST 的 <code>first_key</code> 排序，那么在恢复时需要特殊处理。不能在应用记录的过程中构建 <code>sstables</code>，因为记录中的 SST 可能已经被压缩，从而对应的文件已经从磁盘删除。</p>
<p><strong>为保证磁盘中 SST 和 Manifest 文件的一致性，需要在追加 Manifest 文件之前 Sync 整个存储目录，或者可以在修改文件之后总是执行 Sync。</strong> 在关闭 LSM 之前，需要将所有内存表刷新到 SST 中。在恢复时需要维护最大的 <code>max_sst_id</code>，恢复完成之后需要根据 <code>max_sst_id + 1</code> 创建当前的内存表。由于 Manifest 文件会记录所有操作，所以需要定时创建快照来截断日志（例如 Raft 中状态机快照），来减少空间占用以及加快恢复速度。</p>
<h3 id="Write-Ahead-Log-WAL">Write-Ahead Log (WAL)</h3>
<p>Manifest 文件可以保证正常关闭时，LSM 状态的持久性，但是如果发生崩溃，就需要依靠 WAL 来保证持久性。每个内存表对应一个 WAL 文件，如果冻结内存表被刷新到 SST 文件中，则可以将 WAL 文件删除，前提是该 SST 文件已经被 Sync 到磁盘中（默认在创建 SST 时就会 Sync）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len | key | value_len | value |</span><br></pre></td></tr></table></figure>
<p>为了能够在重启时恢复内存表，需要在 Manifest 文件中维护 NewMemtable 记录，该记录存储内存表的 ID。为减少磁盘 I/O 以及系统调用开销，可以在将当前内存表转移到冻结内存表时刷新 WAL 到磁盘，而不是在每次修改内存表时刷新，不过如果宕机则会丢失当前内存表的数据。创建 WAL 文件应该在追加 Manifest 记录之前，这样可以保证恢复时的一致性。在重启恢复时，依然不能在应用记录的过程中读取 WAL，因为记录中的 WAL 可能已经被删除，由于该内存表已经被刷新到 SST 中。</p>
<h3 id="Snack-Time-Batch-Write-and-Checksums">Snack Time: Batch Write and Checksums</h3>
<p>实现批量写入接口，允许用户提供一组 <code>put</code> 和 <code>delete</code> 操作批量执行。给 Block、SST Meta（Block Meta、Bloom Filter）、WAL 以及 Manifest 文件添加校验和，从而允许检查数据是否损坏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">|                   Block Section                     |                            Meta Section                           |</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">| data block | checksum | ... | data block | checksum | metadata | meta block offset | bloom filter | bloom filter offset |</span><br><span class="line">|   varlen   |    u32   |     |   varlen   |    u32   |  varlen  |         u32       |    varlen    |        u32          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">|                                                Meta Section                                            |</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br><span class="line">| no. of block | metadata | checksum | meta block offset | bloom filter | checksum | bloom filter offset |</span><br><span class="line">|     u32      |  varlen  |    u32   |        u32        |    varlen    |    u32   |        u32          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len | key | value_len | value | checksum |</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| len | JSON record | checksum | len | JSON record | checksum | len | JSON record | checksum |</span><br></pre></td></tr></table></figure>
<h2 id="Week-3-Overview-Multi-Version-Concurrency-Control">Week 3 Overview: Multi-Version Concurrency Control</h2>
<h3 id="Timestamp-Key-Encoding-Refactor">Timestamp Key Encoding + Refactor</h3>
<h3 id="Snapshot-Read-Memtables-and-Timestamps">Snapshot Read - Memtables and Timestamps</h3>
<h3 id="Snapshot-Read-Engine-Read-Path-and-Transaction-API">Snapshot Read - Engine Read Path and Transaction API</h3>
<p>为实现 MVCC 需要重构代码，首先替换 Key 的表示以包含时间戳字段，按照 <code>user_key</code> 升序 <code>ts</code> 降序排序，这样可以优先读到新版本的数据。然后修改内存表、Block、SST、WAL 以支持时间戳字段，在重启恢复 LSM 状态时需要根据 SST 和内存表中使用的最大时间戳来确定当前时间戳。在整个 <code>write_batch</code> 中需要持有 MVCC 的 <code>write_lock</code>，从而确保按照时间戳递增的顺序执行写入操作（只有写入操作会递增时间戳）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alternative key representation: | user_key (varlen) | ts (8 bytes) | in a single slice</span><br><span class="line">Our key representation: | user_key slice | ts (u64) |</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_overlap_len (u16) | remaining_key_len (u16) | key (remaining_key_len) | timestamp (u64)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| key_len (exclude ts len) (u16) | key | ts (u64) | value_len (u16) | value | checksum (u32) |</span><br></pre></td></tr></table></figure>
<p>在压缩过程中，暂时忽略 <code>compact_to_bottom_level</code> 保留所有版本的数据（不执行实际的删除操作）。确保不同时间戳的相同 <code>user_key</code> 在同一个的 SST 中，即使超出 SST 的大小限制，从而简化其他功能的开发。个人认为主要是 Leveled Compaction 会从上层部分压缩到下层，如果多个版本不在一个 SST 中，会存在旧版本的键值对在上层而新版本的键值对被压缩到下层的情况。修改 <code>LsmIterator</code> 包含时间戳字段，只迭代 <code>&lt;=</code> 当前时间戳的最新数据，如果键被删除就跳过该键的所有旧版本。应该首先判断版本再判断删除，因为删除操作可能是在快照之后的版本执行的。</p>
<p>在 <code>get</code> 读取路径中，只需要根据当前时间戳创建事务，读取快照内可见的数据即可。不过由于内存表会包含多个版本的数据，所以只能使用范围查询来查找该 <code>user_key</code> 的最新可见版本。在 <code>scan</code> 读取路径中，如果 <code>lower</code> 和 <code>upper</code> 是 <code>Bound::Included</code>，则对应的时间戳是 <code>ts</code> 和 <code>TS_RANGE_END</code>。如果是 <code>Bound::Excluded</code>，则对应的时间戳是 <code>TS_RANGE_END</code> 和 <code>ts | TS_RANGE_BEGIN</code>。因为对于 <code>lower</code> 而言，必须定位到对应 <code>user_key_begin</code> 的最旧版本，才能确保迭代器跳过该 <code>user_key_begin</code>。对于 <code>upper</code> 而言，必须定位到 <code>ts</code> 及更新的版本才能确保迭代器跳过该 <code>user_key_end</code>。</p>
<h3 id="Watermark-and-Garbage-Collection">Watermark and Garbage Collection</h3>
<p>Watermark 是维护系统中 <code>lowest_read_ts</code> 的结构，可以在创建/终止事务时，使用 <code>BTreeMap</code> 维护各个时间戳的引用计数来实现。然后压缩操作保留所有键的最新快照以及所有 <code>&gt;= lowest_read_ts</code> 的快照，例外情况是如果当前压缩到 <code>compact_to_bottom_level</code>，且键的最新快照是删除操作，且该快照 <code>&lt;= lowest_read_ts</code>，则不保留该键值对到新 SST 中。</p>
<h3 id="Transaction-and-Optimistic-Concurrency-Control">Transaction and Optimistic Concurrency Control</h3>
<p>事务内执行的修改操作都存储到事务的 <code>local_storage</code> 本地内存表中，该表不包含时间戳信息。读取操作会先读取本地内存表，再读取公共内存表及 SST 文件。本地内存表迭代器 <code>TxnLocalIterator</code> 和之前没有时间戳的公共内存表实现相同，而 <code>TxnIterator</code> 会使用 <code>TwoMergeIterator</code> 合并本地和公共数据，不过需要跳过被删除的键，由于之前只有 <code>LsmIterator</code> 会执行该逻辑。</p>
<p>提交事务会将当前事务的状态设置为已提交，然后将本地内存表的数据通过 <code>LsmStorageInner::write_batch</code> 批量提交到公共内存表中。如果在写入公共内存表的过程中崩溃，恢复时的 WAL 无法区分事务之间的边界，从而不能保证事务的原子性。可以实现批量 WAL，将事务内的写入操作批量提交给 WAL，然后添加 Header 和 Footer 来区分事务边界。而且要保证批量写入操作都存储到相同的内存表中，从而使得事务内的批量操作只存储在一个 WAL 文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   HEADER   |                          BODY                                      |  FOOTER  |</span><br><span class="line">|     u32    |   u16   | var | u64 |    u16    |  var  |           ...            |    u32   |</span><br><span class="line">| batch_size | key_len | key | ts  | value_len | value | more key-value pairs ... | checksum |</span><br></pre></td></tr></table></figure>
<h3 id="A-Partial-Serializable-Snapshot-Isolation">(A Partial) Serializable Snapshot Isolation</h3>
<p>在事务内执行读写操作时维护读写集，然后在提交时验证当前事务是否和已提交事务冲突（OCC），从而实现可串行化快照隔离。首先，需要确保验证、提交操作的原子性，所以在 <code>commit</code> 方法开始时持有 MVCC 的 <code>commit_lock</code> 锁。然后遍历在 <code>(read_ts, expected_commit_ts)</code> 范围内提交的事务，判断当前事务的读集是否和这些事务的写集重叠。如果重叠则说明当前事务和已提交事务冲突，直接返回错误信息。例外情况是，如果当前事务是只读的，则不需要验证冲突。基本想法是，写操作会基于读操作的结果执行，而只读则不会修改公共数据。</p>
<p>在本项目中，对于 <code>scan</code> 操作只将扫描到的键加入读集而不是扫描范围，这样实现简单但是无法真正保证可串行化快照隔离（依然存在 write skew 异常）。在读写集中存储的是键的哈希值，这样可以减少内存空间占用、加快验证速度，但是会存在哈希冲突导致误报。在提交事务时可以将提交时间戳小于 <code>lowest_read_ts</code> 的已提交事务数据移除，然后将当前事务数据加入已提交事务集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">txn1: len(scan(..)) = 2</span><br><span class="line">txn2: len(scan(..)) = 2</span><br><span class="line">txn1: put key1 = 2, commit, read set = &#123;a, b&#125;, write set = &#123;key1&#125;</span><br><span class="line">txn2: put key2 = 2, commit, read set = &#123;a, b&#125;, write set = &#123;key2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Snack-Time-Compaction-Filters">Snack Time: Compaction Filters</h3>
<p>如果需要删除以某个字符串为前缀的所有键，正常调用删除方法不但不会减少空间占用，反而会为每个键新增一个删除版本，只有压缩到最底层才会真正删除。可以使用压缩过滤器，添加前缀匹配规则到压缩过滤器，然后在压缩过程中不保留匹配的键值对到 SST 中。不过保证正确的前提是，所有事务都不会读取相关的键。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">158</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"><span class="level-start"><span class="level-item">CSAPP/OSTEP</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"><span class="level-start"><span class="level-item">消息队列</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/"><span class="level-start"><span class="level-item">Kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Rust/"><span class="level-start"><span class="level-item">Rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"><span class="level-start"><span class="level-item">GAMES101</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"><span class="level-start"><span class="level-item">NJU ICS/OS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"><span class="level-start"><span class="level-item">NJU Static Analysis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"><span class="level-start"><span class="level-item">UCB CS61A</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/"><span class="level-start"><span class="level-item">Mini-LSM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-13T01:09:43.306Z">2025-07-13</time></p><p class="title"><a href="/2025/07/13/CS229%20Machine%20Learning/">CS229: Machine Learning（草稿）</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-14T12:42:16.492Z">2025-05-14</time></p><p class="title"><a href="/2025/05/14/System%20Design/">System Design（草稿）</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/">系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-26T00:11:50.404Z">2025-04-26</time></p><p class="title"><a href="/2025/04/26/LSM%20in%20a%20Week/">LSM in a Week</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a> / <a href="/categories/%E9%A1%B9%E7%9B%AE/Mini-LSM/">Mini-LSM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-18T10:01:46.499Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/Guava%20RateLimiter/">Guava RateLimiter</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-17T16:42:59.185Z">2025-04-18</time></p><p class="title"><a href="/2025/04/18/CMU%2015-445645%20%E2%80%94%20Fall%202024%20Projects/">CMU 15-445/645 — Fall 2024 Projects</a></p><p class="categories"><a href="/categories/%E8%AF%BE%E7%A8%8B/">课程</a> / <a href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/">CMU 15-445</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/"><span class="level-start"><span class="level-item">2025</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">102</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Debugging/"><span class="tag">Debugging</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Draft/"><span class="tag">Draft</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://47.96.68.192/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Lc-Predictor</span></span><span class="level-right"><span class="level-item tag">47.96.68.192</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>