{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 893 (Div. 2)","text":"Buttons优先选择公共按钮，当且仅当先手的按钮数量大于后手的按钮数量时，先手者胜。 12345public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (a + c % 2 &gt; b) io.println(&quot;First&quot;); else io.println(&quot;Second&quot;);} The Walkway模拟题，特别需要注意头尾的边界处理，加上哨兵真的会方便很多。可以假设位置 \\(1-d\\) 和位置 \\(n+1\\) 有卖家，这样就不用特判，可以直接处理！！！ 123456789101112131415161718192021222324252627public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] s = new int[m + 2]; for (int i = 1; i &lt;= m; i++) { s[i] = io.nextInt(); } s[0] = 1 - d; s[m + 1] = n + 1; int ans = m - 1, delta = Integer.MAX_VALUE, cnt = 0; for (int i = 1; i &lt;= m; i++) { int A = (s[i] - s[i - 1] - 1) / d; int B = (s[i + 1] - s[i] - 1) / d; int C = (s[i + 1] - s[i - 1] - 1) / d; int D = C - A - B; if (D &lt; delta) { delta = D; cnt = 1; } else if (D == delta) { cnt++; } ans += A; } ans += (s[m + 1] - s[m] - 1) / d + delta - 1; io.println(ans + &quot; &quot; + cnt);} Yet Another Permutation Problem构造题，首先需要发现什么公约数不可能出现，很明显不可能得到 \\(d_{i}=\\gcd (a_{i},a_{(i\\bmod n)+1})&gt; \\lfloor \\frac{n}{2}\\rfloor\\)。然后考虑所有小于等于 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 的数是否能被包含，可以发现对于每个 \\(a_{i}=x\\leq \\lfloor \\frac{n}{2}\\rfloor\\) 总有 \\(a_{(i\\bmod n)+1}=2\\cdot x\\leq n\\)，所以我们可以枚举所有奇数乘以二的幂来构造答案。 12345678910111213public static void solve() { int n = io.nextInt(), idx = 0; int[] ans = new int[n]; for (int i = 1; i &lt;= n; i += 2) { for (int j = i; j &lt;= n; j *= 2) { ans[idx++] = j; } } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} Trees and Segments难以描述，看代码吧，调试半天。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[][] prefix = new int[n + 1][k + 1]; int[][] suffix = new int[n + 1][k + 1]; // 枚举可以在 k 次操作内变为全 0 的子数组，并将其长度记录到所属的前后缀中 for (int i = 0; i &lt; n; i++) { int cnt1 = 0; for (int j = i; j &lt; n; j++) { cnt1 += s[j] - '0'; if (cnt1 &gt; k) break; prefix[j + 1][cnt1] = Math.max(prefix[j + 1][cnt1], j - i + 1); suffix[i][cnt1] = Math.max(suffix[i][cnt1], j - i + 1); } } // 在前缀 [0, i] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= k; j++) { prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i][j]); if (j &gt; 0) prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i + 1][j - 1]); } } // 在后缀 [i, n - 1] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= k; j++) { suffix[i][j] = Math.max(suffix[i][j], suffix[i + 1][j]); if (j &gt; 0) suffix[i][j] = Math.max(suffix[i][j], suffix[i][j - 1]); } } // 枚举连续 1 的起点和终点，并记录该连续 1 的长度对应的连续 0 的最长长度（注意包含长度为 0 的情况） int[] max0by1 = new int[n + 1]; Arrays.fill(max0by1, -1); max0by1[0] = suffix[0][k]; for (int i = 0; i &lt; n; i++) { int cnt0 = 0; for (int j = i; j &lt; n; j++) { cnt0 += (s[j] - '0') ^ 1; if (cnt0 &gt; k) break; max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], prefix[i][k - cnt0]); max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], suffix[j + 1][k - cnt0]); } } // 计算答案 int[] ans = new int[n + 1]; for (int a = 1; a &lt;= n; a++) { for (int i = 0; i &lt;= n; i++) { if (max0by1[i] == -1) continue; ans[a] = Math.max(ans[a], i + max0by1[i] * a); } } for (int i = 1; i &lt;= n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}","link":"/2023/08/16/Codeforces%20Round%20893%20(Div.%202)/"},{"title":"第 111 场力扣夜喵双周赛","text":"统计和小于目标的下标对数目使用排序 + 双指针优化。如果 \\(nums[lo]+nums[hi]&lt;target\\)，那么 \\([lo+1,hi]\\) 范围内的数都能与 \\(nums[lo]\\) 组成对，\\(lo\\) 加一；反之，\\([lo,hi-1]\\) 范围内的数都不能与 \\(nums[hi]\\) 组成对，\\(hi\\) 减一。 Java 123456789101112131415class Solution { public int countPairs(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int lo = 0, hi = nums.size() - 1, ans = 0; while (lo &lt; hi) { if (nums.get(lo) + nums.get(hi) &lt; target) { ans += hi - lo; lo++; } else { hi--; } } return ans; }} C++ 12345678910111213141516class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans = 0; for (int i = 0, j = n - 1; i &lt; j; ) { if (nums[i] + nums[j] &lt; target) { ans += j - i; i++; } else { j--; } } return ans; }}; 循环增长使字符串子序列等于另一个字符串贪心取就行。 Java 1234567891011class Solution { public boolean canMakeSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1.charAt(i) == str2.charAt(j) || (str1.charAt(i) + 1 - 'a') % 26 == str2.charAt(j) - 'a') { j++; } } return j == n; }} C++ 123456789101112class Solution {public: bool canMakeSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1[i] == str2[j] || (str1[i] + 1 - 'a') % 26 == str2[j] - 'a') { j++; } } return j == n; }}; 将三个组排序要将 \\(nums\\) 变为美丽数组，就要将 \\(nums\\) 变为非递减的形式，所以问题就变为求最长非递减子序列。 Java 动态规划： 12345678910111213141516class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), ans = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (nums.get(i) &gt;= nums.get(j)) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } return n - ans; }} 贪心 + 二分： 1234567891011121314151617class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), maxLen = 0; int[] aux = new int[n]; for (int x : nums) { int lo = 0, hi = maxLen - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (aux[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } aux[lo] = x; if (lo == maxLen) maxLen++; } return n - maxLen; }} 状态机 DP： 有点妙啊，\\(dp[i][j]\\) 表示将子数组 \\([0,i]\\) 变为以 \\([1,j]\\) 为结尾的美丽数组所需的最小修改次数，然后可以空间优化。 1234567891011class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int[] dp = {Integer.MAX_VALUE, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = Math.min(dp[i - 1], dp[i] + (x == i ? 0 : 1)); } } return dp[3]; }} C++ 123456789101112class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { int dp[4] = {INT_MAX, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = min(dp[i - 1], dp[i] + (x != i)); } } return dp[3]; }}; 范围中美丽整数的数目经典数位 DP 没什么好说的，主要是记忆化取模，边乘边取模。 Java 1234567891011121314151617181920212223242526class Solution { public int numberOfBeautifulIntegers(int low, int high, int k) { return f(0, 10, 0, true, false, high + &quot;&quot;, k, new Integer[10][20][k]) - f(0, 10, 0, true, false, low - 1 + &quot;&quot;, k, new Integer[10][20][k]); } private int f(int i, int diff, int mod, boolean isLimit, boolean isNum, String s, int k, Integer[][][] dp) { if (i == s.length()) { return isNum &amp;&amp; diff == 10 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff][mod] != null) { return dp[i][diff][mod]; } int res = 0; if (!isNum) res += f(i + 1, diff, mod, false, false, s, k, dp); int lo = isNum ? 0 : 1, hi = isLimit ? s.charAt(i) - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += f(i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true, s, k, dp); } if (!isLimit &amp;&amp; isNum) { dp[i][diff][mod] = res; } return res; }} C++ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int numberOfBeautifulIntegers(int low, int high, int k) { string s; const int BASE = 10; int dp[10][20][k]; auto f = [&amp;](auto self, int i, int diff, int mod, bool isLimit, bool isNum) { if (i == s.size()) { return isNum &amp;&amp; diff == 0 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff + BASE][mod] != -1) { return dp[i][diff + BASE][mod]; } int res = 0; if (!isNum) res += self(self, i + 1, diff, mod, false, false); int lo = isNum ? 0 : 1, hi = isLimit ? s[i] - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += self(self, i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true); } if (!isLimit &amp;&amp; isNum) dp[i][diff + BASE][mod] = res; return res; }; auto calc = [&amp;](int x) { s = to_string(x); memset(dp, -1, sizeof(dp)); return f(f, 0, 0, 0, true, false); }; return calc(high) - calc(low - 1); }};","link":"/2023/08/21/%E7%AC%AC%20111%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 359 场力扣周赛","text":"判别首字母缩略词Java 123456789101112class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { int n = words.size(), m = s.length(); if (n != m) return false; for (int i = 0; i &lt; n; i++) { if (words.get(i).charAt(0) != s.charAt(i)) { return false; } } return true; }} C++ 12345678910111213class Solution {public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) { int m = words.size(), n = s.size(); if (m != n) return false; for (int i = 0; i &lt; n; i++) { if (words[i][0] != s[i]) { return false; } } return true; }}; k-avoiding 数组的最小总和贪心。 Java 123456class Solution { public int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }} C++ 1234567class Solution {public: int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }}; 销售利润最大化不从动态规划的角度思考，我首先用的是对左端点排序。如果用动态规划，那么根据转移方程就会对右端点排序，处理方式也比对左端点排序简单一些。还可以不排序做，使用桶存储相同 \\(end\\) 的 \\(offer\\)，分别处理每个桶。 Java 1234567891011121314class Solution { public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) { Collections.sort(offers, (a, b) -&gt; a.get(1) - b.get(1)); offers.add(List.of(n - 1, n - 1, 0)); int m = offers.size(), i = 0; int[] leftMax = new int[n + 1]; for (var offer : offers) { int s = offer.get(0), e = offer.get(1), g = offer.get(2); for (; i &lt;= e; i++) leftMax[i + 1] = leftMax[i]; leftMax[e + 1] = Math.max(leftMax[e + 1], leftMax[s] + g); } return leftMax[n]; }} C++ 1234567891011121314151617class Solution {public: int maximizeTheProfit(int n, vector&lt;vector&lt;int&gt;&gt;&amp; offers) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; groups(n); for (auto &amp;offer : offers) { groups[offer[1]].emplace_back(offer[0], offer[2]); } vector&lt;int&gt; f(n + 1); for (int end = 0; end &lt; n; end++) { f[end + 1] = f[end]; for (auto &amp;[start, gold] : groups[end]) { f[end + 1] = max(f[end + 1], f[start] + gold); } } return f[n]; }}; 找出最长等值子数组Java 滑动窗口： 12345678910111213141516171819class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int lo = 0, hi = 0, ans = 0; while (hi &lt; n) { map.merge(nums.get(hi++), 1, Integer::sum); if (hi - lo - map.get(nums.get(lo)) &gt; k) { map.merge(nums.get(lo++), -1, Integer::sum); } ans = Math.max(ans, map.get(nums.get(lo))); } while (lo + 1 &lt; n) { map.merge(nums.get(lo++), -1, Integer::sum); ans = Math.max(ans, map.get(nums.get(lo))); } return ans; }} 滑动窗口（优化）： 优化一：观察到 \\(1\\leq nums[i]\\leq nums.lenth\\)，所以可以用数组模拟哈希表。 优化二：滑动窗口直接枚举右端点，这样可以枚举到所有情况。但是如何保证删除的元素数量小于等于 \\(k\\) 呢？当左端点的值 \\(nums[i]\\) 不能构成等值数组，则将左端点右移。为什么这样可以保证？当 \\(nums[i]\\neq nums[j]\\) 时，移动左端点不影响答案；当 \\(nums[i]=nums[j]\\) 时，移动左端点可以保证删除的元素数量小于等于 \\(k\\)。 1234567891011121314class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; int[] map = new int[n + 1]; for (int i = 0, j = 0; j &lt; n; j++) { map[nums.get(j)]++; if (j - i + 1 - map[nums.get(i)] &gt; k) { map[nums.get(i++)]--; } ans = Math.max(ans, map[nums.get(j)]); } return ans; }} C++ 分组 + 双指针： 123456789101112131415161718192021class Solution {public: int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); for (int i = 0; i &lt; n; i++) { pos[nums[i]].push_back(i); } for (auto &amp;ps : pos) { int left = 0; for (int right = 0; right &lt; ps.size(); right++) { while (ps[right] - ps[left] - right + left &gt; k) { left++; } ans = max(ans, right - left + 1); } } return ans; }};","link":"/2023/08/21/%E7%AC%AC%20359%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 315","text":"tcdr模拟。 Java 123456789public static void solve() { String s = io.next(); var sb = new StringBuilder(); Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); for (char c : s.toCharArray()) { if (!set.contains(c)) sb.append(c); } io.println(sb.toString());} C++ 12345678void solve() { string s; cin &gt;&gt; s; s.erase(remove_if(s.begin(), s.end(), [&amp;](char c) { return set{'a', 'e', 'i', 'o', 'u'}.count(c); }), s.end()); cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;} The Middle Day模拟。 Java 1234567891011121314151617public static void solve() { int m = io.nextInt(); int[] d = new int[m]; int tot = 0; for (int i = 0; i &lt; m; i++) { d[i] = io.nextInt(); tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { io.println(i + 1 + &quot; &quot; + mid); return; } mid -= d[i]; }} C++ 123456789101112131415161718void solve() { int m; cin &gt;&gt; m; int tot = 0; vector&lt;int&gt; d(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; d[i]; tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot;\\n&quot;; return; } mid -= d[i]; }} Flavors模拟。 Java 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] buckets = new List[n + 1]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int f = io.nextInt(), s = io.nextInt(); buckets[f].add(s); } int ans = 0, max1 = 0, max2 = 0; for (var bucket : buckets) { if (bucket.isEmpty()) continue; Collections.sort(bucket, (a, b) -&gt; b - a); int a = bucket.get(0); if (a &gt; max1) { max2 = max1; max1 = a; } else if (a &gt; max2) { max2 = a; } if (bucket.size() &lt; 2) continue; int b = bucket.get(1); ans = Math.max(ans, a + b / 2); } ans = Math.max(ans, max1 + max2); io.println(ans);} C++ 12345678910111213141516171819202122232425void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; buckets(n + 1); for (int i = 0; i &lt; n; i++) { int f, s; cin &gt;&gt; f &gt;&gt; s; buckets[f].push_back(s); } int ans = 0, max1 = 0, max2 = 0; for (auto &amp;bucket : buckets) { if (bucket.empty()) continue; nth_element(bucket.begin(), bucket.begin() + 1, bucket.end(), greater()); if (bucket[0] &gt; max1) { max2 = max1; max1 = bucket[0]; } else if (bucket[0] &gt; max2) { max2 = bucket[0]; } if (bucket.size() &lt; 2) continue; ans = max(ans, bucket[0] + bucket[1] / 2); } ans = max(ans, max1 + max2); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} Magical Cookies算是暴力吧。首先最多执行 \\(m+n\\) 次操作，然后每次操作将所有行和列遍历，判断是否可以标记。如果不优化，那么遍历的复杂度是 \\(O(mn)\\)，总时间复杂度就是 \\(O(mn(m+n))\\)，会超时。可以维护剩余的行数 \\(r\\) 和剩余的列数 \\(c\\)，那么如果某行的某颜色的数量等于列数，那么就说明可以标记该行，列同理。这样我们就可以只维护行列中的每个颜色有多少饼干，而不需要维护位置关系，从而将遍历的时间复杂度降为 \\(O(26(m+n))\\)。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] arr = new String[m]; for (int i = 0; i &lt; m; i++) { arr[i] = io.next(); } int[][] row = new int[m][26]; int[][] col = new int[n][26]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { row[i][arr[i].charAt(j) - 'a']++; col[j][arr[i].charAt(j) - 'a']++; } } int r = m, c = n; boolean[] vr = new boolean[m]; boolean[] vc = new boolean[n]; for (int k = 0; k &lt; m + n; k++) { List&lt;int[]&gt; mr = new ArrayList&lt;&gt;(); List&lt;int[]&gt; mc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { if (vr[i]) continue; for (int j = 0; j &lt; 26; j++) { if (row[i][j] == c &amp;&amp; c &gt;= 2) { mr.add(new int[]{i, j}); } } } for (int i = 0; i &lt; n; i++) { if (vc[i]) continue; for (int j = 0; j &lt; 26; j++) { if (col[i][j] == r &amp;&amp; r &gt;= 2) { mc.add(new int[]{i, j}); } } } for (int[] p : mr) { r--; vr[p[0]] = true; for (int i = 0; i &lt; n; i++) { col[i][p[1]]--; } } for (int[] p : mc) { c--; vc[p[0]] = true; for (int i = 0; i &lt; m; i++) { row[i][p[1]]--; } } } io.println(r * c);} Prerequisites首先找到第 \\(1\\) 本书的所有前置书，然后对所有书进行拓扑排序，将之前找到的前置书按拓扑排序的倒序打印即可。或者直接 DFS。。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(); int[] indegree = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); for (int j = 0; j &lt; c; j++) { int q = io.nextInt() - 1; g[i].add(q); indegree[q]++; } } boolean[] mark = new boolean[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty()) { int x = q.poll(); for (int y : g[x]) { if (mark[y]) continue; mark[y] = true; q.offer(y); } } for (int i = 0; i &lt; n; i++) { if (indegree[i] == 0) { q.offer(i); } } Deque&lt;Integer&gt; ans = new ArrayDeque&lt;&gt;(); while (!q.isEmpty()) { int x = q.poll(); if (mark[x]) ans.push(x); for (int y : g[x]) { if (--indegree[y] == 0) { q.offer(y); } } } while (!ans.isEmpty()) io.print(ans.pop() + 1 + &quot; &quot;); io.println();} C++ 123456789101112131415161718192021222324252627282930313233void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; j++) { int q; cin &gt;&gt; q; q--; adj[i].push_back(q); } } vector&lt;bool&gt; mark(n); auto dfs = [&amp;](auto self, int x) { if (mark[x]) { return; } for (auto y : adj[x]) { self(self, y); } mark[x] = true; if (x != 0) { std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; } }; dfs(dfs, 0); cout &lt;&lt; &quot;\\n&quot;;} Shortcuts动态规划，调试好久。。如果所有点都选，那么答案最多为 \\(10^{9}\\)，所以可以确定不选的点不会超过 \\(30\\)。然后定义状态 \\(dp[i][j]\\) 表示到达第 \\(i\\) 个点并且总共跳过 \\(j\\) 个点的最短距离。如何想到定义该状态呢，因为答案和具体选哪几个点无关，只和最短距离以及跳过多少个点有关，大概是这样吧。 Java 1234567891011121314151617181920212223242526272829public static void solve() { int c = 30; int n = io.nextInt(); int[] x = new int[n]; int[] y = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } double[][] dp = new double[n][c]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][0] = 0; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; c; j++) { for (int k = i + 1; k &lt; n &amp;&amp; k - i - 1 + j &lt; c; k++) { int nj = j + k - i - 1; dp[k][nj] = Math.min(dp[k][nj], dp[i][j] + Math.sqrt((x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]))); } } } double ans = Integer.MAX_VALUE; for (int i = 0; i &lt; c; i++) { ans = Math.min(ans, dp[n - 1][i] + (i == 0 ? 0 : 1 &lt;&lt; (i - 1))); } io.println(ans);}","link":"/2023/08/21/AtCoder%20Beginner%20Contest%20315/"},{"title":"Educational Codeforces Round 153 (Rated for Div. 2)","text":"Not a Substring构造题。如果 \\(s\\) 中存在连续相同的括号，则可以构造交替出现的括号；如果 \\(s\\) 是交替出现的括号，那么就构造连续的括号，此时包含的唯一交替的括号就是 \\(()\\)，特判一下即可。 123456789101112131415161718public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = false; for (int i = 1; i &lt; n; i++) { if (s[i] == s[i - 1]) { ok = true; break; } } if (new String(s).equals(&quot;()&quot;)) { io.println(&quot;NO&quot;); return; } io.println(&quot;YES&quot;); if (ok) io.println(&quot;()&quot;.repeat(n)); else io.println(&quot;(&quot;.repeat(n) + &quot;)&quot;.repeat(n));} Fancy Coins数学题。假设最终使用 \\(x\\) 枚价值为 \\(1\\) 的硬币，\\(y\\) 枚价值为 \\(k\\) 的硬币。如果 \\(x\\) 大于等于 \\(k\\)，我们总是将其合成为价值为 \\(k\\) 的硬币，所以可以保证 \\(x\\) 小于 \\(k\\)。显然 \\(x=m\\bmod k\\)，\\(y=\\frac{m}{k}\\)。那么需要补充多少花色硬币呢？易知，需要补充 \\(\\max(0,x-a_{1})\\) 个价值为 \\(1\\) 的花色硬币，和 \\(\\max (0,y-a_{k}-\\max (0,\\frac{a_{1}-x}{k}))\\) 个价值为 \\(k\\) 的花色硬币。 12345public static void solve() { int m = io.nextInt(), k = io.nextInt(), a1 = io.nextInt(), ak = io.nextInt(); int ans = Math.max(0, m % k - a1) + Math.max(0, m / k - ak - Math.max(0, a1 - m % k) / k); io.println(ans);} Game on Permutation一开始的想法是，如果某个元素左边恰好只有一个小于它的元素，那么该位置就是胜位。然而暴力找每个位置左边比它小的元素个数的时间复杂度是 \\(O(n^{2})\\)，赛时就不知道怎么优化。其实我们可以知道，给定一个序列，胜位是固定不变的。所以可以考虑维护左边的最小元素（表示下一步是否可以下棋）和最小的胜位（如果大于最小胜位，则当前位必输），然后就可以很方便的模拟出答案。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] p = new int[n]; int ans = 0, min = n + 1, minWin = n + 1; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); if (min &lt; p[i] &amp;&amp; p[i] &lt;= minWin) { ans++; minWin = Math.min(minWin, p[i]); } min = Math.min(min, p[i]); } io.println(ans);} Balanced String不会不会。。o(╥﹏╥)o","link":"/2023/08/21/Educational%20Codeforces%20Round%20153%20(Rated%20for%20Div.%202)/"},{"title":"Project #0 - C++ Primer","text":"项目准备项目地址：Project #0 - C++ Primer。 准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。 Task #1 - Copy-On-Write Trie实现Get 函数 没有什么特别需要注意的，实现比较简单。 实现逻辑： 如果 root_ == nullptr 为真，则返回 nullptr。 沿着 Trie 树遍历，如果节点不存在，则返回 nullptr。 如果目标节点不是 TrieNodeWithValue 类型，则返回 nullptr。 否则，返回目标节点的值。 Put 函数 一开始比较疑惑的点是，智能指针存储的都是 const 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？ 其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 const 指针就能做到。 本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 key.empty() 和 root_ == nullptr。 实现逻辑： 如果 key.empty() 为真： 如果 root_ == nullptr 为真，则使用 value​ 构造 Trie 树并返回。 否则，使用 root_-&gt;children_ 和 value 构造 Trie 树并返回。 根据 root_ == nullptr 条件初始化新 Trie 树的 root。 沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）： 如果克隆完所有字符，则返回新 Trie 树。 否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。 Remove 函数 需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意： ① 节点不包含值需要转换为 TrieNode 类型，也就是说拷贝的时候需要调用 TrieNode::Clone()。 ② 如果节点满足 children_.empty() &amp;&amp; !is_value_node_ 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 erase 父节点中 map 的 key。 实现逻辑： 如果 root_ == nullptr 为真，则返回 *this。 如果 key.empty() 为真，则调用 root_-&gt;TrieNode::Clone() 克隆，并返回新 Trie 树。 沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 *this。 将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。 否则，依次克隆栈中的元素，然后返回新 Trie 树。 补充C++ 因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。 ① 使用 at 访问 const map 对象，因为 [] 运算符可能会自动添加键值。 123const map&lt;int,int&gt; m;cout &lt;&lt; m[1024]; // 错误，No viable overloaded operator[] for type 'const map&lt;int, int&gt;'cout &lt;&lt; m.at(1024); // 正确 ② = 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。 12345map&lt;int,int&gt; m;m[1024] = 1024;auto n = m;n[1024] = 2048;cout &lt;&lt; m[1024]; // 输出：1024 ③ 在 Java 中只要是对象就可以和 null 比较，而 C++ 中只有指针可以和 nullptr 比较。 GDB ① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击此处产生该问题的原因，以及相应的解决方案告诉我下载 libstdc++6-dbgsym，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。 ② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以在此查看该课程提供的 GDB 教程。以及可以阅读：GDB Tutorial: Finding Segmentation Faults。 ③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。 CMake 项目推荐使用 clang-14 作为编译器，解决方案在此。 Task #2 - Concurrent Key-Value Store实现因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 std::mutex 即可。读操作在获取 root_ 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 write_lock_ 上锁。Put 时记得使用 std::move()，因为值可能是不可复制的。 补充① 关于线程和锁的知识，推荐阅读 CS110 Lecture 10: Threads and Mutexes。 ② C++ 有个复制省略（Copy elision）的优化。 ③ 关于 C++ 模板的 FAQ、template 关键字的讨论 和 Dependent names 的定义。（好复杂啊）之所以查这些内容，是因为 CLion 给我生成了不同的表达式： 123auto value = root.template Get&lt;T&gt;(key);root = root.template Put(key, std::move(value));root = root.Remove(key); 以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 &lt;&gt; 来指定类型。然后何时使用 template 没怎么弄明白。 Task #3 - Debugging实现挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 Put 时打断点调试的，应该差不多吧。 补充无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：/usr/bin/ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案在此。 Task #4 - SQL String Functions实现文件的路径：./src/include/execution/expressions 和 ./src/planner/plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 std::tolower 或许有一些注意事项。注册函数时，需要保证参数是有效的，即参数只有一个并且是 VARCHAR 类型。 测试结果就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord 讨论。 修改之后通过！ 项目小结任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 key 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。","link":"/2023/08/26/Project%200%20-%20C++%20Primer/"},{"title":"Codeforces Round 894 (Div. 3)","text":"Gift Carpet从左到右每列贪心取即可。 12345678910111213141516171819202122public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] g = new String[m]; for (int i = 0; i &lt; m; i++) { g[i] = io.next(); } int idx = 0; String s = &quot;vika&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (g[j].charAt(i) == s.charAt(idx)) { idx++; break; } } if (idx == s.length()) { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Sequence Game构造题。当 \\(b_{i-1}&gt;b_{i}\\) 时，在两个数中间添加一个 \\(1\\) 即可。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(b[0]); for (int i = 1; i &lt; n; i++) { if (b[i] &lt; b[i - 1]) ans.add(1); ans.add(b[i]); } io.println(ans.size()); for (int x : ans) io.print(x + &quot; &quot;); io.println();} Flower City Fence阅读理解。题目中的“对角线对称”这个概念根本不用管，就是不断对区间做加法，然后判断是否和原数组相等，可以使用差分 + 前缀和解决。看完题解，发现其实也可以 \\(O(1)\\) 空间解决，因为数组是非递增的，按顺序遍历就行，具体见代码。 123456789101112131415public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } for (int i = 0, j = n; i &lt; n; i++) { for (; j &gt; 0 &amp;&amp; a[j - 1] &lt;= i; j--) ; if (a[i] != j) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Ice Cream Balls题目描述很有问题，其实就是问从一个长度为 \\(m\\) 的序列中选两个值组成集合，使得不同集合的数目恰好为 \\(n\\) 的 \\(m\\) 是多少。可以先二分求 \\(x\\)，使得 \\(C_{x}^{2}\\leq n\\) 且 \\(C_{x+1}^{2}&gt;n\\)。然后答案就是 \\(x+(n-C_{x}^{2})\\)，表示 \\([1,n-C_{x}^{2}]\\) 范围内的每个数各取两个，以及 \\([n-C_{x}^{2}+1,x]\\) 范围内的每个数各取一个。PS：读题很容易漏掉恰好两个字。 12345678910public static void solve() { long n = io.nextLong(); long lo = 2, hi = (long) 1e9 * 2; while (lo &lt;= hi) { long mid = lo + (hi - lo) / 2; if (mid * (mid - 1) / 2 &lt;= n) lo = mid + 1; else hi = mid - 1; } io.println(hi + (n - hi * (hi - 1) / 2));} Kolya and Movie Theatre做这道题时漏掉“开业前一天去过电影院”这个条件，导致想了半天。答案要求最多看 \\(m\\) 部电影的最大娱乐价值，首先我们可以观察到娱乐值的下降幅度只与最后一次去电影院的日期 \\(x\\) 有关，即下降幅度为 \\(x\\cdot d\\)。所以我们可以从前往后枚举 \\(x\\)，并且维护最大长度为 \\(m\\) 的优先队列，来保证最多看 \\(m\\) 部电影。需要注意电影的娱乐值可能是负数，而我们只需要在优先队列中存储正数即可。 123456789101112131415public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = io.nextInt(); PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); long sum = 0L, ans = 0L; for (int i = 0; i &lt; n; i++) { if (a[i] &lt;= 0) continue; q.offer(a[i]); sum += a[i]; if (q.size() &gt; m) sum -= q.poll(); ans = Math.max(ans, sum - (long) d * (i + 1)); } io.println(ans);} Magic Will Save the World初见时想到的是二分时间 + 动态规划，赛后优化发现可以直接动态规划做。我是用背包做的，\\(dp[i][j]\\) 表示前 \\(i\\) 个怪物使用 \\(j\\) 点法术值能够击败的怪物总强度最大是多少，然后枚举水法术值计算答案。但是其实可以不用这样，我们只需要知道怪物的子集的所有可能强度是多少，然后枚举所有能够到达的强度即可。（C++ 位图很方便） 12345678910111213141516171819202122public static void solve() { int w = io.nextInt(), f = io.nextInt(), n = io.nextInt(); int sum = 0; int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); sum += s[i]; } boolean[] dp = new boolean[sum + 1]; dp[0] = true; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= s[i]; j--) { dp[j] = dp[j] || dp[j - s[i]]; } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt;= sum; i++) { if (!dp[i]) continue; ans = Math.min(ans, Math.max((i + w - 1) / w, (sum - i + f - 1) / f)); } io.println(ans);} The Great Equalizer很容易就可以得出结论，设备的输出值是数组的最大值 + 排序后相邻元素的最大差值，但是不知道怎么维护。使用 C++ 的 multiset 很容易写，详细见大佬的代码。","link":"/2023/08/26/Codeforces%20Round%20894%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 317","text":"Potions二分。 12345678910111213141516public static void solve() { int n = io.nextInt(), h = io.nextInt(), x = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); } x = x - h; int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (p[mid] &lt; x) lo = mid + 1; else hi = mid - 1; } io.println(lo + 1);} MissingNo.求和公式。 12345678910111213public static void solve() { int n = io.nextInt(); int sum = 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); sum += a; min = Math.min(min, a); max = Math.max(max, a); } io.println((min + max) * (max - min + 1) / 2 - sum);} Remembering the Days暴力 DFS。 12345678910111213141516171819202122232425262728293031private static int ans = Integer.MIN_VALUE;public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, w = io.nextInt(); g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { dfs(i, 0, g, vis); } io.println(ans);}private static void dfs(int x, int dis, List&lt;int[]&gt;[] g, boolean[] vis) { vis[x] = true; ans = Math.max(ans, dis); for (int[] t : g[x]) { int y = t[0], w = t[1]; if (!vis[y]) { dfs(y, dis + w, g, vis); } } vis[x] = false;} President01 背包，比赛时转移方程弄错了一个细节，本来以为和答案是等价的，赛后改下就过了。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); int sum = 0; int[] x = new int[n]; int[] y = new int[n]; int[] z = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); z[i] = io.nextInt(); sum += z[i]; } long[] dp = new long[sum + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= z[i]; j--) { if (dp[j - z[i]] == Long.MAX_VALUE) continue; dp[j] = Math.min(dp[j], dp[j - z[i]] + Math.max(0, (y[i] - x[i] + 1) / 2)); } } long ans = Long.MAX_VALUE; for (int i = (sum + 1) / 2; i &lt;= sum; i++) { ans = Math.min(ans, dp[i]); } io.println(ans);} Avoid Eye Contact模拟题，比赛时想复杂了，直接模拟就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void solve() { int h = io.nextInt(), w = io.nextInt(); String[] a = new String[h]; for (int i = 0; i &lt; h; i++) { a[i] = io.next(); } int s = -1, g = -1; boolean[][] mark = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { char c = a[i].charAt(j); if (c == 'S') { s = i * w + j; } else if (c == 'G') { g = i * w + j; } else if (c == '#') { mark[i][j] = true; } else if (c == '^') { mark[i][j] = true; for (int k = i - 1; k &gt;= 0 &amp;&amp; a[k].charAt(j) == '.'; k--) { mark[k][j] = true; } } else if (c == 'v') { mark[i][j] = true; for (int k = i + 1; k &lt; h &amp;&amp; a[k].charAt(j) == '.'; k++) { mark[k][j] = true; } } else if (c == '&lt;') { mark[i][j] = true; for (int k = j - 1; k &gt;= 0 &amp;&amp; a[i].charAt(k) == '.'; k--) { mark[i][k] = true; } } else if (c == '&gt;') { mark[i][j] = true; for (int k = j + 1; k &lt; w &amp;&amp; a[i].charAt(k) == '.'; k++) { mark[i][k] = true; } } } } int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; int[] dis = new int[h * w]; Arrays.fill(dis, -1); dis[s] = 0; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(s); while (!q.isEmpty()) { int z = q.poll(); int x = z / w, y = z % w; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= h || ny &lt; 0 || ny &gt;= w || mark[nx][ny]) continue; int nz = nx * w + ny; if (dis[nz] != -1) continue; dis[nz] = dis[z] + 1; q.offer(nz); } } io.println(dis[g]);}","link":"/2023/08/28/AtCoder%20Beginner%20Contest%20317/"},{"title":"Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2)","text":"Increasing and Decreasing比赛时漏看第三个条件，搞半天。而且似乎倒着减会比较容易做（差不多）。 123456789101112131415public static void solve() { int x = io.nextInt(), y = io.nextInt(), n = io.nextInt(); int z = (1 + n - 1) * (n - 1) / 2; if (z &gt; y - x) { io.println(-1); return; } io.print(x + &quot; &quot;); int d = x + y - x - z; for (int i = n - 1; i &gt;= 1; i--) { d += i; io.print(d + &quot; &quot;); } io.println();} Swap and Reverse找规律。第一个操作表明奇数下标相互连通，偶数下标相互连通。第二个操作，如果 \\(k\\) 是奇数，则连通性不会改变，分别对奇偶字母排序，然后构造即可；如果 \\(k\\) 是偶数，则奇数下标和偶数下标相互连通，对所有字母排序即可。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); if (k % 2 == 0) { Arrays.sort(s); io.println(new String(s)); } else { PriorityQueue&lt;Character&gt; list1 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; list2 = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) list1.add(s[i]); else list2.add(s[i]); } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) sb.append(list1.poll()); else sb.append(list2.poll()); } io.println(sb.toString()); }} Divisor Chain比赛时瞎猜 AC 的，当时是想从 \\(1\\) 开始构造到 \\(x\\)，过程比答案复杂。正解是从 \\(x\\) 一直减去最低有效位的一（必定是除数），直到 \\(x\\) 等于 \\(2\\) 的幂（只剩一个一），然后让 \\(x\\) 一直减去 \\(\\frac{x}{2}\\) 即可。 123456789101112131415161718public static void solve() { int x = io.nextInt(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(x); while ((x &amp; (x - 1)) != 0) { x &amp;= (x - 1); ans.add(x); } while (x != 1) { x /= 2; ans.add(x); } io.println(ans.size()); for (int y : ans) { io.print(y + &quot; &quot;); } io.println();} Matrix Cascade使用差分数组维护从上到下的翻转次数，需要注意的是正负需要分开存，正数每层左移一位，负数每层右移一位。PS：这题 \\(p\\) 和 \\(q\\) 总是写错，Debug 很久。以及大佬的代码看不懂。 1234567891011121314151617181920212223242526272829303132public static void solve() { int n = io.nextInt(); char[][] a = new char[n][]; for (int i = 0; i &lt; n; i++) { a[i] = io.next().toCharArray(); } int ans = 0; int[] p = new int[n + 1]; int[] q = new int[n + 1]; int[] sum = new int[n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (a[i][j] - '0' != sum[j + 1] % 2) { ans++; p[j] ^= 1; q[j + 1] ^= 1; } } p[0] ^= p[1]; for (int j = 1; j &lt; n; j++) { p[j] = p[j + 1]; } q[n] ^= q[n - 1]; for (int j = n - 1; j &gt; 0; j--) { q[j] = q[j - 1]; } for (int j = 0; j &lt; n; j++) { sum[j + 1] = sum[j] ^ p[j] ^ q[j]; } } io.println(ans);} Guess Game有点难以描述，超出能力范围了。这是一个比较好理解的做法，分别考虑每一位。从最低位开始，如果前缀相同，那么就计算当前位 \\(0\\) 和 \\(1\\) 的个数，只有爱丽丝拿 \\(1\\)，鲍勃拿 \\(1\\) 或 \\(0\\) 的情况，当前位才会多走一轮。初始时，设置答案为 \\(n \\times n\\)，因为每个组合至少会走一轮。最后需要使用快速幂求 \\(n\\) 的逆元。 1234567891011121314151617181920212223242526272829303132333435363738private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); long ans = (long) n * n; for (int t = 0; t &lt; 30; t++) { for (int l = 0, r = 0; l &lt; n; l = r) { int[] cnt = new int[2]; while (r &lt; n &amp;&amp; a[l] / 2 == a[r] / 2) { cnt[a[r] % 2]++; r++; } ans += (long) cnt[1] * (cnt[1] + cnt[0]); } for (int i = 0; i &lt; n; i++) { a[i] /= 2; } } ans = ans % MOD * pow(n, MOD - 2) % MOD * pow(n, MOD - 2) % MOD; io.println(ans);}private static int pow(int a, int n) { long res = 1, x = a; while (n != 0) { if (n % 2 == 1) { res = (res * x) % MOD; } x = (x * x) % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/08/28/Harbour.Space%20Scholarship%20Contest%202023-2024%20(Div.%201%20+%20Div.%202)/"},{"title":"第 360 场力扣周赛","text":"距离原点最远的点核心：要距离原点最远，那么可选的位置肯定是向同一个方向移动。 123456789101112class Solution { public int furthestDistanceFromOrigin(String moves) { int n = moves.length(), dis = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { char c = moves.charAt(i); if (c == 'L') dis--; else if (c == 'R') dis++; else cnt++; } return Math.max(cnt - dis, cnt + dis); }} 找出美丽数组的最小和和上周一样的题目。 123456class Solution { public long minimumPossibleSum(int n, int target) { long m = Math.min(target / 2, n); return (m * (m + 1) + (target * 2 + n - m - 1) * (n - m)) / 2; }} 使子序列的和等于目标的最少操作次数比赛时思路满天飞，各种乱写。其实最后的思路是对的，但是基于之前的代码改写，导致有很多 Bug。赛后 15 分钟 AC。从低位到高位枚举 \\(target\\) 中的 \\(1\\)，假设当前 \\(1\\) 对应的值为 \\(x\\)，那么 \\(nums\\) 中所有小于等于 \\(x\\) 的值都可以用来填补 \\(x\\)，如果不够那么肯定需要将下一个大于 \\(x\\) 的值分解为 \\(x\\)。（更优的做法） 123456789101112131415161718192021class Solution { public int minOperations(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int n = nums.size(); int idx = 0, sum = 0, ans = 0; for (int i = target; i != 0; ) { int x = i &amp; -i; i -= x; while (idx &lt; n &amp;&amp; nums.get(idx) &lt;= x) { sum += nums.get(idx++); } sum -= x; if (sum &lt; 0) { if (idx == n) return -1; ans += Integer.numberOfTrailingZeros(nums.get(idx) / x); sum += nums.get(idx++); } } return ans; }} 在传球游戏中最大化函数值参考大佬的题解。 方法一：倍增 DP 因为 CPU 缓存的原因，数组开成 new int[35][n] 会更快。因为这样转移的时候只从上一行转移，具有空间局部性；而下面的代码是从左边一列转移，不具有空间局部性。 1234567891011121314151617181920212223242526272829class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); int[][] f = new int[n][35]; long[][] w = new long[n][35]; for (int i = 0; i &lt; n; i++) { f[i][0] = receiver.get(i); w[i][0] = i; } for (int j = 1; j &lt; 35; j++) { for (int i = 0; i &lt; n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; w[i][j] = w[i][j - 1] + w[f[i][j - 1]][j - 1]; } } long ans = 0L; for (int i = 0; i &lt; n; i++) { long cur = 0L; int pos = i; for (int j = 0; j &lt; 35; j++) { if ((k &gt;&gt; j &amp; 1) == 0) continue; cur += w[pos][j]; pos = f[pos][j]; } ans = Math.max(ans, cur + pos); } return ans; }} 方法二：内向基环树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[receiver.get(i)]++; reverse[receiver.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[receiver.get(x)] == 0) { q.offer(receiver.get(x)); } } // 计算每个环的前缀和，并记录每个节点在哪个环的哪个位置 int[] cirNum = new int[n]; int[] cirPos = new int[n]; boolean[] vis = new boolean[n]; List&lt;List&lt;Long&gt;&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { List&lt;Long&gt; cir = new ArrayList&lt;&gt;(); cir.add(0L); // 前缀和的冗余节点 // 存储环的节点，并记录每个节点在哪个环的哪个位置 for (int cur = i; !vis[cur]; cur = receiver.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cirPos[cur] = cir.size(); cir.add((long) cur); } // 重复存储环的节点，方便计算从任意节点开始和结束的价值和 for (int t = cir.size() - 1, j = 1; t &gt; 0; t--, j++) { cir.add(cir.get(j)); } // 计算前缀和 for (int j = 1; j &lt; cir.size(); j++) { cir.set(j, cir.get(j) + cir.get(j - 1)); } circles.add(cir); } } // 对环内的每个节点向环外进行 dfs，从而计算出以每个节点作为起点的价值和 long ans = 0L; // 存储环外节点的前缀和 List&lt;Long&gt; outSum = new ArrayList&lt;&gt;(); outSum.add(0L); for (int i = 0; i &lt; n; i++) { // 注意传递 k + 1，表示总节点数量 if (in[i] != 0) ans = Math.max(ans, dfs(i, circles.get(cirNum[i]), cirPos[i], reverse, in, outSum, k + 1)); } return ans; } private long dfs(int x, List&lt;Long&gt; cir, int pos, List&lt;Integer&gt;[] reverse, int[] in, List&lt;Long&gt; outSum, long k) { long res = 0L; int outLen = outSum.size() - 1; if (outLen &lt; k) { int n = cir.size() / 2; // 因为 cir 多存储了 n - 1 个环内节点，以及一个冗余节点，所以 cir.size() / 2 就是环的长度 res = (k - outLen) / n * cir.get(n) + cir.get(pos + (int) ((k - outLen) % n) - 1) - cir.get(pos - 1); } res += outSum.get(outLen) - outSum.get((int) Math.max(0L, outLen - k)); for (int y : reverse[x]) { if (in[y] != 0) continue; outSum.add(outSum.get(outLen) + y); res = Math.max(res, dfs(y, cir, pos, reverse, in, outSum, k)); outSum.remove(outLen + 1); } return res; }}","link":"/2023/08/28/%E7%AC%AC%20360%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Homework #1 - SQL","text":"作业准备项目地址：Homework #1 - SQL。 准备工作：阅读 Chapters 1-2 27 3-5，学习 Lecture #01 #02，以及阅读课堂笔记。 Q1 [0 points] (q1_sample):Ctrl + C，Ctrl +V。 Q2 [5 points] (q2_not_the_same_title):查询只涉及 titles 表，比较简单。 1234567891011121314SELECT premiered, primary_title || ' (' || original_title || ')'FROM titlesWHERE primary_title != original_title AND type = 'movie' AND genres LIKE '%Action%'ORDER BY premiered DESC, primary_titleLIMIT 10; Q3 [5 points] (q3_longest_running_tv):题目描述很不清晰啊，类型都不知道具体是什么。 12345678910111213SELECT primary_title, IIF(ended IS NULL, 2023, ended) - premiered AS runtimeFROM titlesWHERE primary_title IS NOT NULL AND type = 'tvSeries'ORDER BY runtime DESC, primary_titleLIMIT 20; Q4 [10 points] (q4_directors_in_each_decade):唯一要注意的就是使用 DISTINCT。 12345678910111213SELECT CAST(born / 10 * 10 AS TEXT) || 's' AS decade, COUNT(DISTINCT(people.person_id)) AS num_directorsFROM people INNER JOIN crew USING(person_id)WHERE category = 'director' AND born &gt;= 1900GROUP BY decadeORDER BY decade; Q5 [10 points] (q5_german_type_ratings):德语的缩写是 de。 12345678910111213141516SELECT t.type, ROUND(AVG(r.rating), 2) AS avg_rating, MIN(r.rating), MAX(r.rating)FROM akas as a INNER JOIN ratings as r USING(title_id) INNER JOIN titles as t USING(title_id)WHERE a.language = 'de' AND a.types IN ('imdbDisplay', 'original')GROUP BY t.typeORDER BY avg_rating; Q6 [10 points] (q6_who_played_a_batman):坑点就是模糊查询时 Batman 两边要加上双引号，即 &quot;Batman&quot;。以及在连接 people 和 crew 表时，顺序很重要，如果使用 crew INNRE JOIN people USING(person_id) 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。 12345678910111213crew INNER JOIN people USING(person_id)QUERY PLAN|--SCAN crew USING INDEX ix_crew_person_id|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCTpeople INNER JOIN crew USING(person_id)QUERY PLAN|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCT 12345678910111213141516171819202122232425WITH t AS ( SELECT DISTINCT(person_id), name FROM people INNER JOIN crew USING(person_id) WHERE category = 'actor' AND characters LIKE '%&quot;Batman&quot;%')SELECT name, ROUND(AVG(rating), 2) AS avg_ratingFROM t INNER JOIN crew USING(person_id) INNER JOIN ratings USING(title_id)GROUP BY person_idORDER BY avg_rating DESCLIMIT 10; Q7 [15 points] (q7_born_with_prestige):SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。 123456789SELECT COUNT(DISTINCT(person_id))FROM titles INNER JOIN people ON titles.premiered = people.born INNER JOIN crew USING(person_id)WHERE primary_title = 'The Prestige' AND category IN ('actor', 'actress'); 12345QUERY PLAN|--USE TEMP B-TREE FOR count(DISTINCT)|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?) Q8 [15 points] (q8_directing_rose.sql):比官解快一秒。注意使用 Rose% 而不是 Rose %。 12345678910111213141516171819SELECT DISTINCT(name)FROM crew INNER JOIN people USING(person_id)WHERE category = 'director' AND title_id IN ( SELECT title_id FROM crew INNER JOIN people USING(person_id) WHERE category = 'actress' AND name LIKE 'Rose%' )ORDER BY name; Q9 [15 points] (q9_ode_to_the_dead):这就是窗口函数么，学习了。 123456789101112131415161718192021222324252627282930313233343536373839WITH t AS ( SELECT category, name, died, primary_title, runtime_minutes, DENSE_RANK() OVER( PARTITION BY category ORDER BY died, name ) AS rank_died_name, DENSE_RANK() OVER( PARTITION BY category, person_id ORDER BY runtime_minutes DESC, title_id ) AS rank_runtime_title FROM crew INNER JOIN people USING(person_id) INNER JOIN titles USING(title_id) WHERE died IS NOT NULL AND runtime_minutes IS NOT NULL)SELECT category, name, died, primary_title, runtime_minutes, rank_died_nameFROM tWHERE rank_died_name &lt;= 5 AND rank_runtime_title = 1ORDER BY category, rank_died_name; Q10 [15 points] (q10_all_played_by_leo):不会。。json_each 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。 123456789101112131415161718192021222324252627WITH t1(characters) AS ( SELECT characters FROM people INNER JOIN crew USING(person_id) WHERE name = 'Leonardo DiCaprio' AND born = 1974),t2(value) AS ( SELECT DISTINCT(value) FROM t1, json_each(t1.characters) WHERE value != '' AND value NOT LIKE '%SELF%' ORDER BY value)SELECT GROUP_CONCAT(value)FROM t2; 作业小结最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）","link":"/2023/08/29/Homework%201%20-%20SQL/"},{"title":"Pinely Round 2 (Div. 1 + Div. 2)","text":"Channel如果同时在线人数到达 \\(n\\)，就表示所有人都阅读过；否则，如果总上线人数大于等于 \\(n\\)，则有可能所有人阅读过；否则，不可能所有人阅读过。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), a = io.nextInt(), q = io.nextInt(); String s = io.next(); int cur = a, tot = a; for (int i = 0; i &lt; q &amp;&amp; cur &lt; n; i++) { if (s.charAt(i) == '+') { cur++; tot++; } else { cur--; } } if (cur == n) { io.println(&quot;YES&quot;); } else if (tot &gt;= n) { io.println(&quot;MAYBE&quot;); } else { io.println(&quot;NO&quot;); }} Split Sort对于每个 \\(p_{i}=k+1\\) 和 \\(p_{j}=k\\) 并且 \\(i&lt;j\\)，那么就一定要选一次 \\(x=k+1\\)。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt() - 1; } int[] map = new int[n]; for (int i = 0; i &lt; n; i++) { map[p[i]] = i; } int ans = 0; for (int i = 1; i &lt; n; i++) { if (map[i] &lt; map[i - 1]) { ans++; } } io.println(ans);} MEX Repetition每执行一次操作，就会去除最后一个数，并将 \\(MEX\\) 添加到序列头部。所以可以通过在数组末尾加上原始数组的 \\(MEX\\)，将操作看成是向左移动循环数组的起始索引。求原始数组的 \\(MEX\\) 可以使用求和公式。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); long sum = 0L; int[] a = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } a[n] = (int) ((long) (1 + n) * n / 2 - sum); k = k % (n + 1); for (int i = 0; i &lt; n; i++) { io.print(a[(-k + n + 1 + i) % (n + 1)] + &quot; &quot;); } io.println();} Two-Colored Dominoes横放的牌只会对列有影响，竖放的牌只会对行有影响，所以分别处理。按行遍历竖放的牌，每当遇到 \\(U\\) 就染上和上次相反的颜色，如果该行只包含奇数个 \\(U\\)，就返回 \\(-1\\)。横放的牌同理。 123456789101112131415161718192021222324252627282930313233343536373839public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } final char[] aux = {'B', 'W'}; for (int i = 0; i &lt; n - 1; i++) { int xor = 0; for (int j = 0; j &lt; m; j++) { if (s[i][j] == 'U') { s[i][j] = aux[xor]; s[i + 1][j] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int j = 0; j &lt; m - 1; j++) { int xor = 0; for (int i = 0; i &lt; n; i++) { if (s[i][j] == 'L') { s[i][j] = aux[xor]; s[i][j + 1] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int i = 0; i &lt; n; i++) { io.println(new String(s[i])); }} Speedrun其实思路是知道的，就是不知道怎么写。这个解法看着有点懵，可能其他解法会更好理解一点。注意题目给定 \\(a_{i}&lt;b_{i}\\)。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); int[] h = new int[n]; for (int i = 0; i &lt; n; i++) { h[i] = io.nextInt(); } List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, idx -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1; g[a].add(b); } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从 h[i] 开始） long[] dp = new long[n]; for (int i = n - 1; i &gt;= 0; i--) { for (int j : g[i]) { dp[i] = Math.max(dp[i], dp[j] + (h[j] - h[i] + k) % k); } } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从零开始） long max = 0L; for (int i = 0; i &lt; n; i++) { dp[i] += h[i]; max = Math.max(max, dp[i]); } // 按照 h[i] 的大小，从小到大枚举起点 Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; h[i] - h[j]); long ans = Long.MAX_VALUE; for (int i : aux) { ans = Math.min(ans, max - h[i]); // 如果起点大于 h[i]，那么任务 i 的完成时间需要加 k，从而导致 dp[i] + k // 其实只要枚举入度为 0 的任务就行，但是即使任务 i 不是入度为 0 任务也没有关系，因为对答案没有影响 max = Math.max(max, dp[i] + k); } io.println(ans);}","link":"/2023/08/31/Pinely%20Round%202%20(Div.%201%20+%20Div.%202)/"},{"title":"Educational Codeforces Round 154 (Rated for Div. 2)","text":"Prime Deletion从 \\(1\\) 到 \\(9\\) 的序列中删除一些数（至少保留两位），使得结果为质数。可以发现 \\(13\\) 和 \\(31\\) 都是质数，所以判断 \\(1\\) 和 \\(3\\) 的先后顺序，然后输出即可。 12345678910111213public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; for (int i = 0; i &lt; n; i++) { if (s[i] == '1') { io.println(13); return; } else if(s[i] == '3') { io.println(31); return; } }} Two Binary Strings比赛时我是从左往右遍历记录不相等的数量，如果有不相等的，那么就需要一个 \\(0\\)，否则遇到 \\(1\\) 就输出 YES。和正解的思路是一样的，就是麻烦一点。正解是有相同的 \\(01\\) 出现时就输出 YES。 123456789101112public static void solve() { char[] a = io.next().toCharArray(); char[] b = io.next().toCharArray(); int n = a.length; for (int i = 0; i &lt; n - 1; i++) { if (a[i] == b[i] &amp;&amp; a[i] == '0' &amp;&amp; a[i + 1] == b[i + 1] &amp;&amp; a[i + 1] == '1') { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Queries for the Array比较简单的写法就是用一个标记数组做记录，递增会向左传递，递减会向右传递，然后判断是否冲突即可。更进一步观察，可以发现只需要记录最大的递增位置，和最小的递减位置。 1234567891011121314151617181920212223242526272829public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = true; int pos = -1, neg = n, cur = -1; for (char c : s) { if (c == '+') { cur++; } else if (c == '-') { if (cur-- == neg) { neg = n; } pos = Math.min(pos, cur); } else if (c == '0') { if (cur == pos || cur &lt;= 0) { ok = false; break; } neg = Math.min(neg, cur); } else { if (neg &lt;= cur) { ok = false; break; } pos = cur; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Sorting By Multiplication没想到啊。枚举负数前缀的长度：在负数前缀中，如果 \\(a[i]&lt;=a[i+1]\\)，就需要操作一次；在正数后缀中，如果 \\(a[i]&gt;=a[i+1]\\) 就需要操作一次。（下面的代码很妙啊，不需要加额外的判断语句。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int cnt = 0; for (int i = 0; i &lt; n - 1; i++) { if (a[i] &gt;= a[i + 1]) { cnt++; } } int ans = cnt; for (int i = 1; i &lt; n; i++) { if (a[i - 1] &gt;= a[i]) cnt--; ans = Math.min(ans, cnt + 1); if (a[i - 1] &lt;= a[i]) cnt++; } io.println(ans);}","link":"/2023/09/04/Educational%20Codeforces%20Round%20154%20(Rated%20for%20Div.%202)/"},{"title":"AtCoder Beginner Contest 318","text":"Full Moon模拟。 1234public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); io.println(n &lt; m ? 0 : (n - m) / p + 1);} Overlapping sheets比赛时没什么思路，想到扫描线，就用扫描线 + 区间合并来做了。结果一看题解，暴力标记每个点，没想到。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; int[][] g = new int[100][100]; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(), b = io.nextInt(); int c = io.nextInt(), d = io.nextInt(); for (int x = a; x &lt; b; x++) { for (int y = c; y &lt; d; y++) { if (g[x][y]++ == 0) ans++; } } } io.println(ans);} Blue Spring看到大佬的解法后，感觉我模拟的方式好蠢啊。当时我是枚举是否要买 \\(d\\) 张票，有点麻烦，原来枚举买当日的票更简单。 1234567891011121314public static void solve() { int n = io.nextInt(), d = io.nextInt(), p = io.nextInt(); int[] f = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { f[i] = io.nextInt(); } Arrays.sort(f); long ans = Long.MAX_VALUE, sum = 0L; for (int i = 0; i &lt;= n; i++) { sum += f[i]; ans = Math.min(ans, sum + (long) (n - i + d - 1) / d * p); } io.println(ans);} General Weighted Max Matching动态规划有点不太会，赛时瞎搞 AC 的。记忆化搜索会很好写，然后 DP 的话，我是用三层循环解决的，下面的解法优化掉一层循环。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[][] d = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { d[i][j] = io.nextInt(); } } long[] dp = new long[1 &lt;&lt; n]; for (int k = 2; k &lt; 1 &lt;&lt; n; k++) { int i = Integer.numberOfTrailingZeros(k &amp; -k); dp[k] = dp[k ^ (1 &lt;&lt; i)]; for (int j = i + 1; j &lt; n; j++) { if ((k &gt;&gt; j &amp; 1) == 1) { dp[k] = Math.max(dp[k], dp[k ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j)] + d[i][j]); } } } io.println(dp[(1 &lt;&lt; n) - 1]);} Sandwiches比较显然的做法是把相同的数分为一组，然后组内枚举中间的数。对于每个中间的数，让答案加上 \\(L\\times R\\)，其中 \\(L\\) 和 \\(R\\) 分别是左右两边相等的数的个数，枚举时可以一次性枚举间隔内所有数。 第二个解法是参考大佬的代码得到的，相当于枚举右端点吧。对于每个右端点，它的贡献可以根据下面代码中的公式得出，感觉比较巧妙。 12345678910111213public static void solve() { int n = io.nextInt(); int[] cnt = new int[n]; long[] sum = new long[n]; long ans = 0L; for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; ans += (long) i * cnt[a] - sum[a] - (long) (1 + cnt[a]) * cnt[a] / 2; cnt[a]++; sum[a] += i; } io.println(ans);} Octopus有点抽象，不是很懂。大概是枚举了 \\(N^{2}\\) 个极限位置，然后分别对每个位置判断可行性。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int N = io.nextInt(); long[] X = new long[N]; long[] L = new long[N]; for (int i = 0; i &lt; N; i++) { X[i] = io.nextLong(); } for (int i = 0; i &lt; N; i++) { L[i] = io.nextLong(); } List&lt;Long&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { pos.add(X[i] - L[j]); pos.add(X[i] + L[j] + 1); } } Collections.sort(pos); long ans = 0L; for (int i = 0; i &lt; pos.size() - 1; i++) { long[] dis = new long[N]; for (int j = 0; j &lt; N; j++) { dis[j] = Math.abs(pos.get(i) - X[j]); } Arrays.sort(dis); boolean ok = true; for (int j = 0; j &lt; N; j++) { if (dis[j] &gt; L[j]) { ok = false; break; } } if (ok) { ans += pos.get(i + 1) - pos.get(i); } } io.println(ans);}","link":"/2023/09/04/AtCoder%20Beginner%20Contest%20318/"},{"title":"第 112 场力扣夜喵双周赛","text":"判断通过操作能否让字符串相等 I同下。 判断通过操作能否让字符串相等 II模拟。也可以手动比较，就是适用性不好。（PS：想出一个写法，结果被自己 Hack 掉了~） 1234567891011class Solution { public boolean checkStrings(String s1, String s2) { int n = s1.length(); int[][] c1 = new int[2][26], c2 = new int[2][26]; for (int i = 0; i &lt; n; i++) { c1[i &amp; 1][s1.charAt(i) - 'a']++; c2[i &amp; 1][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(c1, c2); }} 几乎唯一子数组的最大和滑动窗口。 12345678910111213141516171819class Solution { public long maxSum(List&lt;Integer&gt; nums, int m, int k) { int n = nums.size(); long sum = 0L, ans = 0L; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge(nums.get(i), 1, Integer::sum); sum += nums.get(i); if (i &gt;= k - 1) { if (map.size() &gt;= m) ans = Math.max(ans, sum); if (map.merge(nums.get(i - k + 1), -1, Integer::sum) == 0) { map.remove(nums.get(i - k + 1)); } sum -= nums.get(i - k + 1); } } return ans; }} 统计一个字符串的 k 子序列美丽值最大的数目因为和选择的顺序没有关系，所以贪心的选择出现次数最大的字母就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { private static final long MOD = (long) 1e9 + 7; public int countKSubsequencesWithMaxBeauty(String s, int k) { char[] ss = s.toCharArray(); int[] cnt = new int[26]; for (char c : ss) { cnt[c - 'a']++; } TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((a, b) -&gt; b - a); for (int i = 0; i &lt; 26; i++) { map.merge(cnt[i], 1, Integer::sum); } long ans = 1L; for (var e : map.entrySet()) { int key = e.getKey(), val = e.getValue(); if (val &gt;= k) { return (int) (ans * comb(val, k) % MOD * pow(key, k) % MOD); } k -= val; ans = (ans * pow(key, val)) % MOD; } return 0; } private long pow(long x, int n) { long res = 1L; while (n != 0) { if ((n &amp; 1) == 1) res = (res * x) % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; } private long comb(long n, int k) { long res = n; for (int i = 2; i &lt;= k; i++) { res = res * --n / i; } return res % MOD; }}","link":"/2023/09/04/%E7%AC%AC%20112%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 361 场力扣周赛","text":"统计对称整数的数目模拟。 12345678910111213141516171819202122class Solution { public int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i &lt;= high; i++) { int x = i, n = 0; int[] aux = new int[10]; for (; x != 0; x /= 10) { aux[n++] = x % 10; } if (n % 2 == 0) { int sum = 0; for (int j = 0; j &lt; n / 2; j++) { sum += aux[j] - aux[j + n / 2]; } if (sum == 0) { ans++; } } } return ans; }} 生成特殊数字的最少操作比较简洁的暴力写法，当然从个位开始找 \\(25,75,50,00,0\\) 更快。 1234567891011121314151617class Solution { public int minimumOperations(String num) { int n = num.length(), ans = n; for (int i = 0; i &lt; n; i++) { if (num.charAt(i) == '0') { ans = Math.min(ans, n - 1); } for (int j = i + 1; j &lt; n; j++) { int x = (num.charAt(i) - '0') * 10 + num.charAt(j) - '0'; if (x % 25 == 0) { ans = Math.min(ans, n - i - 2); } } } return ans; }} 统计趣味子数组的数目最开始的思路是，找到所有满足 \\(nums[i]\\bmod modulo=k\\) 的下标放入新的列表，然后在新列表中枚举左端点 \\(i\\)，此时满足条件的右端点就是 \\(i+k-1+j\\times modulo\\)。暴力解决的时间复杂度 \\(O(n^{2})\\)，所以可以倒序枚举左端点，顺便记录间隔为 \\(modulo\\) 的后缀和。但是，这样解决还需要特判 \\(k=0\\) 的情况，总之很麻烦。 更好的做法是利用同余的性质。将所有 \\(nums[i]\\bmod modulo=k\\) 的数字看作 \\(1\\)，其他数字看作 \\(0\\)，这样我们要求的就是满足 \\((sum[r+1]-sum[l])\\bmod modulo=k\\) 的所有子数组的数目。我们可以枚举右端点，找到满足 \\((sum[r+1]-k)\\equiv sum[l]\\pmod{modulo}\\) 的左端点的个数，使用前缀和 + 哈希表即可。 12345678910111213141516class Solution { public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) { long ans = 0L; int n = nums.size(), sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int x : nums) { if (x % modulo == k) { sum = (sum + 1) % modulo; } ans += map.getOrDefault((sum - k + modulo) % modulo, 0); map.merge(sum, 1, Integer::sum); } return ans; }} 边权重均等查询树上倍增求最近公共祖先，同时维护边权的计数。详细见灵神题解。（发现汪佬的写法更简单，在 DFS 的同时进行倍增，以及通过拷贝数组来维护边权的计数信息。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution { private static final int M = 14; public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2] - 1; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] depth = new int[n]; int[][] cnt = new int[n][26]; int[][] parent = new int[M][n]; dfs(0, -1, g, depth, parent, cnt); // 查询 int k = queries.length; int[] ans = new int[k]; while (k-- != 0) { int x = queries[k][0], y = queries[k][1]; int z = lca(x, y, depth, parent), max = 0; for (int i = 0; i &lt; 26; i++) { max = Math.max(max, cnt[x][i] + cnt[y][i] - 2 * cnt[z][i]); } ans[k] = depth[x] + depth[y] - 2 * depth[z] - max; } return ans; } // DFS 的同时进行倍增，以及维护边权的计数 private void dfs(int x, int fa, List&lt;int[]&gt;[] g, int[] depth, int[][] parent, int[][] cnt) { for (int i = 1; 1 &lt;&lt; i &lt;= depth[x]; i++) { parent[i][x] = parent[i - 1][parent[i - 1][x]]; } for (int[] t : g[x]) { int y = t[0], w = t[1]; if (y != fa) { parent[0][y] = x; System.arraycopy(cnt[x], 0, cnt[y], 0, 26); cnt[y][w]++; depth[y] = depth[x] + 1; dfs(y, x, g, depth, parent, cnt); } } } // 求最近公共祖先 private int lca(int x, int y, int[] depth, int[][] parent) { if (depth[x] &gt; depth[y]) { int t = x; x = y; y = t; } // 先向上跳到相同深度 int step = depth[y] - depth[x]; for (int i = 0; i &lt; 32; i++) { if ((step &gt;&gt; i &amp; 1) != 0) { y = parent[i][y]; } } // 尽量向上跳 if (x != y) { for (int i = M - 1; i &gt;= 0; i--) { int px = parent[i][x], py = parent[i][y]; if (px != py) { x = px; y = py; } } x = parent[0][x]; } return x; }}","link":"/2023/09/04/%E7%AC%AC%20361%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 362 场力扣周赛","text":"与车相交的点差点又想区间合并做，看下数据范围，直接暴力，更好的做法是差分数组。 123456789101112131415class Solution { public int numberOfPoints(List&lt;List&lt;Integer&gt;&gt; nums) { int[] d = new int[102]; for (var num : nums) { d[num.get(0)]++; d[num.get(1) + 1]--; } int ans = 0; for (int i = 1; i &lt;= 100; i++) { d[i] += d[i - 1]; if (d[i] &gt; 0) ans++; } return ans; }} 判断能否在给定时间到达单元格题目说恰好第 \\(t\\) 秒到达，我还以为之前都不能到达，结果可以。那么特殊情况就是起点和终点相同，并且 \\(t=1\\)。 1234567class Solution { public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx &amp;&amp; sy == fy &amp;&amp; t == 1) return false; int a = Math.abs(sx - fx), b = Math.abs(sy - fy); return Math.max(a, b) &lt;= t; }} 将石头分散到网格图的最少移动次数方法一：回溯 记录所有等于零和大于一的位置，然后 DFS 搜索每个零从哪个位置获取一。 12345678910111213141516171819202122232425262728293031class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); else if (grid[i][j] &gt; 1) b.add(new int[]{i, j}); } } dfs(0, grid, a, b, 0); return ans; } private void dfs(int i, int[][] grid, List&lt;int[]&gt; a, List&lt;int[]&gt; b, int cnt) { if (i == a.size()) { ans = Math.min(ans, cnt); return; } int[] p = a.get(i); for (int j = 0; j &lt; b.size(); j++) { int[] q = b.get(j); if (grid[q[0]][q[1]] &gt; 1) { grid[q[0]][q[1]]--; dfs(i + 1, grid, a, b, cnt + Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1])); grid[q[0]][q[1]]++; } } }} 方法二：状压 DP 不是很懂，具体解释可以看大佬的题解。 123456789101112131415161718192021222324252627282930class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); for (int k = 2; k &lt;= grid[i][j]; k++) b.add(new int[]{i, j}); } } int n = a.size(); int[] f = new int[1 &lt;&lt; n]; for (int i = 1; i &lt; 1 &lt;&lt; n; i++) { f[i] = Integer.MAX_VALUE; int m = Integer.bitCount(i); for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j &amp; 1) == 1) { f[i] = Math.min(f[i], f[i ^ (1 &lt;&lt; j)] + distance(a.get(m - 1), b.get(j))); } } } return f[(1 &lt;&lt; n) - 1]; } private int distance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); }} 字符串转换KMP + 矩阵快速幂，详细见灵神题解，学习 KMP 看代码随想录，还有各种其他解法可以看题解区（很不错！）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { private static final int MOD = (int) 1e9 + 7; public int numberOfWays(String s, String t, long k) { int n = s.length(); char[] text = (s + s.substring(0, n - 1)).toCharArray(); char[] pattern = t.toCharArray(); int c = kmp(text, pattern); // f[0][0] = s.equals(t) ? 1 : 0; // f[0][1] = s.equals(t) ? 0 : 1; // f[i][0] = f[i - 1][0] * (c - 1) + f[i - 1][1] * c; // f[i][1] = f[i - 1][0] * (n - c) + f[i - 1][1] * (n - c - 1); long[][] m = {{c - 1, c}, {n - c, n - c - 1}}; m = pow(m, k); return s.equals(t) ? (int) m[0][0] : (int) m[0][1]; } private int kmp(char[] text, char[] pattern) { int m = text.length, n = pattern.length; int[] next = new int[n]; for (int i = 1, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) { j = next[j - 1]; } if (pattern[i] == pattern[j]) j++; next[i] = j; } int cnt = 0; for (int i = 0, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) { j = next[j - 1]; } if (text[i] == pattern[j]) j++; if (j == n) { cnt++; j = next[j - 1]; } } return cnt; } private long[][] pow(long[][] a, long n) { long[][] res = {{1, 0}, {0, 1}}; while (n != 0) { if ((n &amp; 1) == 1) res = mul(res, a); a = mul(a, a); n &gt;&gt;= 1; } return res; } private long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % MOD; } } return c; }}","link":"/2023/09/11/%E7%AC%AC%20362%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 896 (Div. 2)","text":"Make It Zero挺简单的一道题，偶数长度的数组操作两次就可以，如果是奇数长度，则额外操作两次。写的时候，把 \\(n\\) 错写成 \\(n-1\\)，找 BUG 花了一倍的时间。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } if (n % 2 == 0) { io.println(2); io.println(1 + &quot; &quot; + n); io.println(1 + &quot; &quot; + n); return; } io.println(4); io.println(1 + &quot; &quot; + (n - 1)); io.println(1 + &quot; &quot; + (n - 1)); io.println((n - 1) + &quot; &quot; + n); io.println((n - 1) + &quot; &quot; + n);} 2D Traveling\\(a\\) 和 \\(b\\) 的最短距离有两种情况，一个是 \\(a\\) 和 \\(b\\) 的曼哈顿距离，另一个是 \\(a\\) 和 \\(b\\) 经过 \\(k\\) 的曼哈顿距离，该情况只要求 \\(k\\) 个点中距离 \\(a\\) 和距离 \\(b\\) 最近的距离就行。比赛时遇到个坑点，两个 Long.MAX_VALUE 相加会溢出，所以初始时除以二。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(), a = io.nextInt(), b = io.nextInt(); long[] x = new long[n], y = new long[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } long ak = Long.MAX_VALUE / 2, bk = Long.MAX_VALUE / 2; for (int i = 0; i &lt; k; i++) { ak = Math.min(ak, Math.abs(x[i] - x[a - 1]) + Math.abs(y[i] - y[a - 1])); bk = Math.min(bk, Math.abs(x[i] - x[b - 1]) + Math.abs(y[i] - y[b - 1])); } long ab = Math.abs(x[b - 1] - x[a - 1]) + Math.abs(y[b - 1] - y[a - 1]); io.println(Math.min(ab, ak + bk));} Fill in the Matrix比赛时代码很乱，赛后总是可以优化成比较简单的形式。分类讨论，\\(n\\) 和 \\(m\\) 的大小关系，可以直接得出最大美丽值，需要注意特判 \\(m=1\\) 的情况。然后就是构造，当 \\(n\\leq m-1\\) 时，让一个从 \\(0\\) 开始的数组循环左移来构造行，这样可以保证得到最大美丽值；当 \\(n&gt;m-1\\) 时，前 \\(m-1\\) 行与之前一样构造，之后多余的行只需要和最后一行相同即可（保证不会影响美丽值）。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), m = io.nextInt(); if (m == 1) { io.println(0); } else if (n &lt;= m - 1) { io.println(n + 1); } else { io.println(m); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &lt; Math.min(n, m - 1)) { io.print((j + i) % m + &quot; &quot;); } else { io.print(j + &quot; &quot;); } } io.println(); }} Candy Party (Easy Version)找 BUG 花了半个小时，将判断 hi 是否是二的幂写成 hi % 2 != 0，修改为 Long.bitCount(hi) != 1 后通过，也可以写成 (hi &amp; hi - 1) != 0。因为每个人都需要发送和接收糖果，计算每个人和平均糖果数的差值 \\(x\\)，如果 \\(x\\) 的二进制位不是由连续的 \\(1\\) 组成，那么就无解，否则总是有唯一的 \\(lo\\) 和 \\(hi\\)（都是二的幂），使得 \\(hi-lo=|x|\\)。这样可以计算出每个人发送和接收多少糖果，如果最后相互抵消，则存在满足题目要求的交换方案。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); long lo = x &amp; -x, hi = x + lo; if (Long.bitCount(hi) != 1) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 0; i &lt; 32; i++) { if (cnt[i] != 0) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Candy Party (Hard Version)考虑什么人可以不发送或者不接收糖果，必定是持有糖果数与平均糖果数的差值为二的幂的人，它们比原来多出一种选择，就是只执行一次发送或接收。具体操作见代码，有点说不清。最后大概是从高位到低位遍历，如果当前位不满足条件，就将低一位的差值与平均糖果数为二的幂的数分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; int[] in = new int[32], out = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); if ((x &amp; x - 1) == 0) { int r = Long.numberOfTrailingZeros(x); if (a[i] &lt; avg) in[r]++; else out[r]++; continue; } long lo = x &amp; -x, hi = x + lo; if ((hi &amp; hi - 1) != 0) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 31; i &gt;= 0; i--) { cnt[i] += out[i] - in[i]; if (i == 0) break; in[i - 1] -= cnt[i]; out[i - 1] += cnt[i]; if (in[i - 1] &lt; 0 || out[i - 1] &lt; 0) { io.println(&quot;NO&quot;); return; } } io.println(cnt[0] == 0 ? &quot;YES&quot; : &quot;NO&quot;);}","link":"/2023/09/11/Codeforces%20Round%20896%20(Div.%202)/"},{"title":"Project #1 - Buffer Pool","text":"项目准备项目地址：Project #1 - Buffer Pool 准备工作：阅读 Chapter 12.1-12.4 13.2-13.3 24.2，学习 Lecture #03 #04，以及阅读课堂笔记。 项目结构buffer_pool_manager pages_ 数组相当于缓冲池，frame_id 是该数组的下标，也就唯一标识一个 Page，即标识一个缓冲页面。一个 Page 可以存储不同的物理页面，Page 的数据成员 page_id_ 唯一标识一个物理页面。因为不管是 FetchPage，还是 DeletePage 等函数，我们都是针对实际的物理页面做操作，所以 buffer_pool_manager 中的函数的形参都是提供 page_id。 lru_k_replacer 该类提供缓冲页面的淘汰策略，即淘汰某个 fram_id 对应的缓冲页面。一个缓冲页面会有一个对应的 LRUKNode，它负责记录该缓冲页面的访问历史。 page_guard 主要有三个类：BasicPageGuard，ReadPageGuard 和 WritePageGuard。BasicPageGuard 的作用是保证缓冲页面在使用完后会进行 UnpinPage 操作。而 ReadPageGuard 和 WritePageGuard，它们和 BasicPageGuard 是组合关系，它们的作用在 BasicPageGuard 的基础上保证页面在使用完后会解除读写锁。 Task #1 - LRU-K Replacement Policy实现① 一开始以为 current_timestamp_ 自动就是当前时间戳，调试时发现一直是 \\(0\\)，我真笨。可以直接从 \\(0\\) 开始手动模拟时间戳，调用 RecordAccess 时，让当前时间戳加 \\(1\\) 即可。 ② 在 Evict 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 frame，结果淘汰的是第一次访问时间最早的 frame。 ③ 在 ListNode 中使 history_ 的长度不超过 k_，如果超过就调用 pop_front()，这样每次获取之前第 k_ 个访问记录只需要调用 front() 函数。 ④ 在 RecordAccess 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 BufferPoolManager 构造函数的实现如下： 12345678// we allocate a consecutive memory space for the buffer poolpages_ = new Page[pool_size_];replacer_ = std::make_unique&lt;LRUKReplacer&gt;(pool_size, replacer_k);// Initially, every page is in the free list.for (size_t i = 0; i &lt; pool_size_; ++i) { free_list_.emplace_back(static_cast&lt;int&gt;(i));} 上述代码说明 frame_id 是小于 pool_size 的，所以大于等于 pool_size 的 fram_id 都应该抛出异常。（或许小于零的也应该抛出异常） 补充① 测试时将 DISABLED_SampleTest 改为 SampleTest。 ② 忘记 C++ 的 = 是拷贝，传引用加上 &amp;： 1auto node = node_store_.at(frame_id); // 错误：拷贝 ③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。 Task #2 - Buffer Pool Manager实现① NewPage 和 FetchPage 有很多逻辑相同的部分，可以加个辅助函数来获取 frame_id。 ② 注意，在 FetchPage 时，如果页面在内存中并且 pin_count_ = 0，则需要将其设置为不可淘汰的。 ③ 在 UnpinPage 中，更新 is_dirty 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。 ④ 在 FlushPage 中，注释表示 REGARDLESS of the dirty flag，应该说的是函数调用者，我们在实现时可以根据 is_dirty 来判断是否实际刷盘。 补充① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。 ② 实现 FetchPage 时，有个情况我忘记调用 RecordAccess，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。 Task #3 - Read/Write Page Guards实现① 使用移动构造和移动赋值后，需要清除 that 的元数据。 ② 移动赋值的调用者，也就是 this，如果其 page_ != nullptr，那么需要先将其 Drop，再进行赋值操作。 ③ 实现读写页面守卫的移动构造函数，可以直接赋值 std::move(that.guard_)，相当于调用之前实现的 BasicPageGuard 的移动赋值运算符。 ④ 实现读写页面守卫的 Drop 时，需要注意在调用 guard_.Drop() 之后再解锁页面，所以在 Drop 之前需要保存一下指向页面的指针。 ⑤ 在实现 BufferPoolManager 中的 FetchPageRead 和 FetchPageWrite 时，为页面加读写锁。 ⑥ 和 PageGuard 有关的 FetchPage 函数会返回一个 PageGuard 对象，但是如果所有缓存页已经被 pin，那么该返回什么。一开始我是直接拿 nullptr 构造 PageGuard，但是发现不对，因为 PageGuard 对象并没有检查 page_ == nullptr 的函数，所以页面必须被 Fetch 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管） Leaderboard Task (Optional)准备性能分析 看到CMU 15-445 2023 P1 优化攻略中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 perf 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。 Brendan Gregg’s Homepage How to use flamegraphs for performance profiling profiling 与性能优化总结 speedscope LRU-K（对优化似乎没有帮助） 关于 LRU-K 的论文：The LRU-K Page Replacement Algorithm For Database Disk Buffering。 LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析） 解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂） LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。 LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\\(K\\geq 2\\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。 实现更新：以下内容存在一些错误，将会在下一节纠正。 ① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。 ② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 frame_id，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我） ③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 bpm-bench 测试），结果发现是我理解有问题。尝试使用读写锁在 BufferPoolManager 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 Unknown 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 FetchPage 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。 ④ 参考CMU 15-445 2023 P1 优化攻略，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 ResetMemory 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。 ⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 BufferPoolManager 之前析构 DiskManager，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。 ⑥ 本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 LRUKNode 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 Evict 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性） Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 61 ALEX 111924 104867 261 484 5123 32 ALEX 102401 96293 4886 5221 57123 2 ALEX 120664 123402 182590 248050 2663116 12 ALEX 143562 133514 3813 8132 85169 重做实现纠错 在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 page_table_），但是，如果在刷盘过程中，有另一个线程读取该页面，它在 page_table_ 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误，错误在 disk_manager_memory.h 中被检测： 1234if (page_id &gt;= static_cast&lt;int&gt;(data_.size()) || page_id &lt; 0) { LOG_WARN(&quot;page not exist&quot;); return;} 所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 page_id 和 frame_id，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 page_table_ 的锁，以确保在其他线程 FetchPage 时，表中已有该 page_id）。这时如果有其他线程 Fetch 该 page_id，不会直接从磁盘读，而是读这个表拿到之前的 frame_id，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 FetchPage 该 page_id 时，会发生已淘汰又被 pin 的情况，还会发生其他很复杂的情况） 如何优化 既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 README（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）： ① 缓存页面的访问规则 读写页面时必须 pin 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 pin） 在读页面时，可以释放页面的读锁，因为已经拿到页面的 pin。 在写页面时，必须拿到 pin 和写锁，并且需要检查 pincount_ == 1，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 unpin，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 pin，但是没有关系，因为当前线程拿到写锁，其他线程 pin 之后还需要拿锁才能读写页面。 我们的项目和上面的描述不一样，但是无伤大雅，基本上 PageGuard 和 FetchPage 等函数已经提供了这些功能。 ② 缓冲池管理器的内部锁定 访问 page_table_ 前需要拿到 page_table 的读写锁（文中称作 BufMappingLock）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 pin。在修改 page_table_，或者修改缓存页面头部字段（应该是指 Page 的除 data_ 以外的成员变量，在本项目中就是 page_id_、pin_count_ 和 is_dirty_），或者从磁盘读物理页面到缓存页面时，需要拿到 page_table_ 的写锁。 可以将 BufMappingLock 拆分为 NUM_BUFFER_PARTITIONS 个锁，每个锁负责映射的一部分。每个 page_id_ 属于哪个分区，由 page_id_ 的哈希值的低比特位决定（其实就是有多个 page_table_，每个 page_id 会根据哈希函数来确定存放在哪个 page_table_ 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。 为空闲列表和页面替换提供独占的自旋锁 buffer_strategy_lock ，当拿到该锁时，不应该去获取任何其他锁。 每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 BufMappingLock 锁）。 BM_IO_IN_PROGRESS 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 BufMappingLock 锁吧）。 缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。 ③ 后台线程刷盘 按照淘汰顺序扫描页面，选择 is_dirty_ == true &amp;&amp; pin_count_ == 0 的页面，然后 pin 该页面并刷盘，最后回收到空闲列表。 还有一些优化方式，没看懂就不翻译了。 总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。 尝试实现 重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。 ① FetchPage 在判断 page_id 是否在 page_table_ 时，需要使用 page_table_ 的独占锁。并且如果页面不在 page_table_ 中，则在函数返回 nullptr 或修改 page_table_ 之前不能释放该锁，以防止多次 FetchPage 同一个 page_id 时，多次从 free_list_ 中获取页面或者多次淘汰页面。 ② 因为在 FetchPage 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 pin 的，所以之后设置 pin_count_ 时，不能直接设置为 1，而是进行 ++ 操作。 第一次重构没有拆分 BufMappingLock，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 unique_lock 作为参数，并且 atomic_flag 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。不搞了，像个小丑，没意思。 Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 26 ALEX 92024 80293 5082 5287 57971 调试① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。 ② 优化时容易出问题的点就是 NewPage 和 FetchPage，以及 UnpinPage。像是 FlushPage、FlushAllPage 以及 DeletePage 都可以暂时不管（可以直接 return），这样比较方便调试。 补充① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。 ② 遇到 Reference to non-static member function must be called 问题，解决方案在此。 ③ MySQL Buffer Pool 的实现 15.5.1 Buffer Pool。 ④ Linus Torvalds 发表的一篇评论：do not use spinlocks in user space, unless you actually know what you’re doing。 ⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。 ⑥ 发现一个感觉不错的博客：MC++。 测试结果测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。 优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。 每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行： 123456789#!/bin/bashmake lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)./test/lru_k_replacer_test./test/buffer_pool_manager_test./test/page_guard_testmake formatmake check-lintmake check-clang-tidy-p1make submit-p1 项目小结① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。 ② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，bpm 优化也就是简单减少锁的粒度，lru 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。 ③ 我好菜啊！！！前三个任务花了两天，优化花了好几天。 更新：发现 Lecture #06 就是讲 BufferPool 优化的（课堂笔记），不知道能不能在这用上，等做完所有 Project 再来试试。","link":"/2023/09/12/Project%201%20-%20Buffer%20Pool/"},{"title":"Codeforces Round 897 (Div. 2)","text":"green_gold_dog, array and permutation让最小值减去最大值，就一定可以得到 \\(n\\) 个不同的差值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; a[i] - a[j]); int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { int t = aux[i]; ans[t] = n - i; } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} XOR Palindromes算是简单的分类讨论，比赛时写的稀烂。 123456789101112131415161718public static void solve() { int n = io.nextInt(), cnt = 0; char[] s = io.next().toCharArray(); for (int i = 0; i &lt; n / 2; i++) { if (s[i] != s[n - i - 1]) { cnt++; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt;= n; i++) { if (i &lt; cnt || i &gt; n - cnt || (i - cnt) % 2 == 1 &amp;&amp; n % 2 == 0) { sb.append('0'); } else { sb.append('1'); } } io.println(sb);} Salyg1n and the MEX Game比赛调试一小时，疯狂超时，结果是限制太强的原因。（浪费时间。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); } Arrays.sort(s); int x = n; for (int i = 0; i &lt; n ; i++) { if (s[i] != i) { x = i; break; } } while (x != -1) { io.println(x); io.flush(); x = io.nextInt(); }} Cyclic Operations做了一个多小时 AC，有点像之前做的内向基环树，该题每个点都有个出边，所以至少有一个环。首先要特判 \\(k=1\\) 的情况，该情况每个位置都必须自成一个环，即 \\(a_{i}=i\\)；其他情况所有环的长度都必须为 \\(k\\)，这样可以保证答案存在。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[b[i]]++; } Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } while (!q.isEmpty()) { int x = q.poll(); if (--in[b[x]] == 0) { q.offer(b[x]); } } int cnt = 0; boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { if (in[i] == 0 || vis[i]) continue; int len = 0; for ( ; !vis[i]; i = b[i]) { vis[i] = true; len++; } if (len != k) { io.println(&quot;NO&quot;); return; } cnt++; } if (k == 1 &amp;&amp; cnt != n) { io.println(&quot;NO&quot;); } else { io.println(&quot;YES&quot;); }} Salyg1n and Array (simple version)注意，\\(n\\) 和 \\(k\\) 都是偶数！手推的话可能可以做出来吧。 12345678910111213141516public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } for (; i &lt;= n; i++) { io.println(&quot;? &quot; + (i - k + 1)); io.flush(); ans ^= io.nextInt(); } io.println(&quot;! &quot; + ans); io.flush();} Salyg1n and Array (hard version)技巧性有点强，真想不到。就是如果多出一部分，可以通过两次异或算出来。 123456789101112131415161718public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } int t = n - i + 1; io.println(&quot;? &quot; + (n - k + 1 - t / 2)); io.flush(); ans ^= io.nextInt(); io.println(&quot;? &quot; + (n - k + 1)); io.flush(); ans ^= io.nextInt(); io.println(&quot;! &quot; + ans); io.flush();}","link":"/2023/09/17/Codeforces%20Round%20897%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 320","text":"Leyland Number模拟。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(); int x = 1; for (int i = 0; i &lt; b; i++) { x *= a; } int y = 1; for (int i = 0; i &lt; a; i++) { y *= b; } io.println(x + y);} Longest Palindrome模拟。 123456789101112131415public static void solve() { String s = io.next(); int n = s.length(); int ans = 1; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { String a = s.substring(i, j + 1); String b = new StringBuilder(a).reverse().toString(); if (a.equals(b)) { ans = Math.max(ans, j - i + 1); } } } io.println(ans);} Slot Strategy 2 (Easy)暴力枚举每个转盘的时间。 1234567891011121314151617181920212223public static void solve() { int n = 3, m = io.nextInt(); int ans = Integer.MAX_VALUE; String[] s = new String[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.next(); } for (int i = 0; i &lt; n * m; i++) { char a = s[0].charAt(i % m); for (int j = 0; j &lt; n * m; j++) { if (i == j) continue; char b = s[1].charAt(j % m); for (int k = 0; k &lt; n * m; k++) { if (i == k || j == k) continue; char c = s[2].charAt(k % m); if (a == b &amp;&amp; b == c) { ans = Math.min(ans, Math.max(i, Math.max(j, k))); } } } } io.println(ans == Integer.MAX_VALUE ? -1 : ans);} Relative PositionDFS 模拟，需要注意给的不是一棵树，所以在 DFS 时要使用访问数组，而不能用父结点。 1234567891011121314151617181920212223242526272829303132333435public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1, x = io.nextInt(), y = io.nextInt(); g[a].add(new int[]{b, x, y}); g[b].add(new int[]{a, -x, -y}); } long[] X = new long[n]; long[] Y = new long[n]; Arrays.fill(X, Long.MAX_VALUE); Arrays.fill(Y, Long.MAX_VALUE); boolean[] vis = new boolean[n]; dfs(0, vis, g, 0, 0, X, Y); for (int i = 0; i &lt; n; i++) { if (X[i] != Long.MAX_VALUE &amp;&amp; Y[i] != Long.MAX_VALUE) { io.println(X[i] + &quot; &quot; + Y[i]); } else { io.println(&quot;undecidable&quot;); } }}private static void dfs(int i, boolean[] vis, List&lt;int[]&gt;[] g, long x, long y, long[] X, long[] Y) { X[i] = x; Y[i] = y; vis[i] = true; for (int[] t : g[i]) { int j = t[0]; if (vis[j]) continue; long nx = t[1] + x, ny = t[2] + y; dfs(j, vis, g, nx, ny, X, Y); }} Somen Nagashi还是模拟，可以一边输入一边处理，减少代码量。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); long[] ans = new long[n], re = new long[n]; PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;((a, b) -&gt; Long.compare(re[a], re[b])); for (int i = 0; i &lt; n; i++) { q.offer(i); } while (m-- != 0) { int t = io.nextInt(), w = io.nextInt(), s = io.nextInt(); while (!p.isEmpty() &amp;&amp; re[p.peek()] &lt;= t) q.offer(p.poll()); if (q.isEmpty()) continue; int x = q.peek(); ans[x] += w; re[x] = t + s; p.offer(q.poll()); } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }}","link":"/2023/09/17/AtCoder%20Beginner%20Contest%20320/"},{"title":"第 113 场力扣夜喵双周赛","text":"使数组成为递增数组的最少右移次数直接从最小值开始判断数组是否递增，或者可以找到第一个递减的位置，然后再判断数组是否递增（因为如果数组满足条件，则其最多只有一个递减段）。 12345678910111213141516class Solution { public int minimumRightShifts(List&lt;Integer&gt; nums) { int n = nums.size(), idx = -1, min = 101; for (int i = 0; i &lt; n; i++) { if (nums.get(i) &lt; min) { min = nums.get(i); idx = i; } } for (int i = 0; i &lt; n - 1; i++) { int x = (idx + i) % n, y = (x + 1) % n; if (nums.get(x) &gt; nums.get(y)) return -1; } return (n - idx) % n; }} 删除数对后的最小数组长度贪心，比赛时我是用双指针做的，前半部分和后半部分进行匹配（当时边界想了很久，真笨！）。其他做法，参考题解：【小羊肖恩】数学 + 贪心：解决较长数组脑筋急转弯问题的关键。（因为 HashMap 很慢，所以用双指针会更快。） 方法一：贪心 1234567891011class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), i = 0; for (int j = (n + 1) / 2; j &lt; n; j++) { if (nums.get(i) &lt; nums.get(j)) { i++; } } return n - i * 2; }} 方法二：贪心 + 数学 12345678910class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), max = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { max = Math.max(max, map.merge(x, 1, Integer::sum)); } return 2 * max &lt;= n ? n % 2 : n - (n - max) * 2; }} 统计距离为 k 的点对枚举 \\(x_{1}\\oplus x_{2}\\) 的值为 \\(p\\)，可以得到 \\(y_{1}\\oplus y_{2}\\) 的值为 \\(k-p\\)。可以使用 HashMap 对前缀中的值计数来求解，需要注意循环的顺序，如果调换顺序会使代码变复杂，会花费更多的时间计算答案。 1234567891011121314class Solution { public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates, int k) { int ans = 0; Map&lt;List&lt;Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;(); for (var c : coordinates) { int x = c.get(0), y = c.get(1); for (int i = 0; i &lt;= k; i++) { ans += map.getOrDefault(List.of(x ^ i, y ^ (k - i)), 0); } map.merge(c, 1, Integer::sum); } return ans; }} 可以到达每一个节点的最少边反转次数换根 DP，关键是要想到建立反向边，并为边添加相应的边权。 12345678910111213141516171819202122232425262728293031323334class Solution { public int[] minEdgeReversals(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(new int[]{v, 0}); g[v].add(new int[]{u, 1}); } int[] ans = new int[n]; ans[0] = dfs(0, -1, g); dfs2(0, -1, g, ans); return ans; } private int dfs(int x, int fa, List&lt;int[]&gt;[] g) { int res = 0; for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; res += dfs(y, x, g) + w; } return res; } private void dfs2(int x, int fa, List&lt;int[]&gt;[] g, int[] ans) { for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; ans[y] = ans[x] + (w == 0 ? 1 : -1); dfs2(y, x, g, ans); } }}","link":"/2023/09/17/%E7%AC%AC%20113%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 363 场力扣周赛","text":"计算 K 置位下标对应元素的和模拟。 1234567891011class Solution { public int sumIndicesWithKSetBits(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i++) { if (Integer.bitCount(i) == k) { ans += nums.get(i); } } return ans; }} 让所有学生保持开心的分组方法数比赛时又写复杂了，当时是想到所有相同的数都必须同时选，所以加了一层循环来跳过相同的数。但是相同的数天然的不满足判断条件，所以不需要这样写。这题唯一需要注意的就是特判全都不选的情况，以及全都选的情况必定满足，可以直接加到答案里（以减少判断代码）。 12345678910111213class Solution { public int countWays(List&lt;Integer&gt; nums) { Collections.sort(nums); int n = nums.size(), ans = 1; if (nums.get(0) &gt; 0) ans++; for (int i = 0; i &lt; n - 1; i++) { if (i + 1 &gt; nums.get(i) &amp;&amp; i + 1 &lt; nums.get(i + 1)) { ans++; } } return ans; }} 最大合金数比赛时又又写复杂了，当时是把所有的库存都清除了再二分的，其实可以直接二分！！ 12345678910111213141516171819class Solution { public int maxNumberOfAlloys(int n, int k, int budget, List&lt;List&lt;Integer&gt;&gt; composition, List&lt;Integer&gt; stock, List&lt;Integer&gt; cost) { int ans = 0; for (var cur : composition) { int lo = 0, hi = (int) 2e8; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; long cnt = 0L; for (int i = 0; i &lt; n; i++) { cnt += Math.max((long) cur.get(i) * mid - stock.get(i), 0L) * cost.get(i); } if (cnt &lt;= budget) lo = mid + 1; else hi = mid - 1; } ans = Math.max(ans, hi); } return ans; }} 完全子集的最大元素和注意题目的描述是每对元素的乘积都是完全平方数。朴素的想法就是对下标进行质因数分解，将所有出现次数为奇数质因数相乘，其结果作为桶的下标，把所有同类的数放在同一个桶里面，然后对每个桶求和取最大值，这样的时间复杂度是 \\(O(n\\sqrt{n})\\)。但是有 \\(O(n)\\) 的解法，如下所示。 1234567891011121314class Solution { public long maximumSum(List&lt;Integer&gt; nums) { long ans = 0L; int n = nums.size(); for (int i = 1; i &lt;= n; i++) { long sum = 0L; for (int j = 1; i * j * j &lt;= n; j++) { sum += nums.get(i * j * j - 1); } ans = Math.max(ans, sum); } return ans; }}","link":"/2023/09/17/%E7%AC%AC%20363%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 321","text":"321-like Checker模拟。 1234567891011public static void solve() { int n = io.nextInt(); String s = String.valueOf(n); for (int i = 0; i &lt; s.length() - 1; i++) { if (s.charAt(i) &lt;= s.charAt(i + 1)) { io.println(&quot;No&quot;); return; } } io.println(&quot;Yes&quot;);} Cutoff比赛时是暴力做的，赛后这个 \\(O(1)\\) 还想了半天。不多解释，代码还是比较好理解的。 12345678910111213141516public static void solve() { int n = io.nextInt(), x = io.nextInt(); int min = 101, max = -1, sum = 0; for (int i = 0; i &lt; n - 1; i++) { int t = io.nextInt(); sum += t; min = Math.min(min, t); max = Math.max(max, t); } int t = x - (sum - min - max); if (t &gt; max) { io.println(-1); } else { io.println(t &lt;= min ? 0 : t); }} 321-like Searcher原来是使用十个二进制位来表示对应数字是否存在，通过暴力枚举算出所有可能的数，最后排序获取对应的位置即可，真的没想到。 123456789101112131415public static void solve() { int k = io.nextInt(); List&lt;Long&gt; ans = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; 1 &lt;&lt; 10; i++) { long x = 0L; for (int j = 9; j &gt;= 0; j--) { if ((i &gt;&gt; j &amp; 1) == 1) { x = x * 10 + j; } } ans.add(x); } Collections.sort(ans); io.println(ans.get(k - 1));} Set Menu二分，状态真差，把加法和乘法混淆了。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); long[] sum = new long[m + 1]; for (int i = 0; i &lt; m; i++) { sum[i + 1] = sum[i] + b[i]; } long ans = 0L; for (int i = 0; i &lt; n; i++) { int x = p - a[i]; int lo = 0, hi = m - 1; while (lo &lt;= hi) { int mid= lo + (hi - lo) / 2; if (b[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } ans += ((long) lo * a[i] + sum[lo]) + (long) (m - lo) * p; } io.println(ans);}","link":"/2023/09/27/AtCoder%20Beginner%20Contest%20321/"},{"title":"第 364 场力扣周赛","text":"最大二进制奇数模拟。 12345678910111213141516class Solution {public: string maximumOddBinaryNumber(string s) { int n = s.size(), cnt = 0; for (char c : s) { if (c == '1') cnt++; } string ans; for (int i = 0; i &lt; n - 1; i++) { if (i &lt; cnt - 1) ans.push_back('1'); else ans.push_back('0'); } ans.push_back('1'); return ans; }}; 美丽塔 I同下。 美丽塔 II枚举以每个位置作为山顶，可以得到的最大高度和。通过使用单调栈 + 前后缀分解，可以 \\(O(n)\\) 的时间算出答案。 1234567891011121314151617181920212223242526class Solution {public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { int n = maxHeights.size(); vector&lt;long long&gt; left(n + 1), right(n + 1); stack&lt;int&gt; stk; stk.push(-1); for (int i = 0; i &lt; n; i++) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); left[i + 1] = left[stk.top() + 1] + 1LL * maxHeights[i] * (i - stk.top()); stk.push(i); } stk = stack&lt;int&gt;(); stk.push(n); for (int i = n - 1; i &gt;= 0; i--) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); right[i] = right[stk.top()] + 1LL * maxHeights[i] * (stk.top() - i); stk.push(i); } long long ans = 0; for (int i = 0; i &lt; n; i++) { ans = max(ans, left[i] + right[i]); } return ans; }}; 统计树中的合法路径数目树型 DP，对于每个节点，计算以该节点为根的子树中，经过该节点的有效路径数，我们只需要维护子树中不包含质数的路径数和只包含一个质数的路径数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { private static final int N = (int) 1e5; private static final boolean[] np = new boolean[N + 1]; static { np[0] = np[1] = true; for (int i = 2; i &lt;= N / i; i++) { if (!np[i]) { for (int j = i; j &lt;= N / i; j++) { np[j * i] = true; } } } } long ans = 0L; public long countPaths(int n, int[][] edges) { List&lt;Integer&gt;[] g = new List[n + 1]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { g[e[0]].add(e[1]); g[e[1]].add(e[0]); } dfs(1, 0, g); return ans; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g) { int zero = 0, one = 0; if (np[x]) zero = 1; else one = 1; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g); ans += (long) zero * t[1] + (long) one * t[0]; if (np[x]) { zero += t[0]; one += t[1]; } else { one += t[0]; } } return new int[]{zero, one}; }}","link":"/2023/09/27/%E7%AC%AC%20364%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 899 (Div. 2)","text":"Increasing Sequence模拟，注意最后答案要减一。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int b = 1; for (int i = 0; i &lt; n; i++) { if (b == a[i]) b += 2; else b += 1; } io.println(b - 1);} Sets and Union比赛时写复杂了，就是枚举不选哪个数，使用位运算会很简单。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); long xor = 0L; long[] s = new long[n]; for (int i = 0; i &lt; n; i++) { int k = io.nextInt(); for (int j = 0; j &lt; k; j++) { s[i] |= 1L &lt;&lt; io.nextInt(); } xor |= s[i]; } int ans = 0; for (int i = 1; i &lt;= 50; i++) { if ((xor &gt;&gt; i &amp; 1) != 1) continue; long res = 0L; for (int j = 0; j &lt; n; j++) { if ((s[j] &gt;&gt; i &amp; 1) != 1) { res |= s[j]; } } ans = Math.max(ans, Long.bitCount(res)); } io.println(ans);} Card Game思维题，没想出来。不管前两张牌如何操作，都必定可以拿到之后的所有正数牌，然后对前两张牌分类讨论即可。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } long ans = 0L; for (int i = 2; i &lt; n; i++) { ans += Math.max(0, a[i]); } ans += Math.max(0, a[0] + Math.max(0, n &gt; 1 ? a[1] : 0)); io.println(ans);} Tree XOR很典的换根 DP，因为第三题花费太长时间，导致差几分钟 AC。只要相邻的两个节点值不相同，它们就需要做一次操作。先以一个节点为根做 DFS，并记录所有节点的子树大小，和以该节点为根的成本。然后再做一次 DFS，换根计算代价的差值。（比赛时犯蠢，在换根的过程中打印答案，但是遍历不能保证从 \\(1\\) 到 \\(n\\) 的顺序，所以是错的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static long[] ans;private static int[] value, sz;private static List&lt;Integer&gt;[] g;public static void solve() { int n = io.nextInt(); value = new int[n]; for (int i = 0; i &lt; n; i++) { value[i] = io.nextInt(); } g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1; g[u].add(v); g[v].add(u); } sz = new int[n]; ans = new long[n]; dfs1(0, -1); dfs2(0, -1); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs1(int x, int fa) { sz[x] = 1; for (int y : g[x]) { if (y == fa) continue; dfs1(y, x); sz[x] += sz[y]; ans[0] += (long) sz[y] * (value[x] ^ value[y]); }}private static void dfs2(int x, int fa) { for (int y : g[x]) { if (y == fa) continue; ans[y] = ans[x] + (long) (sz[0] - sz[y] - sz[y]) * (value[x] ^ value[y]); dfs2(y, x); }}","link":"/2023/09/27/Codeforces%20Round%20899%20(Div.%202)/"},{"title":"Educational Codeforces Round 155 (Rated for Div. 2)","text":"Rigged!模拟。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] s = new int[n]; int[] e = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); e[i] = io.nextInt(); } for (int i = 1; i &lt; n; i++) { if (s[i] &gt;= s[0] &amp;&amp; e[i] &gt;= e[0]) { io.println(-1); return; } } io.println(s[0]);} Chips on the Board有两种情况，每行都放一个或者每列都放一个，然后模拟即可。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] b = new int[n]; long suma = 0L; int mina = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); suma += a[i]; mina = Math.min(mina, a[i]); } long sumb = 0L; int minb = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); sumb += b[i]; minb = Math.min(minb, b[i]); } io.println(Math.min(suma + (long) minb * n, sumb + (long) mina * n));} Make it Alternating所有连续重复数的个数就是最少操作次数，然后就是简单的应用组合数学。 1234567891011121314151617181920private static final int MOD = 998244353;public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; long cnt = n, sum = 1L; for (int i = 0; i &lt; n; ) { int j = i + 1; while (j &lt; n &amp;&amp; s[j] == s[j - 1]) { j++; } sum = sum * (j - i) % MOD; cnt--; i = j; } for (long i = 1; i &lt;= cnt; i++) { sum = sum * i % MOD; } io.println(cnt + &quot; &quot; + sum);} Sum of XOR Functions固定右端点，然后分别考虑每一位，计算答案，公式如下： $$ \\sum_{r=1}^{n}\\sum_{l=1}^{r}f(l,r)\\cdot (r-l+1) =\\sum_{r=1}^{n}\\sum_{i=0}^{31}\\sum_{l=1}^{r}(f_{i}(1,r)\\oplus f_{i}(1,l-1))\\cdot (r-(l-1)) $$ 可以发现对于每一位，\\(f_{i}(1,r)\\oplus f_{i}(1,l-1)\\) 的值不是 \\(1\\) 就是 \\(0\\)，只有当值为 \\(1\\) 时才会对答案有贡献。如果 \\(f_{i}(1,r)=1\\)，那么右端点 \\(r\\) 的第 \\(i\\) 位对答案的贡献为 \\((cnt[i][0]\\cdot r-sum[i][0])\\cdot 2^{i}\\)（其中 \\(cnt[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的个数，\\(sum[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的区间长度之和），另一种情况同理。 12345678910111213141516171819202122private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] s = new int[n + 1]; for (int i = 0; i &lt; n; i++) { s[i + 1] = s[i] ^ io.nextInt(); } long ans = 0L; long[][] cnt = new long[32][2]; long[][] sum = new long[32][2]; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt; 32; j++) { int x = s[i] &gt;&gt; j &amp; 1; ans = (ans + (cnt[j][x ^ 1] * i - sum[j][x ^ 1]) % MOD * (1 &lt;&lt; j)) % MOD; cnt[j][x]++; sum[j][x] += i; } } io.println(ans);}","link":"/2023/09/27/Educational%20Codeforces%20Round%20155%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 900 (Div. 3)","text":"How Much Does Daytona Cost?所有长度为 \\(1\\) 的子数组，包含的元素必定是众数，所以只需判断 \\(k\\) 是否存在于数组中。 12345678910public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean ok = false; for (int i = 0; i &lt; n; i++) { if (k == io.nextInt()) { ok = true; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Aleksa and Stack两个奇数相加得到偶数，两个奇数相乘得到奇数，奇数不会被偶数整除，所以构造一个全是奇数的序列即可。 1234567public static void solve() { int n = io.nextInt(); for (int i = 0; i &lt; n; i++) { io.print(i * 2 + 1 + &quot; &quot;); } io.println();} Vasilije in Cacak只要 \\(x\\) 在最小值和最大值之间，就总是可以被表示出来。 12345678public static void solve() { int n = io.nextInt(), k = io.nextInt(); long x = io.nextLong(); long a = (long) (1 + k) * k / 2; long b = (long) (n - k + 1 + n) * k / 2; if (x &gt;= a &amp;&amp; x &lt;= b) io.println(&quot;YES&quot;); else io.println(&quot;NO&quot;);} Reverse Madness数组被 \\(l\\) 和 \\(r\\) 分段，每一段都是相互独立的，可以单独考虑段内的反转情况。可以发现段内反转总是中心对称的，每个元素是否反转，取决于该元素位置被反转次数的奇偶性，可以用两边向中间求累加和的方式统计，也可以用差分数组。（比赛时我没有统计奇偶性，而是抵消相邻的反转的相同部分） 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[] l = new int[k]; for (int i = 0; i &lt; k; i++) { l[i] = io.nextInt() - 1; } int[] r = new int[k]; for (int i = 0; i &lt; k; i++) { r[i] = io.nextInt() - 1; } int q = io.nextInt(); int[] cnt = new int[n]; for (int i = 0; i &lt; q; i++) { cnt[io.nextInt() - 1]++; } for (int i = 0; i &lt; k; i++) { int sum = 0; for (int a = l[i]; a &lt;= (l[i] + r[i]) / 2; a++) { int b = r[i] + l[i] - a; sum += cnt[a] + cnt[b]; if (sum % 2 == 1) { char c = s[a]; s[a] = s[b]; s[b] = c; } } } io.println(new String(s));} Iva &amp; Pav比较简单的做法是，计算每个比特位的前缀和，然后对每个查询二分答案的位置，将二分位置的值和 \\(k\\) 比较来判断二分的走向。比赛时我是用下面的方法做的，就是没想到二分，其实也可以不用二分，但是没看明白为什么，代码在此。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } // next[i][j] 表示 a[i] 的第 j 位等于 0 的下一个位置 int[][] next = new int[n + 1][32]; Arrays.fill(next[n], n); for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; 32; j++) { next[i][j] = next[i + 1][j]; if ((a[i] &gt;&gt; j &amp; 1) == 0) { next[i][j] = i; } } } int q = io.nextInt(); while (q-- != 0) { int l = io.nextInt() - 1, k = io.nextInt(); if (a[l] &lt; k) { io.print(&quot;-1 &quot;); continue; } int lo = l, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; int cur = 0; for (int i = 0; i &lt; 32; i++) { if (next[mid][i] &gt; mid &amp;&amp; next[mid][i] == next[l][i]) { cur |= 1 &lt;&lt; i; } } if (cur &gt;= k) lo = mid + 1; else hi = mid - 1; } io.print(hi + 1 + &quot; &quot;); } io.println();}","link":"/2023/09/27/Codeforces%20Round%20900%20(Div.%203)/"},{"title":"CodeTON Round 6 (Div. 1 + Div. 2, Rated, Prizes!)","text":"MEXanized Array分类讨论，一开始以为不能有重复，花了很多时间。（菜） 12345public static void solve() { int n = io.nextInt(), k = io.nextInt(), x = io.nextInt(); if (n &lt; k || x &lt; k - 1) io.println(-1); else io.println((k - 1) * k / 2 + (n - k) * (x == k ? k - 1 : x));} Friendly Arrays又看错题了，其实是道很简单的题。 123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); int a = 0; for (int i = 0; i &lt; n; i++) { a ^= io.nextInt(); } int b = 0; for (int i = 0; i &lt; m; i++) { b |= io.nextInt(); } int min = a, max = a; if (n % 2 == 0) { min = a ^ (a &amp; b); } else { max = a | b; } io.println(min + &quot; &quot; + max);} Colorful Table一个数可以向外扩展到大于等于它的的数的位置，我们可以按 \\(k\\) 的大小记录左右端点，然后按照从大到小遍历，来扩展边界，最后计算答案。注意，排除不在数组中的数。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean[] mark = new boolean[k]; int[] l = new int[k], r = new int[k]; Arrays.fill(l, n); Arrays.fill(r, -1); for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; mark[a] = true; l[a] = Math.min(l[a], i); r[a] = i; } for (int i = k - 2; i &gt;= 0; i--) { l[i] = Math.min(l[i], l[i + 1]); r[i] = Math.max(r[i], r[i + 1]); } for (int i = 0; i &lt; k; i++) { if (!mark[i]) io.print(0 + &quot; &quot;); else io.print(2 * (r[i] - l[i] + 1) + &quot; &quot;); } io.println();} Prefix Purchase又又犯蠢了，题目都没读明白。如果右边有更小的数，那么肯定选更小的数是更优的，可以从右向左遍历，将右边的最小值传递到当前位置。然后就是依次处理每个位置，细节见代码。 1234567891011121314151617181920void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; c(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c[i]; } int k; cin &gt;&gt; k; for (int i = n - 2; i &gt;= 0; i--) { c[i] = min(c[i], c[i + 1]); } int m = k; for (int i = 0; i &lt; n; i++) { int x = i == 0 ? c[i] : c[i] - c[i - 1]; if (x != 0) m = min(m, k / x); k -= x * m; cout &lt;&lt; m &lt;&lt; &quot; \\n&quot;[i == n - 1]; }}","link":"/2023/09/27/CodeTON%20Round%206%20(Div.%201%20+%20Div.%202,%20Rated,%20Prizes!)/"},{"title":"Project #2 - B+Tree","text":"项目准备项目地址：Project #2 - B+Tree 准备工作：阅读 Chapter 14.5 24.5 14.1-14.4 18.10.2，学习 Lecture #07 #08 #09，以及阅读课堂笔记。 Task #1 - B+Tree Pages实现① 第一个比较迷惑的点就是 max_size_ 的含义，对官方提供的B+Tree进行插入操作，发现叶子节点的 size_ 不会到达 max_size_。难道叶子节点实际只能包含 max_size_ - 1 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 max_size_ 时，进行分裂，内部节点在插入前大小达到 max_size_ 时进行分裂。所以对于内部节点，max_size_ 表示它能包含的指针数量；对于叶子节点，max_size_ 表示它能包含的键值对数量。 ② GetMinSize 的实现，同样参考官方示例，对于非叶子节点，返回 (max_size_ + 1) / 2；对于叶子节点，返回 max_size_ / 2。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。 补充① 如何理解 MappingType array_[0]，注释表示它是 Flexible array member for page data，参见维基百科Flexible array member。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。 ② 在内部节点和叶子节点中，array_ 的唯一区别就是在搜索内部节点时不能使用 array[0]_.first，因为它并不能准确表示 array_[0].second 中 key 的范围（向 array_[0].second 中插入一个更小的 key，它就失效了）。 Task #2a - B+Tree Insertion and Search for Single Values实现① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \\(O(n)\\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。 ② 可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Search 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 -index - 1（方便之后插入，类似 Java 中的 BinarySearch）。具体的实现逻辑： 内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 index - 1。 叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 -index - 1，否则返回 index。 ③ 特别注意 PageGuard 的使用，只有当操作完页面之后，才对其进行 Drop 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 Drop，这样可以尽早释放页面的锁以及 Unpin 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 Drop 上个页面（使用 Context）。注意拿锁和 Drop 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。 ④ 获取页面需要进行类型转换，如果只读不写就使用 page_guard.h 中提供的 As 函数，只有需要写页面时才使用 AsMut 函数，因为该函数会将页面置为脏页。先将其转换为 BPlusTreePage，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 BPlusTree 类中已经为我们提供了别名： 12using InternalPage = BPlusTreeInternalPage&lt;KeyType, page_id_t, KeyComparator&gt;;using LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;; 一开始我没有注意，在对内部节点转换时，误将其 page_id_t 转为 ValueType，导致完全误解了整个项目的结构。 ⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Split 函数，来实现分裂。 叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（BufferPoolManager，Context），我将分裂函数的参数设计为 BPlusTreeInternalPage &amp;new_page，它会返回将插入到上层的 key，即新节点的第一个 key。 内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 array_[GetMinSize() - 1] 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 array_[0].first，因为分裂的时候复制了）。 ⑥ 同理，在内部页面和叶子页面类中可以添加 Insert 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 page_id 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为 const std::optional&lt;KeyType&gt; &amp;opt 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 Search 的实现，当 index ≥ 0 时返回 false，否则继续插入。 调试调试时可以先使用可视化网站查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（解决方案）： 123#!/bin/bashmake b_plus_tree_printer -j$(nproc){ echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; } | ./bin/b_plus_tree_printer 在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN - Drawing an empty tree 错误，原因是我们没有实现 b_plus_tree.cpp 中的 IsEmpty 函数。 补充① 如何使用 upper_bound 和 lower_bound（Java 选手表示踩了很多坑），可以看看 cppreference 的示例代码，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。 ② 测试时忽略 iterators 的测试。 ③ GetValue 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 BufferPoolManager 的实现）。 Task #2b - B+Tree Deletions实现① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 page_id。 ② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。 ③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 next_page_id_。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 DeletePage 操作，在 DeletePage 之前需要 Drop/Unpin 页面。有个疑问，DeletePage 之前 Drop 之后，如果有线程 Fetch，那么删除页面的操作就会失败。） 调试实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 pop_back() 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。 Task #3 - An Iterator for Leaf Scans基本上没有难度，遇到唯一的错误就是把 GetSize 打成了 GetMaxSize（因为用的自动补全）。 Task #4 - Concurrent Index① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 MixTest2，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 2 3，将 total_keys 修改为 1000，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。 ② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN - page not exist，发现是 BufferPoolManager 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 FetchPageBasic/Read/Write 返回 nullptr 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（但是重构了个寂寞，效率没变，难受啊） ③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 Fetch 和 Drop 的顺序就 OK。 (Optional) Leaderboard Task① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。 ② 优化暂时搁置。 Rank Submission Name read_qps write_qps total_qps 36 ALEX 200376 603 200980 测试结果Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。 Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。 12345678910#!/bin/bashmake b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)./test/b_plus_tree_insert_test./test/b_plus_tree_sequential_scale_test./test/b_plus_tree_delete_test./test/b_plus_tree_concurrent_testmake formatmake check-lintmake check-clang-tidy-p2make submit-p2 项目小结开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 MaxSize 和 MinSize，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 key。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧）","link":"/2023/09/29/Project%202%20-%20B+Tree/"},{"title":"AtCoder Beginner Contest 322","text":"First ABC 2123456public static void solve() { int n = io.nextInt(); String s = io.next(); int ans = s.indexOf(&quot;ABC&quot;); io.println(ans &lt; 0 ? -1 : ans + 1);} Prefix and Suffix1234567891011121314public static void solve() { int n = io.nextInt(), m = io.nextInt(); String s = io.next(), t = io.next(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (s.charAt(i) != t.charAt(i)) { ans |= 2; } if (s.charAt(i) != t.charAt(m - n + i)) { ans |= 1; } } io.println(ans);} Festival1234567891011121314151617public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] ans = new int[n]; Arrays.fill(ans, -1); for (int i = 0; i &lt; m; i++) { int x = io.nextInt() - 1; ans[x] = 0; } for (int i = n - 2; i &gt;= 0; i--) { if (ans[i] == -1) { ans[i] = ans[i + 1] + 1; } } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }} Polyomino模拟题，使用位运算似乎更简单，题解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public static void solve() { char[][][] G = new char[3][4][4]; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 4; j++) { G[i][j] = io.next().toCharArray(); } } io.println(dfs(0, G, new char[4][4]) ? &quot;Yes&quot; : &quot;No&quot;);}private static boolean dfs(int i, char[][][] G, char[][] C) { if (C == null) return false; if (i == 3) return check(C); for (int j = 0; j &lt; 4; j++) { for (int dx = -3; dx &lt;= 3; dx++) { for (int dy = -3; dy &lt;= 3; dy++) { char[][] T = move(dx, dy, G[i]); if (T == null) continue; if (dfs(i + 1, G, add(T, C))) return true; } } G[i] = rotate(G[i]); } return false;}private static char[][] rotate(char[][] A) { char[][] B = new char[4][4]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { B[i][j] = A[3 - j][i]; } } return B;}private static char[][] move(int dx, int dy, char[][] G) { char[][] res = new char[4][4]; for (int i = 0; i &lt; 4; i++) { Arrays.fill(res[i], '.'); } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { int nx = i + dx, ny = j + dy; if(G[i][j] == '#') { if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4) { return null; } res[nx][ny] = G[i][j]; } } } return res;}private static char[][] add(char[][] T, char[][] C) { char[][] res = new char[4][4]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (C[i][j] == '#' &amp;&amp; T[i][j] == '#') return null; if (C[i][j] == '#' || T[i][j] == '#') res[i][j] = '#'; else res[i][j] = '.'; } } return res;}private static boolean check(char[][] C) { for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (C[i][j] != '#') return false; } } return true;} Product Development动态规划，\\(dp[i][j]\\) 表示从前 \\(i\\) 个计划中选择开发计划，使得参数到达 \\(j\\)，需要的最小成本，其中 \\(j\\) 表示 \\(a_{1},a_{2},\\dots,a_{k}\\) 的某个取值，通过将序列看作 \\(p+1\\) 进制数，可以将一个序列转换为某个数值（在这里就是 \\(j\\)）。 12345678910111213141516171819202122232425262728293031323334public static void solve() { int n = io.nextInt(), k = io.nextInt(), p = io.nextInt(); int[] pw = new int[k + 1]; pw[0] = 1; for (int i = 1; i &lt;= k; i++) { pw[i] = pw[i - 1] * (p + 1); } long[] dp = new long[pw[k]]; Arrays.fill(dp, -1L); dp[0] = 0; for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); int[] a = new int[k]; for (int j = 0; j &lt; k; j++) { a[j] = io.nextInt(); } for (int s = pw[k] - 1; s &gt;= 0; s--) { int t = 0; for (int j = 0; j &lt; k; j++) { int cur = s / pw[j] % (p + 1); int nxt = Math.min(p, cur + a[j]); t += nxt * pw[j]; } if (dp[s] != -1 &amp;&amp; (dp[t] == -1 || dp[t] &gt; dp[s] + c)) { dp[t] = dp[s] + c; } } } io.println(dp[pw[k] - 1]);}","link":"/2023/10/02/AtCoder%20Beginner%20Contest%20322/"},{"title":"Codeforces Round 901 (Div. 2)","text":"Jellyfish and Undertale每个工具对答案的贡献为 \\(\\min(a-1,x_{i})\\)，并且答案可能会爆 \\(long\\)，状态好差，WA 两次。 12345678public static void solve() { int a = io.nextInt(), b = io.nextInt(), n = io.nextInt(); long ans = b; for (int i = 0; i &lt; n; i++) { ans += Math.min(a - 1, io.nextInt()); } io.println(ans);} Jellyfish and Game数学题。当 \\(k\\bmod 2=1\\) 时，先手会得到 \\(\\min(0,maxb-mina)\\)；反之，后手此时必然有最小价值的苹果 \\(\\min(mina,minb)\\)，而先手此时会有最大价值的苹果 \\(\\max(maxa,maxb)\\)，做一次交换即可。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); long suma = 0L; int mina = Integer.MAX_VALUE, maxa = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int x = io.nextInt(); suma += x; mina = Math.min(mina, x); maxa = Math.max(maxa, x); } int minb = Integer.MAX_VALUE, maxb = Integer.MIN_VALUE; for (int i = 0; i &lt; m; i++) { int x = io.nextInt(); minb = Math.min(minb, x); maxb = Math.max(maxb, x); } if (k % 2 == 1) { io.println(suma + Math.max(0, maxb - mina)); } else { io.println(suma + Math.max(0, maxb - mina) - Math.max(maxa, maxb) + Math.min(mina, minb)); }} Jellyfish and Green Apple完了，官方解法看不懂，下面是我的解法，就是一直乘二求余，贪心的拆分。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), m = io.nextInt(); int x = n % m, y = m / gcd(n, m); if ((y &amp; (y - 1)) != 0) { io.println(-1); return; } long ans = 0L; while (x != 0) { ans += x; x *= 2; x %= m; } io.println(ans);}private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} 下面是官解，大概懂了。\\(\\frac{a}{b}\\) 表示最终每个人得到的苹果价值的小数部分（可以表示为 \\(\\sum_{i\\in S}\\frac{1}{2^{i}}\\)），因为 \\(b\\) 必须是二的幂，所以 \\(a\\) 中 \\(1\\) 的个数就表示这个人所需的最小苹果片数（就是集合 \\(S\\) 中元素的个数），乘以 \\(m\\) 就表示最后总共的苹果片数，然后减去最开始的 \\(n\\) 片就是需要进行操作的次数（因为每次操作会增加 \\(1\\) 片）。（这个题解很详细，提供了另一种视角） 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); n %= m; int x = gcd(n, m), a = n / x, b = m / x; if ((b &amp; (b - 1)) != 0) { io.println(-1); } else { io.println((long) Integer.bitCount(a) * m - n); }}private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} Jellyfish and Mex其实是很简单的动态规划，但就是动不起来啊。定义 \\(dp[i]\\) 为将 \\(MEX\\) 变为 \\(i\\) 需要的最小代价，然后从大到小转移即可。 12345678910111213141516171819202122private static final int N = 5001;public static void solve() { int n = io.nextInt(); int[] cnt = new int[N]; for (int i = 0; i &lt; n; i++) { int x = io.nextInt(); if (x &lt; n) cnt[x]++; } int mex = 0; while (cnt[mex] &gt; 0) mex++; long[] dp = new long[mex + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[mex] = 0; for (int i = mex - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt;= mex; j++) { dp[i] = Math.min(dp[i], dp[j] + (long) (cnt[i] - 1) * j + i); } } io.println(dp[0]);}","link":"/2023/10/02/Codeforces%20Round%20901%20(Div.%202)/"},{"title":"第 365 场力扣周赛","text":"有序三元组中的最大值 I同下。 有序三元组中的最大值 II方法一：枚举 j 比赛时第一想法是枚举 \\(j\\)，然后取左边和右边的最大值计算答案。 123456789101112131415161718class Solution { public long maximumTripletValue(int[] nums) { int n = nums.length; int[] pre = new int[n + 1]; int[] suf = new int[n + 1]; for (int i = 0; i &lt; n; i++) { pre[i + 1] = Math.max(pre[i], nums[i]); } for (int i = n - 1; i &gt;= 0; i--) { suf[i] = Math.max(suf[i + 1], nums[i]); } long ans = 0L; for (int j = 1; j &lt; n - 1; j++) { ans = Math.max(ans, (long) (pre[j] - nums[j]) * suf[j + 1]); } return ans; }} 方法二：枚举 k 参考灵神的题解，可以枚举 \\(k\\)，使空间复杂度降为 \\(O(1)\\)。主要想法就是枚举时，维护前缀最大差值。 123456789101112class Solution { public long maximumTripletValue(int[] nums) { long ans = 0; int maxDiff = 0, preMax = 0; for (int x : nums) { ans = Math.max(ans, (long) maxDiff * x); maxDiff = Math.max(maxDiff, preMax - x); preMax = Math.max(preMax, x); } return ans; }} 无限数组的最短子数组比赛时思路很快出来，但是实现的时候漏掉一些边界条件，导致 WA 多次，本来有机会进第一页的。比较直接的想法是枚举起始位置，然后利用前缀和二分结束的位置，如果满足条件就记入答案。也可以使用哈希表来优化，避免二分。这里贴一下灵神的滑动窗口解法，时间复杂度 \\(O(n)\\)，空间复杂度 \\(O(1)\\)。 12345678910111213141516171819class Solution { public int minSizeSubarray(int[] nums, int target) { int n = nums.length; long sum = 0L, pre = 0L; for (int x : nums) sum += x; int q = (int) (target / sum), r = (int) (target % sum); int lo = 0, hi = 0, ans = Integer.MAX_VALUE; while (hi &lt; 2 * n) { pre += nums[hi++ % n]; while (pre &gt; r) { pre -= nums[lo++ % n]; } if (pre == r) { ans = Math.min(ans, hi - lo); } } return ans == Integer.MAX_VALUE ? -1 : ans + q * n; }} 有向图访问计数看完题目就知道是内向基环树，直接修改上次的代码，轻松通过，本题是上次的简化版。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { public int[] countVisitedNodes(List&lt;Integer&gt; edges) { int n = edges.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[edges.get(i)]++; reverse[edges.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[edges.get(x)] == 0) { q.offer(edges.get(x)); } } // 记录每个节点在哪个环 int[] cirNum = new int[n]; boolean[] vis = new boolean[n]; List&lt;Integer&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { int cnt = 0; for (int cur = i; !vis[cur]; cur = edges.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cnt++; } circles.add(cnt); } } // 对环内的每个节点向环外进行 dfs int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { if (in[i] != 0) dfs(i, reverse, in, circles.get(cirNum[i]), ans); } return ans; } private void dfs(int x, List&lt;Integer&gt;[] reverse, int[] in, int len, int[] ans) { ans[x] = len; for (int y : reverse[x]) { if (in[y] != 0) continue; dfs(y, reverse, in, len + 1, ans); } }} 有个非常简单的写法，参考题解。 12345678910111213141516171819202122232425262728class Solution { public int[] countVisitedNodes(List&lt;Integer&gt; edges) { int n = edges.size(); int[] ans = new int[n]; int[] vis = new int[n]; for (int i = 0; i &lt; n; i++) { if (ans[i] == 0) { int cnt = 0, cirLen = 0, totLen = 0, pos = i; while (vis[pos] == 0) { vis[pos] = ++cnt; pos = edges.get(pos); } if (ans[pos] == 0) { cirLen = cnt - vis[pos] + 1; totLen = cnt; } else { totLen = cnt + ans[pos]; } pos = i; while (ans[pos] == 0) { ans[pos] = Math.max(totLen--, cirLen); pos = edges.get(pos); } } } return ans; }}","link":"/2023/10/02/%E7%AC%AC%20365%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 366 场力扣周赛","text":"分类求和并作差数学性质，\\([1,n]\\) 中能被 \\(m\\) 整除的数有 \\(\\lfloor \\frac{n}{m}\\rfloor\\) 个。 12345class Solution { public int differenceOfSums(int n, int m) { return (1 + n) * n / 2 - (1 + (n / m)) * (n / m) * m; }} 最小处理时间排序 + 贪心。 1234567891011class Solution { public int minProcessingTime(List&lt;Integer&gt; processorTime, List&lt;Integer&gt; tasks) { Collections.sort(processorTime); Collections.sort(tasks, (a , b) -&gt; b - a); int n = processorTime.size(), ans = 0; for (int i = 0; i &lt; n; i++) { ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4)); } return ans; }} 执行操作使两个字符串相等方法一：动态规划 今天脑子有点笨啊，本来做出来了，但是我将 dp 的初始值设置为 Integer.MAX_VALUE，将 dfs 不满足条件时的返回值也设置为该值，而判断是否记忆化的条件也设置为该值，所以所有不满足条件的方案都没有记忆化上。 我经常会写出从上到下记忆化的代码，但是每次都比从下到上的记忆化慢，经过分析，原因如下：从下到上的记忆化，只要该节点计算过，就会直接返回；而从上到下的记忆化，只有在当前节点的值比记忆化的值大时，才会直接返回，也就是说，这样的代码只会将所有大于记忆化的值的方案给剪枝掉，所有小于记忆化的值的方案会重复计算。 12345678910111213141516171819202122232425262728293031class Solution { public int minOperations(String s1, String s2, int x) { int n = s1.length(); int[][][] dp = new int[n][n + 1][2]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n + 1; j++) { Arrays.fill(dp[i][j], -1); } } int ans = dfs(0, 0, 0, s1, s2, x, dp); return ans &gt;= (int) 1e9 ? -1 : ans; } private int dfs(int i, int c, int r, String s1, String s2, int x, int[][][] dp) { if (i == s1.length()) { if (c % 2 == 0 &amp;&amp; r == 0) { return -c / 2 * x; } return (int) 1e9; } if (dp[i][c][r] != -1) return dp[i][c][r]; int res = 0; if ((s1.charAt(i) == s2.charAt(i)) == (r == 0)) { res = dfs(i + 1, c, 0, s1, s2, x, dp); } else { res = dfs(i + 1, c + 1, 0, s1, s2, x, dp) + x; res = Math.min(res, dfs(i + 1, c, 1, s1, s2, x, dp) + 1); } return dp[i][c][r] = res; }} 方法二：动态规划 时间复杂度 \\(O(n)\\)，空间复杂度 \\(O(1)\\) 的解法，其实比赛时第一眼差不多就想到这种解法，但是没有细想。 1234567891011121314151617class Solution { public int minOperations(String s1, String s2, int x) { int n = s1.length(); int pre = -1, cnt = 0; int dp0 = (int) 1e9, dp1 = 0; for (int i = 0; i &lt; n; i++) { if (s1.charAt(i) != s2.charAt(i)) { cnt ^= 1; int t = dp1; dp1 = Math.min(dp1 + (cnt == 1 ? x : 0), dp0 + i - pre); dp0 = t; pre = i; } } return cnt == 1 ? -1 : dp1; }} 对数组执行操作使平方和最大挺简单一道题，T3 卡太久，脑子短路没时间做这题。对于每一位，每次操作其实就是交换两个数之间的 \\(0\\) 和 \\(1\\)，我们应该总是把 \\(1\\) 交换到更大的数上，这样平方和最大。所以统计每一位的 \\(1\\) 的个数，贪心的组合成最大的数，然后取平方加入答案即可。 1234567891011121314151617181920212223242526class Solution { private static final int MOD = (int) 1e9 + 7; public int maxSum(List&lt;Integer&gt; nums, int k) { int[] cnt = new int[30]; for (int x : nums) { for (int i = 0; i &lt; 30; i++) { cnt[i] += x &gt;&gt; i &amp; 1; } } long ans = 0L; while (k-- != 0) { int x = 0; for (int i = 0; i &lt; 30; i++) { if (cnt[i] &gt; 0) { cnt[i]--; x |= 1 &lt;&lt; i; } } ans = (ans + (long) x * x) % MOD; } return (int) ans; }}","link":"/2023/10/09/%E7%AC%AC%20366%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round)","text":"Goals of Victory所有效率之和等于零。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n - 1; i++) { sum += io.nextInt(); } io.println(-sum);} Helmets in Night Light贪心选择最小花费的通知，注意维护已经被通知的下标，根据该下标判断是否需要加 \\(p\\)，并且如果某个人通知其他人的成本大于 \\(p\\)，则他不会通知其他人。发现大佬的解法好简单，取一个最小值，维护一个剩余人数即可。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; b[i] - b[j]); long ans = p; int r = n - 1; for (int i : aux) { int x = Math.min(r, a[i]); ans += (long) x * Math.min(p, b[i]); r -= x; } io.println(ans);} Joyboard分类讨论，注意被 \\(n\\) 整除的数。 1234567public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); if (k == 3) io.println(Math.max(0, m - n - m / n + 1)); else if (k == 2) io.println(m / n + Math.min(n - 1, m)); else if (k == 1) io.println(1); else io.println(0);} Effects of Anti Pimples很容易的想到计算选择每个索引位置，能够得到的最大分数，时间复杂度为 \\(O(n\\log{n})\\)。然后计算每个位置有多少种方案，比赛时我以为选择一个索引位置，默认就选择了它的所有倍数位置，导致不会做。其实只要排序，然后每个位置的方案数就是它左边的数选或不选的方案数，这样可以保证不会重复计算，所以快速幂计算方案数（可以在遍历的时候计算方案数），再乘以得分累加到答案即可。 123456789101112131415161718192021222324private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { dp[i] = io.nextInt(); } dp[0] = Integer.MAX_VALUE; for (int i = 1; i &lt;= n; i++) { for (int j = 2 * i; j &lt;= n; j += i) { dp[i] = Math.max(dp[i], dp[j]); } } Arrays.sort(dp); long ans = 0L, pow = 1L; for (int i = 0; i &lt; n; i++) { ans = (ans + dp[i] * pow) % MOD; pow = pow * 2 % MOD; } io.println(ans);} Autosynthesis方法一：内向基环树 对于每个 \\(i\\)，建立一条从 \\(i\\) 指向 \\(a_{i}\\) 的边，最终会得到多个内向基环树。规则一：入度为零的节点不会被选择；规则二：如果一个节点的所有入度节点都被选择，那么它不会被选择；规则三：如果一个节点不被选择，那么它指向的节点会被选择。（以上规则可以使用拓扑序 + 染色法实现） 如图，数组为 \\([2,3,4,5,6,3,3,4]\\)，剩余索引 \\([1,5,7,8]\\)，剩余元素 \\([2,6,3,4]\\)，选择索引 \\([2,6,3,4]\\)。应用规则一，得出索引 \\([1,7,8]\\) 不被选择；应用规则三，得出索引 \\([2,3,4]\\) 被选择；应用规则二，得出索引 \\([5]\\) 不被选择；应用规则三，得出索引 \\([6]\\) 被选择。 特殊情况，如果内向基环树没有环外节点，无法应用上述规则，那么需要单独对环交替染色，若此时环的长度为奇数，则没有解，其他情况均有解。也就是说，当且仅当内向基环树没有环外节点，且环的长度为奇数时，无解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[a[i]]++; } // 拓扑序染色（-1 表示不选择，1 表示选择） int[] col = new int[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); col[i] = -1; } } while (!q.isEmpty()) { int x = q.poll(), y = a[x]; if (col[y] != 0) continue; if (--in[y] == 0 || col[x] == -1) { q.offer(y); col[y] = -col[x]; } } // 单独处理没有环外节点的基环树 for (int i = 0; i &lt; n; i++) { if (col[i] != 0) continue; int j = i, pre = -1; while (col[j] == 0) { col[j] = -pre; pre = col[j]; j = a[j]; } if (col[j] == pre) { io.println(-1); return; } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (col[i] == -1) ans.add(a[i] + 1); } io.println(ans.size()); for (int x : ans) { io.print(x + &quot; &quot;); } io.println();} 方法二：外向基环树 好像有建立外向基环树的解法，没时间看，在此。","link":"/2023/10/09/Codeforces%20Round%20902%20(Div.%202,%20based%20on%20COMPFEST%2015%20-%20Final%20Round)/"},{"title":"JDK-8299339 : HashMap merge and compute methods can cause odd resizing pathologies","text":"贴一下去年发现的 Bug，嘿嘿。 导致 Bug 的示例代码如下： 12345678910111213public class Main { public static void main(String[] args) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(2); map.merge(1, 1, Integer::sum); map.merge(2, 1, Integer::sum); map.forEach((k, v) -&gt; { map.merge(k, -1, Integer::sum); System.out.println(k); }); }} Java Bug DataBase 链接，里面比较详细的讨论了发生的问题，由于当时急着发出去，我的评论有点乱，而且是中文翻译为英文的，有点拉。","link":"/2023/10/09/JDK-8299339%20HashMap%20merge%20and%20compute%20methods%20can%20cause%20odd%20resizing%20pathologies/"},{"title":"Educational Codeforces Round 156 (Rated for Div. 2)","text":"Sum of Three当 n &lt;= 6 || n == 9 时，不能凑出三个不同的不能被 \\(3\\) 整除的正整数，其他情况均可以通过以下方式凑出。 1234567891011121314public static void solve() { int n = io.nextInt(); if (n &lt;= 6 || n == 9) { io.println(&quot;NO&quot;); return; } int a = 1, b = 2, c = n - 3; if (c % 3 == 0) { c -= 2; b += 2; } io.println(&quot;YES&quot;); io.println(a + &quot; &quot; + b + &quot; &quot; + c);} Fear of the Dark可以分为四种情况：点 \\(O\\) 和 点 \\(P\\) 在圆 \\(A\\) 内/上；点 \\(O\\) 和 点 \\(P\\) 在圆 \\(B\\) 内/上；点 \\(O\\) 和 点 \\(P\\) 分别在圆 \\(A\\) 和圆 \\(B\\) 内/上，并且圆 \\(A\\) 和圆 \\(B\\) 相切/相交；点 \\(O\\) 和 点 \\(P\\) 分别在圆 \\(B\\) 和圆 \\(A\\) 内/上，并且圆 \\(A\\) 和圆 \\(B\\) 相切/相交。 方法一：浮点二分 12345678910111213141516171819202122public static void solve() { double px = io.nextInt(), py = io.nextInt(); double ax = io.nextInt(), ay = io.nextInt(); double bx = io.nextInt(), by = io.nextInt(); double lo = 0, hi = 1e4; while (hi - lo &gt; 1e-9) { double mid = lo + (hi - lo) / 2; boolean oToA = dist(0, 0, ax, ay) &lt;= mid; boolean aToP = dist(ax, ay, px, py) &lt;= mid; boolean oToB = dist(0, 0, bx, by) &lt;= mid; boolean bToP = dist(bx, by, px, py) &lt;= mid; boolean aToB = dist(ax, ay, bx, by) &lt;= 2 * mid; if ((oToA &amp;&amp; aToP) || (oToB &amp;&amp; bToP) || (oToA &amp;&amp; aToB &amp;&amp; bToP) || (oToB &amp;&amp; aToB &amp;&amp; aToP)) hi = mid; else lo = mid; } io.println(hi);}private static double dist(double x1, double y1, double x2, double y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));} 方法二：直接计算 123456789101112131415161718192021public static void solve() { double px = io.nextInt(), py = io.nextInt(); double ax = io.nextInt(), ay = io.nextInt(); double bx = io.nextInt(), by = io.nextInt(); double oToA = dist(0, 0, ax, ay); double aToP = dist(ax, ay, px, py); double oToB = dist(0, 0, bx, by); double bToP = dist(bx, by, px, py); double aToB = dist(ax, ay, bx, by); double ans = Math.max(oToA, aToP); ans = Math.min(ans, Math.max(oToB, bToP)); ans = Math.min(ans, Math.max(oToA, Math.max(aToB / 2, bToP))); ans = Math.min(ans, Math.max(oToB, Math.max(aToB / 2, aToP))); io.println(ans);}private static double dist(double x1, double y1, double x2, double y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));} Decreasing String二分删除的字符数 \\(p\\)，可以通过计算得到 \\(q=pos-\\frac{(n+(n-p+1))\\cdot p}{2}\\)，则答案为 \\(s_{1+p}[q]\\)，可以使用单调栈删除字符，然后获取答案即可。 1234567891011121314151617181920212223public static void solve() { String s = io.next(); long pos = io.nextLong(); int n = s.length(); int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if ((long) (n + n - mid + 1) * mid / 2 &lt; pos) lo = mid + 1; else hi = mid - 1; } int p = hi, q = (int) (pos - (long) (n + n - hi + 1) * hi / 2); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { while (p &gt; 0 &amp;&amp; !sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - 1) &gt; s.charAt(i)) { sb.deleteCharAt(sb.length() - 1); p--; } sb.append(s.charAt(i)); } io.print(sb.charAt(q - 1));} Monocarp and the Set很容易想到当 s[0] == '?' 时，方案数为 \\(0\\)，并且 &gt; 和 &lt; 符号的位置放什么数都是确定的，也就是说只有 ? 位置对答案有贡献。分别考虑每个 ? 位置（从位置 \\(1\\) 开始，因为位置 \\(0\\) 不能是 ?），假设该位置的下标为 \\(i\\)，那么它是第 \\(i+2\\) 个的数（因为添加第 \\(1\\) 个数时，不会记录字符到 \\(s\\) 中，并且下标从 \\(0\\) 开始，所以加 \\(2\\)），第 \\(i+2\\) 个数必须要大于前 \\(i+1\\) 个数的最小值，小于前 \\(i+1\\) 个数的最大值。我们可以将前 \\(i+1\\) 个数排成有序的序列，然后根据大小将第 \\(i+2\\) 个数插入到序列中，总共有 \\(i+2\\) 个插入位置，但在限制条件下，我们只能选择 \\(i\\) 个位置进行插入，对所有 ? 位置累乘 \\(i\\) 即可得到当前字符串的插入方案数。 看半天才懂，很多题解只提到插入法，根本没提到有序序列，只要知道是根据大小插入就很简单了。也就是说，插入时根本不关心当前是什么数，只关心当前数在前面数的最大值和最小值之间。在将所有的数插入完成后，所有 ? 位置是什么数就随之确定，也就确定了一种方案。 12345678910111213141516171819202122232425262728293031323334353637383940private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 1L; for (int i = 1; i &lt; n - 1; i++) { if (s[i] == '?') ans = ans * i % MOD; } query(s, ans); while (m-- != 0) { int i = io.nextInt() - 1; char c = io.next().charAt(0); if (i != 0 &amp;&amp; s[i] == '?') { ans = ans * pow(i, MOD - 2) % MOD; } s[i] = c; if (i != 0 &amp;&amp; s[i] == '?') { ans = ans * i % MOD; } query(s, ans); }}private static void query(char[] s, long ans) { if (s[0] == '?') io.println(0); else io.println(ans);}private static int pow(int a, int n) { long res = 1L, x = a; while (n != 0) { if ((n &amp; 1) == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/10/10/Educational%20Codeforces%20Round%20156%20(Rated%20for%20Div.%202)/"},{"title":"第 115 场力扣夜喵双周赛","text":"上一个遍历的整数模拟。 1234567891011121314151617class Solution { public List&lt;Integer&gt; lastVisitedIntegers(List&lt;String&gt; words) { int idx = -1; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; aux = new ArrayList&lt;&gt;(); for (String word : words) { if (word.equals(&quot;prev&quot;)) { if (idx &lt; 0) ans.add(-1); else ans.add(aux.get(idx--)); } else { aux.add(Integer.valueOf(word)); idx = aux.size() - 1; } } return ans; }} 最长相邻不相等子序列 I贪心。 1234567891011class Solution { public List&lt;String&gt; getWordsInLongestSubsequence(int n, String[] words, int[] groups) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i == n - 1 || groups[i] != groups[i + 1]) { ans.add(words[i]); } } return ans; }} 最长相邻不相等子序列 II和最长递增子序列有点像，处理的时候记录一下路径就好。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;String&gt; getWordsInLongestSubsequence(int n, String[] words, int[] groups) { int pos = 0; int[] from = new int[n]; int[] maxLen = new int[n]; Arrays.fill(maxLen, 1); for (int i = 1; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (maxLen[i] &lt; maxLen[j] + 1 &amp;&amp; groups[i] != groups[j] &amp;&amp; words[i].length() == words[j].length()) { int cnt = 0; for (int k = 0; k &lt; words[i].length(); k++) { if (words[i].charAt(k) != words[j].charAt(k) &amp;&amp; ++cnt &gt; 1) { break; } } if (cnt == 1) { maxLen[i] = maxLen[j] + 1; from[i] = j; if (maxLen[i] &gt; maxLen[pos]) { pos = i; } } } } } int m = maxLen[pos]; LinkedList&lt;String&gt; ans = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { ans.addFirst(words[pos]); pos = from[pos]; } return ans; }} 和带限制的子多重集合的数目明显是多重背包问题，求背包中物品重量在 \\([l,r]\\) 之间的方案数，朴素的转移方程为： $$ dp[i][j]=\\sum_{k=0}^{cnt[i]}{(dp[i-1][j-k\\cdot w[i]])} $$ 这样做的时间复杂度为 \\(O(rn)\\)，其中 \\(n\\) 为 \\(nums\\) 的长度。在题目的数据范围下，复杂度达到 \\(4\\cdot 1e8\\) 数量级，会导致超时。优化方式如下，当 \\(j\\geq(cnt[i]+1)\\cdot w[i]\\) 且 \\(w[i]\\neq 0\\) 时，有： $$ dp[i][j-w[i]]=dp[i-1][j-w[i]]+dp[i-1][j-2\\cdot w[i]]+\\cdots+dp[i-1][j-(cnt[i]+1)\\cdot w[i]] $$ $$ dp[i][j]=dp[i-1][j]+dp[i-1][j-w[i]]+\\cdots+dp[i-1][j-cnt[i]\\cdot w[i]] $$ 然后错位相减，得到： $$ dp[i][j]=dp[i][j-w[i]]+(dp[i-1][j]-dp[i-1][j-(cnt[i]+1)\\cdot w[i]]) $$ 当 \\(j\\geq(cnt[i]+1)\\cdot w[i]\\) 且 \\(w[i]=0\\) 时，直接使用朴素转移方程，得到： $$ dp[i][j]=\\sum_{k=0}^{cnt[i]}{(dp[i-1][j])} $$ 同理可得，当 \\(w[i]\\leq j&lt;(cnt[i]+1)\\cdot w[i]\\) 时，错位相减得到： $$ dp[i][j]=dp[i][j-w[i]]+dp[i-1][j] $$ 当 \\(j&lt;w[i]\\) 时，直接使用朴素转移方程，得到： $$ dp[i][j]=dp[i-1][j] $$ 这样做的时间复杂度为 \\(O(r\\sqrt{S})\\)，其中 \\(S\\) 表示 \\(nums\\) 的元素和，\\(\\sqrt{S}\\) 表示 \\(nums\\) 中不同元素的最大数量。不同元素的最大数量满足 \\(\\frac{(0+(x-1))\\cdot x}{2}\\leq S\\)，解得 \\(x\\leq \\frac{1+\\sqrt{1+8\\cdot S}}{2}\\)。还有一些常数级别的优化，比如减少遍历的上界等。 12345678910111213141516171819202122232425262728293031323334353637class Solution { private static final int MOD = (int) 1e9 + 7; public int countSubMultisets(List&lt;Integer&gt; nums, int l, int r) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { map.merge(x, 1, Integer::sum); } int zero = map.getOrDefault(0, 0); map.remove(0); int m = map.size(); int[] f = new int[r + 1]; int[] g = new int[r + 1]; f[0] = zero + 1; for (var e : map.entrySet()) { int w = e.getKey(), c = e.getValue(); System.arraycopy(f, 0, g, 0, r + 1); for (int j = w; j &lt;= r; j++) { f[j] = (f[j - w] + f[j]) % MOD; if (j - (c + 1) * w &gt;= 0) { f[j] = (f[j] - g[j - (c + 1) * w] + MOD) % MOD; } } } int ans = 0; for (int i = l; i &lt;= r; i++) { ans = (ans + f[i]) % MOD; } return ans; }} 分开处理，先做前缀和，再倒序减去某个前缀和，就可以不使用辅助数组 \\(g\\)： 1234567891011121314151617181920212223242526272829303132333435class Solution { private static final int MOD = (int) 1e9 + 7; public int countSubMultisets(List&lt;Integer&gt; nums, int l, int r) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { map.merge(x, 1, Integer::sum); } int zero = map.getOrDefault(0, 0); map.remove(0); int m = map.size(); int[] f = new int[r + 1]; f[0] = zero + 1; for (var e : map.entrySet()) { int w = e.getKey(), c = e.getValue(); for (int j = w; j &lt;= r; j++) { f[j] = (f[j - w] + f[j]) % MOD; } for (int j = r; j &gt;= (c + 1) * w; j--) { f[j] = (f[j] - f[j - (c + 1) * w] + MOD) % MOD; } } int ans = 0; for (int i = l; i &lt;= r; i++) { ans = (ans + f[i]) % MOD; } return ans; }}","link":"/2023/10/16/%E7%AC%AC%20115%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 367 场力扣周赛","text":"找出满足差值条件的下标 I同下。 最短且字典序最小的美丽子字符串滑动窗口。 1234567891011121314151617181920212223242526class Solution { public String shortestBeautifulSubstring(String s, int k) { int n = s.length(); int lo = s.indexOf('1'); if (lo &lt; 0) { return &quot;&quot;; } String ans = &quot;&quot;; int hi = lo, cnt = 0; while (hi &lt; n) { cnt += s.charAt(hi++) - '0'; while (cnt &gt; k || s.charAt(lo) == '0') { cnt -= s.charAt(lo++) - '0'; } if (cnt == k) { String t = s.substring(lo, hi); if (ans.isEmpty() || t.length() &lt; ans.length() || t.length() == ans.length() &amp;&amp; t.compareTo(ans) &lt; 0) { ans = t; } } } return ans; }} 找出满足差值条件的下标 II维护最大值和最小值就行。 1234567891011121314151617181920212223class Solution { public int[] findIndices(int[] nums, int indexDifference, int valueDifference) { int n = nums.length; int minIndex = 0, maxIndex = 0; for (int j = indexDifference; j &lt; n; j++) { int i = j - indexDifference; if (nums[i] &gt; nums[maxIndex]) { maxIndex = i; } else if (nums[i] &lt; nums[minIndex]) { minIndex = i; } if (nums[maxIndex] - nums[j] &gt;= valueDifference) { return new int[]{maxIndex, j}; } if (nums[j] - nums[minIndex] &gt;= valueDifference) { return new int[]{minIndex, j}; } } return new int[]{-1, -1}; }} 构造乘积矩阵前后缀分解，将二维数组看作一维数组。 1234567891011121314151617181920212223242526class Solution { private static final int MOD = 12345; public int[][] constructProductMatrix(int[][] grid) { int n = grid.length, m = grid[0].length; int[][] p = new int[n][m]; long suf = 1; for (int i = n - 1; i &gt;= 0; i--) { for (int j = m - 1; j &gt;= 0; j--) { p[i][j] = (int) suf; suf = suf * grid[i][j] % MOD; } } long pre = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { p[i][j] = (int) (p[i][j] * pre % MOD); pre = pre * grid[i][j] % MOD; } } return p; }}","link":"/2023/10/16/%E7%AC%AC%20367%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 324","text":"Same12345678public static void solve() { int n = io.nextInt(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) { set.add(io.nextInt()); } io.println(set.size() == 1 ? &quot;Yes&quot; : &quot;No&quot;);} 3-smooth Numbers123456public static void solve() { long n = io.nextLong(); while (n % 2 == 0) n /= 2; while (n % 3 == 0) n /= 3; io.println(n == 1 ? &quot;Yes&quot; : &quot;No&quot;);} Error Correction额，很简单的题，赛时花费很长时间，代码写得很乱。 123456789101112131415161718192021222324252627282930313233public static void solve() { int n = io.nextInt(); String t = io.next(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int k = 0; k &lt; n; k++) { String s = io.next(); int i = 0; for (; i &lt; s.length() &amp;&amp; i &lt; t.length(); i++) { if (s.charAt(i) != t.charAt(i)) { break; } } int j = 0; for (; j &lt; s.length() &amp;&amp; j &lt; t.length(); j++) { if (s.charAt(s.length() - 1 - j) != t.charAt(t.length() - 1 - j)) { break; } } boolean ok = s.length() == t.length() &amp;&amp; i + j &gt;= t.length() - 1; ok |= s.length() == t.length() + 1 &amp;&amp; i + j &gt;= t.length(); ok |= s.length() == t.length() - 1 &amp;&amp; i + j &gt;= t.length() - 1; if (ok) { ans.add(k + 1); } } io.println(ans.size()); ans.forEach(i -&gt; io.print(i + &quot; &quot;)); io.println();} Square Permutation还是直接使用字符串更简单，要不然还要拆位。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); Arrays.sort(s); long max = (long) Math.pow(10, n); int ans = 0; for (long i = 0; i * i &lt; max; i++) { StringBuilder sb = new StringBuilder(String.valueOf(i * i)); while (sb.length() &lt; n) { sb.append(&quot;0&quot;); } char[] t = sb.toString().toCharArray(); Arrays.sort(t); if (Arrays.equals(s, t)) { ans++; } } io.println(ans);} Joint Two Strings记录每个字符串的子序列匹配目标字符串的最大前后缀的长度，因为答案和下标无关，所以使用排序 + 二分计算答案。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); String t = io.next(); int[] prefix = new int[n]; int[] suffix = new int[n]; for (int k = 0; k &lt; n; k++) { String s = io.next(); for (int i = 0; i &lt; s.length() &amp;&amp; prefix[k] &lt; t.length(); i++) { if (s.charAt(i) == t.charAt(prefix[k])) { prefix[k]++; } } for (int i = 0; i &lt; s.length() &amp;&amp; suffix[k] &lt; t.length(); i++) { if (s.charAt(s.length() - 1 - i) == t.charAt(t.length() - 1 - suffix[k])) { suffix[k]++; } } } Arrays.sort(suffix); long ans = 0L; for (int i = 0; i &lt; n; i++) { int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (prefix[i] + suffix[mid] &gt;= t.length()) hi = mid - 1; else lo = mid + 1; } ans += n - lo; } io.println(ans);} Beautiful Path二分答案，将除法转化为乘法，因为顶点的边限制 \\(u&lt;v\\)，所以从 \\(1\\) 到 \\(n\\) 处理顶点就是拓扑序，并且一定没有环，拓扑序动态规划求最长路径即可。（额，昨天刚做拓扑序动态规划求最长路径，竟然还没做出这题。） 1234567891011121314151617181920212223242526272829303132333435363738public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n]; List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, b = io.nextInt(), c = io.nextInt(); g[u].add(new int[]{v, b, c}); in[v]++; } double lo = 0, hi = 1e4; while (hi - lo &gt;= 1e-10) { double mid = lo + (hi - lo) / 2; if (check(g, in.clone(), mid)) lo = mid; else hi = mid; } io.println(lo);}private static boolean check(List&lt;int[]&gt;[] g, int[] in, double x) { int n = g.length; double[] dist = new double[n]; Arrays.fill(dist, Long.MIN_VALUE); dist[0] = 0; for (int u = 0; u &lt; n; u++) { for (int[] t : g[u]) { int v = t[0], b = t[1], c = t[2]; if (dist[v] &lt; dist[u] + b - c * x) { dist[v] = dist[u] + b - c * x; } } } return dist[n - 1] &gt;= 0;}","link":"/2023/10/16/AtCoder%20Beginner%20Contest%20324/"},{"title":"AtCoder Beginner Contest 325","text":"Takahashi san12345public static void solve() { String s = io.next(); io.next(); io.println(s + &quot; san&quot;);} World Meeting比赛时用滑窗没有做出来，原来要滑两倍的数组长度啊。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] cnt = new int[24]; for (int i = 0; i &lt; n; i++) { int w = io.nextInt(), x = io.nextInt(); cnt[x] += w; } int ans = 0; for (int i = 0; i &lt; 24; i++) { int sum = 0; for (int j = 0; j &lt; 9; j++) { sum += cnt[(i + j) % 24]; } ans = Math.max(ans, sum); } io.println(ans);} Sensors直接 DFS 或者并查集都行。 1234567891011121314151617181920212223242526272829303132public static void solve() { int h = io.nextInt(), w = io.nextInt(); boolean[][] g = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { String s = io.next(); for (int j = 0; j &lt; w; j++) { if (s.charAt(j) == '#') { g[i][j] = true; } } } int ans = 0; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { if (g[i][j]) { ans++; dfs(i, j, g); } } } io.println(ans);}private static void dfs(int x, int y, boolean[][] g) { if (x &lt; 0 || x &gt;= g.length || y &lt; 0 || y &gt;= g[0].length || !g[x][y]) return; g[x][y] = false; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { dfs(x + i, y + j, g); } }} Printing Machine贪心，对于每个时刻，我们选择已经进入传送带的，右端点最小的产品。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); long[][] aux = new long[n][]; for (int i = 0; i &lt; n; i++) { long t = io.nextLong(), d = io.nextLong(); aux[i] = new long[]{t, t + d}; } Arrays.sort(aux, (a, b) -&gt; Long.compare(a[0], b[0])); int i = 0, ans = 0; Queue&lt;Long&gt; q = new PriorityQueue&lt;&gt;(); for (long t = 0; ; t++) { if (q.isEmpty()) { if (i == n) break; t = aux[i][0]; } while (i &lt; n &amp;&amp; aux[i][0] == t) { q.offer(aux[i++][1]); } while (!q.isEmpty() &amp;&amp; q.peek() &lt; t) { q.poll(); } if (!q.isEmpty()) { ans++; q.poll(); } } io.println(ans);}","link":"/2023/10/24/AtCoder%20Beginner%20Contest%20325/"},{"title":"第 368 场力扣周赛","text":"元素和最小的山形三元组 I同下。 元素和最小的山形三元组 II前后缀分解。 1234567891011121314151617181920class Solution { public int minimumSum(int[] nums) { int n = nums.length; int[] pre = new int[n + 1], suf = new int[n + 1]; pre[0] = suf[n] = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { pre[i + 1] = Math.min(pre[i], nums[i]); } for (int i = n - 1; i &gt;= 0; i--) { suf[i] = Math.min(suf[i + 1], nums[i]); } int ans = Integer.MAX_VALUE; for (int i = 1; i &lt; n - 1; i++) { if (nums[i] &gt; pre[i] &amp;&amp; nums[i] &gt; suf[i + 1]) { ans = Math.min(ans, pre[i] + nums[i] + suf[i + 1]); } } return ans == Integer.MAX_VALUE ? -1 : ans; }} 合法分组的最少组数贪心，不太会，直接看题解。 1234567891011121314151617181920212223242526class Solution { public int minGroupsForValidAssignment(int[] nums) { Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int x : nums) { cnt.merge(x, 1, Integer::sum); } int k = nums.length; for (int x : cnt.values()) { k = Math.min(k, x); } for (; ; k--) { int ans = 0; for (int x : cnt.values()) { if (x / k &lt; x % k) { ans = 0; break; } ans += (x + k) / (k + 1); } if (ans &gt; 0) { return ans; } } }} 得到 K 个半回文串的最少修改次数直接记忆化搜索就能搞定，特别注意子字符串的长度要求至少为 \\(2\\)。当然还可以预处理出所有因子，也可以将记忆化搜索转化为自底向上的动态规划。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public int minimumChanges(String s, int k) { int n = s.length(); int[][] change = new int[n][n]; for (int i = 0; i &lt; n - 1; i++) { for (int j = i + 1; j &lt; n; j++) { change[i][j] = calc(s.substring(i, j + 1)); } } int[][] dp = new int[n][k]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], -1); } return dfs(0, s, n, k - 1, change, dp); } private int calc(String s) { int n = s.length(), res = n; for (int d = 1; d &lt; n; d++) { if (n % d == 0) { int cnt = 0; for (int k = 0; k &lt; d; k++) { for (int i = k, j = n - d + k; i &lt; j; i += d, j -= d) { if (s.charAt(i) != s.charAt(j)) { cnt++; } } } res = Math.min(res, cnt); } } return res; } private int dfs(int i, String s, int n, int k, int[][] change, int[][] dp) { if (k == 0) { return change[i][n - 1]; } if (dp[i][k] != -1) { return dp[i][k]; } int res = n; for (int j = i + 1; j &lt; n - 2 * k; j++) { res = Math.min(res, dfs(j + 1, s, n, k - 1, change, dp) + change[i][j]); } return dp[i][k] = res; }}","link":"/2023/10/24/%E7%AC%AC%20368%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 904 (Div. 2)","text":"Simple Design12345678910111213141516public static void solve() { int x = io.nextInt(), k = io.nextInt(); while (sum(x) % k != 0) { x++; } io.println(x);}private static int sum(int x) { int res = 0; while (x != 0) { res += x % 10; x /= 10; } return res;} Haunted House好难啊，做得很慢。对于每个 \\(i\\)，如果它是满足条件的，那么 \\([n-i,n-1]\\) 需要全为 \\(0\\)，它的最少操作次数为 \\([n-i,n-1]\\) 中所有值为 \\(1\\) 的下标和，减去 \\([0,n-i-1]\\) 中最近的值为 \\(0\\) 的对应个数的下标和。我们可以使用双指针 \\(O(n)\\) 的计算所有 \\(i\\)，具体见代码。指针 \\(j\\) 枚举每个下标，同时求出后缀的下标和，指针 \\(i\\) 指向指针 \\(j\\) 需要的最远的 \\(0\\) 的下标位置，同时求出后缀值为 \\(0\\) 的下标和，它们的差值就是 \\(j\\) 的最少操作次数。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); String s = io.next(); long sum = 0L; int i, j, cnt = 0; for (i = n - 1, j = n - 1; i &gt;= 0; j--) { cnt++; sum += j; for (; i &gt;= 0 &amp;&amp; cnt &gt; 0; i--) { if (s.charAt(i) == '0') { cnt--; sum -= i; } } io.print(cnt &gt; 0 ? &quot;-1 &quot; : sum + &quot; &quot;); } io.println(&quot;-1 &quot;.repeat(j + 1));} 发现一个超级简单的写法，基本思路就是从低到高放置 \\(0\\)，操作次数即为 \\(0\\) 的移动次数，废话不多说，代码很好懂。 123456789101112131415public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 0L; int l = n - 1, r = n - 1; for (; l &gt;= 0; l--) { if (s[l] == '0') { ans += r - l; r--; io.print(ans + &quot; &quot;); } } io.println(&quot;-1 &quot;.repeat(r + 1));} Medium Design最小值一定在位置 \\(1\\) 或位置 \\(m\\)，我们可以考虑处理区间不包含 \\(1\\) 和不包含 \\(m\\) 两种情况下，能够得到的最大值，根据简单的推导可以知道问题是等价的。如何计算最大值，根据题解所说似乎是扫描线算法，使用 \\((l,1)\\) 表示进入某个区间，\\((r,-1)\\) 表示离开某个区间，注意初始时我们将每个左端点减 \\(1\\)，表示从区间 \\(0\\) 开始算，\\((l,r)\\) 是左闭右开区间，所以 \\(r\\) 表示离开某个区间，然后每当处理完某个端点就更新答案。（其实也可以使用差分哈希表进行区间求和） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] l = new int[n]; int[] r = new int[n]; for (int i = 0; i &lt; n; i++) { l[i] = io.nextInt() - 1; r[i] = io.nextInt(); } // 第一次扫描，不包含第一个位置 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (l[i] != 0) { list.add(new int[]{l[i], 1}); list.add(new int[]{r[i], -1}); } } list.sort((a, b) -&gt; a[0] - b[0]); int ans = sweep(list); // 第二次扫描，不包含最后一个位置 list.clear(); for (int i = 0; i &lt; n; i++) { if (r[i] != m) { list.add(new int[]{l[i], 1}); list.add(new int[]{r[i], -1}); } } list.sort((a, b) -&gt; a[0] - b[0]); ans = Math.max(ans, sweep(list)); io.println(ans);}private static int sweep(List&lt;int[]&gt; list) { // cnt 表示在多少个区间内 // lst 表示上次处理的端点 int res = 0, cnt = 0, lst = 0; for (int[] t : list) { if (t[0] &gt; lst) { res = Math.max(res, cnt); } cnt += t[1]; lst = t[0]; } return res;} Counting Rhyme一对数 \\(x,y\\) 不能同时被数组中的数整除，即 \\(\\gcd(x,y)\\) 不能被数组中的数整除。我们首先可以计算出数组中有多少对数它们的 \\(\\gcd=1,2,3\\dots,n\\)，然后排除掉能够被数组中的数整除的 \\(\\gcd\\)，剩下的 \\(\\gcd\\) 对应的对数之和就是答案。第一步可以使用动态规划求解，转移方程如下： $$ sum = cnt[i]+cnt[2\\times i]+\\cdots+cnt[k\\times i] \\\\ dp[i]= \\frac{sum\\times (sum-1)}{2}-(dp[2\\times i]+dp[3\\times i]+\\cdots+dp[k\\times i]) $$ 第二步切记不能枚举数组中的数来排除，这样在所有值都为 \\(1\\) 的样例下时间复杂度会达到 \\(O(n^{2})\\)，除非将数组去重，或者像下面代码一样枚举。最后计算答案即可。本题的另一种解法是 GCD 卷积，暂时不学。 123456789101112131415161718192021222324252627282930313233public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] cnt = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); cnt[a[i]]++; } long[] dp = new long[n + 1]; for (int i = n; i &gt; 0; i--) { long tot = 0L; for (int j = i; j &lt;= n; j += i) { tot += cnt[j]; dp[i] -= dp[j]; } dp[i] += tot * (tot - 1) / 2; } for (int i = 1; i &lt;= n; i++) { if (cnt[i] != 0) { for (int j = i; j &lt;= n; j += i) { dp[j] = 0; } } } long ans = 0L; for (int i = 1; i &lt;= n; i++) { ans += dp[i]; } io.println(ans);}","link":"/2023/10/24/Codeforces%20Round%20904%20(Div.%202)/"},{"title":"Codeforces Round 905 (Div. 2)","text":"Chemistry只要奇数字母的个数不大于 \\(k+1\\) 即可，因为回文串最多有一个奇数字母。 1234567891011121314151617public static void solve() { int n = io.nextInt(), k = io.nextInt(); String s = io.next(); int[] cnt = new int[26]; for (int i = 0; i &lt; n; i++) { cnt[s.charAt(i) - 'a']++; } int sum = 0; for (int x : cnt) { if (x % 2 == 1) { sum++; } } io.println(sum - 1 &gt; k ? &quot;NO&quot; : &quot;YES&quot;);} Raspberries当 \\(k=2,3,5\\) 时，因为 \\(k\\) 是质数，如果所有数的乘积能够被 \\(k\\) 整除，必定存在一个数能够被 \\(k\\) 整除，所以单独计算每个数即可。当 \\(k=4\\) 时，需要计算存在一个数能被 \\(4\\) 整除的最少操作数，还需要计算存在两个能被 \\(2\\) 整除的数的最少操作数，答案为两者的最小值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); int cnt = 0; int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); if (a[i] % 2 == 0) { cnt++; } } int ans = k; for (int i = 0; i &lt; n; i++) { ans = Math.min(ans, (k - a[i] % k) % k); } if (k == 4) { ans = Math.min(ans, Math.max(0, 2 - cnt)); } io.println(ans);} You Are So Beautiful如果某个子数组作为子序列只出现过一次，因为子数组本身就是子序列，所以没有其他方式能够构成该子数组，即子数组的左端点左边没有和它相同的数，右端点的右边也没有和它相同的数。我们可以使用集合 + 前缀和的方式预先计算每个位置及其左边满足条件的左端点个数，然后倒序处理数组，对每个满足条件的右端点，都将其对应的左端点的个数添加到答案。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int[] prefix = new int[n + 1]; for (int i = 0; i &lt; n; i++) { prefix[i + 1] = prefix[i] + (set.add(a[i]) ? 1 : 0); } set.clear(); long ans = 0L; for (int i = n - 1; i &gt;= 0; i--) { if (set.add(a[i])) { ans += prefix[i + 1]; } } io.println(ans);} Dances (Easy version)题目真难读，简单版只会在数组 \\(a\\) 中添加一个 \\(1\\)，然后计算最少操作数，可以使用排序 + 双指针进行处理。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; a[0] = 1; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(a); Arrays.sort(b); int k = 0; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { k++; j++; } } io.println(k);} Dances (Hard Version)困难版，计算在数组中分别添加 \\([1,m]\\) 需要的最少操作数。通过观察可以发现（真发现不了），改变 \\(a[0]\\) 最多只会使操作次数加 \\(1\\)，所以我们可以二分该边界值，然后计算答案即可。 12345678910111213141516171819202122232425262728293031323334353637public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(b); int k = calc(a, b, 1); int lo = 1, hi = m; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (calc(a, b, mid) == k) lo = mid + 1; else hi = mid - 1; } io.println((long) m * k + (m - lo + 1));}private static int calc(int[] a, int[] b, int x) { a[0] = x; a = a.clone(); Arrays.sort(a); int n = a.length, k = 0; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { k++; j++; } } return k;} 竟然还有更简单的方法，首先计算 \\(a\\) 中 \\(n-1\\) 个数对应 \\(b\\) 中 \\(n\\) 个数的最少删除次数，并同时维护 \\(b\\) 中不满足 \\(a[i]&lt;b[j]\\) 的最后一个值，该值就是操作次数的分界点，直接计算答案即可。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; a[0] = Integer.MAX_VALUE; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(a); Arrays.sort(b); int k = 0, val = m + 1; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { val = b[j]; k++; j++; } } io.println((long) m * (k - 1) + Math.max(0, m - val + 1));}","link":"/2023/10/24/Codeforces%20Round%20905%20(Div.%202)/"},{"title":"动态规划","text":"本文内容参考《算法导论》，OI Wiki。 基础知识动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。 适合应用动态规划方法求解的最优化问题应该具备两个要素：最优子结构和重叠子问题。 最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 重叠子问题：如果问题的递归算法会反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。 子问题图 子问题图是一个有向图，每个顶点唯一的对应一个子问题。若求子问题 \\(x\\) 的最优解时需要直接用到子问题 \\(y\\) 的最优解，那么在子问题图中就会有一条从子问题 \\(x\\) 的顶点到子问题 \\(y\\) 的顶点的有向边。 自顶向下动态规划处理子问题图中顶点的顺序为拓扑序，自底向上动态规划处理子问题图中顶点的顺序为逆拓扑序。 通常情况下，动态规划算法的运行时间与子问题图中顶点和边的数量呈线性关系。 选择自顶向下，还是自底向上 通常情况下，如果每个子问题都必须至少求解一次，自底向上动态规划算法会更快，因为没有递归调用的开销，而且对于某些问题，可以利用表的访问模式降低时空开销。如果子问题空间中的某些子问题完全不必求解，自顶向下动态规划算法会更快，因为它只会求解那些必要的子问题。 背包 DP题目：有 \\(n\\) 种物品和一个容量为 \\(W\\) 的背包，每种物品有数量 \\(k_{i}\\)、重量 \\(w_{i}\\) 和价值 \\(v_{i}\\) 三种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。 0-1 背包 每种物品只能取一次，即 \\(k_{i}=1\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max{(dp[i-1][j],dp[i-1][j-w[i]]+v[i])} $$ 空间优化（倒序枚举）： $$ dp[j]=\\max{(dp[j],dp[j-w[i]]+v[i])} $$ 完全背包 每种物品可以取无限次，即 \\(k_{i}=\\infty\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max_{k=0}^{\\infty}{dp[i-1][j-k\\cdot w[i]]+k\\cdot v[i]} $$ 方程优化： $$ dp[i][j]=\\max{(dp[i-1][j],dp[i][j-w[i]]+v[i])} $$ 空间优化（正序枚举）： $$ dp[j]=\\max(dp[j],dp[j-w[i]]+v[i]) $$ 多重背包 每种物品可以取 \\(k_{i}\\) 次，即 \\(k_{i}\\in\\mathbb{N}\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max_{k=0}^{k[i]}{dp[i-1][j-k\\cdot w[i]]+k\\cdot v[i]} $$ 二进制分组优化：将每种物品的 \\(k_{i}\\) 拆分为多个组，每组的数量为 \\(2^{0},2^{1},\\dots,2^{\\lfloor{\\log{k_{i}+1}}\\rfloor -1}\\)，如果 \\(k_{i}+1\\) 不是二的幂，就将多余的数量作为一组，最后将 \\(k_{i}\\) 拆出来的每组都看作数量为 \\(1\\) 的新物品，从而转化为 0-1 背包。可以证明，如果选择 \\(x\\) 次第 \\(i\\) 种物品，其中 \\(x\\in[0,k_{i}]\\)，则该选择方式总是可以由分组后的新物品的某个组合表示。 例题 线性 DP：1143. 最长公共子序列，300. 最长递增子序列，72. 编辑距离。 背包 DP：416. 分割等和子集，322. 零钱兑换，2902. 和带限制的子多重集合的数目。 区间 DP：516. 最长回文子序列，1000. 合并石头的最低成本。 树形 DP：2646. 最小化旅行的价格总和，834. 树中距离之和，2867. 统计树中的合法路径数目。 状压 DP：526. 优美的排列，Mondriaan’s Dream。 数位 DP：233. 数字 1 的个数，1012. 至少有 1 位重复的数字。 概率 DP：D. Bag of mice，E - Roulettes。","link":"/2023/10/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"排序算法","text":"本文内容参考 sorting-algorithms，《算法》，《算法导论》。（强迫症，最后还是把描述性的文字删了，只贴代码） 验证算法的正确性，可以使用：912. 排序数组，148. 排序链表，164. 最大间距。 简单概述理想的排序算法 稳定性：相同键不会重新排序。 原地排序：不使用额外空间存储排序数据。 最坏情况 \\(O(n\\log{n})\\) 次比较，\\(O(n)\\) 次交换。 适应性：当数据接近排序或唯一键很少时，时间复杂度为 \\(O(n)\\)。 如何看待常数因子的改进方案 摘抄自《算法》的一段内容：在每一节中，我们会将书中的每个算法都看做某种应用的关键。但在整体上，我们希望学习的是为每种应用找到最合适的算法。我们并不是在推荐读者一定要实现所有提到的改进方法，而是提醒大家不要对算法初始实现的性能盖棺定论。研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。实现那些只能把运行时间缩短某个常数因子的改进措施可能并不值得。你需要用实验来检验一项改进，正如本书练习所演示的那样。 冒泡排序 稳定性：稳定。 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n)\\)。 1234567891011121314private static void bubbleSort(int[] nums) { int n = nums.length, pos; for (int i = n - 1; i &gt; 0; i = pos) { pos = 0; for (int j = 0; j &lt; i; j++) { // 稳定性的关键 if (nums[j] &gt; nums[j + 1]) { swap(nums, j, j + 1); // 将最后交换的位置，作为下次冒泡的上界 pos = j; } } }} 选择排序 稳定性：不稳定。 时间复杂度：\\(O(n^{2})\\)。元素的交换次数最少的排序算法。 空间复杂度：\\(O(1)\\)。 123456789101112private static void selectionSort(int[] nums) { int n = nums.length; for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } if (minIndex != i) swap(nums, minIndex, i); }} 插入排序 稳定性：稳定。 时间复杂度：\\(O(n^{2})\\)。元素的交换次数等于逆序数。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n)\\)。 1234567891011private static void insertionSort(int[] nums) { int n = nums.length; for (int i = 1; i &lt; n; i++) { int j = i - 1, t = nums[i]; // 稳定性的关键 for (; j &gt;= 0 &amp;&amp; nums[j] &gt; t; j--) { nums[j + 1] = nums[j]; } nums[j + 1] = t; }} 希尔排序 稳定性：不稳定。 时间复杂度：使用 Knuth 增量序列 \\(O(n^{\\frac{3}{2}})\\)，。Knuth 增量序列：\\(1,4,13,40,\\dots,\\frac{3^{k}-1}{2}\\)，相当于首项为 \\(1\\)，公比为 \\(3\\) 的数列的前缀和。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n\\log{n})\\)。 1234567891011121314private static void insertionSort(int[] nums) { int n = nums.length, h = 1; while (h &lt; n / 3) h = 3 * h + 1; while (h &gt;= 1) { for (int i = h; i &lt; n; i++) { int j = i - h, t = nums[i]; for (; j &gt;= 0 &amp;&amp; nums[j] &gt; t; j -= h) { nums[j + h] = nums[j]; } nums[j + h] = t; } h /= 3; }} 归并排序 稳定性：稳定的。 时间复杂度：\\(O(n\\log{n})\\)。 空间复杂度：排序数组 \\(O(n)\\)；自顶向下排序链表 \\(O(\\log{n})\\)（递归的空间），自底向上排序链表 \\(O(1)\\)。 顺序访问数据，缓存友好。 实现一：自顶向下（数组） 123456789101112131415161718192021222324252627private static void mergeSort(int[] nums) { int n = nums.length; int[] aux = new int[n]; mergeSort(nums, aux, 0, n - 1);}private static void mergeSort(int[] nums, int[] aux, int lo, int hi) { if (lo &gt;= hi) return; int mid = lo + (hi - lo) / 2; mergeSort(nums, aux, lo, mid); mergeSort(nums, aux, mid + 1, hi); merge(nums, aux, lo, mid, hi);}private static void merge(int[] nums, int[] aux, int lo, int mid, int hi) { for (int i = lo; i &lt;= hi; i++) { aux[i] = nums[i]; } int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; // 稳定性的关键 else if (aux[i] &lt;= aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; }} 实现二：自底向上（数组） 1234567891011121314151617181920212223private static void mergeSort(int[] nums) { int n = nums.length; int[] aux = new int[n]; for (int len = 1; len &lt; n; len += len) { for (int i = 0; i + len &lt; n; i += len &lt;&lt; 1) { merge(nums, aux, i, i + len - 1, Math.min(n - 1, i + (len &lt;&lt; 1) - 1)); } }}private static void merge(int[] nums, int[] aux, int lo, int mid, int hi) { for (int i = lo; i &lt;= hi; i++) { aux[i] = nums[i]; } int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; // 稳定性的关键 else if (aux[i] &lt;= aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; }} 实现三：自顶向下（链表） 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static ListNode mergeSort(ListNode head) { if (head == null || head.next == null) { return head; } // 分为两个子链表 ListNode mid = middleNode(head); ListNode next = mid.next; mid.next = null; head = mergeSort(head); next = mergeSort(next); return merge(head, next);}// 返回合并链表的头节点private static ListNode merge(ListNode head1, ListNode head2) { ListNode dummy = new ListNode(), curr = dummy; while (head1 != null &amp;&amp; head2 != null) { // 稳定性的关键 if (head1.val &lt;= head2.val) { curr.next = head1; head1 = head1.next; } else { curr.next = head2; head2 = head2.next; } curr = curr.next; } curr.next = head1 != null ? head1 : head2; return dummy.next;}// 调用保证 head != null，并且如果有两个中间节点，则返回前一个（不然会无限递归）// 使用 fast = head.next 可以保证返回前一个中间节点// 使用 fast = head 可以保证返回后一个中间节点private static ListNode middleNode(ListNode head) { if (head == null) return head; ListNode slow = head, fast = head.next; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;} 实现四：自底向上（链表） 下面这个是没有提前计算链表长度，没有断开链表的解法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static ListNode mergeSort(ListNode head) { if (head == null || head.next == null) return head; int len = 1; ListNode dummy = new ListNode(-1, head); while (true) { // 两个子链表的头节点的前一个节点 ListNode prev1, prev2; prev1 = prev2 = dummy; while (true) { for (int i = 0; i &lt; len &amp;&amp; prev2 != null; i++) { prev2 = prev2.next; } if (prev2 == null || prev2.next == null) break; prev1 = prev2 = merge(prev1, prev2, len); } // 如果该轮没有进行合并操作，则排序完成 if (prev1 == dummy) break; len += len; } return dummy.next;}// 返回合并链表的尾节点private static ListNode merge(ListNode prev1, ListNode prev2, int len) { // 判断条件：第一个链表未结束 &amp;&amp; 第二个链表未结束（考虑长度不足的情况） while (prev1 != prev2 &amp;&amp; len != 0 &amp;&amp; prev2.next != null) { // 稳定性的关键 if (prev1.next.val &gt; prev2.next.val) { // 将 prev2.next 插入到 prev1 之后 ListNode temp = prev2.next; prev2.next = prev2.next.next; temp.next = prev1.next; prev1.next = temp; len--; } prev1 = prev1.next; } // 使 prev2 指向合并链表的尾节点 while (len-- != 0 &amp;&amp; prev2.next != null) prev2 = prev2.next; return prev2;} 快速排序 稳定性：不稳定。 时间复杂度：期望 \\(O(n\\log{n})\\)。 空间复杂度：期望 \\(O(\\log{n})\\)。 如果使用三路快排，数据包含大量重复元素时，时间复杂度为 \\(O(n)\\)。 实现一：二路快排 1234567891011121314151617181920212223242526272829private static void quickSort(int[] nums) { int n = nums.length; quickSort(nums, 0, n - 1);}private static void quickSort(int[] nums, int lo, int hi) { if (lo &gt;= hi) return; int index = partition(nums, lo, hi); quickSort(nums, lo, index - 1); quickSort(nums, index + 1, hi);}private static int partition(int[] nums, int lo, int hi) { // 三数取中 int mid = median3(nums, lo, lo + (hi - lo) / 2, hi); swap(nums, lo, mid); int key = nums[lo]; int i = lo, j = hi + 1; while (true) { // 和切分元素相等的元素也会停顿并交换 while (nums[++i] &lt; key &amp;&amp; i != hi); while (nums[--j] &gt; key); if (i &gt;= j) break; swap(nums, i, j); } swap(nums, lo, j); return j;} 实现二：三路快排 12345678910111213141516171819202122232425private static final Random RANDOM = new Random();private static void quickSort(int[] nums) { int n = nums.length; quickSort(nums, 0, n - 1);}private static void quickSort(int[] nums, int lo, int hi) { if (lo &gt;= hi) return; // 随机选择 int randomIndex = lo + RANDOM.nextInt(hi - lo + 1); swap(nums, randomIndex, lo); int key = nums[lo]; int lt = lo, gt = hi, i = lo + 1; while (i &lt;= gt) { if (nums[i] &lt; key) swap(nums, i++, lt++); else if (nums[i] &gt; key) swap(nums, i, gt--); else i++; } quickSort(nums, lo, lt - 1); quickSort(nums, gt + 1, hi);} 堆排序 稳定性：不稳定。 时间复杂度：\\(O(n\\log{n})\\)。 空间复杂度：\\(O(1)\\)。 随机访问数据，缓存不友好。 12345678910111213141516171819202122232425262728public static void heapSort(int[] nums) { int n = nums.length; // 建堆 - 时间复杂度 O(n) for (int i = n / 2 - 1; i &gt;= 0; i--) { sink(nums, i, n - 1); } // 排序 - 时间复杂度 O(nlog(n)) for (int i = n - 1; i &gt; 0; ) { swap(nums, 0, i--); sink(nums, 0, i); }}private static void sink(int[] nums, int i, int n) { int t = nums[i]; while (2 * i + 1 &lt;= n) { int j = 2 * i + 1; if (j + 1 &lt;= n &amp;&amp; nums[j + 1] &gt; nums[j]) { j++; } if (t &gt;= nums[j]) break; nums[i] = nums[j]; i = j; } nums[i] = t;} 计数排序 稳定性：稳定。 时间复杂度：\\(O(n+k)\\)。 空间复杂度：\\(O(n+k)\\)。 12345678910111213141516171819202122// 元素取值范围 [0,k)private static int[] countingSort(int[] nums, int k) { int n = nums.length; int[] cnt = new int[k]; int[] res = new int[n]; // 计数 for (int x : nums) { cnt[x]++; } // 前缀和 for (int i = 1; i &lt; k; i++) { cnt[i] += cnt[i - 1]; } // 排序（倒序遍历，保证稳定性） for (int i = n - 1; i &gt;= 0; i--) { res[--cnt[nums[i]]] = nums[i]; } return res;} 基数排序 稳定性：稳定。 时间复杂度：\\(O(d\\cdot (n+k))\\)。 空间复杂度：\\(O(n+k)\\)。 12345678910111213141516171819202122232425262728293031323334353637// 元素最多有 d 位private static int[] radixSort(int[] nums, int d) { int n = nums.length; int[] cnt = new int[10]; int[] aux = new int[n]; int divisor = 1; for (int i = 0; i &lt; d; i++) { countingSort(nums, cnt, aux, divisor); Arrays.fill(cnt, 0); divisor *= 10; int[] t = nums; nums = aux; aux = t; } return nums;}private static void countingSort(int[] nums, int[] cnt, int[] aux, int divisor) { int n = nums.length; // 计数 for (int x : nums) { cnt[x / divisor % 10]++; } // 前缀和 for (int i = 1; i &lt; 10; i++) { cnt[i] += cnt[i - 1]; } // 排序（倒序遍历，保证稳定性） for (int i = n - 1; i &gt;= 0; i--) { aux[--cnt[nums[i] / divisor % 10]] = nums[i]; }} 桶排序 稳定性：取决于桶内的排序策略。 时间复杂度：期望 \\(O(n)\\)。（输入数据均匀分布时） 空间复杂度：\\(O(n+m)\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static void bucketSort(int[] nums) { int n = nums.length; if (n &lt;= 1) return; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int x : nums) { min = Math.min(min, x); max = Math.max(max, x); } // 小心除以零 int inter = Math.max(1, (max - min) / (n - 1)); int bucketSize = (max - min) / inter + 1; List&lt;Integer&gt;[] buckets = new List[bucketSize]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int x : nums) { int i = (x - min) / inter; buckets[i].add(x); // 插入排序 int j = buckets[i].size() - 1; for (; j &gt; 0 &amp;&amp; buckets[i].get(j - 1) &gt; x; j--) { buckets[i].set(j, buckets[i].get(j - 1)); } buckets[i].set(j, x); } int idx = 0; for (var bucket : buckets) { for (int x : bucket) { nums[idx++] = x; } }}","link":"/2023/10/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"字符串","text":"本文内容参考《算法》，《算法导论》，OI Wiki。 字符串匹配例题 28. 找出字符串中第一个匹配项的下标。 暴力 时间复杂度：最坏 \\(O(NM)\\)，平均 \\(O(N)\\)。 空间复杂度：\\(O(1)\\)。 12345678910111213private static int bruteForce(String text, String pattern) { int i, j; int n = text.length(), m = pattern.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { if (text.charAt(i) == pattern.charAt(j)) { j++; } else { i -= j; j = 0; } } return j == m ? i - m : -1;} KMP 时间复杂度：\\(O(N)\\)。 空间复杂度：\\(O(M)\\)。 12345678910111213141516171819202122232425262728293031private static int kmp(String text, String pattern) { int n = text.length(), m = pattern.length(); if (m &gt; n) return -1; // 处理模式串 // next[i] 表示 pattern 的子串 [0, i] 的最长相等前后缀的长度 int[] next = new int[m]; for (int i = 1, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j)) { j = next[j - 1]; } if (pattern.charAt(i) == pattern.charAt(j)) { j++; } next[i] = j; } // 匹配文本串 for (int i = 0, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; text.charAt(i) != pattern.charAt(j)) { j = next[j - 1]; } if (text.charAt(i) == pattern.charAt(j)) { j++; } if (j == m) { return i - m + 1; } } return -1;} Boyer-Moore 时间复杂度：最坏 \\(O(NM)\\)，平均 \\(O(\\frac{N}{M})\\)。 空间复杂度：\\(O(R)\\)。 1System.out.println(&quot;TODO&quot;); Rabin-Karp 时间复杂度：\\(O(N)\\)。 空间复杂度：\\(O(1)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041private static final int P = 13331;// MOD = 2^64private static int rabinKarp(String text, String pattern) { int n = text.length(), m = pattern.length(); if (m &gt; n) return -1; long PM = pow(P, m - 1); long patHash = hash(pattern, m); long txtHash = hash(text, m); if (txtHash == patHash) { return 0; } for (int i = m; i &lt; n; i++) { txtHash = txtHash - text.charAt(i - m) * PM; txtHash = txtHash * P + text.charAt(i); if (txtHash == patHash) { return i - m + 1; } } return -1;}private static long pow(int a, int n) { long res = 1L, x = a; for (; n != 0; x *= x, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res *= x; } } return res;}private static long hash(String s, int m) { long h = 0L; for (int i = 0; i &lt; m; i++) { h = h * P + s.charAt(i); } return h;} 字符串哈希例题 E. Compress Words（这题使用 \\(MOD=2^{64}\\) 一直在第 65 个测试点 WA，看来还是模质数比较好）。 实现 时间复杂度：预处理 \\(O(N)\\)，获取哈希值 \\(O(1)\\)。 空间复杂度：\\(O(N)\\)。 123456789101112131415161718192021222324252627282930313233343536373839404142class StringHash { private final int K = 2; private static final long[] b = {131, 13331}; private static final long[] m = {1_000_000_007, 998244353}; private int index; private final long[][] h, p; public StringHash(int n) { h = new long[K][n + 1]; p = new long[K][n + 1]; for (int i = 0; i &lt; K; i++) { p[i][0] = 1; } } public StringHash(char[] s) { this(s.length); for (char c : s) add(c); } public void add(char c) { for (int j = 0; j &lt; K; j++) { p[j][index + 1] = p[j][index] * b[j] % m[j]; h[j][index + 1] = (h[j][index] * b[j] + c) % m[j]; } index++; } public long[] get(int l, int r) { long[] res = new long[K]; for (int i = 0; i &lt; K; i++) { long t = h[i][r + 1] - h[i][l] * p[i][r - l + 1]; res[i] = (t % m[i] + m[i]) % m[i]; } return res; } public int length() { return index; }} 字典树（Trie）例题 208. 实现 Trie (前缀树)。 1803. 统计异或值在范围内的数对有多少。 实现 时间复杂度：插入和查找都是 \\(O(k)\\)，其中 \\(k\\) 为字符串的长度。 空间复杂度：\\(O(nR)\\)，其中 \\(n\\) 为节点总数，\\(R\\) 为字母表大小。 12345678910111213141516171819202122232425262728293031323334353637class Trie { private static final int R = 26; private final Node root; private static class Node { boolean exist; Node[] next = new Node[R]; } public Trie() { root = new Node(); } public void insert(String word) { Node node = root; for (int i = 0; i &lt; word.length(); i++) { int idx = word.charAt(i) - 'a'; if (node.next[idx] == null) { node.next[idx] = new Node(); } node = node.next[idx]; } node.exist = true; } public boolean search(String word) { Node node = root; for (int i = 0; i &lt; word.length(); i++) { int idx = word.charAt(i) - 'a'; if (node.next[idx] == null) { return false; } node = node.next[idx]; } return node.exist; }} AC 自动机例题 P5357 【模板】AC 自动机（二次加强版）。 实现 时间复杂度：插入 \\(O(k)\\)，构建 \\(O(nR)\\)，查询 \\(O(k+n)\\)，其中 \\(k\\) 为字符串的长度。 空间复杂度：\\(O(nR)\\)，其中 \\(n\\) 为节点总数，\\(R\\) 为字母表大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class AhoCorasickAutomaton { private static final int R = 26; private final Node root; // 按插入顺序存储模式串尾字符对应的节点 private final List&lt;Node&gt; patternNodes; // 所有节点按层次遍历顺序存储（代码没有存根节点） private final List&lt;Node&gt; levelOrderNodes; private static class Node { int cnt; // 节点出现在文本串中的次数，懒更新 Node fail; // 节点的失配指针，指向当前节点的最长后缀节点 Node[] next = new Node[R]; } public AhoCorasickAutomaton() { root = new Node(); patternNodes = new ArrayList&lt;&gt;(); levelOrderNodes = new ArrayList&lt;&gt;(); } // 插入模式串 public void insert(String pattern) { Node node = root; for (int i = 0; i &lt; pattern.length(); i++) { int idx = pattern.charAt(i) - 'a'; if (node.next[idx] == null) { node.next[idx] = new Node(); } node = node.next[idx]; } patternNodes.add(node); } // 构建失配指针和 Trie 图 public void build() { // 将根节点的直接子节点入队，并构建节点的失配指针和 Trie 图 // 提前入队是因为根节点和其直接子节点与其他节点的处理逻辑不同 root.fail = root; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; R; i++) { if (root.next[i] == null) { root.next[i] = root; } else { root.next[i].fail = root; q.offer(root.next[i]); } } // 层次遍历，构建失配指针和 Trie 图 while (!q.isEmpty()) { Node node = q.poll(); levelOrderNodes.add(node); for (int i = 0; i &lt; R; i++) { if (node.next[i] == null) { node.next[i] = node.fail.next[i]; } else { node.next[i].fail = node.fail.next[i]; q.offer(node.next[i]); } } } } // 查询每个模式串在文本串中的出现次数 public void query(String text, int[] cnt) { // 懒更新出现次数 Node node = root; for (int i = 0; i &lt; text.length(); i++) { int idx = text.charAt(i) - 'a'; node = node.next[idx]; node.cnt++; } // 倒序层次遍历，进一步沿着失配指针传递出现次数 // 倒序遍历是因为失配指针必然在更上层，所以从下向上传递可以保证正确性 for (int i = levelOrderNodes.size() - 1; i &gt;= 0; i--) { node = levelOrderNodes.get(i); node.fail.cnt += node.cnt; } // 获取每个模式串的出现次数 for (int i = 0; i &lt; patternNodes.size(); i++) { cnt[i] += patternNodes.get(i).cnt; } }} 正则表达式例题 10. 正则表达式匹配。使用动态规划或者构造非确定有限状态自动机（NFA）。 实现 时间复杂度：构造 NFA \\(O(m)\\)，匹配 \\(O(nm)\\)，其中 \\(m\\) 为正则表达式的长度，\\(n\\) 为文本串的长度。 空间复杂度：构造 NFA \\(O(m)\\)，匹配 \\(O(m)\\)。 1System.out.println(&quot;TODO&quot;);","link":"/2023/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"数学","text":"本文内容参考《算法导论》，OI Wiki。（数学好难，暂时搁置） 快速幂例题 P1226 【模板】快速幂。 509. 斐波那契数。 整数时间复杂度：\\(O(\\log{n})\\)。 1234567891011private static final long MOD = 1_000_000_007;private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;} 矩阵时间复杂度：\\(O(\\log{n})\\)。 1234567891011121314151617181920212223private static final int MOD = 1_000_000_007;private static long[][] pow(long[][] x, long n) { long[][] res = {{1, 0}, {0, 1}}; for (; n != 0; x = mul(x, x), n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = mul(res, x); } } return res;}private static long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) { c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % MOD; } } } return c;} 数论例题 204. 计数质数。 2521. 数组乘积中的不同质因数数目。 2447. 最大公因数等于 K 的子数组数目。 1250. 检查「好数组」。 判断质数时间复杂度 \\(O(n\\sqrt{n})\\)。 1234567private static boolean isPrime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i++) { if (x % i == 0) return false; } return true;} 质数筛法埃氏筛时间复杂度 \\(O(n\\log{\\log{n}})\\)，筛掉质数的倍数，每个合数都会被筛它的质因数的个数次。 123456789101112private static boolean[] sieveOfEratosthenes(int n) { boolean[] np = new boolean[n + 1]; np[0] = np[1] = true; for (int i = 2; i &lt;= n / i; i++) { if (np[i]) continue; for (int j = i; j &lt;= n / i; j++) { np[j * i] = true; } } return np;} 欧拉筛时间复杂度 \\(O(n)\\)，每个合数都只被它的最小质因数筛掉。 123456789101112131415private static boolean[] sieveOfEuler(int n) { int cnt = 0; int[] p = new int[n + 1]; boolean[] np = new boolean[n + 1]; np[0] = np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) p[cnt++] = i; for (int j = 0; p[j] &lt;= n / i; j++) { np[p[j] * i] = true; if (i % p[j] == 0) break; } } return np;} 分解质因数时间复杂度 \\(O(\\sqrt{n})\\)。 1234567891011private static Map&lt;Integer, Integer&gt; primeFactors(int x) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 2; i &lt;= x / i; i++) { while (x % i == 0) { x /= i; map.merge(i, 1, Integer::sum); } } if (x &gt; 1) map.merge(x, 1, Integer::sum); return map;} 欧拉函数欧拉函数 \\(\\phi(n)\\)，表示 \\([1,n]\\) 范围内和 \\(n\\) 互质的数的个数，有如下性质： 若 \\(\\gcd(a,b)=1\\)，则 \\(\\phi(a\\times b)=\\phi(a)\\times \\phi(b)\\)。 若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，其中 \\(p_{i}\\) 为质数，则 \\(\\phi(n)=n\\times\\prod_{i=1}^{k}(1-\\frac{1}{p_{i}})\\)。 我们可以使用分解质因数求解某个数的欧拉函数，时间复杂度为 \\(O(\\sqrt{n})\\)；也可以使用欧拉筛来求解 \\([1,n]\\) 范围内所有数的欧拉函数，时间复杂度为 \\(O(n)\\)。在欧拉筛中，每个合数都是被它的最小质因子筛掉，设 \\(p\\) 是 \\(n\\) 的最小质因子，则 \\(n=n^{\\prime}\\times p\\)，分类讨论： 如果 \\(n^{\\prime}\\bmod p\\neq 0\\)，因为 \\(p\\) 是质数，所以 \\(\\gcd(n^{\\prime},p)=1\\)，则 \\(\\phi(n)=\\phi(n^{\\prime})\\times \\phi(p)=\\phi(n^{\\prime})\\times (p-1)\\)。 如果 \\(n^{\\prime}\\bmod p=0\\)，则 \\(\\phi(n)=p\\times n^{\\prime}\\times\\prod_{i=1}^{k}(1-\\frac{1}{p_{i}})=p\\times \\phi(n^{\\prime})\\)。 123456789101112131415161718192021222324private static int[] sieveOfEuler(int n) { int cnt = 0; int[] p = new int[n + 1]; int[] phi = new int[n + 1]; boolean[] np = new boolean[n + 1]; phi[1] = 1; np[0] = np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) { p[cnt++] = i; phi[i] = i - 1; } for (int j = 0; p[j] &lt;= n / i; j++) { np[p[j] * i] = true; if (i % p[j] == 0) { phi[p[j] * i] = p[j] * phi[i]; break; } phi[p[j] * i] = (p[j] - 1) * phi[i]; } } return phi;} 最大公约数欧几里得算法时间复杂度 \\(O(\\log{\\max(a,b)})\\)。求得最大公约数之后，使用 \\(\\gcd(a,b)\\times\\operatorname{lcm}(a,b)=a\\times b\\) 公式可以得到最小公倍数。 1234private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} 扩展欧几里得算法常用于求解 \\(ax+by=\\gcd(a,b)\\) 的一组解。 1234567891011121314private static int x, y;private static int exgcd(int a, int b) { if (b == 0) { x = 1; y = 0; return a; } int d = exgcd(b, a % b); int t = x - a / b * y; x = y; y = t; return d;} 其他知识约数个数若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，则 \\(d_{n}=\\prod_{i=1}^{k}(c_{i}+1)\\)。 约数之和若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，则 \\(s_{n}=\\prod_{i=1}^{k}\\sum_{j=0}^{c_{i}}{p_{i}^{j}}\\)。 裴蜀定理若 \\(a,b\\) 是整数，则对于任意的整数 \\(x,y\\)，\\(ax+by\\) 总是 \\(\\gcd(a,b)\\) 的倍数，并且存在整数 \\(x,y\\)，使得 \\(ax+by=\\gcd(a,b)\\)。特别的，若存在整数 \\(x,y\\) 使得 \\(ax+by=1\\)，则 \\(\\gcd(a,b)=1\\)，即 \\(a,b\\) 互质。 费马小定理若 \\(p\\) 是质数，\\(\\gcd(a,p)=1\\)，则 \\(a^{p-1}\\equiv 1\\pmod{p}\\)。 欧拉定理若 \\(\\gcd(a,n)=1\\)，则 \\(a^{\\phi(n)}\\equiv 1\\pmod{n}\\)。 模乘法逆元若 \\(p\\) 是质数，根据费马小定理，有 \\(a\\times a^{-1}\\equiv 1\\equiv a^{p-1}\\pmod{p}\\)，得到 \\(a^{-1}\\equiv a^{p-2}\\pmod{p}\\)。 若 \\(b\\) 是任意整数，求 \\(a\\) 的逆元，等价于求 \\(ax\\equiv 1\\pmod{b}\\) 的解，等价于求 \\(ax+by=1\\) 的解。如果 \\(\\gcd(a,b)=1\\)，则可以使用扩展欧几里得算法求解该方程。如果 \\(\\gcd(a,b)\\neq 1\\)，根据裴蜀定理可知方程无解（或者可以将方程变换为 \\(\\frac{a}{g}x+\\frac{b}{g}y=\\frac{1}{g}\\)，等式左边是整数，右边不是整数，方程无解），即逆元不存在。 线性同余方程求 \\(ax\\equiv c\\pmod{b}\\) 的解，等价于求 \\(ax+by=c\\) 的解，同样的，当 \\(\\gcd(a,b)\\mid c\\) 时方程有解。使用扩展欧几里得算法可以求出 \\(ax+by=\\gcd(a,b)\\) 的解，然后将方程变换为 \\(a\\frac{c}{\\gcd(a,b)}x_{0}+b\\frac{c}{\\gcd(a,b)}y_{0}=c\\)，可以得到方程的解。","link":"/2023/10/26/%E6%95%B0%E5%AD%A6/"},{"title":"数据结构","text":"本文内容参考 OI Wiki。 并查集例题 P3367 【模板】并查集。 实现123456789101112131415161718192021222324252627282930313233343536373839class UnionFind { private final int[] f, s; private int c; public UnionFind(int n) { c = n; f = new int[n]; s = new int[n]; for (int i = 0; i &lt; n; i++) { f[i] = i; s[i] = 1; } } public int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x]; } public void union(int x, int y) { int rx = find(x), ry = find(y); if (rx == ry) return; f[ry] = rx; s[rx] += s[ry]; c--; } public boolean connected(int x, int y) { return find(x) == find(y); } public int size(int x) { return s[find(x)]; } public int count() { return c; }} 树状数组例题 #130. 树状数组 1 ：单点修改，区间查询。 #131. 树状数组 2 ：区间修改，单点查询。 #132. 树状数组 3 ：区间修改，区间查询。 实现单点修改，区间查询123456789101112131415161718192021222324252627class BIT { private final int n; private final long[] t; public BIT(int n) { this.n = n; t = new long[n + 1]; } public void add(int i, int k) { for (; i &lt;= n; i += i &amp; -i) { t[i] += k; } } public long sum(int x) { long res = 0; for (; x &gt; 0; x &amp;= x - 1) { res += t[x]; } return res; } public long get(int l, int r) { return sum(r) - sum(l - 1); }} 区间修改，单点查询1234567891011121314151617181920212223242526272829303132class BIT { private final int n; private final long[] t; public BIT(int n) { this.n = n; t = new long[n + 1]; } private void add(int i, int k) { for (; i &lt;= n; i += i &amp; -i) { t[i] += k; } } public void add(int l, int r, int k) { add(l, k); add(r + 1, -k); } public long sum(int x) { long res = 0L; for (int i = x; i &gt; 0; i &amp;= i - 1) { res += t[i]; } return res; } public long get(int x) { return sum(x); }} 区间修改，区间查询123456789101112131415161718192021222324252627282930313233343536class BIT { private final int n; private final long[] t1, t2; public BIT(int n) { this.n = n; t1 = new long[n + 1]; t2 = new long[n + 1]; } private void add(int i, int k) { long p = (long) k * i; for (; i &lt;= n; i += i &amp; -i) { t1[i] += k; t2[i] += p; } } public void add(int l, int r, int k) { add(l, k); add(r + 1, -k); } public long sum(int x) { long s1 = 0, s2 = 0; for (int i = x; i &gt; 0; i &amp;= i - 1) { s1 += t1[i]; s2 += t2[i]; } return s1 * (x + 1) - s2; } public long get(int l, int r) { return sum(r) - sum(l - 1); }} 线段树例题 P3372 【模板】线段树 1。 P3373 【模板】线段树 2。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class SegmentTree { private final int n; private final long[] t, z; public SegmentTree(int[] a) { n = a.length; t = new long[4 * n]; z = new long[4 * n]; build(a, 1, 1, n); } private void build(int[] a, int i, int l, int r) { if (l == r) { t[i] = a[l - 1]; return; } int mid = l + (r - l) / 2; build(a, 2 * i, l, mid); build(a, 2 * i + 1, mid + 1, r); t[i] = t[2 * i] + t[2 * i + 1]; } private void lazy(int i, int lo, int hi, long k) { t[i] += k * (hi - lo + 1); z[i] += k; } private void down(int i, int lo, int hi) { if (z[i] == 0) { return; } int mid = lo + (hi - lo) / 2; lazy(2 * i, lo, mid, z[i]); lazy(2 * i + 1, mid + 1, hi, z[i]); z[i] = 0; } public void add(int l, int r, int k) { if (l &gt; r) return; add(1, 1, n, l, r, k); } private void add(int i, int lo, int hi, int l, int r, int k) { if (lo &gt;= l &amp;&amp; hi &lt;= r) { lazy(i, lo, hi, k); return; } down(i, lo, hi); int mid = lo + (hi - lo) / 2; if (l &lt;= mid) add(2 * i, lo, mid, l, r, k); if (r &gt; mid) add(2 * i + 1, mid + 1, hi, l, r, k); t[i] = t[2 * i] + t[2 * i + 1]; } public long get(int l, int r) { if (l &gt; r) return 0L; return get(1, 1, n, l, r); } private long get(int i, int lo, int hi, int l, int r) { if (lo &gt;= l &amp;&amp; hi &lt;= r) { return t[i]; } down(i, lo, hi); long res = 0L; int mid = lo + (hi - lo) / 2; if (l &lt;= mid) res += get(2 * i, lo, mid, l, r); if (r &gt; mid) res += get(2 * i + 1, mid + 1, hi, l, r); return res; }} 稀疏表（Sparse Table）例题 P3865 【模板】ST 表。 实现1System.out.println(&quot;TODO&quot;);","link":"/2023/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"AtCoder Beginner Contest 326","text":"2UP3DOWN12345678public static void solve() { int x = io.nextInt(), y = io.nextInt(); if (y - x &gt;= -3 &amp;&amp; y - x &lt;= 2) { io.println(&quot;Yes&quot;); } else { io.println(&quot;No&quot;); }} 326-like Numbers123456789public static void solve() { int n = io.nextInt(); for (; ; n++) { if (n / 100 * (n / 10 % 10) == n % 10) { io.println(n); return; } }} Peak1234567891011121314151617public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); int ans = 0; for (int i = 0, j = 0; j &lt; n; j++) { while (a[j] - a[i] &gt;= m) { i++; } ans = Math.max(ans, j - i + 1); } io.println(ans);} ABC Puzzle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(); char[] r = io.next().toCharArray(); char[] c = io.next().toCharArray(); int[] row = new int[n]; int[] col = new int[n]; char[][] ans = new char[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(ans[i], '.'); } boolean ok = dfs(0, 0, r, c, ans, row, col, 0); if (!ok) { io.println(&quot;No&quot;); return; } io.println(&quot;Yes&quot;); for (int i = 0; i &lt; n; i++) { io.println(new String(ans[i])); }}private static boolean dfs(int x, int y, char[] r, char[] c, char[][] ans, int[] row, int[] col, int cnt) { int n = r.length; if (x == n) { return cnt == 3 * n; } if (n - 1 - y &gt;= 3 - Integer.bitCount(row[x])) { if (dfs(x + (y + 1) / n, (y + 1) % n, r, c, ans, row, col, cnt)) { return true; } } for (int i = 0; i &lt; 3; i++) { if ((row[x] &gt;&gt; i &amp; 1) == 1 || (col[y] &gt;&gt; i &amp; 1) == 1) { continue; } if (row[x] == 0 &amp;&amp; r[x] != 'A' + i) { continue; } if (col[y] == 0 &amp;&amp; c[y] != 'A' + i) { continue; } row[x] |= 1 &lt;&lt; i; col[y] |= 1 &lt;&lt; i; ans[x][y] = (char) ('A' + i); if (dfs(x + (y + 1) / n, (y + 1) % n, r, c, ans, row, col, cnt + 1)) { return true; } row[x] ^= 1 &lt;&lt; i; col[y] ^= 1 &lt;&lt; i; ans[x][y] = '.'; } return false;} Revenge of “The Salary of AtCoder Inc.”概率 DP，答案为 \\(\\sum_{i=1}^{n}{A_{i}P_{i}}\\)，而 \\(P_{i}=\\frac{1}{N}\\sum_{j=0}^{i-1}{P_{j}}=P_{i-1}+\\frac{1}{N}P_{i-1}\\)。（这么简单，真没想到） 1234567891011121314151617181920212223private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); long invn = pow(n, MOD - 2); long ans = 0L, p = invn; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); ans = (ans + p * a) % MOD; p = (p + invn * p) % MOD; } io.println(ans);}private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;}","link":"/2023/10/29/AtCoder%20Beginner%20Contest%20326/"},{"title":"第 116 场力扣夜喵双周赛","text":"子数组不同元素数目的平方和 I同下。 使二进制字符串变美丽的最少修改次数长度为偶数的字符串要满足条件，那么将数组分为长度为 \\(2\\) 的各个小段，使各个子数组满足条件一定是最优的。 123456789class Solution { public int minChanges(String s) { int n = s.length(), ans = 0; for (int i = 0; i &lt; n; i += 2) { ans += (s.charAt(i) ^ s.charAt(i + 1)) &amp; 1; } return ans; }} 和为目标值的最长子序列的长度0-1 背包，转移方程为 \\(dp[i][j]=\\max(dp[i-1][j],dp[i-1][j-nums[i]]+1)\\)，注意初始化为 \\(-1\\)，并在转移时判断有效性。 12345678910111213141516class Solution { public int lengthOfLongestSubsequence(List&lt;Integer&gt; nums, int target) { int n = nums.size(); int[] dp = new int[target + 1]; Arrays.fill(dp, -1); dp[0] = 0; for (int x : nums) { for (int j = target; j &gt;= x; j--) { if (dp[j - x] != -1) { dp[j] = Math.max(dp[j], dp[j - x] + 1); } } } return dp[target]; }} 子数组不同元素数目的平方和 II动态规划 + 线段树，刚学的线段树就用上了，但是不太熟练，忘记我的线段树板子是从下标一开始操作，并且没有特判，如果操作的右端点比左端点小，那么就会导致数组越界，之后得修改一下板子。假设以 \\(i\\) 为右端点的所有子数组的不同计数的平方和为 \\(dp[i]\\)，考虑如何转移到 \\(dp[i+1]\\)。 如果在 \\([0,i]\\) 中和 \\(nums[i+1]\\) 相等的数为 \\(nums[j]\\)，则添加 \\(nums[i+1]\\) 会使左端点在 \\([j+1,i]\\) 范围内的子数组的不同计数加 \\(1\\)，而左端点在 \\([0,j]\\) 范围内子数组的不同计数不变，最后不要忘记加上左端点在 \\(i+1\\) 的子数组的不同计数的平方。我们可以得到如下转移方程，其中 \\(x_{i,j}\\) 表示子数组 \\(nums[i,j]\\) 的不同计数。 $$ \\begin{align} dp[i] &=x_{0,i}^{2}+x_{1,i}^{2}+\\cdots+x_{i,i}^{2} \\\\ dp[i+1] &=x_{0,i}^{2}+\\cdots+x_{j,i}^{2}+(x_{j+1,i}+1)^{2}+\\cdots+(x_{i,i}+1)^{2}+x_{i+1,i+1}^{2} \\end{align} $$ 然后我们将 \\(dp[i]\\) 代入到 \\(dp[i+1]\\) 中，得到： $$ dp[i+1]=dp[i]+2\\sum_{k=j+1}^{i}x_{k,i}+(i-j)+x_{i+1,i+1}^{2} $$ 首先我们需要得到每个数，它左边第一个相同的数的位置，这可以在遍历的过程中使用哈希表得到。然后我们需要维护以当前位置为右端点，所有左端点表示的子数组的不同计数（区间修改），并且需要快速的求区间和，那么就可以使用线段树，这样我们只需要花费 \\(O(\\log{n})\\) 的时间进行转移。转移之后，不要忘记更新左端点在 \\([j+1,i+1]\\) 范围内的子数组的不同计数。 12345678910111213141516171819class Solution { private static final int MOD = (int) 1e9 + 7; public int sumCounts(int[] nums) { int n = nums.length; long ans = 0L, sum = 0L; var st = new SegmentTree(n); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= n; i++) { int j = map.getOrDefault(nums[i - 1], 0); map.put(nums[i - 1], i); sum = (sum + 2 * st.get(j + 1, i) + i - j) % MOD; ans = (ans + sum) % MOD; st.add(j + 1, i, 1); } return (int) ans; }}","link":"/2023/10/29/%E7%AC%AC%20116%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 369 场力扣周赛","text":"找出数组中的 K-or 值模拟。 123456789101112131415class Solution { public int findKOr(int[] nums, int k) { int ans = 0; for (int i = 0; i &lt; 31; i++) { int cnt = 0; for (int x : nums) { cnt += x &gt;&gt; i &amp; 1; } if (cnt &gt;= k) { ans |= 1 &lt;&lt; i; } } return ans; }} 数组的最小相等和分类讨论。所有 \\(0\\) 都必须被替换为正整数，那么首先将所有 \\(0\\) 替换为 \\(1\\)。如果两个数组中都有 \\(0\\)，则此时得到的最大的数组和就应该是答案，因为较小的一方总是可以使用更大的正整数替换 \\(0\\)，使得两个数组的元素和相等。如果某个数组的和不等于最大和，并且数组中不包含 \\(0\\)，那么就无法使两个数组的元素和相等。 123456789101112131415161718class Solution { public long minSum(int[] nums1, int[] nums2) { int cnt1 = 0, cnt2 = 0; long sum1 = 0L, sum2 = 0L; for (int x : nums1) { if (x == 0) cnt1++; sum1 += x; } for (int x : nums2) { if (x == 0) cnt2++; sum2 += x; } long max = Math.max(sum1 + cnt1, sum2 + cnt2); if (sum1 != max &amp;&amp; cnt1 == 0) return -1; if (sum2 != max &amp;&amp; cnt2 == 0) return -1; return max; }} 使数组变美的最小增量运算数按照灵神的题解，每个位置的状态就是它右边有多少个数小于 \\(k\\)，加上这个维度就可以做记忆化搜索，然后转递推真的很妙。题解区还有其他的状态定义方式，可以看看。代码就贴灵神的。（这题感觉很不错，没有见过的类型） 123456789101112class Solution { public long minIncrementOperations(int[] nums, int k) { long f0 = 0, f1 = 0, f2 = 0; for (int x : nums) { long inc = f0 + Math.max(k - x, 0); f0 = Math.min(inc, f1); f1 = Math.min(inc, f2); f2 = inc; } return f0; }} 收集所有金币可获得的最大积分当我们遍历到某个节点时，它的状态就是需要除以多少次 \\(2\\)，由数据范围可知每个节点最多有 \\(15\\) 个状态。我们可以从子问题的最优解推出原问题的最优解，并且子问题可以独立求解，符合最优子结构；如果当前节点处于某个状态，它可能是由不同的路径转移得到的，即存在重叠子问题。所以我们可以使用树型 DP 求解该问题，列出如下状态转移方程： $$ dp[x][i]=\\max(\\sum_{y}{dp[y][i]}+(coins[x]>>i)-k,\\sum_{y}{dp[y][i + 1]}+(coins[x]>>(i+1))) $$ 其中 \\(dp[i][j]\\) 表示到达节点 \\(i\\)，需要除以 \\(2^{j}\\)，该状态下以节点 \\(i\\) 为根的子树能够得到的最大积分。 1234567891011121314151617181920212223242526272829303132class Solution { public int maximumPoints(int[][] edges, int[] coins, int k) { int n = coins.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, t -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } return dfs(0, -1, g, coins, k)[0]; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] coins, int k) { int[] sum1 = new int[15]; int[] sum2 = new int[15]; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g, coins, k); for (int i = 0; i &lt; 14; i++) { sum1[i] += t[i]; sum2[i] += t[i + 1]; } } for (int i = 0; i &lt; 14; i++) { sum1[i] = Math.max(sum1[i] + (coins[x] &gt;&gt; i) - k, sum2[i] + (coins[x] &gt;&gt; (i + 1))); } return sum1; }}","link":"/2023/10/29/%E7%AC%AC%20369%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 907 (Div. 2)","text":"Sorting with Twos因为每次只能操作区间 \\([1,2^{m}]\\)，所以 \\([2^{m}+1,2^{m+1}]\\) 内的所有数是同时进行操作的，它们需要满足非递减的性质，最后不要忘记结尾不能操作的数也需要满足条件。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { a[i] = io.nextInt(); } for (int i = 1; 1 &lt;&lt; i &lt;= n; i++) { int j = Math.min(1 &lt;&lt; (i + 1), n); for (int k = (1 &lt;&lt; i) + 1; k &lt; j; k++) { if (a[k] &gt; a[k + 1]) { io.println(&quot;NO&quot;); return; } } } io.println(&quot;YES&quot;);} Deja Vu如果一个数能够被 \\(2^{i}\\) 整除，那么操作之后，它只能被所有小于等于 \\(2^{i-1}\\) 的二的幂整除。所以预处理所有修改，只保留满足递减顺序的修改，然后模拟即可。或者也可以直接修改，不用预处理，在修改之前判断一下是否比上次小就行。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), q = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int mask = 0; for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); if (mask == 0 || (1 &lt;&lt; x) &lt;= (mask &amp; -mask)) { mask |= 1 &lt;&lt; x; } } for (int i = 0; i &lt; n; i++) { for (int j = 30; j &gt;= 0; j--) { if ((mask &gt;&gt; j &amp; 1) == 1 &amp;&amp; a[i] % (1 &lt;&lt; j) == 0) { a[i] += 1 &lt;&lt; (j - 1); } } } for (int i = 0; i &lt; n; i++) { io.print(a[i] + &quot; &quot;); } io.println();} Smilo and Monsters比赛时我是排序 + 相向双指针模拟的，先干前面的怪物，如果计数和最后一个的怪物群数量相等，则使用终极攻击，比较麻烦的是双指针到达同一个位置时，需要特判一些情况。然后下面的解法，很简洁啊。似乎总是可以使用普通攻击干掉怪物总数的一半向上取整，并且使用终极攻击干掉总数的一半向下取整。然后排序数组并倒序遍历，使得一次终极攻击干掉尽可能多的怪物，这样就得到最少攻击次数。 1234567891011121314151617public static void solve() { int n = io.nextInt(); int[] a = new int[n]; long sum = 0L; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } Arrays.sort(a); long ans = (sum + 1) / 2; sum /= 2; for (int i = n - 1; i &gt;= 0 &amp;&amp; sum &gt; 0; i--) { sum -= a[i]; ans++; } io.println(ans);} Suspicious logarithms\\(f(x)\\) 表示 \\(x\\) 的二进制表示中最高位的 \\(1\\) 所在的位数 \\(y\\)，而 \\(g(x)\\) 表示满足 \\(y^{z}&lt;= x\\) 条件的最大的 \\(z\\)。可以发现如果 \\(y=2,x=10^{18}\\)，则 \\(z=59\\)。我们可以枚举所有 \\(y\\in[2,59]\\)，对于特定的 \\(y\\)，枚举不同的 \\(z\\) 覆盖的区间范围。得到各个区间范围内所有数的 \\(z\\) 值，我们就可以在 \\(O(\\log{(r-l+1)})\\) 的时间复杂度内执行查询。为了避免乘法溢出，在进行比较时需要使用除法。其他人代码有直接使用 \\(\\log\\) 的，也比较简单啊，我还以为很麻烦，结果溢出没想到换除法。当然也可以维护前缀和，然后二分区间位置来进行查询。 12345678910111213141516171819202122232425262728293031323334private static final int MOD = (int) 1e9 + 7;private static final List&lt;long[]&gt;[] list = new List[60];static { Arrays.setAll(list, k -&gt; new ArrayList&lt;&gt;()); for (int f = 2; f &lt; 60; f++) { long l = 1L &lt;&lt; f, r = (1L &lt;&lt; f + 1) - 1; long k = f, g = 1; while (k &lt;= l / f) { k *= f; g++; } for (; l &lt;= r; l = k + 1, g++) { k = k &lt;= r / f ? k * f - 1 : r; list[f].add(new long[]{l, k, g}); } }}public static void solve() { long ans = 0L; long l = io.nextLong(), r = io.nextLong(); int i = 63 - Long.numberOfLeadingZeros(l); int j = 63 - Long.numberOfLeadingZeros(r); for (; i &lt;= j; i++) { for (long[] t : list[i]) { ans = (ans + (Math.max(0, Math.min(t[1], r) - Math.max(t[0], l) + 1)) * t[2]) % MOD; } } io.println(ans);} A Growing Tree每个节点的编号是添加该节点时树的大小，因为修改操作不会影响还未添加到树上的节点，所以我们对每个修改操作添加一个编号（时间），表示修改所影响的范围。我们可以使用单点修改、区间查询的树状数组维护修改操作的编号，然后按照 DFS 序遍历树，每当遍历到一个节点，使用树状数组进行单点修改，因为遍历是 DFS 序，所以当前节点的祖先节点已经进行过修改操作，那么当前节点的答案就是所有大于等于该节点编号的修改操作之和。 那么有没有可能该答案会包含其他满足编号大于当前节点的非祖先节点的修改操作呢，不会包含，因为遍历是 DFS 序，DFS 返回时会取消对节点的修改操作，所以每当遍历到一个节点，修改操作只会包含其祖先节点的修改操作。特别注意，数组开 \\(q+2\\) 的大小，因为初始时有一个根节点，所以节点数量最多为 \\(q+1\\)，然后编号从 \\(1\\) 开始。 12345678910111213141516171819202122232425262728293031323334353637public static void solve() { int q = io.nextInt(), sz = 1; List&lt;int[]&gt;[] queries = new List[q + 2]; Arrays.setAll(queries, k -&gt; new ArrayList&lt;&gt;()); List&lt;Integer&gt;[] g = new List[q + 2]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; q; i++) { int t = io.nextInt(); if (t == 1) { int v = io.nextInt(); g[v].add(++sz); } else { int v = io.nextInt(), x = io.nextInt(); queries[v].add(new int[]{sz, x}); } } var bit = new BIT(sz); long[] ans = new long[sz + 1]; dfs(1, sz, g, queries, bit, ans); for (int i = 1; i &lt;= sz; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs(int x, int sz, List&lt;Integer&gt;[] g, List&lt;int[]&gt;[] queries, BIT bit, long[] ans) { for (int[] q : queries[x]) { bit.add(q[0], q[1]); } ans[x] = bit.get(x, sz); for (int y : g[x]) { dfs(y, sz, g, queries, bit, ans); } for (int[] q : queries[x]) { bit.add(q[0], -q[1]); }}","link":"/2023/10/31/Codeforces%20Round%20907%20(Div.%202)/"},{"title":"图论","text":"本文内容参考《算法》，《算法导论》，OI Wiki。 拓扑排序例题 B3644 【模板】拓扑排序 / 家谱树。 实现 时间复杂度为 \\(O(n+m)\\)。 12345678910111213141516171819202122232425262728293031323334private static int[] topologicalSort(int n, int[][] edges) { int[] in = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); in[v]++; } Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } int idx = 0; int[] res = new int[n]; while (!q.isEmpty()) { int x = q.poll(); res[idx++] = x; for (int y : g[x]) { if (--in[y] == 0) { q.offer(y); } } } // 拓扑排序不存在 assert idx == n; return res;} 最小生成树例题 P3366 【模板】最小生成树。 Prim实现一：朴素版本 时间复杂度为 \\(O(n^{2})\\)。 12345678910111213141516171819202122232425262728293031323334353637383940private static int prim(int n, int[][] edges) { int[][] g = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(g[i], Integer.MAX_VALUE); g[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; if (g[u][v] &gt; w) { g[u][v] = g[v][u] = w; } } int[] d = new int[n]; Arrays.fill(d, Integer.MAX_VALUE); boolean[] vis = new boolean[n]; int res = 0; d[0] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) { t = j; } } // 不是连通图，最小生成树不存在 assert d[t] != Integer.MAX_VALUE; vis[t] = true; res += d[t]; for (int j = 0; j &lt; n; j++) { d[j] = Math.min(d[j], g[t][j]); } } return res;} 实现二：优先队列优化 时间复杂度为 \\(O(m\\log{m})\\)。 12345678910111213141516171819202122232425262728293031323334353637private static int prim(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] d = new int[n]; Arrays.fill(d, Integer.MAX_VALUE); boolean[] vis = new boolean[n]; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]); int res = 0, cnt = 0; d[0] = 0; q.offer(new int[]{0, 0}); while (!q.isEmpty()) { int u = q.poll()[0]; if (vis[u]) continue; vis[u] = true; res += d[u]; if (++cnt == n) break; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (!vis[v] &amp;&amp; d[v] &gt; w) { d[v] = w; q.offer(new int[]{v, d[v]}); } } } // 不是连通图，最小生成树不存在 assert cnt == n; return res;} Kruskal 时间复杂度为 \\(O(m\\log{m})\\)。 123456789101112131415161718private static int kruskal(int n, int[][] edges) { Arrays.sort(edges, (a, b) -&gt; a[2] - b[2]); int cnt = 1, res = 0; UnionFind uf = new UnionFind(n); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; if (uf.connected(u, v)) continue; uf.union(u, v); res += w; if (++cnt == n) break; } // 不是连通图，最小生成树不存在 assert cnt == n; return res;} 最短路例题 P4779 【模板】单源最短路径（标准版）。 B3647 【模板】Floyd。 Dijkstra 使用场景：解决边权非负的单源最短路问题。 实现一：朴素版本 时间复杂度为 \\(O(n^{2})\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static final int INF = (int) 1e9;private static int dijkstra(int n, int[][] edges) { int[][] g = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(g[i], INF); g[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u][v] = Math.min(g[u][v], w); } int[] d = new int[n]; Arrays.fill(d, INF); boolean[] vis = new boolean[n]; d[0] = 0; while (true) { int t = -1; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; (t == -1 || d[t] &gt; d[i])) { t = i; } } if (t == n - 1 || d[t] == INF) { break; } vis[t] = true; for (int i = 0; i &lt; n; i++) { d[i] = Math.min(d[i], d[t] + g[t][i]); } } return d[n - 1] == INF ? -1 : d[n - 1];} 实现二：优先队列优化 时间复杂度为 \\(O(m\\log{m})\\)。 123456789101112131415161718192021222324252627282930313233private static final int INF = (int) 1e9;private static int dijkstra(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); } int[] d = new int[n]; Arrays.fill(d, INF); boolean[] vis = new boolean[n]; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]); d[0] = 0; q.offer(new int[]{0, 0}); while (!q.isEmpty()) { int u = q.poll()[0]; if (u == n - 1) break; if (vis[u]) continue; vis[u] = true; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (d[v] &gt; d[u] + w) { d[v] = d[u] + w; q.offer(new int[]{v, d[v]}); } } } return d[n - 1] == INF ? -1 : d[n - 1];} Bellman-Ford 时间复杂度为 \\(O(nm)\\)。 使用场景：解决任意边权的单源最短路问题；判断是否存在负环；解决有边数限制的单源最短路问题。 实现一：朴素版本 1234567891011121314151617private static final int INF = (int) 1e9;private static int bellmanFord(int n, int[][] edges) { int[] d = new int[n]; Arrays.fill(d, INF); d[0] = 0; for (int i = 0; i &lt; n; i++) { for (var e : edges) { int u = e[0], v = e[1], w = e[2]; d[v] = Math.min(d[v], d[u] + w); } } // d[n - 1] == INF 时，最短路不存在 return d[n - 1];} 实现二：队列优化（不能存在负环） 123456789101112131415161718192021222324252627282930313233343536private static final int INF = (int) 1e9;private static int spfa(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); } int[] d = new int[n]; Arrays.fill(d, INF); Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); boolean[] on = new boolean[n]; d[0] = 0; q.offer(0); on[0] = true; while (!q.isEmpty()) { int u = q.poll(); on[u] = false; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (d[v] &gt; d[u] + w) { d[v] = d[u] + w; if (!on[v]) { q.offer(v); on[v] = true; } } } } // d[n - 1] == INF 时，最短路不存在 return d[n - 1];} Floyd-Warshall 时间复杂度为 \\(O(n^{3})\\)。 使用场景：解决任意边权的多源最短路问题。 123456789101112131415161718192021222324private static final int INF = (int) 1e9;private static int[][] floyd(int n, int[][] edges) { int[][] dp = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], INF); dp[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; dp[u][v] = Math.min(dp[u][v], w); } for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (dp[i][k] != INF &amp;&amp; dp[k][j] != INF) { dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]); } } } } return dp;} 最近公共祖先例题 P3379 【模板】最近公共祖先（LCA）。 倍增 预处理时间复杂度为 \\(O(n\\log{n})\\)，查询时间复杂度为 \\(O(\\log{n})\\)。 原理：\\(f[i][j]\\) 表示节点 \\(j\\) 的第 \\(2^{i}\\) 个祖先，当利用倍增得到 \\(f\\) 时，对于任意两个节点 \\(x,y\\)，先将较深的节点向上跳到相同深度，然后两个节点贪心的向上跳到 \\(\\operatorname{lca}\\) 下方距离它最近的节点，最后得到的节点就是 \\(\\operatorname{lca}\\) 的直接子节点。（在进行倍增时，根节点的父节点可以是任何值，因为该值不会影响算法的正确性） 123456789101112131415161718192021222324252627282930313233343536private static void dfs(int x, int fa, List&lt;Integer&gt;[] g, int[][] f, int[] d) { f[0][x] = fa; for (int i = 1; 1 &lt;&lt; i &lt;= d[x]; i++) { f[i][x] = f[i - 1][f[i - 1][x]]; } for (int y : g[x]) { if (y != fa) { d[y] = d[x] + 1; dfs(y, x, g, f, d); } }}private static int lca(int x, int y, int[][] f, int[] d) { if (d[x] &gt; d[y]) { int t = x; x = y; y = t; } int diff = d[y] - d[x]; for (int i = 0; i &lt; 31; i++) { if ((diff &gt;&gt; i &amp; 1) == 1) { y = f[i][y]; } } if (x != y) { for (int i = 30; i &gt;= 0; i--) { if (f[i][x] != f[i][y]) { x = f[i][x]; y = f[i][y]; } } x = f[0][x]; } return x;} Tarjan 离线查询算法，时间复杂度为 \\(O((n+m)\\log{n})\\)。更精确的复杂度分析可以使用反阿克曼函数。 原理：每当处理完一个子树，就将该子树的根节点和其父节点合并，特别注意合并的方向是 \\(f[y]=x\\)。然后我们会遍历包含当前节点 \\(x\\) 的查询，如果另一个节点 \\(y\\) 访问过，则 \\(\\operatorname{lca}(x,y)=\\operatorname{find}(y)\\)。至于为什么是这样，可以通过分类讨论得到。注意 \\(q\\) 需要像无向图一样，为单个查询存储双向边。 12345678910111213141516private static void tarjan(int x, List&lt;Integer&gt;[] g, boolean[] vis, UnionFind uf, List&lt;int[]&gt;[] q, int[] ans) { vis[x] = true; for (int y : g[x]) { if (!vis[y]) { tarjan(y, g, vis, uf, q, ans); uf.union(x, y); // 注意 f[y] = x } } for (int[] t : q[x]) { int y = t[0], i = t[1]; if (vis[y]) { ans[i] = uf.find(y); } }} 树链剖分 预处理时间复杂度为 \\(O(n)\\)，查询时间复杂度为 \\(O(\\log{n})\\)。 原理：将树划分为若干重链，树中的每条路径不会包含超过 \\(\\log{n}\\) 条不同的重链，所以查询的时间复杂度为 \\(O(\\log{n})\\)。第一次 DFS 得到每个节点的父节点，深度，以及根据子树大小得到每个节点的重子节点。第二次 DFS 通过优先遍历重子节点，再遍历轻子节点，从而得到每个节点所在重链的头节点。然后就可以进行查询，通过比较 \\(x,y\\) 所在重链的头节点，来向上跳跃，最终得到 \\(\\operatorname{lca}\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static void dfs1(int x, int fa, List&lt;Integer&gt;[] g, int[] f, int[] d, int[] s, int[] h) { f[x] = fa; s[x] = 1; h[x] = -1; for (int y : g[x]) { if (y != fa) { d[y] = d[x] + 1; dfs1(y, x, g, f, d, s, h); s[x] += s[y]; if (h[x] == -1 || s[h[x]] &lt; s[y]) { h[x] = y; } } }}private static void dfs2(int x, int head, List&lt;Integer&gt;[] g, int[] f, int[] h, int[] t) { t[x] = head; if (h[x] == -1) { return; } dfs2(h[x], head, g, f, h, t); for (int y : g[x]) { if (y != f[x] &amp;&amp; y != h[x]) { dfs2(y, y, g, f, h, t); } }}private static int lca(int x, int y, int[] f, int[] d, int[] t) { while (t[x] != t[y]) { if (d[t[x]] &gt; d[t[y]]) { x = f[t[x]]; } else { y = f[t[y]]; } } return d[x] &lt; d[y] ? x : y;} 强连通分量例题 P2863 [USACO06JAN] The Cow Prom S。 Tarjan 时间复杂度为 \\(O(n+m)\\)。 原理：\\(dfn[x]\\) 表示节点 \\(x\\) 的 DFS 编号；\\(low[x]\\) 表示节点 \\(x\\) 能够到达的节点的最小的 DFS 编号。我们将图看作一棵树，并定义四种边，那么强连通分量的根节点就是该分量中第一个被遍历到的节点，满足 \\(dfn[x]=low[x]\\)，所以，过程很复杂，难以描述，直接看 wiki 吧。（注意使用的时候，将 \\(dfn\\) 初始化为 \\(-1\\)，并且对所有节点调用该算法前，需要判断 \\(dfn=-1\\) 是否成立） 1234567891011121314151617181920212223242526private static int dfnCnt, sccCnt;private static void tarjan(int x, List&lt;Integer&gt;[] g, int[] dfn, int[] low, Deque&lt;Integer&gt; stk, boolean[] on, int[] scc, int[] size) { dfn[x] = low[x] = dfnCnt++; stk.push(x); on[x] = true; for (int y : g[x]) { if (dfn[y] == -1) { tarjan(y, g, dfn, low, stk, on, scc, size); low[x] = Math.min(low[x], low[y]); } else if (on[y]) { low[x] = Math.min(low[x], dfn[y]); } } if (dfn[x] == low[x]) { for (int y = -1; y != x; ) { y = stk.pop(); on[y] = false; scc[y] = sccCnt; size[sccCnt]++; } sccCnt++; }}","link":"/2023/10/31/%E5%9B%BE%E8%AE%BA/"},{"title":"Project #3 - Query Execution","text":"项目准备项目地址：Project #3 - Query Execution。 准备工作：阅读 Chapter 15 16 22，学习 Lecture #10 #11 #12 #13 #14，以及阅读课堂笔记。 项目结构通过查看 sqllogictest.cpp，可以知道 SQL 语句的整个执行流程。首先调用 SQLLogicTestParser::Parse 将测试文件解析为多个测试记录，然后根据记录的类型分别处理。目前我们主要关注查询语句，只需查看 BustubInstance::ExecuteSqlTxn 函数的代码。如项目介绍描述的那样，代码分别执行 Binder,Planner,Optimize,ExecutionEngine。然后，本来想详细分析一下整个流程，但是由于时间原因，以及项目确实比较复杂，所以暂时搁置。 Task #1 - Access Method Executors实现① 遇到第一个问题，如何在 SeqScanExecutor 中遍历表，可以发现 exec_ctx 成员所属的类 ExecutorContext 中有一个 GetCatalog 方法，只要拿到 Catalog 就可以根据 plan_ 中的信息拿到 TableHeap 的迭代器 TableIterator。然后第二个问题就是如何存储迭代器，TableIterator 是不可复制的，我们可以使用 unique_ptr 来存储迭代器，并使用 make_unique 初始化。（注意，不能在构造函数初始化，一定要在 Init 函数中初始化，不然多次全表扫描会出问题！） ② 实现 Insert 时报错 “The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table”，并且可以看到 Next 函数的注释中表示 “tuple The integer tuple indicating the number of rows inserted into the table”。说实话有点难以理解，我一开始以为每次调用 Next 会像迭代器模式一样，只执行一次插入，但是这样实现就会报上面的错误。然后通过查看 Discord 的讨论，发现是一次性插入所有记录，因为只要返回 true 就会打印插入的行数，返回 false 就不会打印。当插入零行时，还必须打印一个零，这说明，Next 必定要先返回 true，再返回 false。并且在构造 tuple 时需要使用 BIGINT 类型，不然会报其他错误（明明注释说的是 INTEGER 额）。 ③ 在 Insert 的同时需要更新索引，一开始我是直接用普通的 tuple 作为 InsertEntry 的参数，结果在测试 p3.05-index-scan.slt 时报 stack buffer overflow 错误。通过 Debug 发现，在 InsertEntry 时会调用 GenericKey 类的 SetFromKey 函数，该函数会将 tuple 的数据拷贝到该类的 data_ 成员中，作为索引的 key 使用。所以传入的 tuple 必须只包含 key，那么如何确定 tuple 中的哪个数据是 key 呢。可以发现 Tuple 类中有 KeyFromTuple 函数，它的会生成只包含 key 的 tuple，因为需要的索引的 key，那么该函数必定需要传入和索引相关的模式，以及 key 所在列的下标，这些信息可以在 IndexInfo 中找到。（之前我有点迷糊，当成 MySQL 默认使用主键索引了，BusTub 使用的是 TableHeap，也就是说表默认是没有索引的） ④ 实现时不要使用 GetTableOid 函数，因为线上测试的函数名是 TableOid，可能是因为我 fork 的版本太新了，仓库的代码和测试代码不一样，所以只能直接使用 table_oid_ 成员。 ⑤ 实现 update 时要注意，在创建新 tuple 时，使用的是 child_executor_-&gt;GetOutputSchema()，而不是 GetOutputSchema()。 ⑥ 实现 index_scan 时，会使用到 b_plus_tree_index.h 中定义的别名，如 BPlusTreeIndexIteratorForTwoIntegerColumn。 ⑧ 在 IndexScan 的提示中有这么一句话，“do not emit tuples that are deleted”，但是当从表中删除 tuple 时，也会从索引中删除对应的 key，所以应该不会遍历到已经删除的 key 才对，也就是说此时应该不用特判 TupleMeta 中的 is_deleted_ 成员。 ⑨ 测试 p3.06-empty-table.slt 时，遇到 B+Tree 迭代器实现问题。当 B+Tree 的为 empty 时，获取迭代器我原来是抛出异常，现在改为返回一个默认构造的迭代器。 补充① 当没有显示声明复制/移动构造函数或复制/移动运算符，以及析构函数时，编译器才会隐式生成这些函数（其他更复杂的情况可以查看 cppreference.com）。 ② 创建 TupleMeta 时，会将 insertion_txn 和 deletion_txn_ 都初始化为 INVALID_TXN_ID，提示表示这些成员会在以后切换到 MVCC 存储时使用，有点遗憾没能体验一下。 ③ vector 的 reserve 只会影响 capacity 的大小，而不会影响 size，讨论在此。 ④ 重载前置和后置 ++ 的区别，前置 ++ 的重载声明为 operator++()，后置 ++ 的重载声明为 operator++(int)。 ⑤ 为什么应该将移动构造声明为 noexcept，可以阅读 Friendly reminder to mark your move constructors noexcept。 Task #2 - Aggregation &amp; Join Executors实现① 一开始实现真摸不着头脑，AggregationPlanNode 里面怎么这么多东西。group_bys 是指 GROUP BY 时对列的求值表达式，aggregates 是指使用聚合函数时对列的求值表达式，agg_types 是指聚合函数的类型。例如：GROUP BY DAY(col)、MIN(col1 + col2)。我们使用 InsertCombine 函数向哈希表插入值，参数可以使用 MakeAggregateKey 和 MakeAggregateValue 函数获得。 ② 根据项目介绍，AggregationExecutor::Next 返回的 tuple 应该包含 key 和 value（我没看到，找错好难）。特别需要注意，当哈希表为空时，应该返回什么：如果是对某列进行 GROUP BY 操作，那么就返回 false，因为有个测试用例有注释 no groups, no output；否则，返回 true，并且 tuple 存储聚合函数的默认值。（可以通过判断 key 模式的列数是否为零，或者 value 模式的列数是否等于 plan_ 输出模式的列数，来判断当前是否对某列进行 GROUP BY 操作） ③ 实现 NestedLoopJoinExecutor：外层循环遍历左表，内层循环遍历右表，只有当右表遍历完，才会获取下一个左表中的元组。但是，因为每找到一个匹配就会返回，所以我们应该将左表的元组作为数据成员，并且添加一个标志表示右表是否遍历完。每当右表遍历完成，都需要重置标志，获取左表中的下一个元组，并且重新 Init 右表。我们调用 EvaluateJoin 判断元组是否匹配，如果匹配，就将两个元组合并为一个元组。特别注意，如果当前是左连接，并且左元组没有匹配任何右元组，仍然需要返回一个为右元组填充 null 值的合并元组。比较迷惑的是怎么表示 null，我的想法是根据列类型获取对应的 null 值，但是找不到这样的函数，所以我就直接返回 BUSTUB_INT32_NULL 了。突然看到聚合执行器里用到 ValueFactory::GetNullValueByType 函数，太久没写项目给忘了。我还遇到一个 BUG，调试半天，发现我没有在 Init 函数中初始化 SeqScanExecutor 的迭代器，导致重复调用 Init 时不会重置迭代器。 ④ 实现 HashJoin：根据提示我们可以参考 SimpleAggregationHashTable 的实现建立一个哈希表，我们创建一个 JoinKey 类作为键，然后创建一个 hash&lt;bustub::JoinKey&gt; 类，直接复制 aggregation_plan.h 中的代码改个名字就行（不然 C++ 真不熟，又要搞半天）。在哈希表中，将 vector&lt;Tuple&gt; 作为值以处理哈希冲突。搞定哈希的方式之后，我们可以像 aggregation_executor.h 一样添加两个辅助函数 MakeLeftJoinKey 和 MakeRightJoinKey。然后直接在 Init 中对左表建立哈希表，在 Next 中遍历右表，类似 NestedLoopJoinExecutor 的实现，只不过此时需要维护更多的数据成员。特别需要注意如何处理左连接，因为我们是将左表建为哈希表，那么在遍历完右表后，还需要处理没有任何匹配的左表中的元组。这可以在匹配时将元组的地址存储在 unordered_set 中，然后在遍历完右表后再遍历一次左表，并检查 unordered_set 来判断是否输出。（之前我是将元组的 RID 存储到集合中作为标识，但是这是错误的，因为左表可能是临时表，其中元组的 RID 是无效的内容；我们也可以为右表建立哈希表而不是左表，这样对于左连接来说，更好处理） ⑤ 实现 Optimizing NestedLoopJoin to HashJoin：非常的神奇，参考 nlj_as_index_join.cpp 瞎改，感觉代码是一坨，但是竟然没有任何错误，直接通过测试（激动半天）。具体实现的话，一开始我以为传入的参数就是 NestedLoopJoin 计划节点，但是似乎不是，所以我们需要遍历当前计划的子节点，递归的进行优化。之前比较令我迷惑的一点，怎么判断表达式是否是某个类型，我查找很久 API 都没有找到类似的函数，然后想到 Project #0 中好像是直接做 dynamic_cast 转换，如果返回值为 nullptr 就表示类型不匹配，查看 nlj_as_index_join.cpp 发现果然是这样。搞定表达式类型判断之后，就可以根据 ColumnValueExpression::GetTupleIdx 值来交换左右表达式，并返回转换后的节点。 Task #3 - Sort + Limit Executors and Top-N OptimizationEasy！只有两点需要注意：一个是每次调用 Init 时都要初始化所有数据成员，不然下次调用会包含上次调用的数据；第二个是 C++ 的 priority_queue 默认是大顶堆，并且比较器和 Java 中的用法完全相反。 Optional Leaderboard Tasks① 初次提交。 ② 之后优化。 Rank Submission Name Q1 Q2 Q3 Time 123 ALEX 740 30000 4839 4754 测试结果 123456789101112131415161718192021222324252627282930#!/bin/bashmake sqllogictest -j$(nproc)./bin/bustub-sqllogictest ../test/sql/p3.00-primer.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.01-seqscan.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.02-insert.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.04-delete.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.03-update.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.05-index-scan.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.06-empty-table.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.07-simple-agg.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.08-group-agg-1.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.09-group-agg-2.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.10-simple-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.11-multi-way-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.12-repeat-execute.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.14-hash-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.15-multi-way-hash-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.16-sort-limit.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.17-topn.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.18-integration-1.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.19-integration-2.slt --verbosemake formatmake check-lintmake check-clang-tidy-p3make submit-p3 项目小结项目难度主要在项目理解上，常常是不理解某些变量的实际含义，或者知道该怎么做，却找不到对应的 API，或者对返回值理解有错误，而函数文档也不清晰。最后，看到实现的代码能够执行各种 SQL 语句，感觉还是很不错的。","link":"/2023/11/03/Project%203%20-%20Query%20Execution/"},{"title":"2023 OceanBase 数据库大赛","text":"比赛信息 大赛报名。 MiniOB-2023 赛题。 2023 OceanBase 数据库大赛FAQ。 使用 Docker 搭建开发环境 启动报错 Docker Desktop - Unexpected WSL error，搜索半天解决方案，结果是没开 Windows Hypervisor Platform，解决方案在此。 如何在 CLion 中使用 Docker。 遇到 CLion 的 Bug，在 CLion 内置的 Docker 终端无法进行输入，我们直接使用 Docker 客户端打开终端。 终端使用上下左右方向键显示奇怪的编码，似乎是因为默认使用的是 shell，它不支持方向键，我们可以使用 bash 来解决问题，解决方案。 使用 build 构建项目时，报错 $'\\r': command not found，这是 Windows 的换行符和 Linux 不同导致的。为了避免在 clone 时进行换行符的转换，可以添加 autocrlf=false 到全局配置文件，或者可以在克隆的命令中添加该参数，更多详细的设置方法可以参考 GitHub 文档。","link":"/2023/11/03/2023%20OceanBase%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E8%B5%9B/"},{"title":"Educational Codeforces Round 157 (Rated for Div. 2)","text":"Treasure Chest至少走 \\(\\max(x,y)\\) 步，因为最多能扛起箱子 \\(k\\) 秒，所以会往回走 \\(\\max(0,y-x-k)\\) 步。 1234public static void solve() { int x = io.nextInt(), y = io.nextInt(), k = io.nextInt(); io.println(Math.max(x, y) + Math.max(0, y - x - k));} Points and Minimum Distance排序，然后将数组分为左右两部分，分别代表 \\(x,y\\) 坐标序列。可以证明，这是最优的。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[2 * n]; for (int i = 0; i &lt; 2 * n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); io.println(a[n - 1] - a[0] + a[2 * n - 1] - a[n]); for (int i = 0; i &lt; n; i++) { io.println(a[i] + &quot; &quot; + a[i + n]); }} Torn Lucky Ticket对于每个字符串 \\(s_{i}\\)，我们枚举合并字符串的中心位置，这样就可以知道需要在前缀或后缀补上长度以及总和为多少的字符串，使得合并字符串为幸运的。因为合并字符串的中心位置可能不在当前字符串上，所以我们按照长度从小到大处理字符串，这样可以保证不漏掉任何情况。特别的，每个字符串都可以和自身连接成为幸运串。或者也可以进行预处理，这样就不用排序。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(); char[][] arr = new char[n][]; for (int i = 0; i &lt; n; i++) { arr[i] = io.next().toCharArray(); } Arrays.sort(arr, (s1, s2) -&gt; s1.length - s2.length); long ans = 0L; int[][] dp = new int[6][46]; for (char[] s : arr) { int m = s.length; int[] sum = new int[m + 1]; for (int j = 0; j &lt; m; j++) { sum[j + 1] = sum[j] + s[j] - '0'; } for (int j = m / 2 + 1; j &lt;= m; j++) { ans += dp[2 * j - m][Math.max(0, 2 * sum[j] - sum[m])]; ans += dp[2 * j - m][Math.max(0, sum[m] - 2 * sum[m - j])]; } dp[m][sum[m]]++; } io.println(ans + n);} XOR Construction首先构造满足第二个条件的数组 \\(b\\)，我们让 \\(b_{n}=0\\)，然后前面的每个元素 \\(b_{i}=a_{i}\\oplus a_{i+1}\\oplus\\cdots\\oplus a_{n-1}\\)，这样就得到满足第二个条件的数组，可以通过后缀异或得到。那么如何让 \\(b\\) 包含从 \\(0\\) 到 \\(n-1\\) 的每个数，因为数据保证总是可以构造出这样的序列，也就是说我们得到的数组 \\(b\\) 异或某个数，就能够得到目标数组。单独考虑每一位是否需要异或，可以发现，如果该位 \\(1\\) 的数量大于 \\(0\\) 的数量就需要进行异或操作。 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n - 1; i++) { a[i] = io.nextInt(); } for (int i = n - 2; i &gt;= 0; i--) { a[i] = a[i] ^ a[i + 1]; } int[] d = new int[30]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 30; j++) { d[j] += a[i] &gt;&gt; j &amp; 1; } } int mask = 0; for (int i = 0; i &lt; 30; i++) { if (d[i] &gt; n - d[i]) { mask |= 1 &lt;&lt; i; } } for (int i = 0; i &lt; n; i++) { io.print((a[i] ^ mask) + &quot; &quot;); } io.println();}","link":"/2023/11/04/Educational%20Codeforces%20Round%20157%20(Rated%20for%20Div.%202)/"},{"title":"第 370 场力扣周赛","text":"找到冠军 I如果某一列全为 \\(0\\)，则该列表示的队伍会成为冠军。 123456789101112131415class Solution { public int findChampion(int[][] grid) { int n = grid.length; for (int j = 0; j &lt; n; j++) { int cnt = 0; for (int i = 0; i &lt; n &amp;&amp; cnt == 0; i++) { cnt += grid[i][j]; } if (cnt == 0) { return j; } } return -1; }} 找到冠军 II相当于判断入度为 \\(0\\) 的节点是否只有一个。 12345678910111213141516class Solution { public int findChampion(int n, int[][] edges) { int[] in = new int[n]; for (var e : edges) { in[e[1]]++; } int ans = -1; for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { if (ans == -1) ans = i; else return -1; } } return ans; }} 在树上执行操作以后得到的最大分数树形 DP，要求最大分数，可以先求损失的最小分数，然后使用总分减去该分数即可。 123456789101112131415161718192021222324252627282930class Solution { public long maximumScoreAfterOperations(int[][] edges, int[] values) { int n = values.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } long ans = 0L; for (int x : values) { ans += x; } return ans - dfs(0, -1, g, values); } private long dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] values) { if (g[x].size() == 1 &amp;&amp; g[x].get(0) == fa) { return values[x]; } long res = 0L; for (int y : g[x]) { if (y != fa) { res += dfs(y, x, g, values); } } return Math.min(res, values[x]); }} 也可以直接正向做，对于每个节点有两种情况：选择当前节点，要求该节点的每个子树都是健康的；不选当前节点，该节点的所有子节点都可以选。 123456789101112131415161718192021222324252627282930class Solution { public long maximumScoreAfterOperations(int[][] edges, int[] values) { int n = values.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } long[] sum = new long[n]; return dfs(0, -1, g, values, sum); } private long dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] values, long[] sum) { sum[x] = values[x]; if (g[x].size() == 1 &amp;&amp; g[x].get(0) == fa) { return 0; } long dp0 = values[x], dp1 = 0; for (int y : g[x]) { if (y != fa) { dp0 += dfs(y, x, g, values, sum); dp1 += sum[y]; } } sum[x] += dp1; return Math.max(dp0, dp1); }} 平衡子序列的最大和离散化 + 树状数组优化 DP，直接看灵神代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 作者：灵茶山艾府// 链接：https://leetcode.cn/problems/maximum-balanced-subsequence-sum/solutions/2513121/shu-zhuang-shu-zu-you-hua-dp-by-endlessc-3zf4/class Solution { public long maxBalancedSubsequenceSum(int[] nums) { int n = nums.length; int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = nums[i] - i; } Arrays.sort(b); BIT t = new BIT(b.length + 1); for (int i = 0; i &lt; n; i++) { // j 为 nums[i]-i 离散化后的值（从 1 开始） int j = Arrays.binarySearch(b, nums[i] - i) + 1; long f = Math.max(t.preMax(j), 0) + nums[i]; t.update(j, f); } return t.preMax(b.length); }}// 树状数组模板（维护前缀最大值）class BIT { private long[] tree; public BIT(int n) { tree = new long[n]; Arrays.fill(tree, Long.MIN_VALUE); } public void update(int i, long val) { while (i &lt; tree.length) { tree[i] = Math.max(tree[i], val); i += i &amp; -i; } } public long preMax(int i) { long res = Long.MIN_VALUE; while (i &gt; 0) { res = Math.max(res, tree[i]); i &amp;= i - 1; } return res; }}","link":"/2023/11/07/%E7%AC%AC%20370%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 908 (Div. 2)","text":"Secret Sport因为题目保证存在合法的 \\(X\\) 和 \\(Y\\)，那么获胜者总是最后一个下棋者，因为如果不是最后一个，那么对局就不会结束。 12345public static void solve() { int n = io.nextInt(); String s = io.next(); io.println(s.charAt(n - 1));} Two Out of Three对于一组相同元素，它只能满足一个条件，如果满足两个条件，那么它必定会满足三个条件。所以至少要有两组出现次数大于等于 \\(2\\) 的元素，然后分别让其满足一个条件即可。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int k = 2; int[] b = new int[n]; Arrays.fill(b, 1); int[] cnt = new int[101]; for (int i = 0; i &lt; n &amp;&amp; k &lt;= 3; i++) { if (++cnt[a[i]] == 2) { b[i] = k++; } } if (k &lt;= 3) { io.println(-1); return; } for (int i = 0; i &lt; n; i++) { io.print(b[i] + &quot; &quot;); } io.println();} Anonymous Informant如果当前数组是通过移动得到，那么它的最后一个元素必定是由定点元素转移过来，所以我们只需要判断最后一个元素是否在 \\([1,n]\\) 范围内，然后不断地回滚左移操作，即不断地找到移动之前的最后一个元素位置，并进行判断即可。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int i = n - 1; while (b[i] != -1 &amp;&amp; b[i] &lt; n &amp;&amp; --k &gt; 0) { int j = (i - (b[i] + 1) + n) % n; b[i] = -1; i = j; } io.println(k == 0 || b[i] == -1 ? &quot;Yes&quot; : &quot;No&quot;);} Neutral Tonality我们总是可以构造一个数组 \\(c\\)，使得 \\(\\operatorname{LIS}(c)=\\operatorname{LIS}(a)\\)，方法为将数组 \\(b\\) 中的元素 \\(b_{i}\\)，插入到数组 \\(a\\) 中第一个满足 \\(a_{j}\\leq b_{i}\\) 的元素 \\(a_{j}\\) 之前，操作方式类似归并排序。 12345678910111213141516171819202122232425262728293031public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var b = new Integer[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b, ((e1, e2) -&gt; e2 - e1)); int i = 0, j = 0, k = 0; int[] ans = new int[n + m]; while (i &lt; n || j &lt; m) { if (i &gt;= n) { ans[k++] = b[j++]; } else if (j &gt;= m) { ans[k++] = a[i++]; } else if (a[i] &lt;= b[j]) { ans[k++] = b[j++]; } else { ans[k++] = a[i++]; } } for (int x : ans) { io.print(x + &quot; &quot;); } io.println();}","link":"/2023/11/08/Codeforces%20Round%20908%20(Div.%202)/"},{"title":"Project #4 - Concurrency Control","text":"项目准备项目地址：Project #4 - Concurrency Control。 准备工作：阅读 Chapter 18 19，学习 Lecture #15 #16 #17 #18 #19 #20，以及阅读课堂笔记。 项目结构项目的注释中有锁升级的矩阵图，但是没有兼容性的矩阵图，这里贴一下。 Task #1 - Lock Manager实现① 比较关键的一个问题是，LockRequestQueue 里面存什么。我之前漏掉 granted_ 成员，导致整个项目理解都有问题。一个请求会经历未获取锁、已获取锁，已释放锁三个过程，LockRequestQueue 存储所有没有被释放的锁请求，即前两个过程。因为之后能否获取锁，需要和之前已经获取的锁做兼容性判断。 ② 加锁阶段： 代码组织：我们可以根据请求的锁模式来分类讨论，也可以根据事务的锁模式来分类讨论，也可以根据事务是否有锁进行分类讨论。我最后是选择最后一种方式，这样写起来真的简洁。如果当前事务没有该资源的锁，则将请求入队，并且根据该资源是否被其他事务上锁，从而直接拿锁或者进行等待；否则，判断能否进行锁升级。 锁升级： 根据提示，首先判断请求的锁模式是否和事务的锁模式是否相同，如果相同则直接返回 true。我在这里有个比较疑惑的点，如果请求锁模式的级别低于当前持有的锁模式，应该也可以直接返回 true，但是注释中并没有提及，并且线上测试结果告诉我不行，必须抛出异常。似乎是设计的问题，讨论在此，而且这个讨论似乎说的也不完整。 然后判断是否可以锁升级，如果可以，我们需要释放之前的锁，并等待获取升级的锁。这两个步骤可以通过修改队列中的 LockRequest 实现，将锁模式修改为新的锁模式，将 granted_ 修改为 false，然后 cv_.wait() 即可。关键是条件变量的获取锁的条件如何编写。注意，一定要在等待之前从当前事务的锁集中移除原来的锁，因为线上测试会在等待时检查锁集。 获取锁：如何以 FIFO 的方式获取锁，并且使兼容的锁可以同时获取，以及使锁升级的优先级最高。遍历请求队列，如果当前事务是锁升级请求，则只需判断当前请求是否和已 granted_ 的请求兼容。如果当前事务不是锁升级请求，并且存在其他事务的锁升级请求，则直接返回 false，否则不仅需要判断当前请求是否和已 granted_ 的请求兼容，还需要判断当前请求是否和在该请求之前的未 granted_ 的请求兼容。 ③ 解锁阶段：按照注释模拟，需要注意从队列中移除完成的锁请求，并在最后执行 cv_.notify_all()。 ④ 事务的 ABORTED 状态：如果事务被中止，那么应该取消该事务所做的操作，事务中止之后会自动调用 TransactionManager::Abort 函数来进行解锁和还原所有写操作。但是如果事务在等待锁的过程中被中止，那么就需要我们手动重置，因为 Abort 函数不会清除未获取锁的请求。步骤如下：在使用条件变量时，额外判断当前事务的状态是否是 ABORTED，如果是则直接退出等待，并从队列中移除该请求，如果是锁升级还要记得重置 upgrading_，最后调用 cv_.notify_all() 并返回 false。 补充① 一个细节问题，在获取 map 中的 LockRequestQueue 时，我依赖 C++ 在使用 [] 访问会自动创建对象的特性，没有注意到 map 中存的是智能指针，这样默认是创建空指针，结果就会报各种奇怪的错误。 ② 表解锁同样需要改变事务的状态，一开始我天真的以为只需要在行解锁的时候改变就行，因为我以为加表锁必定会加行锁，但是不是这样的，可以只加表锁（或许全表扫描就是只加表锁而不加行锁）。 ③ 线上测试遇到神奇的错误，pthread_mutex_lock.c:94: _pthread_mutex_lock: Assertion ‘mutex-&gt;data.__owner == 0’ failed，而且不是每次测试都会发生。经过排查，发现又是自动补全的锅，导致重复执行 unlock() 操作，有关该错误的讨论在此。 ④ 目前似乎不需要使用事务锁，单个事务加锁/解锁是单线程的。 Task #2 - Deadlock Detection① 构建等待图，使用二重循环遍历 table_lock_map_ 和 row_lock_map_ 来向 waits_for_ 添加从 granted_ == false 请求到 granted_ == true 请求的边。其实这样单纯的加边是比较简单的，但是可能存在锁兼容的情况，这样构成的环是不会造成死锁的，导致误杀事务，不过测试能过就不改代码了。记得加锁。 ② 因为可以存在很多环，如果检测顺序不一样，中止的事务可能完全不同，所以 NOTES 中要求我们从最小的事务开始做 DFS，按照从小到大的顺序遍历相邻节点，如果找到环，则中止环中最大的事务。如果事务被中止，则应该从图中删掉连接该事务的边，或者也可以打标记。有坑！！！HasCycle 应该包含什么代码，之前我是把最小事务编号作为参数传递，然后从该事务开始做 DFS 来检测环。但是线上 GraphTest 测试会调用 HasCycle，按照线上测试代码的逻辑，HashCycle 应该包含整个环检测代码，包括排序 waits_for_，排序 GetEdgeList 得到的边集，以及 DFS。特别注意，不要在 HashCycle 中调用 txn_manager_ 的任何方法，因为 GraphTest 测试根本就没创建事务！！！我是调试半天找不到错，才反应过来，非常无语。 ③ 最后，从 HasCycle 返回时，删除中止事务的边，然后调用 TransactionManager::Abort 函数中止事务。在消除所有环之后清空 waits_for_。 Task #3 - Concurrent Query Execution① 非常非常无语！！！就是我在 Task#1 中提到的，高级锁可以包含低级锁的需求，不应该抛出异常，结果测试不给过，Task#3 又需要我兼容这种情况，那么只能在 Executor 代码中特判了。 ② 根据提示，should not acquire S/X table lock, grab IS/IX instead，只为表加 IS/IX 锁。 ③ 细节问题：行加锁之后再判断行是否删除，这个错误找很长时间才发现；死锁检测在调用 Abort 函数之前，先将事务状态设置为 ABORTED，否则当前事务可能会在之后的解锁过程中被唤醒，触发 LOCK_ON_SHRINKING 异常；实现 Abort 函数时，将恢复阶段放在解锁阶段之前，不然可能会有并发问题。 Leaderboard Task (Optional)① 初次提交。 Rank Submission Name Update QPS Count QPS Weighted QPS 59 ALEX 14 14 14 测试结果 12345678910111213#!/bin/bashmake lock_manager_test -j$(nproc)make deadlock_detection_test -j`nproc`make txn_integration_test -j`nproc`make -j`nproc` terrier-bench ./test/lock_manager_test./test/deadlock_detection_test./test/txn_integration_test./bin/bustub-terrier-bench --duration 30000make formatmake check-lintmake check-clang-tidy-p4make submit-p4 项目小结难点就在项目理解以及代码细节上，Task#1 和 Task#2 被队列和 HashCycle 的理解整晕了，然后要使代码能够在多线程情况下正常运行，一定要注意代码中逻辑的先后顺序！！！实现过程部分参考做个数据库：2022 CMU15-445 Project4 Concurrency Control，Task#1 的解释帮助很大。","link":"/2023/11/14/Project%204%20-%20Concurrency%20Control/"},{"title":"第 371 场力扣周赛","text":"找出强数对的最大异或值 I暴力。 高访问员工模拟。 最大化数组末位元素的最少操作次数两种情况，分类讨论。 找出强数对的最大异或值 II要找满足 \\(\\mid x-y\\mid\\leq\\min(x,y)\\) 的数对，可以排序化简公式，得到 \\(x\\leq y\\leq2x\\)。然后我们可以使用双指针，枚举 \\(y\\) 或者 \\(x\\) 都行，基本上就是把满足条件的数添加到 0-1 trie 树中，把不满足条件的从树中删除，一边枚举一边计算最大异或值。还可以使用哈希表做，参考灵茶山艾府的题解。","link":"/2023/11/14/%E7%AC%AC%20371%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"CUM 15-445 课程总结","text":"幻灯片和笔记，其他同学整理的笔记，Discord 讨论，dbdb.io。 本来想做个课程总结和项目总结的，但是有点没心情做，排行榜优化也暂时搁置吧。:( 更新：还是做一下总结，课程的内容不只下面这些，有很多内容对我来说可能用不到，所以没有记录。 Advanced SQL 查询满足某个条件的记录数量： 12SELECT COUNT(*) FROM t WHERE xx;SELECT SUM(IF(xx, 1, 0)) FROM t; 查询满足某个条件的记录百分率： 1SELECT ROUND(AVG(IFNULL(xx, 0)), 2) FROM t; 窗口函数（文档：12.20 Window Functions）： 12SELECT ROW_NUMBER() OVER(PARTITION BY xx ORDER BY xx) FROM t;SELECT AVG(xx) OVER (PARTITION BY xx ORDER BY xx ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) 日期和时间函数（文档：12.7 Date and Time Functions）： 12SELECT DATE_FORMAT(xx, xx);SELECT DATEDIFF(xx, xx); Database Storage 课程主要介绍面向磁盘的 DBMS，数据库以文件的形式存储在磁盘上，文件以特定于 DBMS 的方式编码，它被表示为页面的集合，每个页面都会有一个唯一标识符（页面 ID），大多数 DBMS 使用哈希表将页面 ID 映射为文件路径和文件内的偏移量。注意区分硬件页面（通常为 4 KB）、操作系统页面（4 KB）和数据库页面（1-16 KB）。存储设备可以保证硬件页面的原子写入，如果数据库页面大于硬件页面，则 DBMS 需要采取额外的措施来保证原子性。 每个页面被分为两部分：页面头部和页面内容。页面头部用于记录有关页面内容的元数据，包括页面大小、校验和、DBMS 版本、事务可见性和自包含（Self-containment）等。页面内容有两种主要的数据布局方式：slotted-pages 和 log-structured。 Storage Models &amp; Compression 三种工作负载：OLTP（在线事务处理），OLAP（在线分析处理），HTAP（混合事务和分析处理）。 两种存储模型：行式存储和列式存储。 Memory Management 缓冲池实际上是一个页面数组，用于缓存磁盘中的页面，为了区分缓冲池页面和磁盘页面，我们将缓冲池页面称为帧（frame）。当 DBMS 请求一个页面时，存储管理器会首先搜索缓冲池，如果页面不在缓冲池中，就将该页面从磁盘复制到空闲的帧中。（有关缓冲池的详细信息可以参考 Project #1） 缓冲池优化方式： 多缓冲池：可以为不同数据库或不同页面类型提供不同的缓冲池，这样可以根据其中的数据定制优化策略。 预取：可以根据查询计划预取页面，通常在顺序访问页面时进行该优化。 扫描共享（同步扫描）：当多个查询扫描的数据存储重叠时，重叠部分可以只进行一次扫描。 缓冲池绕过：顺序扫描或临时数据处理不会将页面存储在缓冲池中，而是为其单独开一块内存，以避免缓冲池污染，因为这些页面通常不会再被访问。 大部分数据库使用直接 I/O 绕过操作系统缓存，以避免多余的页面缓存（Postgres 除外）。 Hash Tables 哈希表的实现由两部分组成： 哈希函数：需要在计算速度和冲突率之间进行权衡。 哈希模式：发生冲突时如何处理。（静态哈希和动态哈希） Trees Indexes 索引的数量越多，查询的速度就越快，但是索引占用的存储空间以及维护成本也会随之提高。 B+ 树是一种平衡查找树，它保持数据有序，并且支持 \\(O(\\log{n})\\) 的查询、插入和删除操作。B+ 树平衡的关键在于，它要求所有节点都至少是半满的。B 树在所有节点中存储值，而 B+ 树只在叶子节点中存储值。B+ 树相比哈希表的优势在于可以进行范围查询以及模糊查询。（有关 B+ 树的详细信息可以参考 Project #2） Index Concurrency Control 区分 Lock 和 Latch： Lock：高级原语，作用是保护数据库的内容（元组、表和数据库），在事务中使用。 Latch：低级原语，作用是保护数据库的内部数据结构，在临界区中使用。 实现 Latch 的底层原语是比较并交换（CAS）原子指令。有多种不同类型的 Latch 可供 DBMS 使用： Blocking OS Mutex：使用操作系统内置的互斥锁基础设施，Linux 提供 futex（fast user-space mutex），它由用户空间的自旋锁和操作系统级别的互斥锁组成。示例 std::mutex，优点是使用简单，缺点是加锁/解锁的时间成本较高并且不可扩展（如果发生竞争，则当前线程会被操作系统阻塞）。 Test-and-Set Spin Latch（TAS）：自旋锁具有更高的灵活性，DBMS 可以控制当存在竞争时应该执行什么操作。示例 std::atomic&lt;T&gt;，优点是加锁/解锁更快，缺点是在竞争比较激烈时，会浪费很多 CPU 资源。 Reader-Writer Latches：示例 std::shared_mutex，优点是可以并发读取，缺点是需要额外的空间存储读/写队列。 B+ 树使用蟹行协议（Latch Crabbing Protocol）来保证自上而下的加锁顺序，当线程的访问模式不包含叶节点扫描时，该实现方式可以避免死锁。因为索引锁不支持死锁检测或避免（疑问：这里的描述和幻灯片第 23 页的内容不太一样），所以叶节点扫描在获取同级锁时遵循无等待模式，即如果获取同级锁失败就立即重启操作。 Sorting &amp; Aggregations Algorithms 排序可能被用在 ORDER BY、GROUP BY、JOIN 和 DISTINCT 操作中。如果数据能够放入内存，则可以使用快速排序（当查询包含 LIMIT 和 ORDER BY 时，可以使用堆排序），否则使用外部归并排序。 外部归并排序由两部分组成： 排序：将数据分为多个可以放入内存的数据块，分别进行排序，然后将排序后的数据写回磁盘。 合并：将排序后的数据块合并。 外部归并排序的 I/O 成本分析： 假设 \\(N\\) 为数据页面的个数，\\(B\\) 为可以使用的缓冲区页面的个数。 在排序阶段，每次可以读取 \\(B\\) 个数据页面到缓冲区，进行排序之后写回磁盘，总共执行 \\(\\lceil \\frac{N}{B}\\rceil\\) 次排序，I/O 成本为 \\(2N\\)（读入缓冲区和写回磁盘各一次）。 在合并阶段，可以使用 \\(B-1\\) 个缓冲区页面存储 \\(B-1\\) 个数据块的第一个页面，剩下一个缓冲区页面存储合并的结果并根据需要写回磁盘，如果将合并的过程看作多叉树，则树的高度为 \\(\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil\\)，每层合并都会将所有数据读写一次，I/O 成本为 \\(2N\\times\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil\\)。 最后，总 I/O 成本为 \\(2N\\times(1+\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil)\\)。 外部归并排序可以使用双缓冲区优化，前台缓冲区进行计算的同时，后台缓冲区预取数据。如果数据在排序键上存在 B+ 树聚集索引，那么可以直接遍历索引得到有序数据。因为，如果是聚集索引，数据访问将是顺序 I/O，成本为 \\(N\\)；如果是非聚集索引，数据访问将是随机 I/O，成本为 \\(N\\times M\\)，其中 \\(M\\) 为每页中的记录个数（缓冲区大小有限，随机 I/O 会导致页面抖动）。 聚合操作有两种实现方式： 排序：首先将数据按照聚合键进行排序，然后对有序数据执行顺序扫描来计算聚合值。 哈希：除非数据已经有序，否则哈希总是比排序更高效。由于内存可能容纳不下整个哈希表，为了避免随机 I/O，肯定不能将哈希表直接溢出到磁盘。我们可以首先进行一次哈希，将数据分区，然后对每个分区单独进行聚合操作，这样每个分区的哈希表大小应该会足够小，最好情况是能放入内存中。 Joins Algorithms 连接操作有两种输出模式： 提前物化（early materialization）：将外表和内表的所有属性都放入临时表。 延迟物化（late materialization）：只将连接键以及外表和内表的记录 ID 放入临时表。 连接算法的 I/O 成本分析（假设连接是等值连接）： 假设外表 \\(R\\) 有 \\(M\\) 页，总共包含 \\(m\\) 个元组；内表 \\(S\\) 有 \\(N\\) 页，总共包含 \\(n\\) 个元组。 Nested Loop Join： 该算法由两个嵌套的 for 循环组成，外层循环遍历外表，内层循环遍历内表，如果两个元组满足连接谓词，则将它们连接并输出。注意，我们总是应该使用较小的表作为外表，因为。 Naive Nested Loop Join：对于外表的每个元组，将其和内表中的每个元组进行比较，I/O 成本为 \\(M+(m\\times N)\\)。 Block Nested Loop Join：对于外表的每个块，将其和内表中的每个元组进行比较。假设有 \\(B\\) 个可用的缓冲区，该算法可以使用 \\(B-2\\) 个缓冲区扫描外表，\\(1\\) 个缓冲区扫描内表，\\(1\\) 个缓冲区存储连接结果，I/O 成本为 \\(M+(\\lceil \\frac{M}{B-2}\\rceil\\times N)\\)。 Index Nested Loop Join：如果内表在连接键上建有索引（或者临时建立索引），那么可以直接使用索引搜索到满足条件的元组，I/O 成本为 \\(M+(m\\times C)\\)，其中 \\(C\\) 为单次索引搜索的成本。 Sort-Merge Join： 首先对外表和内表进行排序，然后使用双指针分别遍历外表和内表，来进行连接谓词判断。如果内表的连接键有重复值，那么内表指针在匹配时可能需要回退。当外表或内表已经有序，或者输出结果要求按照连接键排序时，可以选择使用该算法。 排序成本：外表为 \\(2M\\times(1+\\lceil\\log_{B-1}{\\lceil \\frac{M}{B}\\rceil}\\rceil)\\)，内表为 \\(2N\\times(1+\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil)\\)。 合并成本：最坏情况下，两个表中的所有元组的连接键都相等，合并的成本为 \\(MN\\)。一般情况下，连接键大多是唯一的，合并成本为 \\(M+N\\)。 Hash Join： Basic Hash Join：首先将外表的连接键作为 key 构建哈希表，将外表的元组或者元组 ID 作为 value。然后对于内表中的每个元组，可以直接通过哈希表获取匹配的元组。由于可能存在哈希冲突，即使元组被哈希到某个桶，在桶内肯定还需要进行比较来判断元组是否真的匹配，这里我们可以额外使用布隆过滤器来过滤元组，以减少磁盘 I/O。 Grace Hash Join / Partitioned Hash Join：当哈希表无法放入内存时，Basic Hash Join 存在页面抖动问题，解决该问题的方法是进行分区。首先分别对外表和内表构建哈希表，并根据需要写入磁盘，如果单个桶都无法放入内存，则递归的进行分区（前提是桶内的键存在不同，否则会导致无限递归），I/O 成本为 \\(2\\times(M+N)\\)。然后将外表和内表对应的桶进行嵌套循环连接，此时页面都可以放入内存，I/O 成本为 \\(M+N\\)。 假设 \\(M=10^{3}\\)，\\(m=10^{5}\\)，\\(N=5\\times 10^{2}\\)，\\(n=4\\times 10^{4}\\)，\\(B=100\\)，每页的 I/O 花费 \\(0.1\\) 毫秒，各个算法花费的时间如下： Algorithm I/O Cost Example Naive Nested Loop Join \\(M+(m\\times N)\\) 1.4 hours Block Nested Loop Join \\(M+(M\\times N)\\) 50 seconds Index Nested Loop Join \\(M+(m\\times C)\\) Varies Sort-Merge Join \\(M+N+(sort cost)\\) 0.75 seconds Hash Join \\(3\\times(M+N)\\) 0.45 seconds 该表是课程笔记上的，但是有点疑问，Block Nested Loop Join 的 I/O 成本计算公式有问题吧，如果按照之前说的公式计算，I/O 花费的时间是 \\(0.65\\) 秒。 Query Execution DBMS 将 SQL 语句转化为查询计划，查询计划由操作符构成的树表示，数据从叶子节点流向根节点，根节点的输出就是查询的结果。处理模型（processing model）定义系统如何执行查询计划，下面介绍三种处理模型： 迭代器模型/火山模型（Iterator Model）：每个操作符都会实现 Next 函数，该函数由其父节点调用，以获取子节点的输出元组。因为每次调用只会返回单个元组，所以 Next 函数的调用一般放在循环中。调用从根节点传递到叶子节点，数据从叶子节点通过层层处理返回至根节点（实际上就是一个递归的过程，有点像树的后序遍历）。该模型允许以流水线的方式处理元组，有些操作符需要其子节点传递所有元组才能进行计算，包括哈希连接、子查询和排序等，这些操作符被称为流水线破坏者（pipeline breakers）。 物化模型（Materialization Model）：每个操作符都会实现 Output 函数，该函数会返回所有元组。该模型相比迭代器模型可以减少函数的调用次数，适合 OLTP 工作负载，因为其单词查询访问的数据量不大，而 OLAP 工作负载会查询大量数据，操作符的返回结果将会溢出到磁盘，从而增加 I/O 成本。 向量模型（Vectorization Model）：类似迭代器模型，区别在于每次调用 Next 会返回一批元组（即向量）。该模型适合访问大量数据的 OLAP 工作负载，相比迭代器模型，它可以减少函数调用的次数，还可以允许使用 SIMD 指令成批的处理元组。 PS：这些模型实际上是很简单的东西，无非就是返回的数据量不同，写这么多是不是有点浪费笔墨，额。这让我想起之前的一个感想，有些术语看上去很难懂，但是它们的本质其实非常简单，所以有些东西真的是增加学习难度。如无必要，勿增实体，不知道放在这合不合适。 Query Planning &amp; Optimization 应用程序连接到数据库并发送 SQL 查询，该查询可以被重写为不同的形式，然后查询被解析为抽象语法树，绑定器通过查看系统目录，将语法树中的命名对象替换为内部标识，并生成逻辑计划，该逻辑计划同样可以被重写，之后优化器使用成本模型进行估计，将逻辑计划转化为物理计划。 逻辑计划和物理计划的区别：逻辑计划只描述了抽象的关系代数表达式，物理计划将抽象的表达式对应到某个具体实现，例如连接运算符有多种不同实现。逻辑计划和物理计划并不总是一一对应的。 查询优化有启发式优化（heuristics）和基于成本的搜索（cost-based search）两种策略： 启发式方法将查询的各个部分与已知的模式进行匹配，以将其转换为更有效的模式。 基于成本的搜索枚举等价的查询计划，然后选择成本最低的那个。 基于成本的搜索，如何估计谓词的选择性（就是谓词选择的数据占总数据的比率）： 关系 \\(R\\) 中的元组数量 \\(N_{R}\\)，属性 \\(A\\) 的不同值的数量 \\(V(A,R)\\)。使用这两个信息就可以计算出每个属性值的平均记录数 \\(\\frac{N_{R}}{V(A,R)}\\)，称作选择基数（selection cardinality）。DBMS 可以根据选择基数估计谓词的选择性。 由于数据并不是均匀分布的，各个谓词之间也不是相互独立的，所以通过选择基数估计谓词的选择性偏差较大。DBMS 还可以维护等宽/等深直方图，或者对原表进行抽样得到类似原表分布的副本表，然后通过遍历副本表来计算选择性。 Concurrency Control Theory 关键问题：如何避免竞态条件（race condition），以及实现崩溃恢复。 事务的 ACID 原则： 原子性：事务中的操作要么全部执行，要么都不执行。有两种实现方式：日志（主流实现），写时复制。 一致性：数据在逻辑上是正确的，遵循完整性约束。 隔离性：并发执行的事务相互隔离，就像在串行执行一样，通过使用并发控制协议（concurrency control protocol）实现。并发事务之间存在三种冲突：读写冲突（不可重复读），写读冲突（脏读），写写冲突（丢失修改）。 持久性：已提交的事务所做的修改将会持久化到磁盘上。 Two-Phase Locking Concurrency Control 两阶段锁（2PL）是一种悲观的并发控制协议，将事务执行过程分为两个阶段：加锁阶段（Growing）和解锁阶段（Shrinking）。两阶段锁存在脏读和死锁等问题，它有多个变体： Conservative Two-Phase Locking（C2PL）：在事务开始时获取需要的所有锁，此协议可以避免死锁。 Strict Two-Phase Locking（S2PL）：事务结束时释放写锁，读锁可以在解锁阶段逐步释放，此协议可以避免脏读。 Strong Strict Two-Phase Locking（SS2PL）：事务结束时释放读/写锁，此协议在 S2PL 的基础上保证了事务的提交顺序（Commitment Ordering，CO）。 死锁是事务之间发生循环等待的现象，2PL 中有两种处理死锁的方法： 死锁检测：DBMS 定期构建等待图，如果图中存在环，则通过中止环中的某个事务，来打破循环。 死锁预防：当一个事务试图获取另一个事务持有的锁时，DBMS 会中止两个事务中的某个事务，从而避免死锁。 锁兼容矩阵图： 锁升级矩阵图： 持有锁 目标锁 IS S，X，IX，SIX S X，SIX IX X，SIX SIX X 存在的异常：脏读、不可重复读和幻读。隔离级别：读未提交、读已提交、可重复读和可串行化。（基于 2PL 实现的隔离级别、死锁检测可以参考 Project #4） Timestamp Ordering Concurrency Control Timestamp Ordering（T/O）和 Optimistic Concurrency Control（OCC） 都是乐观的并发控制协议，这些协议假设事务之间很少发生冲突，并且使用时间戳而不是锁来控制事务的执行顺序。 Basic Timestamp Ordering（BASIC T/O）：每个事务都会被分配唯一的时间戳，每个数据库对象都会记录最后一次被读/写的时间戳。每当事务读/写数据库对象时，都会将事务时间戳和对象时间戳做比较，以此确定操作是否能够执行。事务还需要保留对象的本地副本，以确保可重复读。 Optimistic Concurrency Control（OCC）：该协议将数据库对象复制到本地进行更改（写时复制），当事务想要提交时，进行冲突检测（比较事务的时间戳），如果通过则将事务的本地更改应用到数据库。 PS：这节课有点没太明白，特别是 OCC 的验证阶段看不懂。 Multi-Version Concurrency Control 多版本并发控制（MVCC）：DBMS 维护数据库中单个逻辑对象的多个物理版本，当事务开始时，DBMS 会创建数据库快照（通过复制事务状态表），然后根据快照来确定事务可见的对象版本。 MCC 有四个重要的设计决策：使用什么并发控制协议（2PL、T/O、OCC），多版本的存储方式，垃圾收集（回收对所有事务都不可见的版本），索引管理（辅助索引存储对象的逻辑指针还是物理指针，主键索引总是存储对象的物理指针）。 Database Logging 崩溃恢复算法的两个关键原语： UNDO：回滚不完整的更改。 REDO：如果已提交事务的更改没有写入磁盘，则重做这些更改。 两个崩溃恢复算法： 写时复制：字面意思。该算法的 UNDO 操作就是删除所有页面副本，没有 REDO 操作，因为事务提交的同时会原子的修改数据库根节点的指针，即已提交的事务必定会将更改落实到数据库中。 预写日志（Write-Ahead Logging，WAL）：日志首先存放在日志缓冲区中，DBMS 必须先将日志写入磁盘（顺序 I/O），然后才能将脏页写入磁盘（不需要立即执行，可以使用后台线程进行写入操作）。只有当日志写入磁盘，事务才能被视为已提交。DBMS 可以通过批量提交事务，来避免频繁的日志 I/O 操作。每个日志记录都包含：事务 ID，对象 ID，之前的值（用于 UNDO），之后的值（用于 REDO）。（这里应该是指物理日志） 日志的模式（Logging Schemes）： 物理日志（Physical Logging）：记录数据的字节级更改。 逻辑日志（Logical Logging）：记录 INSERT、DELETE 和 UPDATE 语句。 混合日志（Physiological Logging）：混合方法，以逻辑地址（页面中的槽号）的方式记录物理日志。 Database Recovery Algorithms for Recovery and Isolation Exploiting Semantics（ARIES） 是由 IBM 在 1990 年代开发出的恢复算法，该算法包含三个关键概念： Write Ahead Logging：先将日志写入磁盘，才能将脏页写入磁盘。 Repeating History During Redo：数据库重启时，重做日志将数据库恢复到崩溃之前的状态。 Logging Changes During Undo：将回滚操作记录到日志中，以确保再次崩溃时不会重复回滚。 该算法为每个日志记录分配全局唯一的日志序列号（log sequence number，LSN），系统中的各个组件会跟踪与其相关的 LSN。每个数据页面会包含最近一次更新对应的 LSN（\\(pageLSN\\)），缓冲池会包含已经刷到磁盘的最大 LSN（\\(flushedLSN\\)），DBMS 在将第 \\(i\\) 页刷新到磁盘之前，必须保证 \\(pageLSN_{i}\\leq flushedLSN\\)，即预写日志。 事务提交：DBMS 首先将 COMMIT 日志记录写入日志缓冲区，然后将日志刷新到磁盘（顺序 I/O）。当日志已经成功刷新到磁盘之后，DBMS 就会向应用程序返回事务提交成功的信息。在之后的某个时刻，DBMS 将 TXN-END 日志记录写入日志缓冲区，表明该事务已经完成。（额，课程中没有说明在这段时间内，事务会执行什么操作） 事务中止：每个日志记录会包含 \\(prevLSN\\) 字段，表示该 LSN 在事务中对应的上一个 LSN 是多少。DBMS 使用 \\(prevLSN\\) 维护事务的日志链表，以方便进行 UNDO 操作。这里引入一个新类型的日志 compensation log record（CLR），表示所执行的 UNDO 操作，该类型的日志不会被 UNDO。事务中止时，DBMS 首先将 ABORT 日志记录写入日志缓冲区，然后根据 ABORT 日志的 \\(prevLSN\\) 回滚事务的更新，当回滚完成时 DBMS 将 TXN-END 日志记录写入日志缓冲区。 为了避免数据库崩溃之后重做整个日志，DBMS 会定期设置检查点（Checkpoint，其实就是存档），在设置检查点时会将缓冲池中的所有脏页都刷新到磁盘中，Checkpoint 有下面几种实现方式： Blocking Checkpoints：首先停止开始新事物，等待活动事务完成，然后将日志和脏页刷新到磁盘，最后将 CHECKPOINT 日志记录写入缓冲区并刷新到磁盘。之所以要停止并等待事务，是为了避免丢失更新。 Slightly Better Blocking Checkpoints：在开始设置检查点时，会记录内部系统的状态，从而不必等待活动事务完成，取而代之的是暂停活动事务。内部系统状态包括：Active Transaction Table（ATT）和 Dirty Page Table（DPT）。 Fuzzy Checkpoints：通过使用额外的日志记录（CHECKPOINT-BEGIN 和 CHECKPOINT-END）跟踪检查点的边界，从而不需要暂停活动事务。 ARIES 算法在 DBMS 崩溃重启之后执行，分为三个阶段： 分析（Analysis）：从 \\(MasterRecord\\) 对应检查点开始扫描日志，以构建 ATT 和 DPT，它们包含崩溃时缓冲池中存在的脏页以及活动的事务信息。 重做（Redo）：从 DPT 的所有脏页中最小的 \\(recLSN\\) 开始重做，即所有脏页中最旧的修改日志记录。 回滚（Undo）：从崩溃时所有活动事务中最旧的日志记录开始，撤销崩溃时活动事务所做的修改。 Introduction to Distributed Databases 并行数据库和分布式数据库的区别： 并行数据库 分布式数据库 节点之间距离较近 节点之间距离较远 节点之间使用高速局域网连接 节点之间使用公共网络连接 通信的成本很小且可靠 通信的成本很高且不可靠 DBMS 的系统架构指定 CPU 可以访问哪些共享资源，有如下四种架构方式： 一致性哈希： 优势：假设有 \\(n\\) 个键，\\(m\\) 个节点，则一致性哈希平均只需要对 \\(\\frac{n}{m}\\) 个键进行再散列。 原理：使用哈希函数将键和节点映射到圆上，每个键都会被分配给在顺时针方向上的下一个节点。每当添加一个节点时，只需要对其顺时针方向的下一个节点上的键进行再散列；每当删除一个节点时，只需要将当前节点的键移动到顺时针方向的下一个节点。（相当于多个节点将圆划分为多个圆弧，每个节点只包含映射到对应圆弧上的键） Distributed OLTP Database Systems 如果某个事务需要访问多个节点上的数据（由于数据分区），则其是分布式事务。提交分布式事务时，根据协议的不同，可能需要得到所有或大多数节点的同意。原子提交协议（Atomic Commit Protocols）有：Two-Phase Commit，Three-Phase Commit，Paxos，Raft，ZAB，Viewstamped Replication。如果节点不可信，则需要使用拜占庭容错（byzantine fault tolerant）协议。 PS：虽然该课程将以上算法统称为原子提交协议，但是 2PC/3PC 和其他共识算法有一个显著的区别，就是 2PC/3PC 通常用于分布式事务，而其他共识算法通常用于数据复制。前者涉及多个节点上的不同数据，且协调器存在单点故障。后者涉及多个节点上的相同数据，且基于多数原则，不存在单点故障。可以将 2PC/3PC 和其他共识算法结合使用，从而消除单点故障（例如 Spanner 分布式数据库所做的）。 CAP 定理（Consistency，Availability，Partition tolerance）：指在发生网络分区故障时，要么选择一致性（指的是可线性化），要么选择可用性（允许读写网络分区节点）。","link":"/2023/11/15/CUM%2015-445%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"第 372 场力扣周赛","text":"使三个字符串相等等价于求字符串的最长公共前缀。 12345678910class Solution { public int findMinimumOperations(String s1, String s2, String s3) { int n = Math.min(s1.length(), Math.min(s2.length(), s3.length())); int i = 0; while (i &lt; n &amp;&amp; s1.charAt(i) == s2.charAt(i) &amp;&amp; s2.charAt(i) == s3.charAt(i)) { i++; } return i == 0 ? -1 : s1.length() + s2.length() + s3.length() - 3 * i; }} 区分黑球与白球将每个 \\(1\\) 右边 \\(0\\) 的个数累加就是需要交换的次数，或者累加每个 \\(0\\) 左边 \\(1\\) 的个数也行。 1234567891011class Solution { public long minimumSteps(String s) { long ans = 0L; int n = s.length(), cnt = 0; for (int i = n - 1; i &gt;= 0; i--) { if (s.charAt(i) == '0') cnt++; else ans += cnt; } return ans; }} 最大异或乘积要求 \\(\\max((a\\oplus x)\\times(b\\oplus x))\\)，可以得出异或只会在两者都为 \\(0\\) 的位上补 \\(1\\)，或者交换两者某位上的 \\(0\\) 和 \\(1\\)。此时 \\((a\\oplus x)+(b\\oplus x)=c\\)，\\(c\\) 为某个定值，从而问题可以转化为求函数 \\(y=x(c-x)\\) 的最大值，可以知道当 \\(x=\\frac{c}{2}\\) 时取到最大值，即我们需要让 \\((a\\oplus x)\\) 和 \\((b\\oplus x)\\) 尽可能相等。 123456789101112131415161718class Solution { private static final int MOD = (int) 1e9 + 7; public int maximumXorProduct(long a, long b, int n) { long p = a &gt;&gt; n &lt;&lt; n, q = b &gt;&gt; n &lt;&lt; n; for (int i = n - 1; i &gt;= 0; i--) { if ((a &gt;&gt; i &amp; 1) == (b &gt;&gt; i &amp; 1)) { p |= 1L &lt;&lt; i; q |= 1L &lt;&lt; i; } else if (p &lt; q) { p |= 1L &lt;&lt; i; } else { q |= 1L &lt;&lt; i; } } return (int) (p % MOD * (q % MOD) % MOD); }} 找到 Alice 和 Bob 可以相遇的建筑离线查询，可以预处理查询序列，然后使用单调栈 + 二分，或者使用最小堆；在线查询，可以使用线段树（暂时不学）。","link":"/2023/11/20/%E7%AC%AC%20372%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 330","text":"Counting Passes模拟。 12345678910public static void solve() { int n = io.nextInt(), l = io.nextInt(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (io.nextInt() &gt;= l) { ans++; } } io.println(ans);} Minimize Abs 1等价于求 \\(y=|x-a_{i}|\\) 在区间 \\([L,R]\\) 内的最小值对应的 \\(x\\)。 1234567891011121314public static void solve() { int n = io.nextInt(), l = io.nextInt(), r = io.nextInt(); for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); if (l &lt;= a &amp;&amp; a &lt;= r) { io.print(a + &quot; &quot;); } else if (a &lt; l) { io.print(l + &quot; &quot;); } else { io.print(r + &quot; &quot;); } } io.println();} Minimize Abs 2对于每个固定的 \\(x\\)，可以在 \\(O(1)\\) 时间内求出 \\(|y^{2}+(x^{2}-D)|\\) 的最小值（也可以二分），我们枚举 \\([0,\\lceil\\sqrt{D}\\rceil]\\) 范围内的所有 \\(x\\)。 12345678910111213141516public static void solve() { long d = io.nextLong(); long ans = Long.MAX_VALUE; long up = (long) Math.sqrt(d) + 1; for (long x = 0; x &lt;= up; x++) { long t = x * x - d; if (t &gt;= 0) { ans = Math.min(ans, t); } else { long y = (long) Math.sqrt(-t); ans = Math.min(ans, Math.abs(y * y + x * x - d)); ans = Math.min(ans, Math.abs((y + 1) * (y + 1) + x * x - d)); } } io.println(ans);} Counting Ls对行列计数，然后枚举交叉点。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } int[] row = new int[n]; int[] col = new int[n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i][j] == 'o') { row[i]++; col[j]++; } } } long ans = 0L; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i][j] == 'o' &amp;&amp; col[j] &gt; 1) { ans += (long) (col[j] - 1) * (row[i] - 1); } } } io.println(ans);} Mex and Update因为只有 \\(n\\) 个数，所以只需要考虑 \\([0,n]\\) 范围的数的增删，这样集合就可以存储单个数。比赛时没注意，使用的是区间，然后删除区间中的数，需要进行分裂，会麻烦很多，还需要排序以及考虑最左和最右的特殊区间。 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), q = io.nextInt(); int[] a = new int[n]; int[] cnt = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); if (a[i] &lt;= n) { cnt[a[i]]++; } } TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt;= n; i++) { if (cnt[i] == 0) { set.add(i); } } while (q-- != 0) { int i = io.nextInt() - 1, x = io.nextInt(); if (a[i] &lt;= n &amp;&amp; --cnt[a[i]] == 0) { set.add(a[i]); } a[i] = x; if (a[i] &lt;= n &amp;&amp; cnt[a[i]]++ == 0) { set.remove(a[i]); } io.println(set.first()); }}","link":"/2023/11/26/AtCoder%20Beginner%20Contest%20330/"},{"title":"第 118 场力扣夜喵双周赛","text":"查找包含给定字符的单词模拟。 1234567891011class Solution { public List&lt;Integer&gt; findWordsContaining(String[] words, char x) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) { if (words[i].contains(x + &quot;&quot;)) { ans.add(i); } } return ans; }} 最大化网格图中正方形空洞的面积分别求出行和列的最长连续线段，然后最大正方形面积就是两者最小值加一的平方。 1234567891011121314151617181920212223class Solution { public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) { Arrays.sort(hBars); Arrays.sort(vBars); int maxH = 0, maxV = 0; for (int i = 0, j = 0; j &lt; hBars.length; j++) { if (hBars[j] - hBars[i] == j - i) { maxH = Math.max(maxH, j - i + 1); } else { i = j; } } for (int i = 0, j = 0; j &lt; vBars.length; j++) { if (vBars[j] - vBars[i] == j - i) { maxV = Math.max(maxV, j - i + 1); } else { i = j; } } int len = Math.min(maxH, maxV) + 1; return len * len; }} 购买水果需要的最少金币数动态规划，\\(dp[i]\\) 表示获取 \\([i,n]\\) 范围内所有水果所需的最少金币数，有 \\(dp[i]=prices[i]+\\min_{j=i+1}^{2i+1}{dp[j]}\\)，时间复杂度 \\(O(n^{2})\\)。 12345678910111213class Solution { public int minimumCoins(int[] prices) { int n = prices.length; for (int i = (n + 1) / 2 - 1; i &gt; 0; i--) { int min = Integer.MAX_VALUE; for (int j = i + 1; j &lt;= 2 * i + 1; j++) { min = Math.min(min, prices[j - 1]); } prices[i - 1] += min; } return prices[0]; }} 单调队列优化，时间复杂度 \\(O(n)\\)。 12345678910111213141516171819class Solution { public int minimumCoins(int[] prices) { int n = prices.length; Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = n; i &gt; 0; i--) { while (!q.isEmpty() &amp;&amp; q.peekFirst() &gt; 2 * i + 1) { q.pollFirst(); } if (i &lt;= (n + 1) / 2 - 1) { prices[i - 1] += prices[q.peekFirst() - 1]; } while (!q.isEmpty() &amp;&amp; prices[q.peekLast() - 1] &gt;= prices[i - 1]) { q.pollLast(); } q.offerLast(i); } return prices[q.peekLast() - 1]; }} 找到最大非递减数组的长度单调队列优化 DP，随缘补题。","link":"/2023/11/26/%E7%AC%AC%20118%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 373 场力扣周赛","text":"循环移位后的矩阵相似检查模拟。有个性质，如果左移 \\(k\\) 位之后相等，则右移 \\(k\\) 位也必定相等。 12345678910111213class Solution { public boolean areSimilar(int[][] mat, int k) { int m = mat.length, n = mat[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] != mat[i][((j + (i % 2 == 0 ? 1 : -1) * k) % n + n) % n]) { return false; } } } return true; }} 统计美丽子字符串 I将元音字母看作 \\(1\\)，非元音字母看作 \\(-1\\)，使用前缀和 + 哈希表的技巧，可以得到若干个分组，每组中任意两个下标构成的子数组都满足条件一。然后我们可以暴力判断所有满足条件一的子数组的长度是否满足条件二，时间复杂度为 \\(O(n^{2})\\)。（补充：可以纯暴力做，不需要分组。） 123456789101112131415161718192021222324class Solution { public int beautifulSubstrings(String s, int k) { int n = s.length(), sum = 0; Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); map.computeIfAbsent(0, t -&gt; new ArrayList&lt;&gt;()).add(-1); for (int i = 0; i &lt; n; i++) { sum += set.contains(s.charAt(i)) ? 1 : -1; map.computeIfAbsent(sum, t -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = 0; for (var list : map.values()) { for (int j = 0; j &lt; list.size() ; j++) { for (int i = 0; i &lt; j; i++) { int len = (list.get(j) - list.get(i)) / 2; if (len * len % k == 0) { ans++; } } } } return ans; }} 交换得到字典序最小的数组如果 \\(|nums[i]-nums[j]|&lt;=limit\\)，那么就可以交换 \\(nums[i]\\) 和 \\(nums[j]\\)，该交换的性质具有传递性，所以我们可以对原数组进行排序，只要相邻元素的差值小于等于 \\(limit\\)，它们就在同一个可交换集合中。这样可以将原数组划分为若干可交换集合，然后对每个集合排序，从小到大排列即可。 12345678910111213141516171819202122232425262728293031class Solution { public int[] lexicographicallySmallestArray(int[] nums, int limit) { int n = nums.length; var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; nums[i] - nums[j]); int pre = -limit; List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(); for (int i : aux) { if (nums[i] - pre &gt; limit) { buckets.add(new ArrayList&lt;&gt;()); } buckets.get(buckets.size() - 1).add(i); pre = nums[i]; } int[] ans = new int[n]; for (var bucket : buckets) { List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); pos.addAll(bucket); Collections.sort(pos); for (int i = 0; i &lt; pos.size(); i++) { ans[pos.get(i)] = nums[bucket.get(i)]; } } return ans; }} 统计美丽子字符串 II朴素做法的瓶颈在 \\((\\frac{L}{2})^{2}\\bmod{k}=0\\) 的判断上，可以通过将条件二变换为 \\(L\\bmod{k^{\\prime}}=0\\)，然后使用前缀和以及下标模 \\(k^{\\prime}\\) 的值来分组，这样同组内的下标两两组合得到的必定是满足两个条件的子数组。灵神题解，时间复杂度 \\(O(n+\\sqrt{k})\\)。还有另一种枚举的做法，题解。","link":"/2023/11/26/%E7%AC%AC%20373%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 911 (Div. 2)","text":"Cover in Water只要存在三个连续的空格，就可以执行两次操作一，再多次执行操作二，来装满所有空格。 123456789101112131415public static void solve() { int n = io.nextInt(); String s = io.next(); String[] arr = s.split(&quot;#&quot;); int ans = 0; for (String t : arr) { int m = t.length(); if (m &gt;= 3) { io.println(2); return; } ans += m; } io.println(ans);} Laura and Operations注意题目说的是剩下一种类型的数字，而不是一个数字。如果剩下数字 \\(1\\)，那么首先将 \\(2\\) 和 \\(3\\) 抵消，如果 \\(2\\) 多于 \\(3\\)，那么多出的数量如果是偶数，就可以将该数量的一半执行操作，再做一次抵消，最后就只剩下 \\(1\\)；反之亦然。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (Math.abs(b - c) % 2 == 0) io.print(1); else io.print(0); io.print(&quot; &quot;); if (Math.abs(a - c) % 2 == 0) io.print(1); else io.print(0); io.print(&quot; &quot;); if (Math.abs(a - b) % 2 == 0) io.print(1); else io.print(0); io.println();} Anji’s Binary Tree做一次后序遍历即可。题目说的是选择任意字母替换，而不是选择其他节点上的字母替换。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); String s = io.next(); int[][] g = new int[n][]; for (int i = 0; i &lt; n; i++) { int l = io.nextInt() - 1, r = io.nextInt() - 1; g[i] = new int[]{l, r}; } io.println(dfs(0, g, s));}private static int dfs(int x, int[][] g, String s) { if (g[x][0] == -1 &amp;&amp; g[x][1] == -1) { return 0; } int res = Integer.MAX_VALUE; if (g[x][0] != -1) { res = Math.min(res, dfs(g[x][0],g, s) + (s.charAt(x) != 'L' ? 1 : 0)); } if (g[x][1] != -1) { res = Math.min(res, dfs(g[x][1],g, s) + (s.charAt(x) != 'R' ? 1 : 0)); } return res;} Small GCD\\(f(a,b,c)\\) 表示 \\(a,b,c\\) 中最小的两个数的 \\(\\gcd\\)，而我们要求出给定数组的所有不同下标构成的三元组的 \\(f\\) 之和。暴力的想法是枚举中间值，然后计算以该值为中心构成的三元组的 \\(\\gcd\\) 之和，时间复杂度为 \\(O(n^{2})\\)。正确的做法：由于数据范围比较小，我们可以首先计算出 \\([1,N]\\) 范围内每个数的所有约数，然后排序数组，对数组中的每个数枚举它的约数，从而计算出以该约数的倍数作为最大公约数的三元组的个数，然后利用容斥原理得到以该约数作为最大公约数的三元组的个数，最后可以计算出答案。 123456789101112131415161718192021222324252627282930313233343536373839private static final int N = 100000;private static final List&lt;Integer&gt;[] aux;static { aux = new List[N + 1]; Arrays.setAll(aux, k -&gt; new ArrayList&lt;&gt;()); for (int i = 1; i &lt;= N; i++) { for (int j = i; j &lt;= N; j += i) { aux[j].add(i); } }}public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); int[] c = new int[N + 1]; long[] f = new long[N + 1]; for (int i = 0; i &lt; n; i++) { for (int x : aux[a[i]]) { f[x] += (long) c[x] * (n - i - 1); c[x]++; } } long ans = 0L; for (int i = N; i &gt;= 1; i--) { for (int j = i + i; j &lt;= N; j += i) { f[i] -= f[j]; } ans += f[i] * i; } io.println(ans);} Transitive Graph似乎是和强连通分量相关的题目，有空可以补一下。","link":"/2023/11/27/Codeforces%20Round%20911%20(Div.%202)/"},{"title":"第 374 场力扣周赛","text":"需要添加的硬币的最小数量题目 输入长度为 \\(n\\) 的数组 \\(a\\) 和整数 \\(k\\)，输出需要向数组插入多少个数，使得数组的子序列能够表示 \\([1,k]\\) 范围内的所有整数。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq k\\leq 10^{5}\\)。 思路 从小到大遍历数组，假设当前能够表示的区间为 \\([0,s]\\)，此时遍历到数组中的数 \\(a_{i}\\)，我们可以表示区间 \\([a_{i},s+a_{i}]\\)。 如果 \\(a_{i}\\leq s+1\\)，那么就可以合并两个区间，得到 \\([0,s+a_{i}]\\)，然后继续遍历 \\(a_{i+1}\\)。 否则，需要向数组插入数 \\(s+1\\) 来保证区间连续，得到 \\([0,2s+1]\\)，然后再次遍历 \\(a_{i}\\)。 不断重复上述过程直到能够表示区间 \\([1,k]\\)。 排序数组的时间复杂度为 \\(O(n\\log{n})\\)，插入操作最多执行 \\(O(\\log{k})\\) 次。 统计完全子字符串题目 输入长度为 \\(n\\) 的由小写英文字母组成的字符串 \\(s\\) 和整数 \\(k\\)，输出满足以下两个条件的子字符串的个数。 每个字符恰好出现 \\(k\\) 次。 相邻字符在字母表中的距离小于等于 \\(2\\)。 数据范围：\\(1\\leq k\\leq n\\leq 10^{5}\\)。 思路 距离大于 \\(2\\) 的相邻字符可以将字符串分割成若干子串，对于每个子串 \\(t\\) 考虑满足条件一的子串 \\(t_{i}\\) 个数即可。我们可以枚举 \\(t_{i}\\) 包含多少个不同的字符（设为 \\(x\\)），对于每个 \\(x\\) 使用滑动窗口可以得到 \\(t\\) 中满足条件一的长度为 \\(kx\\) 的子串个数。时间复杂度为 \\(O(|\\Sigma| n)\\)，外层循环执行 \\(O(|\\Sigma|)\\) 次，内层循环滑窗执行 \\(O(n)\\) 次，滑窗的同时使用计数数组统计有多少个字符恰好出现 \\(k\\) 次，判断的时间复杂度为 \\(O(1)\\)。 统计感冒序列的数目题目 输入整数 \\(n\\) 和长度为 \\(m\\) 的按照升序排列的数组 \\(a\\)，数组 \\(a\\) 存储下标 \\([0,n-1]\\) 的子序列，输出所有不在数组 \\(a\\) 中的下标被选择的方案数，答案对 \\(10^{9}+7\\) 取余。下标 \\(i\\) 可以被选择，当且仅当下标 \\(i-1\\) 或者 \\(i+1\\) 被选择，数组 \\(a\\) 中的下标可以看作是被选择的。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq m\\leq n-1\\)，\\(0\\leq a_{i}\\leq n-1\\)。 思路 数组 \\(a\\) 中的下标将 \\([0,n-1]\\) 划分为多个子数组，首先考虑每个子数组内部的方案数：最左和最右的子数组只存在一种选择方案，其他子数组存在 \\(2^{x_{i}-1}\\) 种选择方案，\\(x_{i}\\) 为该子数组的长度。然后考虑子数组之间的方案数，最初我们有 \\(n-m\\) 个位置可以放置下标，假设各个子数组的长度分别为 \\(x_{0},x_{1},\\dots,x_{k}\\)，那么总共有 \\(\\prod_{i=0}^{k}{C(n-m-\\sum_{j=0}^{i-1}{x_{j}},x_{i})}=\\frac{(n-m)!}{\\prod_{i=0}^{k}{x_{i}!}}\\) 种放置方案。将两者相乘即可得到答案，计算过程需要使用逆元和快速幂。","link":"/2023/12/05/%E7%AC%AC%20374%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 119 场力扣夜喵双周赛","text":"消除相邻近似相等字符题目 输入长度为 \\(n\\) 的字符串 \\(s\\)，输出所需的最少操作次数，使得字符串 \\(s\\) 中的相邻字符在字母表中的距离大于 \\(1\\)。每次操作可以将字符串 \\(s\\) 中的某个字符修改为任意字符。 数据范围：\\(1\\leq n\\leq 100\\)。 思路 思路一：距离大于 \\(1\\) 的相邻字符可以将字符串 \\(s\\) 分割为若干子串，每个子串所需的最少操作次数为 \\(\\lfloor\\frac{l}{2}\\rfloor\\)，其中 \\(l\\) 表示子串的长度。 思路二：如果相邻字符距离小于等于 \\(1\\)，那么贪心的修改右边的字符即可。 两种思路原理是一样的，只是实现时略有不同。 关闭分部的可行集合数目题目 输入整数 \\(n\\) 表示有 \\(n\\) 个节点，长度为 \\(m\\) 表示无向边的数组 \\(e\\)（包含重边），以及整数 \\(d\\)。输出删除节点的方案数，使得剩余节点两两之间的最短路不超过 \\(d\\)。 数据范围：\\(1\\leq n\\leq 10\\)，\\(0\\leq m\\leq 1000\\)。其他数据不会影响时间复杂度，所以不列出。 思路 题目要求满足条件的方案数，首先想到枚举所有方案，总共有 \\(2^{n}\\) 个方案，然后对每个方案求删除节点后的多源最短路（Floyd 算法），如果剩余节点两两之间的最短路都不超过 \\(d\\)，那么答案就加一，总时间复杂度为 \\(O(m+2^{n}n^{3})\\)。因为是求最短路，所以重边可以只保留最小的那条边。","link":"/2023/12/10/%E7%AC%AC%20119%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 375 场力扣周赛","text":"统计最大元素出现至少 K 次的子数组题目 输入长度为 \\(n\\) 的数组 \\(a\\) 和整数 \\(k\\)，输出满足 \\(\\max(a)\\) 至少出现 \\(k\\) 次的子数组的数目。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq k\\leq 10^{5}\\)。 思路 首先计算出最大值，然后将所有最大值的下标放入列表 \\(l\\) 中，最后枚举右端点即可。假设列表的长度为 \\(m\\)，当前枚举到 \\(i\\)，当 \\(i&lt;m-1\\) 时，区间 \\([l[i],l[i+1]-1]\\) 范围内的右端点都对应 \\(l[i-k+1]+1\\) 数量的左端点，将它们相乘加入答案。特别的，当 \\(i=m-1\\) 时，取区间 \\([l[i],n-1]\\)。PS：也可以滑动窗口，使窗口内只包含 \\(k-1\\) 个最大值，这样计算答案的空间复杂度为 \\(O(1)\\)。 统计好分割方案的数目题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出将数组分割为若干不相交子数组的方案数。不相交表示子数组之间没有相同的元素，答案对 \\(10^{9}+7\\) 取余。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路 因为要求子数组之间没有相同元素，那么相同元素必定只会出现在一个子数组中，首先统计每个元素的最小和最大下标，这两个下标构成的区间是不可分割的。然后将所有不可分割的区间进行合并，最后剩余的区间数假设为 \\(m\\)，那么就会有 \\(2^{m-1}\\) 种分割方案（因为 \\(m\\) 个区间有 \\(m-1\\) 个分割位置，每个分割位置有分割或者不分割两种状态）。PS：① 可以边计数边做乘法，不使用快速幂；② 可以只统计最大下标，然后遍历数组时维护最大下标的最大值，如果当前下标等于该值，那么就可以做一次分割。（代码）","link":"/2023/12/10/%E7%AC%AC%20375%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 915 (Div. 2)","text":"Begginer’s Zelda题目输入一颗树，输出执行的最少操作次数，使得该树只有一个节点。每次操作可以选择树中的两个节点，将它们之间的路径压缩为一个节点，所有连接路径上节点的边都会连向新节点。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq u_{i},v_{i}\\leq n\\)，\\(u_{i}\\neq v_{i}\\)。 思路每次操作贪心的选择两个叶子节点（度数为 \\(1\\) 的节点都看作叶子），根据叶子节点的数量 \\(x\\) 的奇偶性分类讨论： 如果 \\(x\\) 为奇数，\\(x=1\\) 需要 \\(0\\) 次操作，\\(x=3\\) 需要 \\(2\\) 次操作，之后每增加两个叶子，都会使操作次数加 \\(1\\)，由于数据范围限制初始时叶子至少有 \\(2\\) 个，所以操作次数为 \\(\\frac{x+1}{2}\\)。 如果 \\(x\\) 为偶数，\\(x=2\\) 需要 \\(1\\) 次操作，\\(x=4\\) 需要 \\(2\\) 次操作，之后每增加两个叶子，都会使操作次数加 \\(1\\)，所以操作次数为 \\(\\frac{x}{2}\\)。 最后，可以将两种情况的公式合并为 \\(\\lfloor\\frac{x+1}{2}\\rfloor\\)。 Largest Subsequence题目输入长度为 \\(n\\) 的字符串 \\(s\\)，输出执行的最少操作次数，使得字符串有序。每次操作可以将字符串中字典序最大的子序列循环右移一位。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)。 思路首先使用单调栈求出字典序最大的子序列（非严格单调递减），然后通过观察可以发现，执行多次操作最终会将该子序列反转。相当于求最少右移次数，使得子序列反转，该次数等于子序列长度减去子序列中最大字符的数量。其次，还需要判断子序列反转之后，字符串是否有序。 Cyclic MEX题目输入一个包含 \\({0,1,2,\\dots,n-1}\\) 的排列 \\(p\\)，输出排列 \\(p\\) 的所有循环移动的最大代价。对于数组 \\(a\\)，它的代价为 \\(\\sum_{i=1}^{n}{\\operatorname{mex}([a_{1},a_{2},\\dots,a_{i}])}\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路观察每循环左移一次，代价是如何变化的： 排列 \\(2,3,6,7,0,1,4,5\\) 对应的代价为 \\(0,0,0,0,1,4,5,8\\)； 排列 \\(3,6,7,0,1,4,5,2\\) 对应的代价为 \\(0,0,0,1,2,2,2,8\\)； 排列 \\(6,7,0,1,4,5,2,3\\) 对应的代价为 \\(0,0,1,2,2,2,3,8\\)。 可以发现每当将数 \\(x\\) 移动到排列末尾，所有大于 \\(x\\) 的 \\(\\operatorname{mex}\\) 值都会变为 \\(x\\)，然后 \\(x\\) 位置对应的 \\(\\operatorname{mex}\\) 值为 \\(n\\)。 我们可以首先将排列移动为 \\(1,4,5,2,3,6,7,0\\) 形式，对应的代价为 \\(0,0,0,0,0,0,0,8\\)。然后使用单调递增栈维护左移的数构成的递增序列，栈中存储数的下标，模拟上述过程并维护最大代价。","link":"/2023/12/18/Codeforces%20Round%20915%20(Div.%202)/"},{"title":"第 376 场力扣周赛","text":"使数组成为等数数组的最小代价题目输入长度为 \\(n\\) 的整数数组 \\(a\\)，输出执行任意次操作后使得数组中的数全部相等并且是回文数的最小代价（要求该回文数小于 \\(10^{9}\\)）。每次操作可以将数组中的某个数（假设为 \\(a_{i}\\)）修改为任意正整数（假设为 \\(x\\)），对应的代价为 \\(|a_{i}-x|\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq10^{9}\\)。 思路如果没有限制是回文数，那么将数组排序之后按如下方式修改，代价是最小的（假设有序数组中的元素为 \\(a_{0},a_{1},\\dots,a_{n-1}\\)）： 当 \\(n\\) 为奇数时，将所有数修改为中位数 \\(a_{\\lfloor\\frac{n}{2}\\rfloor}\\)。 当 \\(n\\) 为偶数时，将所有数修改为区间 \\([a_{\\lfloor\\frac{n-1}{2}\\rfloor},a_{\\lfloor\\frac{n}{2}\\rfloor}]\\) 内的某个数。 首先使用反证法证明，最小代价可以通过将所有数修改为数组中的某个数取到。 假设将所有数修改为 \\(x\\)，\\(x\\) 在区间 \\((a_{i},a_{i+1})\\) 范围内，其中 \\(a_{i}\\) 和 \\(a_{i+1}\\) 表示数组中相邻的两个数。此时 \\(x\\) 左边有 \\(i+1\\) 个元素，右边有 \\(n-i\\) 个元素。将 \\(x\\) 修改为 \\(a_{i+1}\\) 会使代价增加 \\((i+1)\\times (a_{i+1}-x)\\)，并且使代价减少 \\((n-i)\\times(a_{i+1}-x)\\)。将 \\(x\\) 修改为 \\(a_{i}\\) 会使代价减少 \\((i+1)\\times (x-a_{i})\\)，并且使代价增加 \\((n-i)\\times(x-a_{i})\\)。 当 \\(i+1&lt;n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i+1}\\) 会使代价减少；当 \\(i+1&gt;n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i}\\) 会使代价减少；当 \\(i+1=n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i}\\) 或者 \\(a_{i+1}\\) 代价不变。 特别的，\\(x\\) 在区间 \\([1,a_{0})\\) 或者 \\((a_{n-1},+\\infty]\\) 范围内时，同理。 然后再使用反证法证明上述结论： 假设将数组中的数都修改为 \\(a_{i}\\) 时，代价最小，\\(a_{i}\\) 不满足上述条件。 当 \\(n\\) 为奇数时，由于 \\(a_{i}\\) 不是中位数： 当 \\(i&lt;\\lfloor\\frac{n}{2}\\rfloor\\) 时，有 \\(i+1&lt;n-1-i\\)，此时 \\(i\\) 每向中位数移动一位，代价都会减少 \\((n-1-i)-(i+1)&gt;0\\)。 反之亦然。 当 \\(n\\) 为偶数时，同理。 综上，得出按照上述方式修改代价最少，即 \\(x\\) 越靠近中位数代价越小。所以，如果需要将所有数修改为某个回文数，那么该回文数一定是最靠近中位数的回文数。PS：还是灵神的证明更简单。 该题有两种方法可以找到距离 \\(x\\) 的最近回文数： 方法一：将 \\(x\\) 的前半部分作为回文根，对称之后得到回文数 \\(y\\)。如果 \\(y&lt;x\\)，则将回文根加一再做对称得到回文数 \\(z\\)，然后取 \\(y\\) 和 \\(z\\) 中距离最近者；如果 \\(y&gt;x\\)，则将回文根减一再做对称得到回文数 \\(z\\)，然后取 \\(y\\) 和 \\(z\\) 中距离最近者；否则，\\(x\\) 本身就是回文数。注意，排除大于等于 \\(10^{9}\\) 的回文数，以及做加减法时可能会遇到回文根为 \\(100\\dots0\\) 或 \\(99\\dots9\\) 的特殊情况，此时做对称会得到错误答案，我们应该直接根据长度构造回文数。（这个代码还挺好看，把所有情况都直接循环枚举，就可以不用写那么多判断语句） 方法二：枚举出 \\([1,10^{9}]\\) 范围内的所有回文数，然后二分找到距离 \\(x\\) 最近的回文数。 执行操作使频率分数最大题目输入长度为 \\(n\\) 的整数数组 \\(a\\) 和一个整数 \\(k\\)，输出经过至多 \\(k\\) 次操作之后，数组中众数的最大频率。每次操作可以选择数组中的某个数 \\(a_{i}\\)，将其增加或者减少 \\(1\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)，\\(0\\leq k\\leq 10^{14}\\)。 思路排序 + 前缀和 + 滑动窗口。要使众数尽可能多，可以首先对数组排序，假设最终众数有 \\(x\\) 个，那么这 \\(x\\) 个数一定是在某个子数组中。使用滑动窗口，将尽可能多的数包含在窗口内，同时满足操作次数小于等于 \\(k\\)，如果大于 \\(k\\) 则将左端点右移。类似上一题，将窗口内的所有数都修改为窗口的中位数，所需的操作次数最少。窗口的操作次数可以使用前缀和 \\(O(1)\\) 的计算出来，假设窗口的左右端点的下标分别为 \\(i\\) 和 \\(j\\)，中位数的下标为 \\(k\\)，则窗口的操作次数为：\\((a_{k}\\times (k-i)-(s[k]-s[i]))+((s[j+1]-s[k+1])-a_{k}\\times (j-k))\\)。","link":"/2023/12/18/%E7%AC%AC%20376%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Educational Codeforces Round 160 (Rated for Div. 2)","text":"Swap and Delete题目输入长度为 \\(n\\) 的二进制字符串，输出执行操作需要的最小成本，使得对于操作之后得到的字符串 \\(t\\) 的每个字符 \\(t_{i}\\)，都有 \\(t_{i}\\neq s_{i}\\)，其中 \\(1\\leq i\\leq |t|\\)。有两种操作： 从字符串 \\(s\\) 中删除一个字符，操作的成本为 \\(1\\)。 交换字符串 \\(s\\) 中的两个字符，操作的成本为 \\(0\\)。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)。 思路由于只有删除操作会导致成本增加，所以我们只需要让字符串 \\(t\\) 尽可能长就好。首先对字符串 \\(s\\) 中的 \\(0\\) 和 \\(1\\) 计数，然后贪心的构造字符串 \\(t\\)，如果 \\(s_{i}=0\\)，则 \\(t_{i}=1\\)，反之亦然，直到不能增加长度为止。最后最小成本就是 \\(n-|t|\\)。 Game with Multiset题目输入一个整数 \\(m\\) 表示查询的次数，以及 \\(m\\) 行查询，每行包含两个整数 \\(t_{i}\\) 和 \\(v_{i}\\)。初始时你有一个空的多重集合（multiset）： 如果 \\(t_{i}=1\\)，将元素 \\(2^{v}\\) 加入集合。（\\(0\\leq v_{i}\\leq 29\\)） 如果 \\(t_{i}=2\\)，询问 \\(v_{i}\\) 是否可以表示为当前集合的某个子集之和，并输出 YES 或 NO。（\\(0\\leq v_{i}\\leq 10^{9}\\)） 数据范围：\\(1\\leq m\\leq 10^{5}\\)。 思路 方法一：使用数组对 \\(t_{i}=1\\) 的 \\(v_{i}\\) 计数，对于每个询问，从低到高遍历 \\(v_{i}\\) 的二进制 \\(1\\)。假设当前遍历到 \\(2^{k}\\)，如果集合中存在 \\(2^{k}\\) 则当前位可以被表示（假设集合中有 \\(c_{k}\\) 个 \\(2^{k}\\)），并且集合中剩余的 \\(2^{k}\\) 可以合并为 \\(\\frac{c_{k}-1}{2}\\) 个 \\(2^{k+1}\\)，然后遍历下一位，这样最终可以判断 \\(v_{i}\\) 是否能被集合表示。 方法二：使用数组对 \\(t_{i}=1\\) 的 \\(v_{i}\\) 计数，对于每个询问，从高到低遍历 \\(v_{i}\\) 的二进制 \\(1\\)。假设当前遍历到 \\(2^{k}\\)，则执行 \\(v_{i}=v_{i}-(\\min{(v_{i}&gt;&gt;k,c_{k})}&lt;&lt;k)\\) 操作（假设集合中有 \\(c_{k}\\) 个 \\(2^{k}\\)），表示将集合中的元素尽可能填补到 \\(v_{i}\\) 中，最终 \\(v_{i}\\) 还需要多少值，如果最终 \\(v_{i}=0\\) 则它可以被集合表示。 Array Collapse题目输入长度为 \\(n\\) 的数组 \\(p\\)，其中的元素互不相同。输出执行任意次操作能够得到的不同数组个数，结果对 \\(998244353\\) 取余。每次操作可以选择 \\(p\\) 的一个子数组（假设为 \\([i,j]\\)），将子数组中除最小值之外的所有数删除。 数据范围：\\(1\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq p_{i}\\leq 10^{9}\\)。 思路 方法一：使用分治 + 线段树的时间复杂度为 \\(O(n\\log{n})\\) 的思路，比赛时大概就是这个思路，不过想岔了一点。对于区间 \\([i,j]\\)，使用线段树找到区间最小值的下标，然后左右分治求不同数组的个数，最后将两者相乘。这个方法还有一些特殊情况需要维护，具体看代码。 方法二：参考灵神视频单调栈优化 DP，将 \\(f[i]\\) 定义为以 \\(p[i]\\) 结尾的子序列个数，然后利用动态规划转移，最后将所有 \\(f[i]\\) 求和得到答案。单调栈这个规律有点难想，具体看视频吧。","link":"/2023/12/21/Educational%20Codeforces%20Round%20160%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 916 (Div. 3)","text":"Three Activities题目输入长度为 \\(n\\) 的数组 \\(a,b,c\\)，输出 \\(a_{i}+b_{j}+c_{k}\\) 的最大值，要求 \\(i,j,k\\) 互不相同。 数据范围：\\(3\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i},b_{i},c_{i}\\leq 10^{8}\\)。 思路 方法一：可以发现答案只和数组 \\(a,b,c\\) 中最大的三个元素有关，首先建立三个数组对应的下标数组，对其降序排序。然后使用三重循环暴力枚举前三个元素的组合，要求 \\(i,j,k\\) 互不相同，最后取组合的最大值作为答案。 方法二：状压 DP，定义 \\(dp[i][j]\\) 表示 \\([0,i]\\) 范围内从 \\(j\\)（\\(0\\leq j\\leq 7\\)）所对应数组中各取一个元素，能够得到的元素和的最大值。例如，当 \\(j=3\\) 时，表示从 \\(a\\) 和 \\(b\\) 中取元素。可以使用倒序枚举的方式优化空间。 Game with Marbles (Hard Version)题目输入长度为 \\(n\\) 的数组 \\(a,b\\)，输出游戏结束时的得分 \\(s\\)。游戏内容为：玩家 \\(A,B\\) 每次可以选一个下标 \\(i\\)，如果当前轮到玩家 \\(A\\)，则进行 \\(s=s+(a_{i}-1)\\) 操作，否则进行 \\(s=s-(b_{i}-1)\\) 操作，不能重复选择同一个下标。游戏从玩家 \\(A\\) 开始，并且假设 \\(A,B\\) 双方都以最优的方式进行游戏。 数据范围：\\(2\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq a_{i},b_{i}\\leq 10^{9}\\)。 思路假设当前轮到玩家 \\(A\\)，选择下标 \\(i\\)，则答案会增加 \\(a_{i}-1\\)，并且 \\(b_{i}\\) 将会无效化。相当于每次选择对答案的贡献为 \\(a_{i}+b_{i}\\)，建立一个下标数组，按照该方式对数组降序排序。然后让玩家 \\(A,B\\) 依次选择数组中的下标，该游戏方式是最优的。","link":"/2023/12/21/Codeforces%20Round%20916%20(Div.%203)/"},{"title":"第 120 场力扣夜喵双周赛","text":"统计移除递增子数组的数目 II题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出子数组的数目，使得移除该子数组之后剩余的数是严格递增的，空数组也被认为是递增的。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 首先找到第一个满足 \\(a_{i}&gt;=a_{i+1}\\) 的下标 \\(i\\)。如果 \\(i=n-1\\)，则表示可以移除任意子数组，直接返回 \\(\\frac{n(n-1)}{2}\\)。否则，我们需要移除一个子数组使得剩余前缀和后缀分别递增，并且前缀的右端点小于后缀的左端点。可以使用双指针，一个指针枚举后缀的左端点 \\(j\\)，另一个指针从 \\(i\\) 开始左移，寻找满足条件的前缀的右端点 \\(i\\)，然后将 \\(i+2\\) 添加到答案中，重复此过程直到 \\(a_{j}&gt;=a_{j+1}\\)。","link":"/2023/12/26/%E7%AC%AC%20120%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 377 场力扣周赛","text":"移除栅栏得到的正方形田地的最大面积题目 输入整数 \\(m\\) 和 \\(n\\)，表示宽为 \\(m\\) 长为 \\(n\\) 的矩形，左上角为 \\((1,1)\\)，右下角为 \\((m,n)\\)。输入长度分别为 \\(p\\) 和 \\(q\\) 的数组 \\(a\\) 和 \\(b\\)，数组 \\(a\\) 中的数对矩形水平分割，数组 \\(b\\) 中的数对矩形垂直分割。输出从数组 \\(a\\) 和 \\(b\\) 中移除任意个数，所能够形成的最大正方形面积，结果对 \\(10^{9}+7\\) 取余。 数据范围：\\(3\\leq m,n\\leq 10^{9}\\)，\\(1\\leq p,q\\leq 600\\)，\\(1&lt;a_{i}&lt;m\\)，\\(1&lt;b_{i}&lt;n\\)。 思路 首先考虑对于宽来说，能够表示的长度是多少。显然，可以通过二重循环枚举出所有可能的长度。将宽能够表示的长度放入哈希表，然后同样使用二重循环枚举长能够表示的长度（假设当前枚举到长度 \\(x\\)），如果该长度在哈希表中，则说明可以形成长度为 \\(x\\) 的正方形。最后输出最大值即可。 转换字符串的最小成本 II题目 输入长度为 \\(n\\) 的字符串 \\(source\\) 和 \\(target\\)，以及长度为 \\(m\\) 的字符串数组 \\(original\\)、\\(changed\\) 和 \\(cost\\)。其中 \\(cost[i]\\) 表示将字符串 \\(original[i]\\) 替换为 \\(changed[i]\\) 的成本。输出将 \\(source\\) 转换为 \\(target\\) 所需的最小成本，如果无法转换则输出 \\(-1\\)。任意两个替换操作所替换的区间要么相同，要么不相交。 数据范围：\\(1\\leq n\\leq 1000\\)，\\(1\\leq m\\leq 100\\)，\\(1\\leq \\operatorname{len}(original[i])=\\operatorname{len}(changed[i])\\leq n\\)。 思路 首先使用哈希表将 \\(original\\) 和 \\(changed\\) 数组中的字符串映射为数字，每个数字都作为图中的一个顶点。对于每个下标 \\(i\\)，建立一条从顶点 \\(original[i]\\) 到顶点 \\(changed[i]\\) 的边，然后使用 Floyd 算法求出多源最短路径。最后使用动态规划，定义 \\(dp[i+1]\\) 为对 \\(source\\) 的前缀 \\([0,i]\\) 做替换使其和 \\(target\\) 的前缀 \\([0,i]\\) 相等，所需的最小代价。注意，外层循环枚举前缀的右端点 \\(i\\)，内层循环枚举 \\(original\\) 数组，总时间复杂度为 \\(O(m^{3}+n^{2}m)\\)。使用字典树会更快，参考灵神题解。","link":"/2023/12/26/%E7%AC%AC%20377%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 917 (Div. 2)","text":"Least Product题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出能够使 \\(\\prod_{i=1}^{n}{a_{i}}\\) 最小的最小操作次数。每次操作可以选择数组中的任意元素 \\(a_{i}\\)，如果 \\(a_{i}&lt;0\\)，则可以将其改为 \\([a_{i},0]\\) 中的任意整数，否则可以将其改为 \\([0,a_{i}]\\) 中的任意整数。 数据范围：\\(1\\leq n\\leq 100\\)，\\(-10^{9}\\leq a_{i}\\leq 10^{9}\\)。 思路 由于操作只会让所有元素乘积的绝对值变小，所以如果乘积是非正数，则不需要进行操作，否则只需进行一次操作，将任意一个元素改为 \\(0\\)。 Erase First or Second Letter题目 输入长度为 \\(n\\) 的字符串 \\(s\\)，输出进行任意次操作能够得到的不同非空字符串的个数。每次操作可以删除字符串的第一个字符或者第二个字符。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路 方法一：枚举剩余字符串的第一个字符下标 \\(i\\)，对于每个 \\(i\\) 都可以通过不断删除第二个字符得到 \\(n-i\\) 个不同的字符串。然后思考什么时候会出现相同的字符串，假设两次枚举的第一个字符分别为 \\(i\\) 和 \\(j\\)（\\(i&lt;j\\)），只有当 \\(s_{i}=s_{j}\\) 时才有可能出现相同字符串，进一步观察可以发现，对 \\(i\\) 操作得到的 \\(n-i\\) 个不同的字符串总是包含对 \\(j\\) 操作得到的 \\(n-j\\) 个不同的字符串。所以，假设字符串 \\(s\\) 中有 \\(m\\) 个不同的字符，每个字符第一次出现的位置分别为 \\(k_{0},k_{1},\\dots,k_{m-1}\\)，则答案为 \\(\\sum_{i=0}^{m-1}(n-k_{i})\\)。 方法二：枚举剩余字符串的第二个字符下标 \\(i\\)，对于每个 \\(i\\) 它的贡献为 \\([0,i-1]\\) 中不同字符的个数。 Watering an Array题目 输入长度为 \\(n\\) 的整数数组 \\(a\\)，长度为 \\(k\\) 的整数数组 \\(v\\)，以及整数 \\(d\\)。输出执行 \\(d\\) 次操作能够得到的最大分数。有两种类型的操作： 假设当前执行第 \\(i\\) 次操作，则将数组 \\(a\\) 的前缀 \\([a_{1},a_{b_{i}}]\\) 都加 \\(1\\)。其中 \\(b_{i}=v_{((i-1)\\bmod k)+1}\\)。 将 \\(a_{j}=j\\) 的元素个数加到分数中，然后将数组中的所有元素都置为 \\(0\\)。（下标从 \\(1\\) 开始） 数据范围：\\(1\\leq n\\leq 2000\\)，\\(1\\leq k\\leq 10^{5}\\)，\\(k\\leq d\\leq 10^{9}\\)，\\(0\\leq a_{i}\\leq n\\)，\\(1\\leq v_{i}\\leq n\\)。 思路 如果数组 \\(a\\) 中的元素都为 \\(0\\)，显然最大分数为 \\(\\lfloor\\frac{d}{2}\\rfloor\\)，对应的方案为交替执行两种操作。也就是说，解决问题的关键是确定何时第一次将数组 \\(a\\) 重置。这可以通过枚举实现，但是由于 \\(d\\) 很大，肯定不能直接枚举范围 \\([1,d]\\)。进一步观察可以发现，对前缀进行 \\(2n\\) 次加法，再重置最多得到 \\(n\\) 分，而先重置再交替执行操作，能够得到的分数大于等于 \\(n\\)，所以只需要枚举范围 \\([1,2n]\\)。 Yet Another Inversions Problem题目 输入长度为 \\(n\\) 的数组 \\(p\\)，表示 \\([1,2n-1]\\) 中所有奇数的一个排列。输入长度为 \\(k\\) 的数组 \\(q\\)，表示 \\([0,k-1]\\) 中所有整数的一个排列。定义长度为 \\(nk\\) 的数组 \\(a\\)，对于 \\(0\\leq i&lt;n\\) 和 \\(0\\leq j&lt;k\\)，有 \\(a_{i\\cdot k+j}=p_{i}\\cdot 2^{q_{j}}\\)。输出数组 \\(a\\) 的逆序数，结果对 \\(998244353\\) 取余。 数据范围：\\(1\\leq n,k\\leq 2\\cdot 10^{5}\\)，\\(1\\leq p_{i}\\leq 2n-1\\)，\\(0\\leq q_{i}&lt;k\\)。 思路 可以将数组看作 \\(n\\times k\\) 的矩阵，逆序数可以分为行内和行间。所有行的行内逆序数都是数组 \\(q\\) 的逆序数，使用归并排序或者树状数组即可求解，所以难点在如何快速求出行间的逆序数。首先尝试两两枚举所有行，然后观察对于确定的两个行，它们的逆序数有什么特点。由此可以发现，两行之间的逆序数大概是一个等差数列之和，项数和其他边界条件是由 \\(p_{i}\\) 和 \\(p_{j}\\) 的大小关系确定的。具体来说，假设 \\(p_{i}&lt;p_{j}\\)，等差数列是由满足 \\(p_{i}\\cdot 2^{z}&lt;p_{j}\\) 条件的最大的 \\(z\\) 确定的，确定 \\(z\\) 需要花费 \\(O(\\log{n})\\) 的时间。从而可以得到时间复杂度为 \\(O(n^{2}\\log{n}+k\\log{k})\\) 的朴素解法。（总是假设 \\(i&lt;j\\)） 下面解释等差数列是如何得到的，假设 \\(p_{i}\\cdot 2^{z}&lt;p_{j}\\)（\\(z\\geq0\\)），将对应的两行合并之后可以得到如下序列： $$ p_{i}\\cdot 2^{0},p_{i}\\cdot 2^{1},\\dots,p_{i}\\cdot 2^{z},p_{j}\\cdot 2^{0},p_{i}\\cdot 2^{z+1},p_{j}\\cdot 2^{1},\\dots,p_{i}\\cdot 2^{k-1},p_{j}\\cdot 2^{k-z-1},\\dots,p_{j}\\cdot 2^{k-1} $$ 要求逆序数，可以通过对每个 \\(p_{i}\\) 项前面有多少个 \\(p_{j}\\) 项计数，然后求和得到。可以发现，\\(p_{i}\\cdot 2^{z+1}\\) 前面有 \\(1\\) 个 \\(p_{j}\\) 项，\\(p_{i}\\cdot 2^{z+2}\\) 前面有 \\(2\\) 个 \\(p_{j}\\) 项，\\(p_{i}\\cdot 2^{k-1}\\) 前面有 \\(k-1-z\\) 个 \\(p_{j}\\) 项。得到逆序数为 \\(\\frac{(k-z)(k-1-z)}{2}\\)。 同理，假设 \\(p_{j}\\cdot 2^{z}&lt;p_{i}\\)（\\(z\\geq0\\)），将对应的两行合并之后可以得到如下序列： $$ p_{j}\\cdot 2^{0},p_{j}\\cdot 2^{1},\\dots,p_{j}\\cdot 2^{z},p_{i}\\cdot 2^{0},p_{j}\\cdot 2^{z+1},p_{i}\\cdot 2^{1},\\dots,p_{j}\\cdot 2^{k-1},p_{i}\\cdot 2^{k-z-1},\\dots,p_{i}\\cdot 2^{k-1} $$ 可以发现，\\(p_{i}\\cdot 2^{k-z-1}\\) 到 \\(p_{i}\\cdot 2^{k-1}\\) 的逆序数都为 \\(k\\)，总和为 \\(k(z+1)\\)。剩余部分的逆序数构成首项为 \\(z+1\\)，尾项为 \\(k-1\\)，公差为 \\(1\\) 的等差数列，总和为 \\(\\frac{(k+z)(k-1-z)}{2}\\)。得到逆序数为 \\(\\frac{(k+z)(k-1-z)}{2}+k(z+1)\\)。 如何降低时间复杂度？通过上述分析，可以知道对于任意 \\(p_{i}\\) 和 \\(p_{j}\\)，它们之间的逆序数是由 \\(z\\) 决定的。也就是说，如果给定 \\(p_{i}\\) 和 \\(z\\)（\\(z\\) 为任意整数），对于任意满足 \\(p_{i}\\cdot 2^{z}&lt;p_{j}&lt;p_{i}\\cdot 2^{z+1}\\) 条件的 \\(p_{j}\\) 来说，\\(p_{i}\\) 和 \\(p_{j}\\) 之间的逆序数都是相同的。注意，当 \\(z&lt;0\\) 时，对不等式变形得到 \\(p_{i}\\cdot 2^{-1}&lt;p_{j}\\cdot 2^{-z-1}&lt;p_{i}\\)，此时的 \\(z\\) 和上面逆序数公式中的 \\(z\\) 不同，并且需要处理整数除法的舍入问题（存在一些边界情况）。 要快速求出区间中 \\(p_{j}\\) 的个数，可以使用树状数组/线段树，从而可以得到 \\(O(n\\log{\\min(\\log{n},k)}+k\\log{k})\\) 的解决方案。外层循环枚举 \\(p_{i}\\)（倒序遍历数组 \\(p\\)，因为之前的讨论都基于 \\(i&lt;j\\) 的假设），内层循环枚举 \\(z\\)（大小由 \\(n\\) 和 \\(k\\) 限制），然后使用树状数组求区间和，之后可以 \\(O(1)\\) 时间内计算出该区间的 \\(p_{j}\\) 和当前枚举的 \\(p_{i}\\) 之间的逆序数。 PS：还有另一种写法，只需要对树状数组的前缀求和，而不是区间求和，写起来好像更简单，但是没看懂。好难，溜了。","link":"/2023/12/26/Codeforces%20Round%20917%20(Div.%202)/"},{"title":"数据复制","text":"复制指在多个节点上存储相同的数据，以降低访问延迟（数据分布在多个地理位置），提高容错性和吞吐量。如果复制的数据一成不变，那么只需要简单地将数据复制到每个节点。然而复制的挑战在于如何处理不断变化的数据（如何保证数据的一致性），下面讨论三种流行的应对复制数据变化的方法：主从复制、多主复制和无主复制。 主从复制 工作原理 主从复制也被称为单主复制，客户端必须将写请求发送给主节点，主节点首先将更改应用到本地，然后再将更改发送给所有从节点。客户端可以将读请求发送给主节点或者从节点。 同步和异步复制 同步复制 优点：如果主节点发生故障，则可以在从节点访问到最新数据。 缺点：如果从节点发生故障，则主节点会被阻塞直到从节点复制完成。 异步复制 优点：主节点不会被阻塞，系统的吞吐量更大。 缺点：如果主节点发生不可恢复的故障，则所有未被复制到从节点的更改都会丢失。 实践中，通常只将一个从节点设置为同步模式，其他从节点设置为异步模式。如果主节点发生故障，则可以在同步的从节点访问到最新数据；如果同步的从节点发生故障，则可以将另一个异步的从节点升级为同步模式。这种配置方式被称为半同步。 配置新的从节点 当需要提高系统的容错性或者替换失效的从节点时，就需要增加新的从节点。此时如何保证新的从节点和主节点的数据一致？简单地将数据从主节点复制到从节点是不行的，因为数据在不断变化，这样可能会丢失更改。或者可以对数据库加写锁，但是这会违反高可用的设计目标。 实际上，可以在不中断数据库服务的情况下完成新的从节点的配置。步骤如下：对主节点的数据创建一个一致性快照，将此快照复制到从节点，然后从节点向主节点请求快照之后的更改日志（根据快照中的 LSN 确定），获得日志之后重做日志的更改（这个步骤称为追赶）。 处理节点失效 从节点失效：追赶式恢复 如果从节点发生故障，然后顺利重启，或者主从节点之间的网络发生中断，则从节点可以通过向主节点请求故障期间的日志，并且将日志应用到本地来追赶主节点，从而恢复正常状态。 主节点失效：节点切换 如果主节点发生故障，选择某个从节点将其升级为主节点，同时更新客户端的主节点的信息。切换可以手动进行，也可以自动进行。 自动切换的步骤如下： 确认主节点失效（心跳检测）。 选举新的主节点（共识算法）。 重新配置系统使新主节点生效（修改客户端配置以及原主节点上线之后降级为从节点）。 切换过程存在的问题： 如果使用了异步复制，并且新的主节点并未和原主节点同步，则原主节点上线之后可能会尝试将未完成复制的更改发送到新的主节点，从而产生冲突。常见的解决方案是将未完成复制的更改丢弃，这会违背持久化的承诺。 如果有外部系统依赖于数据库的内容，丢弃数据的方案会产生很严重的问题（可能会导致数据泄露）。 在某些故障下，会发生两个节点同时都认为自己是主节点的情况（称为脑裂），这可能会导致数据丢失或者破坏。 如何设置合适的超时时间来检测主节点失效。 复制日志的实现 原书中描述的是基于语句的复制，基于预写日志的复制，基于行的逻辑日志的复制等。下面将预写日志改为物理日志，将语句和行归为逻辑日志。之所以这样，是因为根据我所看过的一些资料（包括 CMU-15445）都将语句归为逻辑日志，而基于行的复制根据书上的说法，它和存储引擎解耦，同时书上也称其为基于行的逻辑日志的复制，所以我将两者都归为逻辑日志。而把预写日志改为物理日志，是因为书上说预写日志描述的是数据的字节级更改，按照这个说法，明显是预写日志的物理日志模式（CMU-15445 中描述了预写日志的三个日志模式：物理日志，逻辑日志，混合日志）。 基于物理日志的复制 解释：主节点将物理日志发送给从节点。 缺点：由于物理日志描述的是数据的字节级更改，这种复制方案和存储引擎紧密耦合，此时主从节点必须使用相同版本的存储引擎。所以在进行数据库升级时，只能首先将主从节点停机，再进行升级。如果复制方案允许从节点的版本比主节点更高，则可以首先将从节点升级，然后将从节点作为新的主节点，从而实现不停机升级。 基于逻辑日志的复制 解释：分为基于语句的复制和基于行的复制，主节点将逻辑日志（和物理存储引擎解耦的日志格式）发送给从节点。 缺点：如果使用基于语句的复制，则某些语句可能在不同节点产生不同的执行结果。例如：语句使用非确定性函数（NOW，RAND），语句依赖于数据库现有数据，有副作用的语句（触发器、存储过程、用户定义的函数）。 优点：主从节点可以运行不同版本的存储引擎，甚至是不同的存储引擎。对于外部应用程序，逻辑日志格式也更容易解析。 基于触发器的复制 解释：之前的复制都是由 DBMS 实现的，但在某些情况下可能需要更高的灵活性，这时需要将复制交给应用程序实现。一种方法是让应用程序读取数据库日志从而获取数据更改，另一种方法是使用触发器和存储过程，当发生数据更改时自动执行存储过程，将数据更改记录到单独的表中，应用程序通过访问该表来获取数据更改。 分析：此复制方式开销更高，也更容易出错或者暴露一些限制，但是具有更高的灵活性。 复制滞后问题 如果使用异步复制，则会出现主节点和从节点的数据不一致的情况，这种不一致只是暂时的状态。如果停止写数据库，则从节点最终会追赶上主节点，这被称为最终一致性。虽然主从节点最终会保持一致，但是暂时的不一致会引发各种问题，下面将讨论相关问题和解决方案。 写后读 问题：用户写入数据之后立即读取这些数据，如果读请求被发送给滞后的从节点，则用户看不到刚才写入的数据。 解决：此时，我们需要保证写后读一致性（也称为读写一致性），该一致性要求用户能够立即看到自己最近写入的数据，但是不保证其他用户能够立即看到这些数据。系统可以通过跟踪用户最近写入的时间戳，来保证将读请求发送给包含对应数据的节点。 单调读 问题：用户执行两次相同的查询，对应的读请求分别被路由两个不同的从节点，并且第二次查询访问的从节点比第一次查询访问的从节点更滞后。这会导致用户首先看到新数据，然后看到旧数据，就好像数据被回滚一样。 解决：此时，我们需要保证单调读一致性，该一致性要求用户进行多次读取时，不会先读到新数据再读到旧数据，即读取的数据对应的时间戳是单调递增的。系统可以总是将同一用户的读请求路由到同一个节点来保证单调读。 前缀读 问题：存在因果关系的数据被划分到不同的分区，用户在读取数据时可能会先看到果后看到因。 解决：此时，我们需要保证前缀读一致性，该一致性要求按照写入数据的顺序读取数据。对于未分区的单主数据库而言，数据总是按照因果关系的顺序写入数据库[1]，在读取数据时也总是按照因果关系的顺序读取，因此不会发生该异常。但是，如果数据被划分到不同分区，不同分区独立运行，无法保证分区之间的从节点按照因果关系的顺序写入数据[2]，此时将会发生异常。简单的想法是在复制日志中记录时间戳，但是由于存在时钟偏差问题，该方法不可行。一种解决方案是将具有因果关系的写入都交给一个分区完成，但是这样做的效率很低。另一种解决方案是使用版本向量技术跟踪因果关系，这将在无主复制的检测并发写中进行讨论。PS：这部分是按照我的理解描述的，可能存在错误。 多主复制 工作原理 系统中包含多个主节点，每个主节点都可以接收写请求，并且需要将更改发送给其他主节点和自己的从节点。 使用场景 多数据中心：为了容忍数据中心级别的故障或者使数据库更接近用户，可以把数据库的副本存储在多个数据中心。如果使用主从复制，主节点只能存在于某个数据中心，所有写请求都必须经过该数据中心。如果使用多主复制，则可以为每个数据中心设置一个主节点，在数据中心内部使用主从复制，主节点之间通常使用异步复制进行同步。 多主复制相比主从复制在多数据中心场景下的优势：写入延迟更低，对网络性能的依赖更低，能够容忍数据中心失效。缺点是，如果使用异步复制，多个主节点同时更改相同的数据时会产生写冲突。 处理写冲突 冲突检测 如果使用异步复制，那么多个主节点可以同时更改相同的数据，并且只能在稍后的复制过程中检测到冲突。 如果使用同步复制，每次只能进行一个写请求，无法发挥多个主节点的优势，那还不如直接使用主从复制。 冲突避免 可以在应用层保证对相同数据的写请求路由到相同的数据中心，但是在某些时候需要改变事先指定的数据中心，例如在数据中心故障或者用户移动到其他位置导致离某个数据中心更近时，写请求将会被路由到其他数据中心。 冲突解决 可能的解决方式如下： 为每个写请求分配唯一的 ID（时间戳、随机数、UUID、哈希值），然后按照某种规则选择特定的写请求。 为每个节点分配唯一的 ID，然后按照某种规则确定优先级。 将多个写入的值合并。 保存冲突信息，然后在应用层解决冲突。 在应用层解决冲突是最合理的方式，可以在写入时调用用户定义的冲突处理程序解决，还可以保留多个写入值，然后在读取时调用程序或者通知用户解决。还有一些自动解决冲突的方法，包括使用无冲突的复制数据类型（CRDT）、可合并的持久数据结构、操作转换算法。 拓扑结构 复制的拓扑结构描述了写日志从一个节点传播到其他节点的通信路径，包括全部至全部型拓扑（完全图）、环形拓扑、星形拓扑等。在环形和星形拓扑中，写日志需要经过多个节点才能传播到所有节点，为了避免循环复制（自己的写日志被传播给自己，然后又进行一轮传播），在复制日志中都会记录已传播节点的标识符。 星形和环形拓扑的问题是单点故障会影响写日志的传播，这可以通过在故障时重新配置拓扑结构解决。而全部至全部型拓扑的问题是在传播时写日志的因果顺序无法保证（参考复制滞后问题中的前缀读）。 无主复制 工作原理 客户端并行地将写请求发送给多个节点，如果得到多数节点的确认，则认为写入成功。读取时也是并行地从多个节点上读取数据，此时可能得到多个不同的值（由于复制滞后），系统会使用某种机制确定新值以及更新旧值。 读修复和反熵 当节点失效之后重新上线，可以使用以下两种机制进行追赶。 读修复 解释：客户端并行读取多个节点，获取的数据中包含版本号，以判断数据的新旧，同时会更新包含旧数据的节点。 分析：该方法适合读密集的场景，不然包含旧数据的节点得不到更新。 反熵 解释：使用后台进程检测节点之间数据的差异，然后将新数据复制到包含旧数据的节点。 分析：和基于主节点的复制不同，此过程不保证按照特定的顺序复制数据，并且会引入明显的滞后。 读写仲裁（quorum） 如果有 \\(n\\) 个节点参与仲裁，写入时需要得到 \\(w\\) 个节点的确认，读取时至少查询 \\(r\\) 个节点，则只要 \\(w+r&gt;n\\)，读取的节点中就一定会包含最新值。满足该条件的读/写操作被称为仲裁读/写（或者法定票数读/写），可以将 \\(w\\) 和 \\(r\\) 看作是确认读/写操作是否有效的最低票数。 通常会将 \\(n\\) 设置为奇数，将 \\(w\\) 和 \\(r\\) 设置为 \\(\\frac{n+1}{2}\\)。当然也可以根据实际情况做调整，例如对于读多写少的负载，设置 \\(w=n\\) 和 \\(r=1\\) 比较合适，这样读取速度很快，但是只要有一个节点失效就会导致仲裁写失败。 通常读/写请求总是并行发送给所有节点，参数 \\(w\\) 和 \\(r\\) 只是决定要等待的节点数。如果可用的节点数小于 \\(w\\) 或 \\(r\\)，则读/写操作就会返回错误。 也可以将 \\(w\\) 和 \\(r\\) 设置为较小的值，使得 \\(w+r\\leq n\\)，不满足仲裁条件。此时可能读取到的值都是旧值，但是可用获得更低的延迟和更高的可用性。即使在 \\(w+r&gt;n\\) 的情况下，也可能存在只读取到旧值的边界条件。 如果需要更高的容错性，可用使用宽松的读写仲裁：写入和读取仍需要 \\(w\\) 和 \\(r\\) 个节点确认，但是可以利用 \\(n\\) 个节点之外的其它节点（参与仲裁的节点数量为 \\(n\\)，集群中的节点数量大于 \\(n\\)）。例如，当 \\(n\\) 个节点中的多数节点失效时，客户端会向额外的节点发送读/写请求，当失效节点重新上线时，将额外节点中的新值复制到这些滞后的节点。 检测并发写 和多主复制类似，无主复制同样存在写冲突。在多主复制的处理写冲突中介绍过，可以为每个写请求分配一个时间戳，然后选择保留时间戳最大的写请求，这被称为最后写入者获胜（last write wins，LWW）。LWW 可以实现最终一致性，代价是牺牲数据的持久性，因为小于最大时间戳的并发写入都会被覆盖，由于时钟偏差，该算法甚至可能覆盖非并发写入。是否使用该算法依据实际场景而定，例如在缓存系统中覆盖是可以接受的，则可以使用该算法。 我们可以使用版本向量技术来判断两个写操作是否并发。如果一个写操作发生在另一个写操作之前（依赖关系/因果关系），则后面的写操作可以覆盖前面的写操作。如果是并发的，就需要处理写冲突问题。算法的工作流程见书上，本质上就是通过在写之前读，来获取数据的当前值以及版本向量（该数据在所有节点上的版本号的集合），之后的写操作只会覆盖服务器中低版本的数据，从而并发写（高版本）的数据得到保留。PS：书上只是简单提了一下，还有很多细节没说。 首先因被写入数据库，然后因被读取，从而产生果，之后果才被写入数据库。 ↩︎ 参考注 1，分区之间的主节点总是按照因果关系的顺序写入数据，但是分区之间的从节点就无法保证写入顺序。 ↩︎","link":"/2023/12/27/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"},{"title":"数据分区","text":"分区/分片（动词）就是将数据拆分为多个子集，一个子集被称为一个分区[1]（名词）。使用数据分区的目的是提高可扩展性，不同分区可以存储在不同节点上，查询负载也随之分散到多个节点。在面对海量数据集或者非常高的查询压力，使用数据复制还不够，这时就需要使用数据分区。当分区和复制结合使用时（假设为主从复制），每个分区都会有自己的主节点和从节点，这种情况下单个节点也会存储多个分区的数据（作为某个分区的主节点和其他分区的从节点）。 分区方式 最好的情况是将数据和查询负载均匀分布到所有节点。如果分区不均匀，就会出现负载的倾斜，这会导致分区的效率下降。极端情况下，所有负载都集中在单个节点上，其他节点都处于空闲状态，此时这个节点被称为系统的热点。避免热点的最简单的方法是将记录随机分配给所有节点，但是由于不知道数据的分布情况，在查询时需要访问所有节点。下面将会介绍对键值数据和二级索引进行分区的方式。 这节的内容看得有点懵。按我的理解，键（key）也被称为关键字（keyword），它是一列或多列属性的集合，可以是唯一的或者不唯一的。但是按照书中的描述以及我在网上看到的定义来说，在“键值数据”这样的词中，似乎要求键必须是唯一的。书中在介绍完键值数据之后，又紧接着介绍二级索引，然后说二级索引在分区时的复杂性在于索引键的不唯一。但是书中接下来的讨论让我感觉，二级索引在分区时的复杂性在于如何创建二级索引，即是创建本地索引还是全局索引。 键值数据 基于区间的分区 解释：可以为每个分区分配一个关键字区间，区间可以由管理员手动选择，或者由数据库自动选择。 优点：分区内的数据可以按照关键字排序存储，从而支持区间查询。 缺点：如果查询集中访问某个范围内的数据，则会导致热点问题，解决方案是使用额外的内容作为关键字的第一列。 基于哈希的分区 解释：可以为每个分区分配一个哈希值区间，关键字根据哈希值进行分区，用于分区的哈希函数不需要很强的加密性。 分析：可以将关键字均匀的分配到多个分区，但是不能很好地支持关键字上的区间查询（查询时需要将请求发送给所有分区）。如果使用的是联合关键字，则可以只将关键字的第一列用于哈希分区，然后将其他列用作联合索引来对分区内的数据排序，从而可以在关键字的其他列上实现区间查询。 问答：为什么要将哈希值拆分为区间，而不直接使用取模操作？因为如果添加/删除节点，取模会导致大量的数据迁移。 负载倾斜与热点 虽然哈希分区可以减轻热点，但是无法完全避免。极端情况下，所有读/写操作都是针对一个关键字，则最终所有请求都会被路由到同一个分区。例如，发生热点事件时，会产生大量对相同关键字的读/写操作，此时哈希分区起不到作用。大多数系统至今仍无法自动消除这种高度倾斜的负载，而只能通过应用层来减轻倾斜程度。例如，如果某个关键字被认为是热点，则可以通过在关键字的开头或结尾添加随机数（有点像密码学中的盐值），从而将请求路由到不同分区。但是，此时读操作必须将多个分区中的数据合并，开销较大。 二级索引 基于文档的分区 解释：每个分区独自创建和维护二级索引，创建的是本地索引，而非全局索引。 缺点：如果要使用索引查询满足某个条件的数据，则需要将查询请求发送给所有分区，然后合并返回的结果。 基于词条的分区 解释：对所有数据创建全局索引，然后对索引进行分区，可以使用区间或哈希分区。 优点：进行单关键字查询时，只需要读取单个分区，因为相同的索引键都会被分配到相同的节点。 缺点：即使更新的是单个节点上的数据，可能也需要更新多个节点上的索引。如果选择同步更新，那么需要分布式事务的支持，写请求会被阻塞；如果选择异步更新，就意味着更新的滞后。 分区再平衡 在某些情况下，可能需要为数据库添加/删除节点，我们希望在添加/删除节点的过程中平衡所有节点的负载，这个迁移负载的过程被称为再平衡或者动态平衡。 再平衡的策略 固定数量的分区 解释：创建远超实际节点数的固定数量的分区，然后为每个节点分配多个分区。如果添加节点，则从每个现有节点中移动几个分区到新节点；如果删除节点，则将其中的分区均匀分配给剩余节点。也可以将硬件配置考虑进来，为性能更强的节点分配更多的分区。 分析：如果数据的规模不确定，就很难确定合适的分区数量。每个分区包含的数据量的上限是固定的，实际大小应该和集群中的数据总量成正比。如果分区数量太大，则每个分区包含的数据量太小，徒增管理开销；如果分区数量太小，则每个分区包含的数据量太大，再平衡和故障恢复的开销就更大（不是很懂为什么）。 动态分区 解释：为每个分区设置阈值，如果分区中的数据量太大或太小，就会进行分裂或合并（类似 B+ 树）。每个节点可以包含多个分区，当某个分区分裂时，可以将其中一半的数据转移到其他节点，以平衡负载。 分析：优点是分区的数量可以通过分裂和合并自动适配数据总量。对于空的数据库来说，需要进行预分裂，从而避免开始时只存在一个分区，导致负载不均衡的情况。 按节点比例分区 解释：为每个节点分配固定数量的分区。如果添加节点，则随机选择固定数量的现有分区进行分裂。 分析：随机选择可能会带来不公平的分裂，但是当每个节点包含的分区数量较大时，可以减少不公平的概率。 疑问：为什么书上说随机选择分区边界的前提是使用哈希分区，以及为什么说该方法符合一致性哈希。 请求路由 我们已经知道如何将数据分区，以及如何平衡节点上的分区，现在还有一个问题是，如何将请求路由到对应分区所在的节点。如果发生分区再平衡，分区和节点的对应关系还会随之变化，我们需要能够跟踪这些变化。有如下三种处理策略： 客户端将请求发送给任意节点，如果当前节点没有对应的分区，则将请求转发给其他节点，直到找到对应节点。 客户端将请求发送给路由层（负载均衡器），路由层负责将请求转发给对应节点。 客户端跟踪分区和节点之间的关系，直接将请求发送给对应节点。 不管使用哪种方法，核心问题是：作出路由决策的组件（节点、路由器、客户端）如何跟踪分区和节点的对应关系。有的分布式系统依靠独立的协调服务（例如 ZooKeeper）跟踪对应关系，有的使用 gossip 协议在节点之间同步对应关系，等等。 PS：数据分区这章看得有点痛苦，感觉书上的表述很乱，包括多个同义词混用，以及前后表述不一致。一些部分也讲得很模糊，没有一个实际的例子，单是看某句话感觉会有歧义，不知道实际上想表达的是什么。先这样吧，总感觉笔记上有很多问题。 这里讨论的数据分区和网络分区问题（一种节点间的网络故障）中的分区是不同的概念。 ↩︎","link":"/2023/12/29/%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/"},{"title":"Good Bye 2023","text":"Two Divisors 题目 输入两个整数 \\(a\\) 和 \\(b\\)，它们是 \\(x\\) 的最大除数，满足 \\(1\\leq a\\leq b&lt;x\\)。输出 \\(x\\) 的值。 数据范围：\\(1\\leq a\\leq b&lt;x\\leq 10^{9}\\)。 思路 首先 \\(b\\) 肯定等于 \\(x\\) 除以最小的质因数，然后 \\(a\\) 可能等于 \\(x\\) 除以两次最小的质因数，或者等于 \\(x\\) 除以次小的质因数。这可以根据 \\(b\\bmod a\\) 是否等于 \\(0\\) 来确定，如果是则 \\(x=b\\times\\frac{b}{a}\\)，否则 \\(x=b\\times\\frac{a}{\\gcd(a,b)}\\)。 Mathematical Problem 题目 输入奇数 \\(n\\)，输出 \\(n\\) 个不同的数，它们都是整数的平方，并且 \\(n\\) 个数的数位构成的多重集合都相同。 数据范围：\\(1\\leq n\\leq 99\\)。 思路 只需要在 \\(169,196,961\\) 的基础上添加 \\(0\\) 就可以构造出满足条件的 \\(n\\) 个数，方法直接看题解或者代码吧，反正 \\(169\\) 和 \\(961\\) 这两个数比较特殊，真不知道大家怎么做出来的。","link":"/2023/12/31/Good%20Bye%202023/"},{"title":"第 378 场力扣周赛","text":"找出出现至少三次的最长特殊子字符串 II 题目 输入长度为 \\(n\\) 的由小写字母组成的字符串 \\(s\\)。如果一个字符串仅由单一字符组成，则它被称为特殊字符串。输出在 \\(s\\) 中出现至少三次的最长特殊非空子字符串的长度，如果不存在则输出 \\(-1\\)。 数据范围：\\(3\\leq n\\leq 5\\times 10^{5}\\)。 思路 可以直接想到二分答案，时间复杂度为 \\(O(n\\log{n})\\)。不过该题有 \\(O(n)\\) 的做法，其实就是分类讨论。首先遍历一边数组，将数组按照字母分段，把对应的长度存到桶中。假设字符串 \\(s\\) 的最长特殊子字符串的长度为 \\(m\\)，则答案必定在 \\([m-2,m]\\) 范围内，枚举答案然后判断是否满足条件即可。当然还可以像灵神一样讨论得更细，但是不好理解。 回文串重新排列查询 题目 输入长度为偶数 \\(n\\) 的字符串 \\(s\\)，以及长度为 \\(m\\) 的二维数组 \\(q\\)，其中 \\(q_{i}=[a_{i},b_{i},c_{i},d_{i}]\\)。对于每个查询 \\(i\\)，可以将区间 \\([a_{i},b_{i}]\\) 和 \\([c_{i},d_{i}]\\) 中的字符重新排列，输出是否能让字符串 \\(s\\) 变为回文串。每个查询是独立的。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq m\\leq 10^{5}\\)，\\(0\\leq a_{i}\\leq b_{i}&lt;\\frac{n}{2}\\)，\\(\\frac{n}{2}\\leq c_{i}\\leq d_{i}&lt;n\\)。 思路 比赛时基本的思路是有的，就是没有实现出来。首先可以将后半段字符串反转，将原串当成两个字符串，这就将问题转化为判断操作之后两个字符串能否相等，从而简化实现。然后就是预处理前缀的字符计数（类似前缀和），最后对每个查询分类讨论，两个区间是相离、相交还是包含关系。个人觉得稍微复杂点的就是相交关系该如何判断，具体可以看题解区。","link":"/2023/12/31/%E7%AC%AC%20378%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"再见 2023","text":"时间过得好快！今年大概有 5 个月的时间都在搞算法，然后其他时间基本上每周都会打比赛，虽然对面试来说不应该花费这么多时间，但是我喜欢算法给我带来的反馈，以及比赛时能够高度集中注意力的状态。特别是绞尽脑汁然后 AC 的感觉，真的很棒。即使不会做，赛后也可以通过题解来学习。 力扣基本上可以稳定三题，上 2300 分之后就有点没状态，排名波动有点大。在打 CF 之前就听说，力扣分减 700 大概就是 CF 分，结果还真是这样。CF 思维题较多，前四题基本上不会使用很复杂的数据结构，如果能稳定四题就能到 1900 分吧。AtCoder 题目有点水，对我来说，基本上从 D 题开始才算正式进入比赛，但是经常简单题也没做出来。令人印象深刻的是，获得两次群主发的进步奖。 5 月份阅读完《OSTEP》，9、11 月份学习完课程 CMU 15-445，并且做完四个相关的项目，感觉还不错。12 月份阅读《DDIA》25%，然后摸鱼。6-8 月份，高数、线代、Linux、Java 虚拟机、Spring、设计模式雨露均沾，基本上没有特别深入的，当时有点急躁。总的来说，确实有做不少事，但是效率不高，目的不明确，缺乏实践，要做的事还有很多。","link":"/2023/12/31/%E5%86%8D%E8%A7%81%202023/"},{"title":"UNICODE 双向算法","text":"前段时间看到群友聊天，使用特殊的昵称能够让文字的顺序发生变化。我把昵称复制到 IDEA 里面，发现包含一个显示为 RLI 的字符。在网上查询之后，发现是 Unicode 为显示双向文本提供的一个特殊字符，功能是将之后的文本视为独立的从右到左的顺序。还有其他特殊的格式化字符，以及用于解析这些字符并正确显示文本顺序的 Unicode 双向算法。 1print(&quot;⁧;(&quot; 上面的文本在浏览器中会显示为 print(&quot;&quot;);，因为在第一个引号之后有一个 RLI 字符。如果在之后添加文字： 1print(&quot;⁧;(&quot;Hello World! 则会显示为 print(&quot;!Hello World&quot;);，具体的显示方式和双向算法的实现有关。介绍 Unicode 双向算法的两个网站：UNICODE BIDIRECTIONAL ALGORITHM，Unicode Bidirectional Algorithm basics。","link":"/2024/01/01/UNICODE%20%E5%8F%8C%E5%90%91%E7%AE%97%E6%B3%95/"},{"title":"MapReduce: Simplified Data Processing on Large Clusters","text":"阅读论文 MapReduce，做个总结，部分内容参考课程的笔记。 概念 MapReduce 是一个编程模型，用于处理和生成大型数据集。它将并行、容错、数据分布和负载均衡的复杂性隐藏在库中，使得没有任何并行和分布式系统经验的程序员可以轻松利用大型分布式系统的资源。 MapReduce 将计算（computation）抽象为 \\(Map\\) 和 \\(Reduce\\) 函数。通常，\\(Map\\) 函数处理一个键值对，生成一组中间键值对。然后 MapReduce 库将具有相同中间键的值存储在一个列表中，以迭代器的方式提供给 \\(Reduce\\) 函数，避免因为数据量太大从而溢出到磁盘。\\(Reduce\\) 函数处理一个中间键以及该键的值列表，然后将列表中的值合并。 以下是可以被抽象为 MapReduce 计算的问题：统计文档中单词的出现次数，Grep（模式匹配），倒排索引，排序等。 实现 MapReduce 的实现方式取决于使用场景，Google 的常见计算场景是通过交换式以太网连接的大型计算机集群，使用 GFS 管理存储在各个机器的磁盘上的数据。用户将作业（job）提交给调度系统，每个作业由多个任务（task）组成，通过调度系统映射到可用的机器上。有关场景的详细信息见论文，下面介绍基于该场景的 MapReduce 实现。 概述 用户程序在调用 \\(MapReduce\\) 函数之后，用户程序中的 MapReduce 库首先将输入文件划分为 \\(M\\) 块，通常每块 16-64 MB。然后将用户程序复制到集群的多个机器上运行，由一个 master 和多个 worker 组成，master 会将一个 map 任务或 reduce 任务分配给空闲的 worker。 GFS 将所有文件划分为 64 MB 的块，并且将每个块的多个副本存储在不同的机器上。MapReduce 的 master 将 map 任务分配给包含输入文件的机器，从而可以避免通过网络传输输入数据（节省网络带宽）。 map worker 从 GFS 中读取文件，解析键值对并将其传递给用户的 \\(Map\\) 函数。\\(Map\\) 函数生成的中间键值对会被分区函数划分为 \\(R\\) 个文件（每个 reduce 任务一个文件），存储在机器的本地磁盘。\\(R\\) 个中间文件的位置和大小信息会被发送给 master，然后 master 负责将这些信息发送给 reduce worker。 reduce worker 收到文件的位置和大小信息之后，使用远程过程调用（RPC）从 map worker 的磁盘读取文件。当 reduce worker 读取完 \\(M\\) 个中间文件时，它会将数据按照中间键排序，以使相同键的键值对彼此相邻。reduce worker 迭代已排序的数据，它将唯一键以及该键对应的值列表传递给用户的 \\(Reduce\\) 函数。\\(Reduce\\) 函数合并数据，将结果写入 GFS 中的一个文件（每个 reduce 任务一个文件）。PS：GFS 会将输出文件以多个副本块的形式存储在多个机器上。 当所有 map 和 reduce 任务完成之后，master 唤醒用户程序。此时，在用户程序中的 \\(MapReduce\\) 函数调用返回至用户代码。通常，用户不需要将这些文件合并，而是将这些文件作为另一个 MapReduce 作业的输入。 细节 Master 数据结构 对于每个 map 和 reduce 任务，master 会记录任务的状态（idle，in-progress，completed），以及非 idle 任务所在的 worker 的标识。对于每个 map 任务，master 会记录 \\(R\\) 个中间文件的位置和大小信息，总共记录 \\(M\\times R\\) 个信息。 容错 worker 失效 master 定期对每个 worker 执行 ping 操作，如果超时未响应则将其标记为失效。失效 worker 已完成的任何 map 任务、正在执行的 map 和 reduce 任务都会被重置为 idle 状态，从而可以分配给其他 worker。 已完成的 map 任务在 map worker 发生故障时需要重新执行，因为它们的输出存储在失效机器的本地磁盘上，无法被访问。而已完成的 reduce 任务将输出存储在 GFS 中，所以在发生故障时不需要重新执行。 当失效的 map worker A 被 map worker B 替代时，将会通知所有 reduce worker 重新执行，任何没有从 A 读取数据的 reduce 任务将会从 B 读取数据。PS：已从 A 读取数据的 reduce 任务该如何处理，论文没有说明。我的想法是，如果已读取完，则不会有问题。如果读取到一半，那么直接丢弃即可。 master 失效 定期持久化 master 数据结构的检查点（checkpoint），如果 master 失效，则可以从上一个检查点状态重新开始。论文中表示单个 master 失效的可能性不大，所以发生故障时会中止 MapReduce 计算。 PS：检查点和失效点之间的状态会丢失，有可能已完成的 map 任务没有被 master 持久记录已完成。如果持久状态是 idle，则会导致重新分配 map 任务。如果持久状态是 in-progress，则需要等待 worker 发送完成信息，但 worker 如何知道需要重新发送完成信息，这需要额外的机制。 任务粒度 一个 map 任务处理一个文件，生成 \\(R\\) 个中间文件，分别由 \\(R\\) 个 reduce 任务处理。理论上，\\(M\\) 和 \\(R\\) 的大小应该远大于 worker 的数量，从而分配更多的任务给较快的机器，以均衡负载。如果 worker 发生故障，还可以通过将任务分散到多个 worker 上来提升故障恢复的速度。 备份任务 由于 MapReduce 操作需要等待所有任务完成才能够继续推进，所以少数缓慢的机器（straggler）会拖慢整个操作。当 MapReduce 操作接近完成时，master 可以冗余执行剩余的任务，以缩短 MapReduce 的执行时间。 问题 Q：如果网络延迟导致 master 将 worker 标记为失效，master 如何处理旧 map worker 发送的中间文件信息？GFS 如何处理重复 reduce 任务的输出？ A：对于 map 任务，论文提到 master 会忽略 map 任务的重复完成消息，但是它是否会接收旧 worker 的消息，毕竟已经分配新 worker 重新执行该 map 任务。不论如何，只要保证 reduce 任务只从其中一个中间文件读取数据，就没有问题。对于 reduce 任务，输出首先被写入临时文件，当任务完成时再重命名为最终文件，GFS 提供原子重命名（使用锁），从而相同 reduce 任务只会有一个输出文件。 总结 论文在介绍完实现之后，还提出对实现的改进、测试实现在 Grep 和 Sort 场景的性能等。MapReduce 的成功主要在于，隐藏各种细节使得 MapReduce 易于使用，很多问题都可以表示为 MapReduce 计算，而且作者开发的 MapReduce 实现可以有效利用大型计算机集群的资源。从中可以学到：限制编程模型可以使并行和分布式计算更容易，使计算具有容错性；网络带宽是稀缺资源，使用局部性优化可以节省网络带宽；冗余执行可以减少缓慢机器的影响。","link":"/2024/01/06/MapReduce%20Simplified%20Data%20Processing%20on%20Large%20Clusters/"},{"title":"AtCoder Beginner Contest 335","text":"Non-Decreasing Colorful Path 题目 输入有 \\(n\\) 个顶点和 \\(m\\) 条边的连通的无向图（没有重边和自环），每个顶点上有一个整数 \\(A_{i}\\)，输出所有从顶点 \\(1\\) 到 \\(N\\) 的简单路径的最高得分。如果路径中顶点上的整数构成的序列非递减，那么该路径的得分为序列中不同整数的个数，否则得分为 \\(0\\)。 数据范围：\\(2\\leq n\\leq 2 \\times 10^{5}\\)，\\(1\\leq A_{i}\\leq 2\\times 10^{5}\\)。 思路 虽然是无向图，但是序列需要非递减才能有得分。进一步观察可以发现，对于一条非递减路径，所有包含相同整数的顶点只会贡献 \\(1\\) 个得分，我们可以将这些顶点缩为一个顶点。所以，只需要建立满足递增条件的有向边，如果边的两个顶点包含相同的整数，则使用并查集将它们连接（缩点）。然后问题就变为求 DAG 中两个顶点之间的最长路径，不过和一般的使用拓扑排序 + 动态规划来求解的方式不同，因为缩点的缘故，该题不是很好使用拓扑排序。由于 \\(A_{i}\\) 的范围比较小，从小到大枚举顶点整数，然后扩展以该整数为起点的边，结合动态规划可以比较方便的求出答案。实现时，需要注意起点和终点同样可能被缩点，使用时将其替换为并查集中所在连通块的根节点。","link":"/2024/01/07/AtCoder%20Beginner%20Contest%20335/"},{"title":"Hello 2024","text":"Grouping Increases 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，将数组 \\(a\\) 分割为两个子序列（可能为空），输出两个子序列中满足 \\(b_{i}&lt;b_{i+1}\\) 的下标 \\(i\\) 的数量之和的最小值。 数据范围：\\(1\\leq n\\leq 2\\times 10^{5}\\)，\\(1\\leq a_{i}\\leq n\\)。 思路 贪心。假设将数组 \\(a\\) 分割为数组 \\(b\\) 和 \\(c\\)，从空数组开始，将 \\(a\\) 中的元素添加到 \\(b\\) 或 \\(c\\)。假设 \\(b\\) 和 \\(c\\) 的最后一个元素分别为 \\(x\\) 和 \\(y\\)（\\(x\\leq y\\)），如果 \\(a_{i}\\leq x\\) 或 \\(a_{i}&gt;y\\)，则将 \\(a_{i}\\) 添加到 \\(b\\)，否则添加到 \\(c\\)。","link":"/2024/01/07/Hello%202024/"},{"title":"第 379 场力扣周赛","text":"移除后集合的最多元素数 题目 输入长度为偶数 \\(n\\) 的数组 \\(a\\) 和 \\(b\\)，输出从 \\(a\\) 和 \\(b\\) 中分别选择一半元素构成的集合的最大大小。 数据范围：\\(1\\leq n\\leq 2\\times 10^{4}\\)。 思路 要使集合尽可能大，肯定优先选择除 \\(a\\) 和 \\(b\\) 交集以外的元素，假设分别为 \\(x\\) 和 \\(y\\)，则可以选择 \\(s=\\min(x,\\frac{n}{2})+\\min(y,\\frac{n}{2})\\) 个不同元素。此时还有 \\(n-s\\) 个元素待选，假设交集的大小为 \\(z\\)，则答案为 \\(s+\\min(n-s,z)\\)。 执行操作后的最大分割数量 题目 输入长度为 \\(n\\) 的字符串 \\(s\\) 和一个整数 \\(k\\)，输出至多改变一个字符时，执行操作能够得到的最大分割数。每次操作可以分割 \\(s\\) 的最多包含 \\(k\\) 个不同字符的最长前缀。 数据范围：\\(1\\leq n\\leq 10^{4}\\)，\\(1\\leq k\\leq 26\\)。 思路 首先，很容易想到暴力做法，枚举每个位置的所有改变情况，然后通过遍历求分割数，时间复杂度为 \\(O(n^{2}|\\Sigma|\\log{|\\Sigma|})\\)。显然，可以优化的部分就是最后遍历求分割数的 \\(O(n\\log{|\\Sigma|})\\)。然后观察修改字符相比不修改字符会产生什么变化，可以发现修改字符所在的分割段的长度可能发生变化，而前缀的分割数是固定的。可以想到预处理原字符串每个位置 \\(i\\) 的后缀分割数，问题就剩下如何快速求得修改字符所在段的右端点。由于字符数随着长度的增加而增加，所以可以通过二分求得该段的右端点，这还需要花费 \\(O(n|\\Sigma|)\\) 的时间提前预处理出字符数的前缀和。最后，分割数为前缀 + 中间 + 后缀的段数。代码实现时，还有很多其他细节需要注意，强烈建议自己实现一下。","link":"/2024/01/07/%E7%AC%AC%20379%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Threads and RPC","text":"参考 Go FAQ，crawler.go，kv.go，note。 Exercise: Web Crawler 串行爬虫 就是 DFS。 1234567891011121314func Serial(url string, fetcher Fetcher, fetched map[string]bool) { if fetched[url] { return } fetched[url] = true urls, err := fetcher.Fetch(url) if err != nil { return } for _, u := range urls { Serial(u, fetcher, fetched) } return} 并行爬虫 共享 + 锁 在 DFS 的基础上，同时启动多个线程来爬取网页，通过使用锁保护共享变量，使用计数器等待所有线程执行完成。如果网页很多，可能会创建非常多的线程，可以通过使用线程池限制线程的数量。 123456789101112131415161718192021222324252627282930313233343536type fetchState struct { mu sync.Mutex fetched map[string]bool}func (fs *fetchState) testAndSet(url string) bool { fs.mu.Lock() defer fs.mu.Unlock() r := fs.fetched[url] fs.fetched[url] = true return r}func ConcurrentMutex(url string, fetcher Fetcher, fs *fetchState) { if fs.testAndSet(url) { return } urls, err := fetcher.Fetch(url) if err != nil { return } var done sync.WaitGroup for _, u := range urls { done.Add(1) go func(u string) { defer done.Done() ConcurrentMutex(u, fetcher, fs) }(u) } done.Wait() return}func makeState() *fetchState { return &amp;fetchState{fetched: make(map[string]bool)}} 通道（channel） 使用 channel 实现同步，不需要 DFS，没有任何共享变量，自然也不需要使用锁（尽管 channel 内部会使用锁）。代码的组织方式有点像 MapReduce。 12345678910111213141516171819202122232425262728293031323334func worker(url string, ch chan []string, fetcher Fetcher) { urls, err := fetcher.Fetch(url) if err != nil { ch &lt;- []string{} } else { ch &lt;- urls }}func coordinator(ch chan []string, fetcher Fetcher) { n := 1 fetched := make(map[string]bool) for urls := range ch { for _, u := range urls { if fetched[u] == false { fetched[u] = true n += 1 go worker(u, ch, fetcher) } } n -= 1 if n == 0 { break } }}func ConcurrentChannel(url string, fetcher Fetcher) { ch := make(chan []string) go func() { ch &lt;- []string{url} }() coordinator(ch, fetcher)} Go RPC 远程过程调用（Remote procedure call，RPC），指程序调用的过程在远程计算机执行。通常表现为客户端向服务器发送请求，服务器向客户端返回响应。数据在通过网络传输时需要进行序列化和反序列化，序列化是将数据转换为可以存储或传输的格式的过程，反序列化是序列化的逆过程。远程过程调用和本地过程调用的区别在于，如何处理失败的情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//// Client//func connect() *rpc.Client { client, err := rpc.Dial(&quot;tcp&quot;, &quot;:1234&quot;) if err != nil { log.Fatal(&quot;dialing:&quot;, err) } return client}func get(key string) string { client := connect() args := GetArgs{&quot;subject&quot;} reply := GetReply{} err := client.Call(&quot;KV.Get&quot;, &amp;args, &amp;reply) if err != nil { log.Fatal(&quot;error:&quot;, err) } client.Close() return reply.Value}func put(key string, val string) { client := connect() args := PutArgs{&quot;subject&quot;, &quot;6.824&quot;} reply := PutReply{} err := client.Call(&quot;KV.Put&quot;, &amp;args, &amp;reply) if err != nil { log.Fatal(&quot;error:&quot;, err) } client.Close()}//// Server//type KV struct { mu sync.Mutex data map[string]string}func server() { kv := &amp;KV{data: map[string]string{}} rpcs := rpc.NewServer() rpcs.Register(kv) l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;) if e != nil { log.Fatal(&quot;listen error:&quot;, e) } go func() { for { conn, err := l.Accept() if err == nil { go rpcs.ServeConn(conn) } else { break } } l.Close() }()}func (kv *KV) Get(args *GetArgs, reply *GetReply) error { kv.mu.Lock() defer kv.mu.Unlock() reply.Value = kv.data[args.Key] return nil}func (kv *KV) Put(args *PutArgs, reply *PutReply) error { kv.mu.Lock() defer kv.mu.Unlock() kv.data[args.Key] = args.Value return nil} 其他问题 Q：为什么闭包函数可以使用外部函数的变量？ A：闭包函数引用的外部变量存储在堆中，所以当外部函数返回时，变量依旧存在，垃圾收集器会根据引用计数判断是否回收该变量。注意，如果需要引用循环中的变量，需要通过参数传递（值传递），因为外部变量会随循环变化。 Q：假设有两个线程，线程 A 使用条件变量等待某个条件，线程 B 在达到条件时通知线程 A。如果线程 B 在解锁之前通知线程 A 会有问题吗？ A：如果在解锁之前唤醒线程 A，假设线程 A 在 B 解锁之前被调度，那么线程 A 在获取锁时会被阻塞。之后的某个时刻，操作系统会调度线程 B 解锁，此时线程 A 可以重新被调度。注意，条件变量和锁的阻塞队列是独立的，所以不需要再次通知线程 A。","link":"/2024/01/10/Threads%20and%20RPC/"},{"title":"The Google File System","text":"阅读论文 GFS，参考 FAQ，note。 概念 GFS 是一个分布式文件系统，用于大型分布式数据密集型应用程序，例如 MapReduce。系统的设计基于以下场景： 系统由许多机器组成，所以会频繁发生故障。 GB 级别的文件很多，普通文件系统会将文件划分为很多块，不便管理。 读负载由大量顺序读和少量随机读组成，写负载由大量追加写和少量随机写组成。 高持续带宽比低延迟更重要，应用程序需要快速进行批处理，而对响应时间没有严格要求。 实现 GFS 集群由单个 master 和多个 chunkserver 组成，由多个客户端访问。文件被划分为 64 MB 的块（chunk），每个块都是 chunkserver 中的一个文件。在分配空间时使用懒分配策略，避免产生内部碎片从而浪费空间。master 在创建块时，会为其分配一个不可变且全局唯一的 64 位块句柄（chunk handle）。每个块都会被复制到多个 chunkserver 上（默认三个），以保证系统的可靠性。 master 主要负责维护系统的元数据、存储日志和检查点、租约管理以及控制垃圾收集、重新复制、负载均衡和快照创建。元数据包括命名空间、访问控制信息、从文件名到块句柄数组的映射，以及为每个块维护版本号和副本所在 chunkserver 的列表。master 通过心跳消息定期与 chunkserver 通信，向其发出指令和收集其状态。chunkserver 主要负责存储文件数据、版本号和校验和，64 MB 的 chunk 被划分为 64 KB 的 block，每个 block 都有一个 32 位的校验和。 链接到应用程序的 GFS 客户端代码实现文件系统 API，通过与 master 和 chunkserver 通信来代表应用程序读写数据。客户端从 master 获取元数据，从 chunkserver 获取文件数据。客户端不需要缓存文件数据（但会缓存元数据），因为负载通常是顺序读和追加写。客户端没有实现 POSIX API，因此不需要挂钩到 Linux vnode 层。PS：我没有查到 Linux vnode 相关的资料，vnode 似乎是 BSD 中的概念，和 VFS 有关。 块大小 Linux 文件系统的默认块大小为 4 KB，GFS 使用 64 MB 的块大小是基于其 GB 级文件场景而设计的，优势如下： 由于应用程序通常是顺序读写文件数据，所以 64 MB 的块大小可以减少客户端和 master 的交互次数。 许多操作会发生在同一个块中，使得客户端和 chunkserver 保持长 TCP 连接，有利于减少网络开销。 master 中的元数据更少，从而可以全部放入内存，避免磁盘 I/O。 同时，论文提到小文件可能只有一个块，面对多个应用程序的访问，存储该块的 chunkserver 有可能成为热点。GFS 的解决方案是使用更高的复制因子存储小文件，同时使批处理队列系统错开应用程序访问小文件的时间。潜在的解决方案是允许客户端在该情况下从其他客户端读取数据。 元数据 命名空间和映射会以操作日志（operation log）的形式持久化到 master 的本地磁盘和复制到远程机器，保证 master 能够在崩溃之后恢复。为保证一致性，只有在本地和远程将相应的日志刷新到磁盘之后，master 才会响应客户端的操作。可以对刷新和复制批处理，从而减少开销。当日志超过一定大小时，会创建检查点（使用 B 树），从而避免崩溃恢复时重放所有日志。由于创建检查点比较耗时，master 会切换到新的日志文件，并在单独的线程中创建检查点，以避免在创建检查点时停止执行（写）操作。检查点同样也会被复制到远程机器。 master 不会持久化块的位置列表，而是在启动时以及 chunkserver 加入集群时，向 chunkserver 询问其包含的块。因为块是否存在于某个 chunkserver 是由该 chunkserver 决定的，所以在 master 中持久化该信息没有任何意义，反而会面临同步问题。PS：说明 master 内存中的位置列表可能因为 chunkserver 故障，从而产生不一致。 命名空间其实就是一个将目录名和文件名作为节点的树，通过使用读写锁保证写操作的正确性。具体来说，读/写操作会获取路径上所有祖先节点的读锁，以及目标节点的读/写锁。锁在层级间按照自顶向下的顺序获取，在层级内按照字典序获取，从而避免死锁。PS：这让我想到 B+ 树的蟹行协议只锁定会被修改的节点，大概是因为 B+ 树的数据和路径不像文件和路径那样具有很强的关联性。 读操作 客户端使用固定的块大小，将应用程序指定的文件名和字节偏移量转换为文件内的块索引。然后，它向 master 发送包含文件名和块索引的请求，master 回复相应的块句柄（handle）、副本的位置列表，客户端使用文件名和块索引作为键来缓存该信息（会有过期时间）。 然后，客户端选择其中一个副本发送请求（很可能是距离最近的副本），该请求指定块句柄和块内字节范围。在缓存信息过期或重新打开文件之前，客户端不需要和 master 进行交互。客户端可以在向 master 发送的一个请求中请求多个块，master 也可以在回复中包含请求块之后的多个块信息（利用空间局部性），从而减少客户端和 master 交互的次数。 写操作 在发生写操作时，需要保证多个副本之间的一致性。GFS 使用租约（lease）实现一致性（租约是按块授予的），持有租约的 chunkserver 被称为 primary，其他包含副本的 chunkserver 被称为 secondary。租约的超时时间为 60 秒，primary 可以根据需要续约，续约请求包含在定期的心跳消息中发送给 master，master 也可以在租约到期之前撤销租约（用于快照创建）。如果 master 和 primary 发生网络分区故障，master 可以在旧租约到期之后向另一个副本授予租约，从而避免脑裂。 写操作的流程如下： 客户端首先向 master 询问 primary 和 secondary 的位置并将其缓存。如果 primary 不存在，则 master 任选一个包含副本的 chunkserver 授予租约。客户端会缓存位置信息，当 primary 不可达或者回复其租约过期时，客户端会重新联系 master。然后，客户端以流水线的方式将数据发送到 primary 和 secondary（存储在缓冲区中），并且等待它们的确认响应。 客户端收到所有副本的确认之后，向 primary 发送写请求，该请求会使用之前发送的数据。primary 为其收到的来自多个客户端的请求分配序列号（单个客户端的请求肯定是同步的，在收到响应之前不会发送第二个请求，因为 GFS 没法保证客户端请求的 FIFO 顺序），只有当 primary 本地执行成功之后，才会转发给所有 secondary，请求在所有副本上都按照序列号的顺序执行。当 primary 收到所有 secondary 的完成响应时，primary 回复客户端完成。 论文提到，副本的任何错误都会被报告给客户端，客户端会首先从步骤三开始重试几次，然后从步骤一开始重试。论文有一个前后矛盾的点，首先提到 primary 分配序列号然后应用到本地，之后又说如果在 primary 执行失败就不会分配序列号和转发。不过无关紧要。 一致性模型 GFS 具有宽松的一致性模型，数据突变之后文件区域的状态，取决于突变的类型（随机写和追加写）以及是否存在并发，如下图所示。如果无论客户端从哪个副本读取，始终看到相同的数据，则文件区域是一致的。如果文件区域一致，且客户端将会看到整个突变的内容，则文件区域是定义的。PS：这里的一致并不是严格一致性（可线性化）。 随机写：顺序突变成功状态是定义的和一致的；并发突变成功状态是一致的但是未定义，因为 GFS 使用租约保证突变以相同的顺序应用到所有副本（一致的），但是突变没有对文件区域加锁（未定义）。 追加写：不论是顺序还是并发突变成功，状态都是定义的，因为追加是原子操作且按照指定顺序应用到所有副本。只要有一个副本追加失败，客户端会重试整个追加操作，使得在未失败的机器上多次追加相同的数据，在失败的机器上填充无效的数据（因为追加会指定偏移量），从而产生不一致。特别的，追加的偏移量由 primary 指定，而不是单纯的追加到文件末尾，这可以保证多个副本在成功执行追加的偏移位置的数据是一致的，即使之前发生过失败。也就是说，中间区域不一致，最后区域一致。 此外，失败的突变总是会导致不一致。即使突变成功，数据最终一致，客户端仍可能观察到不一致，因为数据可以从任何包含副本的 chunkserver 读取。假设突变由客户端 A 发起，首先应用到 primary，再发送到 secondary。客户端 B 和 C 在突变过程中分别读取 primary 和 secondary，可以观察到不一致的情况。如果突变很慢，由于网络延迟或故障重试，单个客户端也可以观察到不一致。应用程序需要自行适应 GFS 的宽松一致性模型。 版本检测 如果 chunkserver 发生故障，从而错过突变，其上的块副本将会过时。master 和 chunkserver 会为块维护一个版本号，以此来区分新副本和旧副本。当 master 授予某个块租约时，它会递增该块的版本号，同时和 chunkserver 通信来递增最新副本的版本号。任何包含旧副本的 chunkserver 都不会返回给客户端，master 会在心跳检测中检查副本的版本，然后 master 会指示 chunkserver 对旧副本垃圾收集。作为额外的保护措施，master 会在回复客户端请求或指示 chunkserver 复制时包含版本号，客户端和 chunkserver 会在执行操作时进行验证。 故障处理 master 故障 当 master 发生故障时，GFS 的外部监控基础设施会使用检查点和日志快速恢复，即使磁盘发生故障也可以在其他机器上使用检查点和日志的副本进行恢复。客户端仅使用 DNS 别名访问 master（CNAME），其映射可以随时更改，以适应 master 机器的变更。此外，GFS 使用 shadow master 在 master 故障时提供对文件系统的只读访问，shadow master 略微滞后于 master。由于它存储的是元数据，文件数据存储在 chunkserver 中，所以客户端实际上不会读取到旧数据。 PS：论文提到 shadow master 会按顺序执行操作日志的副本，似乎 master 和 shadow master 的关系就是主从复制，但是为什么 shadow master 只提供只读访问，即使在 master 故障之后。它和 master 应该是最终一致的，为什么论文没有说 shadow master 在执行完所有日志之后会被提升为 master，虽然可以肯定需要人工操作，以避免原 master 只是网络分区故障，从而导致脑裂。 chunkserver 故障 master 使用心跳消息判断 chunkserver 是否存活，如果 master 判断 chunkserver 故障，它会指示其他 chunkserver 对不满足复制因子的数据块重新复制。当故障的 chunkserver 上线时，master 也会删除多余的副本，以及因错过突变而过时的副本。 其他功能 使用写时复制实现快照功能；跨机架的块放置策略；根据服务器的负载进行块放置和块迁移；根据优先级重新复制块以恢复冗余；延迟删除和垃圾收集；使用校验和检测数据块是否损坏；生成诊断日志（包含 chunkserver 的启动/关闭，RPC 的请求/回复记录，不包括文件数据）。 问题 Q：租约具体是如何工作的，master 和 chunkserver 如何判断租约是否过期？如何撤销租约？ A：论文没有说明，我猜测：master 首先发送授予租约的请求，chunkserver 收到请求之后开始计时，同时发送响应给 master，master 收到响应之后开始计时。这样 chunkserver 和 master 都可以判断租约是否到期，以及 master 的计时总是晚于 chunkserver，可以保证避免脑裂。撤销租约只修改 master 本地元数据肯定是不行的，因为客户端可能正在和持有租约的 chunkserver 通信，master 必须直接向 primary 发送撤销请求。 Q：根据上述猜测，如果授予租约的响应丢失，master 该如何处理？是否需要考虑时钟同步问题？ A：如果 master 没有收到响应，它就不会把该 chunkserver 记作 primary 返回给客户端，那么该租约实际上是一个无效租约，master 可以重试或者另选一个包含副本的 chunkserver。计算超时使用的是单调时钟，不需要同步。也可以使用时间戳判断租约是否到期，但是使用的是墙上时钟，需要服务器之间时钟同步。 总结 GFS 使用复制进行容错，从而引入多个副本间的一致性问题。但是仅保证宽松的一致性，而将问题交由应用程序处理，该设计基于其特殊的使用场景，顺序读写以及用于批处理，似乎强一致性显得不是很重要。可以查看课程的笔记和问答加深对论文的理解，笔记结尾的优缺点总结还是很不错的，有一个全局的视角，我有点过于关注一致性了。更多关于 GFS 的讨论，可以阅读 GFS: Evolution on Fast-forward。","link":"/2024/01/19/The%20Google%20File%20System/"},{"title":"The Design of a Practical System for Fault-Tolerant Virtual Machines","text":"阅读论文 Fault-Tolerant Virtual Machines，参考 FAQ，note。 概述 论文使用虚拟机、机器级别的主从复制（一主一从）和共享磁盘的方式设计容错系统，目前只支持单处理器的虚拟机。 有两种复制方式，状态转移复制和状态机复制。状态转移复制是将主节点的所有状态复制到从节点；而状态机复制要求节点是一个确定性状态机，不同节点从同一个状态以相同的顺序执行操作，可以得到相同的结果。 比较有意思的是，不像我所了解的常规数据复制，论文实现的系统使用机器级别的复制，状态包含 CPU、内存和 I/O 设备的状态，操作是 x86 指令。在机器级别上，状态转移复制的缺点是会将所有状态的更改通过网络进行传输，发送状态需要很多带宽；状态机复制使用更少的网络带宽，但是需要特殊处理非确定性操作（例如：获取时间、定时中断）来保证主从一致，这在物理服务器上很难实现，特别是当处理器频率增加时。 PS：时间是非确定的很好理解，但是定时中断为什么是非确定的，我的想法是虽然主从的状态是一致的（如果没有中断），但是执行速度也不是完全一致，所以中断的时机可能不同。 论文设计的系统使用状态机复制，利用虚拟机（VM）由虚拟机管理程序完全控制的特性，当主虚拟机执行非确定性操作时，虚拟机管理程序可以捕获必要的信息发送给从虚拟机，将非确定性操作转化为确定性操作，从而保证主从一致。只支持单处理器虚拟机，因为多处理器产生的并发操作是非确定性的，存在显著的性能问题。 主从虚拟机运行在不同的服务器上，从虚拟机和主虚拟机以相同的方式运行，并且总是有较小的延迟（小于 100 毫秒），课程讲义提到至少滞后一个日志项。只有主虚拟机在网络上发布其存在，输入（例如：网络、磁盘、键盘、鼠标）只会发送给主虚拟机，主虚拟机通过网络连接（称为日志通道，logging channel）将其转发给从虚拟机。同时，只有主虚拟机会产生输出，从虚拟机的输出将被虚拟机管理程序丢弃。 确定性重放 VMware FT 使用确定性重放，使从虚拟机能够通过重放日志达到和主虚拟机相同的状态。具体来说，主虚拟机的输入和非确定性操作都会被虚拟机管理程序捕获，然后生成日志（不会写入磁盘），发送给从虚拟机。对于非确定性操作，日志会记录必要的信息，保证主从一致。例如，对于中断操作，日志会记录操作发生时所完成的指令数量。论文提到该技术的实现有使用硬件性能计数器（HPC）。 特别注意，日志仅包含输入和非确定性操作相关的信息，确定性操作在从虚拟机的本地执行。具体来说，主虚拟机和从虚拟机都是状态机，会自动执行操作（由 VM 中的 Linux 和 App 发起，这也说明了为什么主从虚拟机的初始状态必须相同），只不过输入只会发送给主虚拟机，以及存在非确定性操作，所以输入和非确定性操作需要以日志的形式包含额外信息发送给从虚拟机。 容错协议 但是仅使用确定性重放还不够，需要额外的机制保证系统的容错性。如果主虚拟机在执行输出操作之后发生故障，而日志没有发送给从虚拟机，那么从虚拟机接管之后，在其输出之前的非确定性操作（未收到日志的）可能会得到不同的输出结果，从而产生不一致（不一致主要是针对客户端的感知而言）。 解决方案是在主虚拟机发送输出之前，向从虚拟机发送输出操作的日志并等待其确认，当从虚拟机接收到该输出操作及之前的所有日志之后，从虚拟机回复一个确认，然后主虚拟机可以向外部发送输出。注意，主虚拟机只是延迟发送输出，但是没有停止执行（即在等待输出的同时会继续执行其他操作，就像在某个线程等待磁盘 I/O 时会切换到其他线程一样）。该机制在主虚拟机发生故障时，可能会产生两次相同的输出，因为从虚拟机无法得知主虚拟机是否发送输出，但是论文随后提到 TCP 可以保证网络数据包的去重（我的理解是 TCP 是根据序列号去重的，由于主从虚拟机状态相同，所以会产生相同的序列号）。 故障检测和恢复 系统通过监控节点的心跳（使用 UDP），以及日志通道上的流量来判断节点是否发生故障（使用定时中断，保证流量不会停止）。 从虚拟机故障：主虚拟机继续执行，但是停止发送日志。 主虚拟机故障：从虚拟机重放日志以追赶主虚拟机，然后将从虚拟机提升为主虚拟机。VMware FT 会在网络上发布新的主虚拟机的 MAC 地址，以便交换机知道其位于哪个服务器上。 网络分区故障：主虚拟机可能由于网络问题和从虚拟机中断连接，如果此时将从虚拟机提升为主虚拟机，将会导致脑裂。为避免该问题，容错协议要求在检测到故障时，主从虚拟机需要在共享磁盘上执行 test-and-set 原子操作。操作成功的虚拟机作为主虚拟机存活，操作失败的虚拟机会自行中止。 不论是启动系统时，还是故障恢复时，都需要保证存在一个从虚拟机。VMware FT 使用 FT VMotion 功能，将虚拟机复制到集群中的某个服务器上（根据资源使用情况和其他约束条件选择）。该功能会建立从源虚拟机到目标虚拟机的日志通道，并且将源虚拟机设置为主虚拟机（记录日志模式），目标虚拟机设置为从虚拟机（重放日志模式）。该功能仅会中断源虚拟机小于 1 秒的时间，在复制的过程中源虚拟机仍会正常执行，日志会被存放在缓冲区中。 总结 论文介绍容错虚拟机的实现，还提到磁盘 I/O 和网络问题及其解决方案，不同设计的决策以及对各个负载的性能测试，详情参见论文。PS：课程讲义很不错，可以加深对论文内容的理解，我的理解还是太浅。","link":"/2024/01/23/The%20Design%20of%20a%20Practical%20System%20for%20Fault-Tolerant%20Virtual%20Machines/"},{"title":"第 382 场力扣周赛","text":"给定操作次数内使剩余元素的或值最小 题目 输入长度为 \\(n\\) 的整数数组 \\(nums\\) 和整数 \\(k\\)，输出执行至多 \\(k\\) 次操作之后，将数组中所有剩余元素按位或的最小值。每次操作可以选择一个下标 \\(i\\)，满足 \\(0\\leq i&lt;n\\)，将 \\(nums[i]\\) 和 \\(nums[i+1]\\) 替换为它们按位与的结果。注意，是两个数替换为一个数。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(0\\leq nums[i]&lt;2^{30}\\)，\\(0\\leq k&lt; n\\)。 思路 要使按位或的结果最小，肯定是从高位到低位消除。但是高位消除的方式会影响低位消除的方式，它们是相关的，不能单独计算每一位的操作次数。如果暴力枚举所有位的组合，会有 \\(2^{30}\\) 种情况，肯定会超时。如何计算？其实，只需要考虑从高位到低位的组合方式。从高位开始，能够消除的位总是应该被消除，然后判断加上更低的一位是否能被消除（保留相关性），如果不能，则该低位就永远不会被消除，以此类推。那么如何判断某个位的组合是否能被消除？从前往后遍历数组，贪心的将数组分割为若干按位与结果为 0 的子数组（假设为 \\(m\\)），则当前组合消除所需的操作次数为 \\(n-m\\)。具体可以看下灵茶山的题解和小羊的题解。","link":"/2024/01/28/%E7%AC%AC%20382%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"In Search of an Understandable Consensus Algorithm (Extended Version)","text":"阅读论文 Raft，参考 FAQ1，note1，FAQ2，note2。 概述 MapReduce 的 master、GFS 的 master 和 VM FT 的共享磁盘都存在单点故障（即使 GFS 的 master 存在副本，其依然是单点故障，因为故障时系统会停止），从而可以很简单的避免脑裂。脑裂会发生的根本原因在于，无法区分机器故障和网络分区故障。共识算法使用多数原则（仲裁协议，quorum），可以在复制的同时避免脑裂。如果集群中有 \\(2f+1\\) 个服务器，则共识算法可以容忍 \\(f\\) 个服务器故障。共识算法通常使用状态机复制，以复制日志的方式实现。客户端、服务器以及共识算法和状态机的关系见下图。 Raft 的主要设计目标是可理解性，通过分解问题和减少状态来实现。问题被分解为多个子集，例如：领导者选举、日志复制、安全性和成员变更。使用随机化超时时间、限制选举保证日志单向流动等方式，来减少状态。 实现 基础知识 服务器有三种状态：leader、follower、candidate，服务器初始时都是 follower。正常情况下，只有一个 leader 和多个 follower。只有 leader 会处理客户端的请求，如果客户端将请求发送给 follower，该 follower 会将其重定向到 leader。服务器之间使用远程过程调用（RPC）进行通信，基本的 Raft 算法使用两种 RPC，candidate 在选举时会发起 RequestVote RPC，leader 在复制日志和发送心跳时会发起 AppendEntries RPC（心跳消息是没有日志条目的 AppendEntries RPC）。Raft 保证 RPC 是幂等的。 时间被划分为任期（term），使用单调递增的连续整数表示。每个服务器都会持久存储当前任期，不同服务器的任期可能不同（由于故障）。服务器之间进行通信时会交换任期，处于旧任期的服务器会更新其任期。如果 leader 或 candidate 发现自己包含旧任期，它会成为 follower。如果服务器收到具有旧任期的请求，它会拒绝该请求。 领导者选举 如果一个 follower 在超时时间（该时间被称为选举超时，election timeout）内没有收到来自 leader 或 candidate 的有效 RPC（何为有效，个人认为任期不旧就是有效），它将递增其任期成为 candidate，开始选举新的 leader。它为自己投票，然后向集群中的其它服务器发送 RequestVote RPC。 如果 candidate 收到大多数服务器的投票，它会成为新的 leader，同时向其他服务器发送心跳消息，以建立其权威防止新的选举。每个服务器在给定的任期内，只能投票给一个 candidate。服务器是否投票给某个 candidate 存在限制，将在安全性中讨论。 如果在等待投票时，candidate 收到 leader 的 AppendEntries RPC，且 leader 的任期大于等于 candidate 的任期，那么 candidate 会成为 follower。如果 leader 的任期更小，则 candidate 会拒绝该 RPC。或者收到其他 candidate 的 RequestVote RPC，且其任期大于当前 candidate 的任期，当前 candidate 同样会成为 follower。 如果存在多个 candidate 使选票分裂，使得没有 candidate 可以得到大多数服务器的投票，则每个 candidate 都会超时，继续递增任期，重新开始选举。Raft 使用随机 election timeout 来确保选票分裂很少发生（避免同时超时），election timeout 是从一个固定间隔中随机选择的（例如 [150, 300] 毫秒），每个候选人在开始选举时会重新随机化 election timeout。 如果 follower 在执行完成 AppendEntries RPC 之后，回复之前发生崩溃，则 leader 会重试 RPC。如果 follower 重新上线，它会忽略重复请求中的日志条目。如果 candidate 在发送 RequestVote RPC 之后崩溃，重启之后它会重新发送 RPC，follower 会持久存储其投票的 candidate，避免在同一任期内多次投票。 为了保证系统的可用性，election timeout 存在如下要求： $$ broadcastTime\\ll electionTimeout\\ll MTBF $$ 其中 \\(broadcastTime\\) 是发送 RPC 的平均往返时间，\\(electionTimeout\\) 是 follower 的超时时间，\\(MTBF\\) 是单个服务器的平均故障间隔时间。broadcast time 应该比 election timeout 小一个数量级，防止 follower 开始不必要的选举。election timeout 应该比 MTBF 小几个数量级，这样在 leader 真正发生故障时客户端不会等待太久。 日志复制 客户端会向 leader 发送请求，请求包含由复制状态机执行的命令，leader 会将当前任期和命令作为一个条目（entry）追加到日志中（只读命令可以不记录日志，但有额外的限制，在可线性化中描述），由日志索引标识其位置。然后 leader 向其他服务器并行发送 AppendEntries RPC 以复制该条目，当大多数服务器确认复制该条目时，leader 将条目应用到其状态机（即状态机执行条目中的命令），并将执行结果返回给客户端，之后 leader 通过不断地失败重试保证剩余服务器会复制该条目。 只要创建日志条目的 leader 将其复制到大多数服务器上，该日志条目就是已提交的（committed）。注意，是创建日志条目的 leader，而不是之后的 leader，这将在安全性中讨论。Raft 保证已提交的条目是持久的，并且最终会被所有可用的状态机执行。leader 提交其创建的日志条目时，也会提交 leader 日志中在该日志条目之前的所有日志条目，包含由之前 leader 创建的条目（会在安全性中解释原因）。leader 会跟踪其已提交日志条目的最高索引，并且在之后的 AppendEntries RPC 中包含该索引，以通知 follower 哪些日志条目已提交，之后 follower 会应用已提交的日志条目到本地状态机（按照日志顺序）。 Raft 的日志匹配（Log Matching）属性保证不同服务器之间日志的一致性：如果两个日志在同一索引位置的条目具有相同任期，则两个日志中所有小于等于该索引位置的条目都相同。如何实现该属性？leader 在给定任期只会对自己的日志进行追加，而不会覆盖。当 leader 向 follower 发送 AppendEntries RPC 时，会进行一致性检查。请求中会包含上一个条目的索引和任期，如果 follower 中对应索引的任期不同，则 follower 会拒绝该请求，回复 leader 匹配失败。如果系统正常运行，那么所有服务器上的日志都会相同。 但是当发生故障时，服务器之间的日志会产生不一致。如何处理不一致？leader 会为每个 follower 维护一个 nextIndex，表示 leader 下次向 follower 发送该索引位置的日志条目，如果 follower 拒绝 leader 的 AppendEntries RPC，则 leader 会将该 follower 对应的 nextIndex 递减，然后重试 RPC 直到 follower 和 leader 的日志完全相同（冲突条目将被删除）。整个过程表现为，递减 follower 的 nextIndex 到和 leader 日志最长相等前缀之后的一个位置，然后追加条目到 follower 直到其 nextIndex 和 leader 日志的尾后索引相等。 可以对上述算法进行优化，不是将 nextIndex 每次递减 1，而是递减整个任期，这通过在 follower 回复的信息中包含冲突条目的任期以及该任期在其日志中的第一个索引位置来实现。从而，每个冲突的任期都需要一个 AppendEntries RPC，而不是每个冲突的条目一个 RPC。为什么直接返回第一个索引位置，论文并没有描述之后该如何处理。我的理解是，其实并不是从该索引位置开始重传日志条目，因为这样可能会导致不必要的重传已提交的日志条目。在 leader 接收到冲突的任期和第一个索引之后，应该会递增该索引直到任期不同为止（之所以可以这样，是因为日志匹配属性），然后再传递该位置的日志条目。这样关于课程中提出的问题，为什么需要返回任期，而不是只返回第一个索引，也可以得到解答。 安全性 选举限制 即使日志一致，两个状态机也可能执行不同的命令序列。例如，leader 提交日志时，某个 follower 可能发生故障，如果它成为 leader，它将覆盖旧 leader 中的条目，而这些条目可能已经应用于旧 leader 的状态机上。为此 Raft 的领导者完整性（Leader Completeness）属性保证在某个任期被提交的日志条目必定会出现在更高任期的 leader 日志中，从而可以保证所有状态机执行相同的命令序列。 如何实现该属性？candidate 在发送 RequestVote RPC 时，会包含其日志信息，如果投票者的日志比 candidate 的日志更（读第四声）新，则投票者会拒绝投票。更新的定义如下：如果两个日志的最后一个条目具有不同任期，则更大任期的日志更新；否则，更长的日志更新。上述限制使得，只有包含所有已提交日志条目的 candidate 才有可能当选 leader，日志只会从 leader 流向 follower。 提交之前任期的条目 在日志复制中提到，创建日志条目的 leader 将其复制到大多数服务器上，则该日志条目就是已提交的。之所这样定义，是因为即使 leader 将之前任期的条目（不是由当前 leader 创建）复制到大多数服务器上，依然可能会被之后的 leader 覆盖（根据之前描述的日志匹配属性）。如果将其视为已提交，则会违反领导者完整性属性，导致状态机不一致。那么之前任期的条目何时视为已提交？当前任期的一个日志条目被提交时，由于日志匹配属性，之前任期的条目将会间接提交。 日志压缩 日志可能会变得很大，导致崩溃恢复需要花费很多时间重放所有日志，以及日志占用大量空间，Raft 通过使用快照来压缩日志。每个服务器会定期创建快照（通常是当日志达到固定大小时），快照中包含状态机的状态、状态对应的最后一个日志条目的索引和任期（以支持 AppendEntries PRC 的一致性检查）、当时的配置信息（用于集群成员变更）。当服务器将快照持久化之后，可以删除该快照之前的日志和之前的快照（剩余日志的索引并不会重置为从 1 开始，或许会新开一个数组从 1 开始存储，但是对外来说索引总是会加上某个偏移量）。 如果有一个严重滞后或新加入集群的 follower，它需要的日志可能已经被 leader 删除，此时 leader 需要使用 InstallSnapshot RPC 向滞后的 follower 发送快照。通常快照会比 follower 的日志更新，follower 会丢弃整个日志，使用快照替代。但是，由于重传或错误，follower 可能会收到描述其日志前缀的快照，此时仅会删除快照覆盖的日志，快照之后的日志将被保留。 为了避免在创建快照时停止操作，可以使用写时复制技术。状态机可以通过实现某种数据结构支持写时复制，或者使用操作系统的写时复制支持（例如，Linux 的 fork）来创建状态机的内存快照（作者使用该实现方式）。具体来说，Linux 的 fork 创建的子进程会共享和父进程相同的内存页面，如果父进程更新页面，则操作系统会对该页面执行写时复制。 可线性化 什么是可线性化？每个操作似乎在其调用和响应之间的某个时刻以原子的方式执行。Raft 如何实现可线性化语义？如果 leader 在执行命令之后回复客户端之前崩溃，然后客户端在新的 leader 重试请求，将会多次执行同一个命令。如果客户端向新 leader 发送读请求，由于旧 leader 在回复客户端之后发送下一个 AppendEntries RPC 之前崩溃，新 leader 可能并没有将某些已提交的命令应用到状态机，此时客户端可能会从新 leader 读取到旧数据。如果出现网络分区故障，旧 leader 可能不知道它已经被新 leader 取代，此时客户端可能从旧 leader 读取到旧数据。 首先，客户端需要为每个命令分配唯一的序列号，状态机会跟踪为每个客户端处理的最后的序列号以及相关响应。如果状态机收到已被执行的命令，它不会执行该命令而是直接返回响应。注意，日志中依然包含重复命令的日志条目。其次，每个 leader 在任期开始时会提交一个无操作日志条目，从而确定哪些日志条目已被提交并将其应用到状态机。能否通过心跳消息确定哪些日志条目已提交，个人认为不能，就是之前提到的旧任期日志条目不能通过计数判断是否已提交。最后，leader 在回复读请求之前，需要和集群中的大多数交换心跳消息，以确保它仍然是 leader（或者可以使用租约，论文中没有详细介绍，不过课程笔记中有提到具体方式）。 问题 Q：Raft 集群是部署在一个数据中心，还是多个数据中心？ A：通常是一个数据中心，这样可以避免 leader 跨数据中心向多个 follower 发送 RPC（网络延迟）。 Q：客户端如何知道谁是新的 leader？ A：客户端包含所有 server 的地址，它可以随机发送请求，follower 会将请求重定向到它认为的 leader。 Q：为什么日志的索引从 1 开始？ A：可以将其视为从 0 开始，索引 0 包含任期为 0 的空日志条目，以方便 AppendEntries RPC 在初始时的一致性检查。个人认为，类似于求数组的前缀和时从索引 1 开始。 Q：Raft 何时将其状态（currentTerm、votedFor、log）持久化到磁盘？ A：在内存中修改状态的同时刷盘，只有持久化之后 leader 才能向 follower 发送 RPC，follower 才能回复 leader，leader 才能将命令应用到状态机。否则，如果服务器发生崩溃，Raft 的各种属性将无法得到保证。 Q：图 2 中的 lastApplied 为何不需要持久化？如果发生崩溃，服务器如何知道日志条目是否应用于状态机？ A：论文作者在会话中对该问题以及下一个问题进行了解释（推荐阅读）。实际上 lastApplied 是否被持久化取决于状态机是否被持久化。如果状态机不被持久化，那么崩溃恢复之后需要重放所有日志，所以 lastApplied 会被初始化为 0。否则，只需重放 lastApplied 之后的日志。按我的理解，由于快照的存在，以及更新状态机的同时持久化产生的随机 I/O 开销较大，所以状态机一般不会实时持久化。如果存在快照，lastApplied 会被赋值为快照中包含的索引。 Q：图 2 中的 matchIndex 有什么作用？ A：matchIndex 表示 follower 和 leader 匹配的最高日志条目的索引（可能会小于实际值），只要大多数 follower 的 matchIndex 超过 leader 的 commitIndex，并且 log[matchIndex] 条目的任期是当前 leader 的任期（参见提交的定义），则 leader 可以增加 commitIndex。 Q：图 7 的 leader 崩溃之后，谁有可能成为新的 leader？ A：服务器 acd 都有可能成为新的 leader。首先日志 9 是最后一个提交的日志条目，根据领导者完整性属性，只能从 acd 中选择 leader。同时，acd 都有可能得到大多数服务器的投票，对于 a 来说是 abef，对于 c 来说是 abcef，对于 d 来说是 abcdef。有一点需要注意，服务器最后一个日志条目的任期可能并不是其当前任期。 总结 Raft 共识算法实现可线性化一致性模型，核心内容包括领导者选举、日志复制和安全性。论文中还提到 Raft 的集群成员变更机制，我并没有做介绍。然后日志压缩可以看作是 Raft 的额外补充。如课程中所述，论文中也有很多细节没有介绍，单个机制可以有多种不同的实现方式。课程视频、问答和笔记是对论文很好的补充，其中还提到一篇文章 Raft does not Guarantee Liveness in the face of Network Faults，讲述 Raft 在特定情况下无法建立稳定的领导者，除非使用 PreVote 和 CheckQuorum 技术。可见这篇论文介绍的仅仅是 Raft 的基本实现，现实中面临各种复杂场景，或许需要添加很多额外的机制。 附录","link":"/2024/01/29/In%20Search%20of%20an%20Understandable%20Consensus%20Algorithm%20(Extended%20Version)/"},{"title":"ZooKeeper: Wait-free coordination for Internet-scale systems","text":"阅读论文 ZooKeeper，参考 FAQ，note，官方文档，另一个课程的 note。 概述 ZooKeeper 是一个协调服务，用于协调分布式应用程序。它没有实现特定的协调原语（例如：配置、选举、锁），而是提供 API 供应用程序开发者使用，让开发者根据实际需要实现协调原语。ZooKeeper API 具有无等待特性，提供事件驱动机制。ZooKeeper 使用流水线（pipeline）架构处理请求，流水线自动支持客户端请求的 FIFO 执行顺序，从而允许客户端异步发送请求。ZooKeeper 没有实现可线性化一致性模型，它仅保证写操作的异步可线性化，以及读操作的写后读和单调读一致性（术语取自 DDIA），适合读多写少的工作负载。 会话 客户端在连接到服务器时建立一个会话（session），同时获得一个会话 ID。只要会话 ID 有效，应用程序就可以通过客户端调用 ZooKeeper API。客户端会定期向服务器发送心跳，如果服务器在超时时间内没有收到心跳，则服务器会结束会话。如果客户端当前连接的服务器故障，则客户端在会话 ID 过期之前自动尝试连接到另一台服务器。 PS：创建会话类似写操作，需要经过多数服务器同意，会话的状态也会使用日志持久化，它是一个全局会话。这也可以解释，为什么客户端可以使用同一个会话 ID 透明地切换到另一台服务器。由于开销较大，ZooKeeper 在之后的版本添加了本地会话功能，本地会话只能执行全局会话操作的子集，状态只在本地服务器维护。 数据模型和监视 ZooKeeper 以类似文件系统的树形结构在内存中存储协调数据（应用程序元数据），树中的数据节点被称为 znode，由路径名唯一标识。不同的应用程序在各自的子树中组织数据，存储在节点中的数据以原子的方式被读写。节点会维护一个统计结构，包含版本号、时间戳和事务 ID（zxid）等元数据。节点分为常规（Regular）和临时（Ephemeral）两种类型，客户端可以显示创建和删除节点。特别的，临时节点如果没有被显示删除，则在创建它们的会话终止时被自动删除，以及临时节点不能有子节点。 创建节点时，客户端可以设置顺序（sequential）标志，从而将一个计数值附加到该节点的路径末尾，同一父节点的子节点的计数值根据创建顺序单调递增。客户端可以为节点设置一次性监视（watch）标志，该标志在客户端连接的服务器本地维护。当监视触发时，服务器会向客户端发送一个监视事件，同时取消监视。有两种监视类型，监视数据和监视子节点。有四种监视事件，创建、删除、数据变化、子节点变化（不包含子节点的数据变化）。监视和会话相关，当会话结束时，监视也会被取消。ZooKeeper 保证设置监视的客户端在看到变化之前，会收到服务器的通知。会话事件也会触发监视，以便客户端知道监视事件可能延迟。 原语示例 客户端可以使用 ZooKeeper API 实现更强的原语，示例如下。更多示例（双重屏障、2PC、选举）可以查看官方文档。 配置管理 ZooKeeper 可用于分布式应用程序的配置管理，可以将配置存储在 znode 中。客户端从 znode 读取配置，同时设置监视标志。如果配置被更新，则客户端会收到通知，然后再次从该 znode 读取配置和设置监视标志。 群组成员 客户端可以创建一个 znode 表示一个群组，当进程以该群组的成员身份启动时，它会在该 znode 下创建一个临时子 znode。如果每个进程有一个唯一的名称，则将该标识作为子 znode 的名称，否则可以使用顺序标志，使其获得唯一的名称。进程可以将其元数据存储在该子 znode 中，例如地址和端口。如果进程终止，则临时节点会被自动删除。可以通过在 znode 上设置监视标志，从而监视群组成员的变化。 简单锁 可以将一个指定路径的 znode 作为锁，客户端可以创建临时 znode 来获取锁，其他客户端通过判断 znode 是否存在来判断是否能够获取锁，同时设置监视标志。当临时 znode 被显示或自动删除，则表示锁被释放。此时，等待锁的客户端将收到通知。但是该实现存在羊群效应（herd effect）：在锁被释放时，许多客户端会争抢同一个锁。 无羊群效应的简单锁 直觉上来说，将获取锁的请求按照 FIFO 的顺序排队处理，那么就可以避免羊群效应。可以使用顺序标志在指定父 znode 下创建临时子 znode，客户端通过判断其创建的临时 znode 是否是序号最小的，来判断它是否已获取锁。当客户端需要释放锁时，只需删除其创建的临时 znode。个人认为，有无羊群效应的简单锁，有点像是 notify_all 和 notify_one 的区别。 特别的，在代码实现时有一个陷阱，ZooKeeper 没有提供监视来通知当前 znode 的序号是否最小。在创建 znode 之后， 我们首先需要获取子 znode 列表，判断当前是否是最小的。如果不是，则可以在前一个节点上设置监视。但是，该监视触发并不意味着当前客户端已获取锁，因为有可能只是前一个客户端提前结束会话，此时仍存在更小的序号。 读写锁 实现细节 ZooKeeper 使用复制提供容错，使用原子广播协议（ZAB）保证多个副本之间的一致性。客户端仅连接到一个服务器发送请求，写请求会被转发给领导者，读请求读取本地数据库而不需要通过领导者。本地处理读请求使得读取性能可以随着服务器的数量增加而增加，而不会受限于单个领导者。复制数据库是一个内存数据库，当日志持久化到磁盘时，才会将日志应用到内存数据库，同时会定期为数据库生成快照。PS：类似 Raft，内存数据库实际上就是一个状态机。 ZooKeeper 使用 ZAB 保证写操作的可线性化，同时保证异步请求按照客户端 FIFO 的顺序执行，从而实现写操作的异步可线性化（A-linearizability）。当领导者收到写请求时，如果请求包含的版本号和目标 znode 的未来版本号匹配，就会将请求转换为事务。之所以要和未来版本号匹配，是因为可能存在尚未应用到数据库的事务。如果事务未提交（复制到大多数），则无法应用到数据库。ZooKeeper 保证事务是幂等的，〈transactionType, path, value, new-version〉。 ZooKeeper 使用的是模糊快照（fuzzy snapshot），因为允许在创建快照的过程中更改状态机，而且也不像 Raft 使用写时复制，所以快照不对应某个时刻的状态，故称为模糊快照。不过，由于事务的幂等性，重放相同的日志也没有关系。从日志的角度看，模糊快照并不对应一个连续的日志范围，可能是断断续续的。 客户端向服务器发送读写请求和心跳消息，得到的响应中会包含服务器的 zxid。如果客户端连接到新服务器，会检查客户端的 zxid 和新服务器的 zxid，确保新服务器满足客户端的单调读一致性。如果新服务器的视图更旧，客户端可以连接另一台服务器。 问题 Q：无等待（wait-free）是什么意思？ A：论文 Wait-Free Synchronization 进行了介绍，并发数据对象的无等待实现可以保证，任何进程都能在有限步中完成任何操作，而不论其他进程的执行速度如何。个人认为这个定义有点抽象，无等待还有一个层次结构和共识数。类似的术语还有无锁、无障碍、无阻塞。FAQ 提供了一个简单的解释，为什么 ZooKeeper 是无等待的，因为客户端调用 API 不会被其他客户端阻塞，ZooKeeper 没有使用锁来阻塞调用。 Q：为何流水线自动支持客户端请求的 FIFO 执行顺序？异步请求为何能提高性能？ A：我的理解是 TCP 可以保证客户端请求的 FIFO 到达顺序。流水线将一个处理过程分解为多个组件，能够充分利用系统的资源。但流水线依然是一个顺序的处理过程，一般就是按照到达顺序处理的，所以能够自动支持 FIFO 执行顺序。异步请求能提高性能是流水线的特性，如果同步发送请求，流水线中的很多组件会处于空闲状态。 FAQ 中有问到 ZooKeeper 如何实现异步请求的 FIFO 执行顺序，按照论文的逻辑，这个问题就不对。论文首先说流水线支持 FIFO 执行顺序，然后推出客户端可以发送异步请求。从而我觉得，FAQ 的答案也不对。FAQ 对流水线的解释也有问题，他把流水线解释为批处理。 Q：如何实现读操作的写后读和单调读一致性？ A：写后读一致性可以由客户端的 FIFO 执行顺序保证，而单调读一致性通过检查客户端和服务器的 zxid 保证。 Q：ZooKeeper 如何实现监视（watch）？ A：FAQ 有解释，客户端通常会注册一个回调函数，该函数在监视触发时调用。Go 使用通道（channel）来实现，当监视触发时，服务器会向通道发送一个事件，然后应用程序可以从通道中获取该事件。但是有个疑问，Go 的通道能跨网络传输数据么。 Q：为什么请求不幂等，而事务幂等？ A：假设有一个带顺序标志的创建节点的请求，那么多次发送请求会创建不同的节点。事务是请求的幂等形式，论文中提到形如 〈transactionType, path, value, new-version〉。 Q：ZooKeeper 服务器、客户端和应用程序的关系？ A：个人理解，服务器提供低级原语，客户端使用 API 实现更高级的原语，应用程序使用客户端提供的高级原语。 Q：ZooKeeper 中的 zxid 和版本号有什么关系？ A：ZooKeeper 的每次状态更改（写操作）都会递增 zxid，而版本号则是 znode 的属性。个人认为，zxid 是 ZAB 层面的，版本号是数据库（状态机）层面的。 Q：可线性化和可串行化的区别？ A：可以看下 Linearizability versus Serializability，很清晰。 总结 刚开始看这篇论文，涉及很多没见过的术语，看着比较折磨。如果深入细节的话，会花费很多时间。我确实一开始没有抓住重点，陷入如何在代码层面使用 ZooKeeper，无等待和通用对象是什么意思之类的。但是，如果从更高的层面来看，ZooKeeper 可以理解为 ZAB + 数据库（状态机），就是使用数据树结构提供一个通用的 API。 在查找资料的过程中发现很多不一致的地方，例如：API 文档中描述异步请求会排队等待发送，但按照论文的描述应该不是这样的，不然怎么提高性能；一致性保证中提到单一系统映像，定义首先说保证看到相同的视图，然后又说不会看到旧视图，但这完全不是一个意思；FAQ 中对异步请求如何实现客户端 FIFO 执行顺序的讨论，我认为论文和另一份笔记都证明 FAQ 的错误。 在阅读论文和资料的过程中，经常会看到某个描述，感觉模糊不清，只能凭自己的猜测去理解。实际上确实有很多模糊的地方，没有描述具体的实现方式，但有些问题其实论文中也给出了回答。所以，在读论文的过程中还是要仔细一点，遇到不懂的不要随便猜测，先记下问题，因为很可能是一个错误的猜测，还会干扰之后的理解。总之，论文只是提供一个简要的说明，深入理解还需要实际使用 ZooKeeper，以及阅读源码。","link":"/2024/02/05/ZooKeeper%20Wait-free%20coordination%20for%20Internet-scale%20systems/"},{"title":"Chain Replication for Supporting High Throughput and Availability","text":"阅读论文 Chain Replication，参考 note。 概述 链式复制是一种容错复制方式，可以保证高性能、高可用和强一致性（可线性化）。客户端的请求都以原子的方式执行，查询请求直接发送到 tail，更新请求发送到 head，然后沿着链传递到 tail。在没有故障的情况下，可线性化保证源于以下两点：只有 tail 会响应客户端的请求，以及更新操作只会在 head 计算一次，从而可以避免冗余计算和非确定性操作带来的一致性问题。 实现 基本概念 对象由 \\(objID\\) 唯一标识，\\(Hist_{objID}\\) 表示该对象上已执行的请求，\\(Pending_{objID}\\) 表示该对象上待执行的请求。对于链式复制来说，客户端视图中的 \\(Hist_{objID}\\) 被定义为 tail 存储的 \\(Hist_{objID}\\)，\\(Pending_{objID}\\) 被定义为任何服务器接收到的、没有被 tail 执行的客户端请求。注意，这两个状态都是对象的客户端视图，而不是实际存储在服务器中的数据。此外，论文只是为方便论证才将对象状态描述为 \\(Hist_{objID}\\)，实际的状态应该是对象的当前值。 故障检测和恢复 链式复制使用额外的服务来检测故障，重新配置链，通知客户端链头和链尾对应的服务器。论文称该服务为 master，使用复制进行容错，使用 Paxos 维持多个 master 副本之间的一致性。可以将其视为类似 ZooKeeper 的协调服务。虽然论文没有提及，不过检测故障通常是使用定时心跳。 链头故障 master 直接将 head 的下一个节点作为新的 head，然后通知客户端。所有旧 head 接收而未转发给后继的请求最终都会超时，然后客户端会重试。该过程相当于执行 T2 转移。 链尾故障 master 直接将 tail 的上一个节点作为新的 tail，然后通知客户端。因为更新是从前往后传播的，所以上一个节点的视图至少和旧 tail 的视图一样新，不会影响一致性。该过程相当于执行 T3 转移。 中间故障 master 会修改故障节点的前驱和后继的指针，从而将故障节点从链中删除。但是，如果前驱转发更新请求到故障节点，而故障节点没有将其转发至后继，那么前驱需要一种机制识别这部分请求，然后重新将其转发至后继。 每个服务器维护一个更新请求的已转发列表 \\(Sent\\)，当服务器将请求转发到后继时，会将该请求添加到列表中。当更新请求 \\(r\\) 转发到尾节点，并被尾节点处理时，尾节点会向前驱发送确认信息 \\(ack( r)\\)。收到 \\(ack( r)\\) 的服务器会将 \\(r\\) 从 \\(Sent\\) 列表中删除，同时将 \\(ack( r)\\) 转发到前驱。 当中间节点 \\(S\\) 故障，master 向后继 \\(S^{+}\\) 发送其新的前驱 \\(S^{-}\\)，\\(S^{+}\\) 会响应 master 确认消息，其中包含 \\(S^{+}\\) 收到的最后一个更新请求的序列号。然后 master 向前驱 \\(S^{-}\\) 发送其新的后继 \\(S^{+}\\) 和序列号，\\(S^{-}\\) 会将在 \\(Sent_{S^{-}}\\) 中且在序列号之后的请求转发到 \\(S+\\)，这部分请求就是故障节点 \\(S\\) 未转发至 \\(S^{+}\\) 的请求。该机制的关键在于保留已发送请求的列表，\\(ack\\) 的作用只是回收空间。 恢复冗余 发生故障的服务器会从链中删除，需要恢复冗余以保证容错。理论上，可以将新服务器添加到链中的任意位置。实践中，添加到链尾比较简单。master 会要求当前链尾 \\(T\\) 转发对象已执行的请求队列 \\(Hist_{objID}^{T}\\) 到新的链尾 \\(T^{+}\\)，在转发完成之前，依然是当前链尾 \\(T\\) 执行查询请求和前驱传来的更新请求，以及响应客户端。该过程中执行的更新请求同时会被添加到 \\(Sent_{T}\\)，该操作与 \\(Sent_{T}\\) 的定义不一致，之后会处理。当 \\(Hist_{objID}^{T}=Hist_{objID}^{T^{+}}\\oplus Sent_{T}\\) 成立时，也就是转发开始时的 \\(Hist_{objID}^{T}\\) 都转发到 \\(T^{+}\\) 时，\\(T^{+}\\) 可以成为链尾。 过程如下：如果 master 收到上述不变式成立的通知，master 会通知 \\(T\\) 其不是链尾，之后 \\(T\\) 会将收到的查询请求转发到 \\(T^{+}\\)。然后 \\(Sent_{T}\\) 中的更新请求也会被转发到 \\(T^{+}\\)，转发完成之后，就符合 \\(Sent_{T}\\) 的定义，\\(T\\) 会通知 master 将 \\(T^{+}\\) 作为新的链尾。然后，master 会通知客户端新的链尾。PS：注意，此时 \\(Sent^{T}\\) 中的请求已经响应客户端。 对比主从复制 链式复制可以视为特殊的主从复制，头节点和尾节点共同充当主节点，其他节点作为从节点。相比传统的主从复制（指的是强一致性的主从复制）： 链式复制的查询，由链尾的服务器处理，不会被链中其他服务器的活动延迟。而主从复制的查询，主节点需要等待之前的更新被从节点确认，才能执行查询。PS：个人理解，指的应该是多客户端之间的更新和查询，单客户端是同步的，只有接收到上一个请求的响应才会发送下一个请求，否则链式复制是无法保证客户端的 FIFO 执行顺序。 链式复制串行传播更新，主从复制并行传播更新，所以链式复制的更新延迟更高，而且和链的长度成正比。 测试 根据论文中的模拟实验可以发现，链式复制比主从复制具有更高的读取性能，但是强一致性保证使得读写性能不能随着机器的数量线性扩展，不像 ZooKeeper。比较令人惊讶的是，在更新请求至少占总请求数的 15% 时，弱一致性保证的读取方案反而会降低系统的总吞吐量，因为在头节点的查询和更新会产生竞争。主从复制的吞吐量不会受复制因子的影响，而链式复制的更新是串行传播的，似乎吞吐量会随着链的长度增加而减少。但是，只要有足够多的更新请求，那么通过一个预热时间启动流水线，吞吐量可以恢复正常水平。 问题 Q：更新请求不是幂等的，如果响应丢失，客户端重试更新请求怎么办？ A：目前讨论的系统：GFS 的 primary chunkserver 重试会导致重复追加，我猜客户端重试大致也是如此；VM-FT 请求是否幂等取决于虚拟机中的应用程序；Raft 要求请求包含唯一标识，在状态机层去重；尽管 ZooKeeper 的事务是幂等的，但是请求不是幂等的，没有讨论如何处理；链式复制论文提到可以在重试之前，进行查询判断更新是否已经执行。总的来说，是否要求幂等是根据系统的实际使用场景而定的，课程中也提到，ZooKeeper 和链式复制也可以使用和 Raft 类似的方法去重，从而实现幂等。 Q：更新请求的延迟和链的长度成正比，那么超时时间会更长，如果请求丢失似乎需要更多等待？ Q：如果链头 \\(S\\) 和 master 发生网络分区故障，那么 \\(S^{+}\\) 会成为新链头，而此时 \\(S^{+}\\) 依然会收到旧链头 \\(S\\) 的转发。节点必然需要一种机制判断是否应该忽略请求，这可以通过简单的判断请求的来源是否是其前驱来实现。 Q：客户端在连接到服务器时，以及链头或链尾被改变时，master 需要通知客户端，如果客户端很多会有什么问题？ 总结 课程提到，复制状态机有两种主要的实现方式，一种是使用共识算法复制所有操作，另一种是使用配置服务 + 主从复制，配置服务中的共识算法仅复制元数据，其他操作不需要使用共识算法复制。链式复制使用的是第二种方式，它需要利用额外的配置服务进行故障恢复，同时避免脑裂。链式复制概念简单，只有中间故障和恢复冗余稍微复杂一点。和共识算法不同，只要有一个服务器故障，就可能会导致读请求或写请求的短暂中断。论文在模拟实验中提到多链和对象放置策略，我认为论文的描述很模糊，所以没介绍。","link":"/2024/02/10/Chain%20Replication%20for%20Supporting%20High%20Throughput%20and%20Availability/"},{"title":"Codeforces Round 924 (Div. 2)","text":"Rectangle Cutting 题目 输入两个整数 \\(a\\) 和 \\(b\\)，表示矩形 \\(a\\times b\\)，判断是否能将矩形切割一次再拼接得到不同的矩形，切割线要求平行于某条边且得到的矩形边长为整数。 数据范围：\\(1\\leq a,b\\leq 10^{9}\\)。 思路 以下讨论总是假设 \\(a\\leq b\\)： 首先我们总是应该对半切，如果不对半切，并且想要拼接得到矩形，那么只能切割更长的边 \\(b\\)，得到 \\(a\\times a\\) 和 \\(a\\times(b-a)\\)，但是不论怎么拼接都和原矩形相同。 如果 \\(a\\) 是偶数，可以总是对半切 \\(a\\)，然后拼接得到不同的矩形 \\(\\frac{a}{2}\\times 2b\\)。 如果 \\(a\\) 是奇数，\\(b\\) 必须是偶数，否则无法对半切。此时只能对半切 \\(b\\)，拼接得到矩形 \\(2a\\times\\frac{b}{2}\\)，当 \\(a\\neq\\frac{b}{2}\\) 时，得到的矩形和原矩形不同。 代码 12345678910111213public static void solve() { int a = io.nextInt(), b = io.nextInt(); if (a &gt; b) { int t = a; a = b; b = t; } if (a % 2 == 0 || b % 2 == 0 &amp;&amp; b != 2 * a) { io.println(&quot;Yes&quot;); } else { io.println(&quot;No&quot;); }} Equalize 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，可以选择一个 \\([1,n]\\) 的任意排列 \\(p\\)，执行 \\(a_{i}=a_{i}+p_{i}\\) 操作。输出执行操作之后，能够得到的数组 \\(a\\) 中相同元素最大出现次数的最大值。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 将数组加上任意排列，肯定是更小的数对应更大的数，才能使相同元素的最大出现次数最大化。我们可以将数组 \\(a\\) 排序同时去重，之所以去重是因为相同元素加上排列之后必定不相同，然后将排列看作固定的递减数组。只要数组 \\(a\\) 中的两个数的差值小于 \\(n\\)，那么这两个数之间的元素必定可以在操作之后变成相同的元素。问题就转化为求区间的最大长度，同时最大值和最小值的差值小于 \\(n\\)，可以使用滑动窗口求解。 代码 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) { set.add(io.nextInt()); } int m = set.size(), idx = 0; int[] a = new int[m]; for (var x : set) { a[idx++] = x; } int ans = 1; for (int i = 0, j = 1; j &lt; m; j++) { while (a[j] - a[i] &gt;= n) { i++; } ans = Math.max(ans, j - i + 1); } io.println(ans);} Physical Education Lesson 题目 输入两个整数 \\(n\\) 和 \\(x\\)，求 \\(k\\) 的个数，使得对于编号为 \\(1\\) 到 \\(k\\) 的位置，满足第 \\(n\\) 个位置的编号为 \\(x\\)。第 \\(n\\) 个位置是按往返来计算的，例如 \\(1,2,\\dots,k-1,k,k-1,\\dots,2,1\\)，第 \\(1\\) 和 \\(1+2k-2\\) 个位置的编号都为 \\(1\\)。当 \\(k&gt;1\\) 时，编号循环的周期就是 \\(2k-2\\)。题目限制 \\(k&gt;1\\)。 数据范围：\\(1\\leq x&lt;n\\leq 10^{9}\\)。 思路 \\(k\\) 必须满足 \\(k\\geq x\\)，同时 \\((2k-2)\\cdot t+x=n\\) 或 \\((2k-2)\\cdot t+k+k-x=n\\)，变形得到 \\(n-x=2\\cdot(k-1)\\cdot t\\) 或 \\(n+x-2=2\\cdot(k-1)\\cdot(t+1)\\)。求 \\(k\\) 的个数，可以首先求出 \\(\\frac{n-x}{2}\\) 和 \\(\\frac{n+x-2}{2}\\) 的约数，约数加一就是满足等式的 \\(k\\) 值，最后限制 \\(k\\geq x\\)，得到答案。其实也可以不使用集合去重，只需要特判 \\(x=1\\) 和 \\(k=x\\) 的情况。 代码 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(), x = io.nextInt(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); calc(n - x, x, set); calc(n + x - 2, x, set); io.println(set.size());}private static void calc(int x, int y, Set&lt;Integer&gt; set) { if (x % 2 != 0) { return; } x /= 2; for (int i = 1; i &lt;= x / i; i++) { if (x % i == 0) { if (i + 1 &gt;= y) { set.add(i + 1); } if (x / i != i &amp;&amp; x / i + 1 &gt;= y) { set.add(x / i + 1); } } }} Lonely Mountain Dungeons 题目 输入三个整数 \\(n,b,x\\)，以及长度为 \\(n\\) 的数组 \\(c\\)。有 \\(n\\) 种生物，每种生物的数量为 \\(c_{i}\\)。你需要将所有生物分为 \\(k\\) 组，位于不同组的每对同种生物会使总分增加 \\(b\\)，同时总分会减少 \\((k-1)\\cdot x\\)。输出能够得到的最大分数。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq b\\leq 10^{6}\\)，\\(0\\leq x\\leq 10^{9}\\)，\\(1\\leq c_{i}\\leq 2\\cdot 10^{5}\\)，\\(\\sum_{i=1}^{n}c_{i}\\leq 2\\cdot 10^{5}\\)。 思路 首先需要知道，对于某种生物 \\(i\\) 和固定的 \\(k\\)，将 \\(c_{i}\\) 尽量平均分配是最优的，不过我也不知道该怎么证明。当 \\(k&gt;c_{i}\\) 时，得分总是为 \\(C_{c_{i}}^{2}\\cdot y^{2}\\)。当 \\(k\\leq c_{i}\\) 时，就需要将 \\(c_{i}\\) 分为，\\(c_{i}\\bmod k\\) 组包含 \\(y=\\lceil\\frac{c_{i}}{k}\\rceil\\) 个该种生物，\\(k-c_{i}\\bmod k\\) 组包含 \\(y^{\\prime}=\\lfloor\\frac{c_{i}}{k}\\rfloor\\) 个该种生物。得分为： $$ C_{k-c_{i}\\bmod k}^{2}\\cdot y^{2}+C_{c_{i}\\bmod k}^{2}\\cdot y^{\\prime 2}+(k-c_{i}\\bmod k)\\cdot(c_{i}\\bmod k)\\cdot y\\cdot y^{\\prime} $$ 根据以上讨论，很容想到暴力枚举组数 \\(k\\)，然后内层循环计算该组数下的最大得分，总时间复杂度为 \\(O(\\max(c_{i})\\cdot n)\\)。由于题目限制 \\(\\sum_{i=1}^{n}c_{i}\\leq 2\\cdot 10^{5}\\)，我们可以预处理得到所有 \\(c_{i}\\) 在组数为 \\([1,c_{i}]\\) 下的最大得分之和，从而可以将暴力枚举的内循环优化为 \\(O(1)\\) 时间复杂度。 代码 12345678910111213141516171819202122232425262728293031323334public static void solve() { int n = io.nextInt(), b = io.nextInt(), x = io.nextInt(); int m = 0; int[] c = new int[n]; for (int i = 0; i &lt; n; i++) { c[i] = io.nextInt(); m = Math.max(m, c[i]); } long[] f = new long[m + 1]; long[] g = new long[m + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 1; j &lt;= c[i]; j++) { f[j] += calc(c[i], j); } g[c[i]] += calc(c[i], c[i]); } long ans = 0L; for (int i = 1; i &lt;= m; i++) { ans = Math.max(ans, (f[i] + g[i - 1]) * b - (long) (i - 1) * x); g[i] += g[i - 1]; } io.println(ans);}private static long calc(int n, int k) { int a = n / k, b = n % k; long res = (long) (k - b) * (k - b - 1) / 2 * a * a; res += (long) b * (b - 1) / 2 * (a + 1) * (a + 1); res += (long) (k - b) * b * a * (a + 1); return res;}","link":"/2024/02/12/Codeforces%20Round%20924%20(Div.%202)/"},{"title":"Frangipani: A Scalable Distributed File System","text":"阅读论文 Frangipani，参考 FAQ，note。 概述 Frangipani 是一个分布式文件系统，由 Petal 分布式存储服务和多个 Frangipani 服务器组成，Frangipani 服务器共享 Petal 提供的单个虚拟磁盘抽象，同时使用分布式锁保证缓存一致性。 实现 预写日志 每个 Frangipani 服务器都会使用预写日志记录系统元数据的变化（不记录文件数据），只有当日志持久化到 Petal 之后，才能修改系统的元数据。日志首先会按顺序存放在服务器内存的循环缓冲区中，然后定期刷新到 Petal。使用日志记录元数据的变化，可以避免服务器故障时元数据的部分更新导致文件系统结构被破坏（产生不一致），从而可以避免运行 fsck 一致性检查程序，实现快速恢复。 日志由若干大小为 512 字节的日志块组成，每个日志块都有一个单调递增的序列号。论文表示序列号作用是在故障恢复时检测日志的末尾，即使磁盘乱序写入数据。元数据由若干大小为 512 字节的元数据块组成，每个元数据块都有一个单调递增的版本号。日志块也会包含其所修改元数据块的版本号，只有日志块中的版本号大于元数据块的版本号时，才能应用日志。从而可以避免服务器故障恢复时，旧日志覆盖新版本的元数据，以及重复应用已经应用的日志。512 字节的日志块和元数据块实际上对应一个扇区，扇区的读写保证是原子的。 PS：论文提到元数据块被释放然后重用于文件数据导致版本号消失的问题，然后说明限制释放的元数据块仅被新的元数据块重用可以解决该问题。此处所说的元数据块应该是指扇区，所有才会释放和重用，也就是说版本号实际上是和元数据块所在的扇区绑定，而和元数据是什么无关。而且，之所以版本号消失会有问题，是因为日志块记录的是所修改元数据块的扇区位置。这种设计有点奇怪，日志块以及版本号不和修改的元数据关联，而是和扇区关联。 分布式锁 锁服务使用 Paxos 进行容错，为文件系统提供读写锁。当锁服务检测到冲突的锁请求时，会要求当前锁的持有者释放或降级锁，以消除冲突。读写锁允许 Frangipani 服务器从磁盘获取数据并将其缓存。在释放读写锁前，服务器会使缓存无效，从而保证缓存一致性。在释放或降级写锁前，服务器必须将脏数据写入磁盘（包括文件数据）。磁盘被划分为若干逻辑段，每个段都有一个锁，每个日志、文件、目录和符号链接都是一个段。每个文件使用一个锁，适合很少并发写的工作负载，其他负载可能需要使用更细粒度的锁。 锁具有粘性，也就是说 Frangipani 服务器获取锁之后不会主动释放，除非锁服务要求其释放。当挂载 Frangipani 文件系统时，Frangipani 服务器会调用 clerk 模块，该模块会连接到锁服务，获取租约并且在本地打开一个锁表。当文件系统被卸载时，clerk 会关闭锁表。clerk 和锁服务使用异步消息进行通信，有四种消息类型：request、grant、revoke 和 release。 故障处理 当 Frangipani 服务器的租约由于没有续约而过期时，锁服务会认为该服务器故障，此时需要一种机制来释放故障服务器持有的锁。锁服务会在另一个 Frangipani 服务器上启动恢复进程，新服务器会获取租约和故障服务器日志的锁，然后按顺序应用未执行的日志，最后释放（release）所有锁以及释放（free）日志。如果是由于网络分区故障而没有续约，租约过期的 Frangipani 服务器会主动丢弃其所有锁和缓存数据。如果缓存中存在脏数据，则服务器会向用户程序报告错误，将问题交给用户处理。 如果租约在服务器向 Petal 发送写入请求之后到达之前过期，则会产生问题，因为此时锁可能已经被授予故障恢复服务器。论文提到可以为每个写入请求添加过期时间戳，如果请求到达 Petal 的时间戳大于请求中的时间戳，则拒绝该请求。或者将锁服务和 Petal 集成，服务器为写入请求添加租约标识符，然后 Petal 可以判断租约是否过期。 问题 Q：日志序列号的作用有点奇怪，为什么磁盘要乱序写入数据？ Q：日志只会记录元数据，那么有可能只执行元数据更改，而丢失文件数据？ A：该语义符合标准的本地 Unix 文件系统，崩溃之前的写入可能会丢失。应用程序可以使用 fsync 系统调用，强制将数据立即刷新到磁盘。 总结 预写日志存储在 Petal 提供的共享虚拟磁盘上，使得任何服务器都可以使用故障服务器的日志进行恢复。多个日志使得恢复过程变得复杂，需要使用版本号机制避免异常。分布式锁保证服务器之间的缓存一致性。Frangipani 服务器运行在用户侧，负责和共享磁盘通信，该设计要求用户是可信的。该系统使用粗粒度的锁定，一个文件对应一个锁，所以不适用于经常并发写入相同文件的负载。论文的性能测试我没有太多时间看，总结时也忽略了一些我认为不是很重要的细节。","link":"/2024/02/15/Frangipani%20A%20Scalable%20Distributed%20File%20System/"},{"title":"Codeforces Round 925 (Div. 3)","text":"ABC 都是简单模拟题。D 题很经典，利用哈希表求同余的下标对数。E 题需要观察到答案只和元素的位数有关。F 题给出元素的偏序，判断是否存在全序，可以将顺序建模成有向图，然后使用拓扑排序判断是否存在环。G 题需要观察到如下性质，1 和 2 的数量不能相差超过一，3 和 4 放置的方案数相互独立，计算组合数的方式类似将 m 个球放入 n 个可以为空的盒子，公式为 \\(C_{n+m-1}^{n-1}=C_{n+m-1}^{m}\\)，可以看看灵神的视频。","link":"/2024/02/15/Codeforces%20Round%20925%20(Div.%203)/"},{"title":"Codeforces Round 926 (Div. 2)","text":"Sasha and the Drawing 题目 输入整数 \\(n\\) 表示 \\(n\\times n\\) 的正方形网格，网格总共有 \\(4n-2\\) 条对角线，输出最小的着色单元格数量，使得至少有 \\(k\\) 个对角线上存在着色的单元格。 数据范围：\\(2\\leq n\\leq 10^{8}\\)，\\(1\\leq k\\leq 4n-2\\)。 思路 最好情况下，对 \\(1\\) 个单元格着色，可以贡献 \\(2\\) 个对角线，最多有 \\(2n-2\\) 个单元格满足该条件，例如选择着色第一行的 \\(n\\) 个单元格和最后一行的中间 \\(n-2\\) 个单元格。剩下 \\(2\\) 个单元格，每着色 \\(1\\) 个可以贡献 \\(1\\) 个对角线。 代码 12345678public static void solve() { int n = io.nextInt(), k = io.nextInt(); if (k &lt;= 4 * n - 4) { io.println((k + 1) / 2); } else { io.println(2 * n - 2 + (k - (4 * n - 4))); }} Sasha and the Casino 题目 输入三个整数 \\(k,x,a\\)，表示有一个游戏每次可以选择下注 \\(y\\) 个硬币（\\(y\\leq a\\)），如果赢了将获得 \\(y\\cdot k\\) 个硬币，输了不会获得任何硬币，游戏最多连续输 \\(x\\) 次。输出初始有 \\(a\\) 个硬币时，是否存在某个方案能够获取无限数量的硬币。 数据范围：\\(2\\leq k\\leq 30\\)，\\(1\\leq x\\leq 100\\)，\\(1\\leq a\\leq 10^{9}\\)。 思路 首先，前 \\(x\\) 次游戏都下注 \\(1\\) 个硬币，最后下注 \\(a-x\\) 个硬币不是最优策略，因为可能会提前赢，如果赢的时候增量为负，将会输得很惨。所以对于第 \\(i\\) 次下注（\\(1\\leq i\\leq x+1\\)），下注大小 \\(y_{i}\\) 需要满足赢得游戏时 \\(y_{i}\\times (k-1)&gt;\\sum_{j=1}^{i-1}y_{j}\\)。 代码 12345678public static void solve() { int k = io.nextInt(), x = io.nextInt(), a = io.nextInt(); int sum = 0; for (int i = 0; i &lt;= x &amp;&amp; sum &lt;= a; i++) { sum += sum / (k - 1) + 1; } io.println(sum &lt;= a ? &quot;YES&quot; : &quot;NO&quot;);} Sasha and a Walk in the City 题目 输入一棵树，包含 \\(n\\) 个节点和 \\(n-1\\) 条边，输出存在多少个集合，使得任意简单路径都不会包含超过两个在集合中的节点，答案对 \\(998244353\\) 取模。 数据范围：\\(2\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq u_{i},v_{i}\\leq n\\)，\\(u_{i}\\neq v_{i}\\)。 思路 假设节点 \\(1\\) 是树的根节点，定义 \\(dp_{v}\\) 表示以 \\(v\\) 为根的子树的非空集合个数，集合满足不存在一对节点，其中一个是另一个的祖先。假设节点 \\(u_{1},u_{2},\\dots,u_{k}\\) 是节点 \\(v\\) 的子节点，则有 \\(dp_{v}=\\prod_{i=1}^{k}(dp_{u_{i}}+1)\\)，当所有子树的集合为空时，表示只选择节点 \\(v\\)。最后答案为 \\(\\sum_{i=1}^{n}dp_{i}+1\\)，可以通过以下分类讨论得到： 不存在祖先关系的集合个数为 \\(dp_{1}+1\\)，其中 \\(dp_{1}\\) 表示不存在祖先关系的非空集合个数，\\(1\\) 表示集合为空的情况。 存在祖先关系的集合个数为 \\(\\sum_{i=2}^{n}dp_{i}\\)，因为对于每个节点 \\(v\\) 作为祖先，有 \\(\\sum_{i=1}^{k}dp_{u_{i}}\\) 个集合存在祖先关系。 代码 12345678910111213141516171819202122232425262728293031private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1; g[u].add(v); g[v].add(u); } long[] dp = new long[n]; dfs(0, -1, g, dp); long ans = 1L; for (long x : dp) { ans = (ans + x) % MOD; } io.println(ans);}private static void dfs(int x, int fa, List&lt;Integer&gt;[] g, long[] dp) { dp[x] = 1; for (int y : g[x]) { if (y != fa) { dfs(y, x, g, dp); dp[x] = dp[x] * (dp[y] + 1) % MOD; } }} Sasha and the Wedding Binary Search Tree 题目 输入两个整数 \\(n\\) 和 \\(c\\)，表示一颗二叉搜索树，以及节点值的取值范围为 \\([1,c]\\)。然后输入 \\(n\\) 行 \\(l_{i},r_{i},v_{i}\\) 值，表示节点 \\(i\\) 的左右子节点和该节点的值。如果 \\(l_{i}&lt;0\\) 或 \\(r_{i}&lt;0\\)，则表示没有对应的子节点。如果 \\(val_{i}&lt;0\\)，则表示不知道该节点的值是多少。输出可能的二叉搜索树个数，答案对 \\(998244353\\) 取模。 数据范围：\\(2\\leq n\\leq 5\\cdot 10^{5}\\)，\\(1\\leq c\\leq 10^{9}\\)。 思路 首先进行中序遍历，将所有值添加到一个列表，那么可以求出每段连续负数值的方案数，将所有段的方案数相乘就是答案。对于每一段可以知道其上下限，假设段的长度为 \\(m\\)，取值范围为 \\([lo,hi]\\)，则可能的取值数量为 \\(k=hi-lo+1\\)。那么方案数就是将 \\(m\\) 个球放入 \\(k\\) 个盒子的方案数，盒子可以为空，公式为 \\(C_{m+k-1}^{k-1}=C_{m+k-1}^{m}\\)，可以参考上一场比赛的最后一题。 需要注意的是，\\(k\\) 的取值范围很大，我们使用等号右边的公式计算方案数，可以只循环 \\(m\\) 次。由于答案需要取模，循环中取模之后的值可能无法被整除，所以必须计算模乘法逆元。以及下面的代码会栈溢出，但是改写为 C++ 就不会，只能说 Java 占用的栈空间比较大么，但是也有其他人使用 Java 通过测试，真不知道为什么我的就不行。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), c = io.nextInt(); int[] val = new int[n]; int[][] g = new int[n][2]; for (int i = 0; i &lt; n; i++) { int l = io.nextInt() - 1, r = io.nextInt() - 1; val[i] = io.nextInt(); g[i][0] = l; g[i][1] = r; } List&lt;Integer&gt; aux = new ArrayList&lt;&gt;(); dfs(0, g, val, aux); aux.add(c); long ans = 1L; int lo = 1, cnt = 0; for (int x : aux) { if (x &lt; 0) { cnt++; continue; } if (cnt &gt; 0) { ans = ans * calc(lo, x, cnt) % MOD; cnt = 0; } lo = x; } io.println(ans);}private static void dfs(int x, int[][] g, int[] val, List&lt;Integer&gt; aux) { if (x &lt; 0) { return; } dfs(g[x][0], g, val, aux); aux.add(val[x]); dfs(g[x][1], g, val, aux);}private static long calc(int lo, int hi, int cnt) { long res = 1L; int len = hi - lo + 1; for (int i = cnt + len - 1, j = 1; j &lt;= cnt; i--, j++) { res = res * i % MOD * pow(j, MOD - 2) % MOD; } return res;}private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;}","link":"/2024/02/16/Codeforces%20Round%20926%20(Div.%202)/"},{"title":"think-cell Round 1","text":"Permutation Printing 题目 输入一个整数 \\(n\\)，输出长度为 \\(n\\) 的排列，满足不存在两个不同的索引 \\(1\\leq i,j&lt; n\\)，使得 \\(p_{i}\\) 整除 \\(p_{j}\\) 且 \\(p_{i+1}\\) 整除 \\(p_{j+1}\\)。 数据范围：\\(3\\leq n\\leq 10^{5}\\)。 思路 可以构造排列 \\(1,n,2,n-1,\\dots,\\lceil\\frac{n+1}{2}\\rceil\\)。如果 \\(i&lt;j\\)，则有 \\(p_{i+1}&gt;p_{j+1}\\)，必定不能整除，反之亦然。 代码 123456789101112public static void solve() { int n = io.nextInt(); int l = 1, r = n; for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) { io.print(l++ + &quot; &quot;); } else { io.print(r-- + &quot; &quot;); } } io.println();} Lexicographically Largest 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，初始时有一个空集 \\(S\\)，执行以下三步操作恰好 \\(n\\) 次： 选择一个索引 \\(i\\)，\\(1\\leq i\\leq |a|\\)。 将 \\(a_{i}+i\\) 插入集合 \\(S\\)。 从 \\(a\\) 中删除 \\(a_{i}\\)，\\(a_{i}\\) 之后的所有元素的索引将减少 \\(1\\)。 将得到的集合 \\(S\\) 中的元素按照递减顺序排列，输出能够得到的字典序最大的排列。 数据范围：\\(1\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 可以发现字典序最大的排列总是包含 \\(n\\) 个元素。暴力的想法是，可以首先将所有 \\(a_{i}+i\\) 从小到大排序，我们总是优先选择最大的元素，如果有多个元素最大，就优先选择其中索引 \\(i\\) 最小的元素，从而可以保证得到字典序最大的排列。通过观察可以发现，如果从小到大排列 \\(a_{i}+i\\)，然后倒序遍历数组，我们可以得到的最大元素为 \\(\\min(a[i],a[i+1]-1)\\)，对所有 \\(1\\leq i&lt; n\\) 都成立。比赛时没发现，使用的是更复杂的方法，其实不难。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); a[i] += i + 1; } Arrays.sort(a); for (int i = n - 2; i &gt;= 0; i--) { a[i] = Math.min(a[i], a[i + 1] - 1); } for (int i = n - 1; i &gt;= 0; i--) { io.print(a[i] + &quot; &quot;); } io.println();} Sum over all Substrings (Hard Version) 题目 输入长度为 \\(n\\) 的二进制字符串 \\(s\\)，输出 \\(\\sum_{i=1}^{n}\\sum_{j=i}^{n}f(s_{i}s_{i+1}\\cdots s_{j})\\)。对于某个二进制模式串 \\(p\\)，\\(f(p)\\) 表示满足以下条件的二进制字符串 \\(q\\)，其中 \\(1\\) 的最小可能数量：假设 \\(p\\) 和 \\(q\\) 的长度均为 \\(m\\)，对于所有 \\(1\\leq i\\leq m\\)，存在 \\(l\\) 和 \\(r\\)（\\(1\\leq l\\leq i\\leq r\\leq m\\)），使得 \\(p_{i}\\) 在 \\(q_{l}q_{l+1}\\cdots q_{r}\\) 中的出现次数至少为 \\(\\lceil \\frac{m}{2}\\rceil\\)。 数据范围：\\(1\\leq n\\leq 10^{6}\\)。 思路 暴力的想法是枚举所有子串，然后对于每个子串计算 \\(f\\) 值。现在思考对于给定的 \\(p\\)，如何计算 \\(f\\) 值。正序遍历子串，基本算法如下：如果 \\(p_{i}=0\\)，则直接在 \\(q_{i}\\) 放置 \\(0\\)；如果 \\(p_{i}=1\\)，则可以在 \\(q_{i+1}\\) 放置 \\(1\\)，\\(q_{i}\\) 和 \\(q_{i+2}\\) 放置 \\(0\\)，从而不论 \\(p_{i+1}\\) 和 \\(p_{i+2}\\) 是什么，都存在满足条件的 \\(l\\) 和 \\(r\\)（在区间 \\([i,i+2]\\) 范围内）。时间复杂度为 \\(O(n^{3})\\)，如果在遍历的同时计算子串，则时间复杂度为 \\(O(n^{2})\\)。可以使用动态规划将时间复杂度降低为 \\(O(n)\\)，定义 \\(dp_{i}\\) 表示 \\(\\sum_{j=i}^{n}f(s_{i}s_{i+1}\\cdots s_{j})\\)，转移方程见代码。 代码 12345678910111213141516public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 0L; long[] dp = new long[n + 3]; for (int i = n - 1; i &gt;= 0; i--) { if (s[i] == '1') { dp[i] = dp[i + 3] + n - i; } else { dp[i] = dp[i + 1]; } ans += dp[i]; } io.println(ans);}","link":"/2024/02/21/think-cell%20Round%201/"},{"title":"分布式系统的挑战","text":"不可靠的网络 网络分区故障，指网络的一部分由于网络故障而与其他部分断开，其实可以直接称为网络故障。作者推荐，可以通过故意触发网络问题，来测试系统的反应。 在分布式系统中，需要设置响应的超时时间，从而判断节点是否失效。如果时间设置得太长，则需要等待更长的时间。如果时间设置得太短，可能节点只是负载过高而响应缓慢，此时判断节点失效并将负载转移到其他节点会进一步增加系统负载，从而可能导致失效扩散（还可能会导致其他异常）。比较好的做法是，持续测量响应时间及其变化，然后根据测量结果自动调整超时时间。 从广义上讲，网络延迟的波动可以视为资源动态分配的结果。传统的电话网络（非 VoIP）使用电路交换技术，为每个通话分配一条固定带宽的通信链路，网络的延迟是确定的；而互联网使用分组交换技术，所有用户共享网络带宽，用户之间的数据存在排队的情况，该方法可以增加带宽的利用率，但是理论上的延迟是无限大的。 不可靠的时钟 网络上的每台机器都有独立的时钟硬件设备，通常是石英晶体振荡器，用于维护机器的本地时间，该时间可能与其他机器上的时间不同。通常使用网络时间协议（Network Time Protocol，NTP）来同步机器之间的时间，该协议根据一组专门的时间服务器来调整本地时间（调整石英的振动频率），时间服务器则从精确度更高的时间源（例如 GPS 接收器）获取高精度时间。 墙上时钟和单调时钟 现代计算机内部至少有两种时钟：墙上时钟和单调时钟。 墙上时钟 墙上时钟根据某个日期返回当前的日期与时间，例如 Linux 的 clock_gettime(CLOCK_REALTIME) 和 Java 的 System.currentTimeMillis() 会返回自 1970 年 1月 1 日（UTC）以来的秒数和毫秒数，不含润秒。有些系统则使用其他日期作为参考点。 墙上时钟需要使用 NTP 进行同步，但是存在很多问题。特别是，如果本地时钟远远快于 NTP 服务器，则同步之后会发生时间倒退的现象，以及墙上时钟经常忽略润秒，导致其不太适合用于测量时间间隔。 单调时钟 单调时钟不需要和 NTP 服务器时钟进行同步，适合测量时间间隔。例如 Linux 的 clock_gettime(CLOCK_MONOTONIC) 和 Java 中的 System.nanoTime() 返回的都是单调时钟。单调时钟的单个值没有任何意义，它可能是电脑启动后经过的纳秒数或者其他含义，不同节点上的单调时钟没有相同的基准，不能相互比较。 时钟同步和准确性 硬件时钟和 NTP 服务器可能会出现各种问题，例如：计算机中的石英钟存在漂移现象（运行速度会加快或减慢，取决于机器的温度）；如果本地时钟和 NTP 服务器时钟相差太大，应用程序可能会看到时间倒退或跳跃的现象；同步的准确性受限于网络延迟，以及 NTP 服务器是否正常工作；各种其他情况，包括下面提到的润秒。 润秒（Leap second）就是对协调世界时（Coordinated Universal Time，UTC）增加或减少 1 秒，以使协调世界时和世界时（UT，通常指 UT1）之间的差异不超过 0.9 秒。2022 年 11 月，国际计量大会决定在 2035 年之前取消润秒。润秒曾经使许多大型系统崩溃，根本原因是许多系统没有正确适配润秒，软件存在 BUG 从而引发各种问题。可以看下 The Inside Story of the Extra Second That Crashed the Web 这篇文章，讲述了现实中发生过的问题。Google 处理润秒方式是，在一天内逐步调整时间，而不是在一天结束时直接改变 1 秒。PS：一个显示各个时钟目前时间的网站。 如果投入大量资源，可以达到非常高的时钟精度，例如交易系统的时钟就要求很小的时钟误差。高精度的时钟可以使用 GPS 接收器，精确时间协议（PTP）并辅以细致的部署和监测来实现。 依赖同步的时钟 如果应用需要精确同步的时钟，最好仔细监控所有节点上的时钟偏差。如果某个节点的时钟漂移超出上限，则将其视为失效节点并从集群中移除。这样监控的目的是确保在造成重大影响（例如隐式的数据丢失）之前尽早发现并处理问题。 时间戳和事件顺序 在无主复制的检测并发写中提到过，最后写入者获胜（LWW）冲突解决策略由于时钟偏差，可能会覆盖非并发写入。 在上述例子中，时钟同步机制稳定工作，节点 1 和节点 3 之间的时钟偏差小于 3ms，但是时间戳却不能正确排序事件，从而导致客户端 B 的增量操作被覆盖。解决方案就是之前提到过的，使用版本向量技术跟踪因果关系。PS：因果关系其实就是非并发写操作的前后关系，版本向量不仅可以跟踪因果关系，还可以判断写操作是否并发。 时钟的置信区间 或许墙上时钟会返回微秒甚至纳秒级别的信息，但是这种精度的测量值其实并不可信，因为存在石英漂移和网络延迟等不确定性因素。所以，我们不应该将时钟读数视为一个精确的时间点，而应该视为带有置信区间的时间范围。例如，系统可能有 95% 的置信度认为目前时间介于 10.3~10.5 秒之间。 可以根据具体的时间源来推算出时钟误差的上限。如果节点上直接装有 GPS 接收器或原子（铯）时钟，那它的误差范围通常可查询制造商的手册。如果节点是从服务器获取时间，则不确定性取决于上次同步以来的石英漂移范围，加上 NTP 服务器的不确定性，再加上节点和服务器之间的往返时间。 但是，大多数系统并不提供这种误差查询接口，通常只会返回某个确定的时间，而没有任何误差信息。Google Spanner 中的 TrueTime API 提供误差查询，它会返回时间的上下界。 全局快照的同步时钟 该节主要是讲如何在分布式场景下，生成全局单调递增的事务 ID，有点不明白这个标题是什么意思。如果是单节点数据库，使用一个计数器就可以实现正确的事务 ID。但是，如果是多节点数据库，则更加复杂并且开销更大。 Twitter 使用雪花（Snowflake）算法来生成近似单调递增的唯一 ID。如果节点之间的墙上时钟完全同步，则也可以将其作为事务 ID，但是实际上是不可能的。Google Spanner 使用 TrueTime API 返回的时钟置信区间作为事务 ID，如果两个置信区间没有重叠，则可以知道两个事务的先后顺序。 进程暂停 在使用主从复制的数据库中，只有主节点可以接受写入，如果主节点失效则需要将某个从节点提升为主节点。判断节点是否失效可以使用租约来实现：如果某个节点持有租约，那么它就是主节点；如果租约过期，则该节点失效。我们可以使用单调时钟来判断租约是否过期，但是可能由于垃圾收集、上下文切换或磁盘 I/O 等原因导致进程暂停，从而使得暂停之前判断租约没有过期，暂停之后发送请求时租约已经过期。 上图是 HBase 曾经遇到的问题，不正确的分布式锁实现，导致未持有锁的客户端修改数据。解决方案是，锁服务为每个锁维护一个单调递增的 fencing 令牌（实际上就是版本号），在锁服务授予客户端租约和客户端向存储服务发送写请求时会包含该令牌，存储服务也会维护数据最后一次修改对应的令牌。如果存储服务收到的写请求包含旧令牌，则会拒绝该请求。如果使用 ZooKeeper 作为锁服务，则事务标识 zxid 或节点版本 cversion 可以充当 fencing 令牌。","link":"/2024/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/"},{"title":"AtCoder Beginner Contest 344","text":"String Bags 题目 输入字符串 \\(T\\) 和整数 \\(N\\)，表示有 \\(N\\) 个袋子。然后对每个袋子，输入其包含的字符串个数 \\(A_{i}\\)，以及 \\(A_{i}\\) 个字符串 \\(S_{i,1},S_{i,2},\\dots,S_{i,A_{i}}\\)。对于每个袋子，我们只能从中选择一个字符串或者不选。输出选择袋子的最少个数，使得按照袋子的编号顺序拼接字符串，能够得到字符串 \\(T\\)。如果无法得到字符串 \\(T\\)，则输出 \\(-1\\)。 数据范围：\\(1\\leq \\operatorname{len}(T)\\leq 100\\)，\\(1\\leq N\\leq 100\\)，\\(1\\leq A_{i}\\leq 10\\)，\\(1\\leq \\operatorname{len}(S_{i,j})\\leq 10\\)。 思路 定义 \\(dp[i][j]\\) 表示从袋子 \\([1,i]\\) 中选择袋子的最少个数，使得拼接得到的字符串和 \\(T\\) 的前缀 \\([1,j]\\) 相同（下标从 \\(1\\) 开始）。初始状态和转移方程见代码，算是基本的动态规划，太久没做题加上原题表述有歧义，竟然没做出来。 代码 1234567891011121314151617181920212223242526public static void solve() { String t = io.next(); int n = io.nextInt(); int m = t.length(); int[] dp = new int[m + 1]; Arrays.fill(dp, m + 1); dp[0] = 0; for (int i = 0; i &lt; n; i++) { int z = io.nextInt(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int j = 0; j &lt; z; j++) { set.add(io.next()); } for (int j = m - 1; j &gt;= 0; j--) { for (int k = 1; k &lt;= 10 &amp;&amp; k &lt;= j + 1; k++) { if (set.contains(t.substring(j - k + 1, j + 1))) { dp[j + 1] = Math.min(dp[j + 1], dp[j + 1 - k] + 1); } } } } io.println(dp[m] == m + 1 ? -1 : dp[m]);}","link":"/2024/03/10/AtCoder%20Beginner%20Contest%20344/"},{"title":"第 388 场力扣周赛","text":"K 个不相交子数组的最大能量值 题目 输入长度为 \\(n\\) 的整数数组 \\(nums\\) 和正奇数 \\(k\\)，输出从数组中选择 \\(k\\) 个不相交的子数组，能够得到的最大得分。\\(k\\) 个子数组的得分为 \\(\\sum_{i=1}^{k}(-1)^{i+1}\\times sum[i]\\times (k-i+1)\\)，其中 \\(sum[i]\\) 表示第 \\(i\\) 个子数组中元素之和。 数据范围：\\(1\\leq n\\leq 10^{4}\\)，\\(-10^{9}\\leq nums[i]\\leq 10^{9}\\)，\\(1\\leq k\\leq n\\)，\\(1\\leq n\\times k\\leq 10^{6}\\)。 思路 定义 \\(dp[i][r]\\) 表示从区间 \\([0,r-1]\\) 选择 \\(i\\) 个不相交子数组，能够得到的最大得分。对于元素 \\(nums[r-1]\\)，我们有选或者不选两种情况，状态转移方程如下： $$ dp[i][r]=\\max(dp[i][r-1],\\max_{l=i-1}^{r-1}(dp[i-1][l]+(sum[r]-sum[l])\\times (-1)^{i+1}\\times (k-i+1))) $$ 初始时，对于所有 \\(0\\leq i\\leq n\\)，有 \\(dp[0][i]=0\\)，其他值初始化为负无穷。使用上述转移方程，时间复杂度为 \\(O(kn^{2})\\)。可以对其变形，将时间复杂度优化为 \\(O(kn)\\)，详细参见灵神的题解。小羊的题解使用的是另一种做法，似乎更简洁，但是看不太懂啊。 代码 123456789101112131415161718192021222324class Solution { public long maximumStrength(int[] nums, int k) { int n = nums.length; long[] sum = new long[n + 1]; for (int i = 0; i &lt; n; i++) { sum[i + 1] = sum[i] + nums[i]; } long[][] dp = new long[k + 1][n + 1]; for (int i = 1; i &lt;= k; i++) { Arrays.fill(dp[i], Long.MIN_VALUE); } for (int i = 0; i &lt; k; i++) { long max = Long.MIN_VALUE; int w = (2 * (i &amp; 1) - 1) * -1 * (k - i); for (int r = i; r &lt; n - (k - i - 1); r++) { max = Math.max(max, dp[i][r] - sum[r] * w); dp[i + 1][r + 1] = Math.max(dp[i + 1][r], sum[r + 1] * w + max); } } return dp[k][n]; }}","link":"/2024/03/10/%E7%AC%AC%20388%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 394 场力扣周赛","text":"使矩阵满足条件的最少操作次数 题目 输入 \\(m\\times n\\) 的矩阵 \\(grid\\)，输出需要的最少操作次数，使得每列的值相等，且相邻两列的值不相等。每次操作可以将任意单元格的值修改为任意非负整数。 数据范围：\\(1\\leq n,m\\leq 1000\\)，\\(0\\leq grid[i][j]\\leq 9\\)。 思路 首先，每列的值肯定是修改为 \\([0,9]\\) 之间更优，因为操作次数可能更少。我们可以从前往后枚举每列修改为什么值，可以发现存在重叠子问题。定义 \\(dp[i][j]\\) 表示将第 \\(i\\) 列修改为 \\(j\\)，使得 \\([0,i]\\) 列满足条件所需的最少操作次数。有状态转移方程 \\(dp[i][j]=\\min{(dp[i-1][k])}+cnt_{i,j}\\)，其中 \\(0\\leq k\\leq 9\\) 且 \\(k\\neq j\\)，\\(cnt_{i,j}\\) 表示将第 \\(i\\) 列修改为 \\(j\\) 所需的操作次数。时间复杂度为 \\(O(mn+nU^{2})\\)，空间复杂度为 \\(O(nU)\\)，其中 \\(U\\) 表示 \\(grid[i][j]\\) 的值域大小。灵神题解提到一个优化方式，状态转移只会从前面所有列操作的最优值或者次优值转移过来，利用这个特性可以降低时间和空间复杂度。 代码 1234567891011121314151617181920212223242526272829303132class Solution { public int minimumOperations(int[][] grid) { int m = grid.length, n = grid[0].length; int[][] cnt = new int[n][10]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { cnt[j][grid[i][j]]++; } } int[][] dp = new int[n + 1][10]; for (int i = 1; i &lt;= n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (k != j) { dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][k] + (m - cnt[i][j])); } } } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt; 10; i++) { ans = Math.min(ans, dp[n][i]); } return ans; }} 最短路径中的边 题目 输入整数 \\(n\\) 和长度为 \\(m\\) 的数组 \\(edges\\)，表示包含 \\(n\\) 个节点和 \\(m\\) 条边的无向带权图（无重边和自环）。输出长度为 \\(m\\) 的布尔数组 \\(ans\\)，如果从节点 \\(0\\) 到节点 \\(n-1\\) 的所有最短路中包含 \\(edges[i]\\)，则 \\(ans[i]=true\\)。 数据范围：\\(2\\leq n\\leq 5\\times 10^{4}\\)，\\(1\\leq m\\leq\\min{(5\\times 10^{4},\\frac{n(n-1)}{2})}\\)，\\(1\\leq w_{i}\\leq 10^{5}\\)。 思路 首先使用 Dijkstra 算法求出从节点 \\(0\\) 到所有其他节点的最短路，然后暴力的想法是以节点 \\(0\\) 为起点使用 DFS 回溯来遍历图，遍历的同时存储路径上的边，当到达节点 \\(n-1\\) 的路径长度等于最短路时，则将该路径上的边都置为 \\(true\\)。回溯理论上最坏情况下的时间复杂度为 \\(O(n\\times n!)\\)，但是可以通过力扣的测试，因为可以利用最短路的限制进行剪枝，至于能否构造出 Hack 回溯的测试用例，我不太清楚。 正确的解法是使用两次 Dijkstra 算法，分别求出从节点 \\(0\\) 到所有其他节点的最短路，和从节点 \\(n-1\\) 到所有其他节点的最短路。然后枚举每一条边，判断路径长度 \\(d_{0,u}+w_{u,v}+d_{v,n-1}\\) 或者 \\(d_{0,v}+w_{u,v}+d_{u,n-1}\\) 是否等于最短路，从而可以得出该边是否在某个最短路中。 另一种做法是只对起点使用一次 Dijkstra 算法，然后从终点反向 DFS，经过的边如果满足 \\(d_{0,v}+w_{u,v}=d_{0,u}\\)，则说明该边在某个最短路上。","link":"/2024/05/13/%E7%AC%AC%20394%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 350","text":"Sort 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，表示从 \\(1\\) 到 \\(n\\) 的排列。输出操作的次数和过程，使得排列有序。每次操作可以交换 \\(a_{i}\\) 和 \\(a_{j}\\)，其中 \\(1\\leq i&lt;j\\leq n\\)。 数据范围：\\(2\\leq n\\leq 2\\times 10^{5}\\)。 思路 如果 \\(a_{i}=i\\)，则说明 \\(a_{i}\\) 在正确的位置上。否则，\\(a_{i}\\) 应该移动到位置 \\(a_{i}\\) 上，即交换下标 \\(i\\) 和 \\(a_{i}\\) 的值。这样每次交换都至少使得一个数在正确的位置上，最多交换 \\(n-1\\) 次，时间复杂度为 \\(O(n)\\)。PS：太久没做题，竟然没有做出来。比赛时多此一举，使用的是下标数组 + 排序做的，其实也没问题，就是最后没有按照大小顺序输出。 代码 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt() - 1; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { while (a[i] != i) { ans.add(new int[]{Math.min(i, a[i]), Math.max(i, a[i])}); int t = a[a[i]]; a[a[i]] = a[i]; a[i] = t; } } io.println(ans.size()); for (var t : ans) { io.println((t[0] + 1) + &quot; &quot; + (t[1] + 1)); }}","link":"/2024/05/13/AtCoder%20Beginner%20Contest%20350/"},{"title":"第 397 场力扣周赛","text":"矩阵中的最大得分 题目 输入一个 \\(m\\times n\\) 的矩阵 \\(grid\\)，输出选择任意单元格作为起点，至少移动一次能够得到的最大得分。每次移动只能向正右方和正下方的单元格移动，不必相邻。假设从单元格 \\((x_{1},y_{1})\\) 移动到 \\((x_{2},y_{2})\\)，则本次移动的得分为 \\(grid[x_{2}][y_{2}]-grid[x_{1}][y_{1}]\\)。 数据范围：\\(2\\leq m,n\\leq 1000\\)，\\(4\\leq m\\times n\\leq 10^{5}\\)，\\(1\\leq grid[i][j]\\le 10^{5}\\)。 思路 比赛时想到计算过程存在重叠子问题，可以使用记忆化搜索。定义 \\(f[i][j]\\) 表示以 \\((i,j)\\) 为起点能够得到的最大得分，初始化 \\(f[i][j]\\) 为负无穷。当 \\(i&lt;m-1\\) 且 \\(j&lt;n-1\\) 时，状态转移方程为 \\(f[i][j]=\\max{(f[i+1][j]+grid[i+1][j]-grid[i][j],f[i][j+1])+grid[i][j+1]-grid[i][j]}\\)。也可以将记忆化搜索转化为自底向上的形式，或者定义 \\(f[i][j]\\) 表示以 \\((i,j)\\) 为终点能够得到的最大得分。 通过观察可以发现，对于某个移动路径，得分只和起点和终点有关，中间的值都被抵消了。也就是说，某个起点能够得到的最大得分，是其右下角的最大值减去起点的值，反之亦然。所以也可以定义 \\(f[i][j]\\) 表示 \\((i,j)\\) 右下角的最大值或者左上角的最小值，然后进行递推。 时间复杂度为 \\(O(mn)\\)，空间复杂度为 \\(O(mn)\\)。灵神题解有个空间复杂度为 \\(O(n)\\) 的做法，思路是维护每列的最小值。 代码 123456789101112131415161718192021222324252627282930313233class Solution { public int maxScore(List&lt;List&lt;Integer&gt;&gt; grid) { int m = grid.size(), n = grid.get(0).size(); int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) { Arrays.fill(dp[i], Integer.MIN_VALUE); } dfs(0, 0, grid, dp); int ans = Integer.MIN_VALUE; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { ans = Math.max(ans, dp[i][j]); } } return ans; } private int dfs(int x, int y, List&lt;List&lt;Integer&gt;&gt; grid, int[][] dp) { int m = grid.size(), n = grid.get(0).size(); if (dp[x][y] == Integer.MIN_VALUE) { if (x + 1 &lt; m) { int diff = grid.get(x + 1).get(y) - grid.get(x).get(y); dp[x][y] = Math.max(dp[x][y], diff + dfs(x + 1, y, grid, dp)); } if (y + 1 &lt; n) { int diff = grid.get(x).get(y + 1) - grid.get(x).get(y); dp[x][y] = Math.max(dp[x][y], diff + dfs(x, y + 1, grid, dp)); } } return Math.max(0, dp[x][y]); }} 找出分数最低的排列 题目 输入从 \\(0\\) 到 \\(n-1\\) 的一个排列 \\(nums\\)，输出从 \\(0\\) 到 \\(n-1\\) 的排列 \\(perm\\)，使得 \\(score(perm)=\\sum_{i=0}^{n-1}{|perm[i]-nums[perm[(i+1)\\bmod n|}\\) 的值最小。如果有多个满足条件的排列，则返回字典序最小的那个。 数据范围：\\(2\\leq n\\leq 14\\)。 思路 通过观察可以发现，对于一个给定的排列 \\(perm\\)，将其循环移动不会改变 \\(score(perm)\\) 的值。要使满足条件的 \\(perm\\) 字典序最小，那么必然有 \\(perm[0]=0\\)。暴力的想法是枚举所有排列，但是时间复杂度为 \\(n!\\times n\\)。由于枚举过程中，存在重复子问题，可以使用记忆化搜索来降低时间复杂度到 \\(O(2^{n}n^{2})\\)。定义 \\(f[mask][pre]\\) 表示已经选择集合 \\(mask\\) 中的数，上一个选择的数是 \\(pre\\)，剩余的数排列能够得到的最小分数。同理，定义 \\(g[mask][pre]\\) 表示下一个选择什么数能够使得分数最小，以及相同分数的排列字典序最小。可以看下灵神题解，不使用记忆化搜索，自底向上的解法也是非常经典的。 代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int[] findPermutation(int[] nums) { int n = nums.length; int[][] f = new int[1 &lt;&lt; n][n]; int[][] g = new int[1 &lt;&lt; n][n]; for (int i = 0; i &lt; (1 &lt;&lt; n) - 1; i++) { Arrays.fill(f[i], -1); } for (int i = 0; i &lt; n; i++) { f[(1 &lt;&lt; n) - 1][i] = Math.abs(i - nums[0]); } dfs(1, 0, nums, f, g); int[] ans = new int[n]; for (int i = 0, mask = 0, cur = 0; i &lt; n; i++) { ans[i] = cur; mask |= 1 &lt;&lt; cur; cur = g[mask][cur]; } return ans; } private int dfs(int mask, int pre, int[] nums, int[][] f, int[][] g) { int n = nums.length; if (mask == (1 &lt;&lt; n) - 1 || f[mask][pre] != -1) { return f[mask][pre]; } int res = Integer.MAX_VALUE; for (int i = 1; i &lt; n; i++) { if ((mask &gt;&gt; i &amp; 1) == 0) { int cur = dfs(mask | 1 &lt;&lt; i, i, nums, f, g) + Math.abs(pre - nums[i]); if (cur &lt; res) { res = cur; g[mask][pre] = i; } } } return f[mask][pre] = res; }}","link":"/2024/05/13/%E7%AC%AC%20397%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 130 场力扣夜喵双周赛（VP）","text":"正方形中的最多点数 题目 输入长度为 \\(n\\) 的二维数组 \\(points\\) 和字符串 \\(s\\)，\\(points[i]\\) 表示第 \\(i\\) 个点的坐标，\\(s[i]\\) 表示第 \\(i\\) 个点的标签。如果以 \\((0,0)\\) 为中心且边平行于坐标轴的正方形内（包括边上的点，且边长可以为 \\(0\\)），不包含标签相同的两个点，则该正方形是合法的。输出合法正方形可以包含的最多点数。其中 \\(points\\) 中的点互不相同，\\(s\\) 只包含小写英文字母。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(-10^{9}\\leq points[i][0],points[i][1]\\leq 10^{9}\\)。 思路 首先可以想到，正方形的边长越长，包含的点就越多，越可能不合法。具有单调性，可以使用二分求解。在二分的过程中，判断正方形是否合法，如果合法则更新答案。时间复杂度为 \\(O(n\\log{U})\\)，其中 \\(U=\\max_{i=0}^{n-1}(|x_{i}|,|y_{i}|)\\)。更好的做法是观察到，如果正方形包含某个点 \\((x,y)\\)，则正方形的边长 \\(len\\) 必须满足 \\(len\\geq 2\\times\\max(|x|,|y|)\\)。其中，\\(\\max(|x|,|y|)\\) 是点 \\((x,y)\\) 到点 \\((0,0)\\) 的切比雪夫距离。实际上，我们只需要维护每种标签点的最小切比雪夫距离 \\(min_{i}\\)，以及除此之外所有点的最小切比雪夫距离 \\(k\\)。因为，如果正方形包含某个标签 \\(i\\)，必定是包含具有该标签的切比雪夫距离最小的那个点，而这个点需要满足 \\(min_{i}&lt;k\\)。详情见代码，时间复杂度为 \\(O(n)\\)。优化思路参考灵神题解。 代码 1234567891011121314151617181920212223242526272829class Solution { public int maxPointsInsideSquare(int[][] points, String s) { int n = points.length; int[] min = new int[26]; Arrays.fill(min, Integer.MAX_VALUE); int k = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { int x = points[i][0]; int y = points[i][1]; int z = Math.max(Math.abs(x), Math.abs(y)); int c = s.charAt(i) - 'a'; if (z &lt; min[c]) { k = Math.min(k, min[c]); min[c] = z; } else { k = Math.min(k, z); } } int ans = 0; for (int x : min) { if (x &lt; k) { ans++; } } return ans; }} 分割字符频率相等的最少子字符串 题目 输入长度为 \\(n\\) 的字符串 \\(s\\)（只包含小写英文字母），输出 \\(s\\) 最少能被分割为多少个平衡子字符串。平衡字符串就是字符串中不同字符出现频次都相同的字符串。 数据范围：\\(1\\leq n\\leq 1000\\)。 思路 定义 \\(dp[i+1]\\) 表示字符串 \\([0,i]\\) 最少能被分割的平衡子字符串数目，则转移方程为 \\(dp[i+1]=\\min(dp[j]+1)\\)，其中 \\(0\\leq j\\leq i\\) 且字符串 \\([j,i]\\) 必须是平衡字符串。 代码 12345678910111213141516171819class Solution { public int minimumSubstringsInPartition(String s) { int n = s.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = i + 1; int k = 0, max = 0; int[] cnt = new int[26]; for (int j = i; j &gt;= 0; j--) { k += cnt[s.charAt(j) - 'a'] == 0 ? 1 : 0; max = Math.max(max, ++cnt[s.charAt(j) - 'a']); if (i - j + 1 == k * max) { dp[i + 1] = Math.min(dp[i + 1], dp[j] + 1); } } } return dp[n]; }} 大数组元素的乘积 不会。","link":"/2024/05/14/%E7%AC%AC%20130%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B%EF%BC%88VP%EF%BC%89/"},{"title":"南京大学 计算机系统基础 课程实验 2022","text":"实验网站，2020 南京大学计算机系统基础习题课。 PA0 - 世界诞生的前夜: 开发环境配置 使用 vimtutor 命令启动 vim 教程。 教程：GNU/Linux，Makefile，GDB，tmux，Git，Linux C编程一站式学习。 课程：The Missing Semester of Your CS Education。 其他：Visualizing Git Concepts with D3。 使用 apt-get install 经常遇到 “The following packages have unmet dependencies” 错误，原因是因为依赖的包和现有的包版本冲突，之前我都是手动 apt-get remove，但是经常遇到该问题。STFW 之后，这里推荐的 aptitude 工具比较方便，发生冲突时会询问是否降级。（apt-get，aptitude，apt 的区别，是否有必要使用 aptitude？讨论。） 使用 make 经常遇到 “No such file or directory” 之类缺失头文件的错误，目前是遇到两种情况。一种是缺失对应的包，直接 apt-get install 即可解决；另一种是有对应的包，但是当前项目中 .mk 文件配置的程序名称和现有名称不一致（例如，配置的是 llvm-config，而现有的是 llvm-config-11），修改 .mk 文件即可解决。 PA1 - 开天辟地的篇章: 最简单的计算机 手册：riscv-isa-manual，riscv-elf-psabi-doc，etc，NEMU ISA API。 可以在目标命令之前添加 time 命令，从而计算目标命令的执行时间。使用 make 命令的 -j 选项，可以启用多线程编译。make -j4 表示创建 4 个线程并行编译，具体创建多少个线程，可以根据 lscpu 命令查询得到的系统中的 CPU 数量来确定。使用 ccache 工具可以缓存目标文件，从而加速执行 make clean 之后，再次执行 make 的速度。 如何实现宏 IFDEF 和 MUXDEF。其中 IFDEF 表示，如果定义了 CONFIG_DEVICE 宏，才会调用 init_device() 函数。而 MUXDEF 表示，如果定义了 CONFIG_TRACE 宏，则预处理结果为 ON，否则预处理结果为 OFF。 12IFDEF(CONFIG_DEVICE, init_device());MUXDEF(CONFIG_TRACE, &quot;ON&quot;, &quot;OFF&quot;) 在 nemu/include/macro.h 文件中有如下定义： 1234567891011121314151617181920212223// macro concatenation#define concat_temp(x, y) x ## y#define concat(x, y) concat_temp(x, y)// macro testing// See https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro#define CHOOSE2nd(a, b, ...) b#define MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)// define placeholders for some property#define __P_DEF_0 X,#define __P_DEF_1 X,// define some selection functions based on the properties of BOOLEAN macro#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)// simplification for conditional compilation#define __IGNORE(...)#define __KEEP(...) __VA_ARGS__// keep the code if a boolean macro is defined#define IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__) 我们可以使用如下代码进行测试，同时给出宏展开的步骤。需要注意的是，只有当 CONFIG_DEVICE 被定义为 0 或 1 时，才会执行函数调用。 123456789101112#include &lt;stdio.h&gt;#define CONFIG_DEVICE 1void init_device() { printf(&quot;Hello, Linux World!\\n&quot;);}int main(void) { IFDEF(CONFIG_DEVICE, init_device()); return 0;} 12345678910IFDEF(CONFIG_DEVICE, init_device());IFDEF(1, init_device());MUXDEF(1, __KEEP, __IGNORE)(init_device());MUX_MACRO_PROPERTY(__P_DEF_, 1, __KEEP, __IGNORE)(init_device());MUX_WITH_COMMA(concat(__P_DEF_, 1), __KEEP, __IGNORE)(init_device());MUX_WITH_COMMA(__P_DEF_1, __KEEP, __IGNORE)(init_device());MUX_WITH_COMMA(X,, __KEEP, __IGNORE)(init_device());CHOOSE2nd(X, __KEEP, __IGNORE)(init_device());__KEEP(init_device());init_device();","link":"/2024/08/12/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%20%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C%202022/"},{"title":"南京大学 操作系统 课程 2022","text":"课程网站，课程视频，OSTEP，CSAPP。 Part 1 资料：ENIAC Simulator and Related Material。 The special problem we tried to get at with these lectures was to maintain the interest of the very enthusiastic and rather smart students coming out of the high schools and into Caltech. They have heard a lot about how interesting and exciting physics is—the theory of relativity, quantum mechanics, and other modern ideas. By the end of two years of our previous course, many would be very discouraged because there were really very few grand, new, modern ideas presented to them. They were made to study inclined planes, electrostatics, and so forth, and after two years it was quite stultifying. The problem was whether or not we could make a course which would save the more advanced and excited student by maintaining his enthusiasm. (The Feynman Lectures on Physics) 思考 Why - What - How，为什么 - 是什么 - 怎么做。 Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP) 关键问题：操作系统如何发展成现在这样的？（硬件、软件） 工具：gdb，strace。（tldr，xxd） 资料：Vim help files，logisim.c，seven-seg.py，minimal.S。 以下代码是 logisim.c 的简化版，实现数字逻辑电路的模拟器。我们可以在 vim 中使用 !gcc % &amp;&amp; ./a.out 命令，运行如下代码。代码中使用 X macro 技巧，我们可以使用 !gcc -E % 命令输出宏展开之后的代码。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define REGS_FOREACH(_) _(X) _(Y)#define RUN_LOGIC X1 = !X &amp;&amp; Y; \\ Y1 = !X &amp;&amp; !Y;#define DEFINE(X) static int X, X##1;#define UPDATE(X) X = X##1;#define PRINT(X) printf(#X &quot; = %d; &quot;, X);int main() { REGS_FOREACH(DEFINE); while (1) { // clock RUN_LOGIC; REGS_FOREACH(PRINT); REGS_FOREACH(UPDATE); putchar('\\n'); sleep(1); }} 123456789int main() { static int X, X1; static int Y, Y1;; while (1) { X1 = !X &amp;&amp; Y; Y1 = !X &amp;&amp; !Y;; printf(&quot;X&quot; &quot; = %d; &quot;, X); printf(&quot;Y&quot; &quot; = %d; &quot;, Y);; X = X1; Y = Y1;; putchar('\\n'); sleep(1); } } 程序 seven-seg.py 使用 ANSI escape code 来控制字符的颜色。\\033[37m 和 \\033[31m 分别表示，将当前和之后的字符设置为白色、红色，而 \\033[0m 表示重置设置。\\033[2J 表示清空屏幕同时将光标移至左上角，\\033[1;1f 表示将光标移至第 1 行和第 1 列（应该是这样，HVP 和 CUP 的区别没看懂）。最后，我们可以使用管道，将 logisim.c 的输出作为 seven-seg.py 的输入，从而模拟数码管的显示（执行 ./a.out | python3 seven-seg.py 命令）。 彩蛋：telnet towel.blinkenlights.nl（命令行电影），ssh sshtron.zachlatta.com（网络游戏）。（使用 ANSI escape code 实现） 关键概念：程序是状态机。可以从以下两个视角，抽象的理解。 源代码视角：状态 = 栈帧列表（每个栈帧都有 PC）+ 全局变量。 二进制视角：状态 = 寄存器 + 内存，程序 = 计算指令 + syscall 指令。 问题：如何构造一个最小的 “Hello, World” 程序？（RTFM，man syscall） 1234567891011121314151617#include &lt;sys/syscall.h&gt;.globl _start_start: movq $SYS_write, %rax // write( movq $1, %rdi // fd=1, movq $st, %rsi // buf=st, movq $(ed - st), %rdx // count=ed-st syscall // ); movq $SYS_exit, %rax // exit( movq $1, %rdi // status=1 syscall // );st: .ascii &quot;\\033[01;31mHello, OS World\\033[0m\\n&quot;ed:","link":"/2024/08/14/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E8%AF%BE%E7%A8%8B%202022/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"CMU 15-445","slug":"课程/CMU-15-445","link":"/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OceanBase","slug":"数据库/OceanBase","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"},{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"书籍","slug":"书籍","link":"/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"DDIA","slug":"书籍/DDIA","link":"/categories/%E4%B9%A6%E7%B1%8D/DDIA/"},{"name":"模板","slug":"基础/模板","link":"/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"},{"name":"MIT 6.824","slug":"课程/MIT-6-824","link":"/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"},{"name":"实验","slug":"实验","link":"/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"系统","slug":"系统","link":"/categories/%E7%B3%BB%E7%BB%9F/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}