{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 893 (Div. 2)","text":"Buttons优先选择公共按钮，当且仅当先手的按钮数量大于后手的按钮数量时，先手者胜。 12345public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (a + c % 2 &gt; b) io.println(&quot;First&quot;); else io.println(&quot;Second&quot;);} The Walkway模拟题，特别需要注意头尾的边界处理，加上哨兵真的会方便很多。可以假设位置 \\(1-d\\) 和位置 \\(n+1\\) 有卖家，这样就不用特判，可以直接处理！！！ 123456789101112131415161718192021222324252627public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] s = new int[m + 2]; for (int i = 1; i &lt;= m; i++) { s[i] = io.nextInt(); } s[0] = 1 - d; s[m + 1] = n + 1; int ans = m - 1, delta = Integer.MAX_VALUE, cnt = 0; for (int i = 1; i &lt;= m; i++) { int A = (s[i] - s[i - 1] - 1) / d; int B = (s[i + 1] - s[i] - 1) / d; int C = (s[i + 1] - s[i - 1] - 1) / d; int D = C - A - B; if (D &lt; delta) { delta = D; cnt = 1; } else if (D == delta) { cnt++; } ans += A; } ans += (s[m + 1] - s[m] - 1) / d + delta - 1; io.println(ans + &quot; &quot; + cnt);} Yet Another Permutation Problem构造题，首先需要发现什么公约数不可能出现，很明显不可能得到 \\(d_{i}=\\gcd (a_{i},a_{(i\\bmod n)+1})&gt; \\lfloor \\frac{n}{2}\\rfloor\\)。然后考虑所有小于等于 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 的数是否能被包含，可以发现对于每个 \\(a_{i}=x\\leq \\lfloor \\frac{n}{2}\\rfloor\\) 总有 \\(a_{(i\\bmod n)+1}=2\\cdot x\\leq n\\)，所以我们可以枚举所有奇数乘以二的幂来构造答案。 12345678910111213public static void solve() { int n = io.nextInt(), idx = 0; int[] ans = new int[n]; for (int i = 1; i &lt;= n; i += 2) { for (int j = i; j &lt;= n; j *= 2) { ans[idx++] = j; } } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} Trees and Segments难以描述，看代码吧，调试半天。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[][] prefix = new int[n + 1][k + 1]; int[][] suffix = new int[n + 1][k + 1]; // 枚举可以在 k 次操作内变为全 0 的子数组，并将其长度记录到所属的前后缀中 for (int i = 0; i &lt; n; i++) { int cnt1 = 0; for (int j = i; j &lt; n; j++) { cnt1 += s[j] - '0'; if (cnt1 &gt; k) break; prefix[j + 1][cnt1] = Math.max(prefix[j + 1][cnt1], j - i + 1); suffix[i][cnt1] = Math.max(suffix[i][cnt1], j - i + 1); } } // 在前缀 [0, i] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= k; j++) { prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i][j]); if (j &gt; 0) prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i + 1][j - 1]); } } // 在后缀 [i, n - 1] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= k; j++) { suffix[i][j] = Math.max(suffix[i][j], suffix[i + 1][j]); if (j &gt; 0) suffix[i][j] = Math.max(suffix[i][j], suffix[i][j - 1]); } } // 枚举连续 1 的起点和终点，并记录该连续 1 的长度对应的连续 0 的最长长度（注意包含长度为 0 的情况） int[] max0by1 = new int[n + 1]; Arrays.fill(max0by1, -1); max0by1[0] = suffix[0][k]; for (int i = 0; i &lt; n; i++) { int cnt0 = 0; for (int j = i; j &lt; n; j++) { cnt0 += (s[j] - '0') ^ 1; if (cnt0 &gt; k) break; max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], prefix[i][k - cnt0]); max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], suffix[j + 1][k - cnt0]); } } // 计算答案 int[] ans = new int[n + 1]; for (int a = 1; a &lt;= n; a++) { for (int i = 0; i &lt;= n; i++) { if (max0by1[i] == -1) continue; ans[a] = Math.max(ans[a], i + max0by1[i] * a); } } for (int i = 1; i &lt;= n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}","link":"/2023/08/16/Codeforces%20Round%20893%20(Div.%202)/"},{"title":"第 111 场力扣夜喵双周赛","text":"统计和小于目标的下标对数目使用排序 + 双指针优化。如果 \\(nums[lo]+nums[hi]&lt;target\\)，那么 \\([lo+1,hi]\\) 范围内的数都能与 \\(nums[lo]\\) 组成对，\\(lo\\) 加一；反之，\\([lo,hi-1]\\) 范围内的数都不能与 \\(nums[hi]\\) 组成对，\\(hi\\) 减一。 Java 123456789101112131415class Solution { public int countPairs(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int lo = 0, hi = nums.size() - 1, ans = 0; while (lo &lt; hi) { if (nums.get(lo) + nums.get(hi) &lt; target) { ans += hi - lo; lo++; } else { hi--; } } return ans; }} C++ 12345678910111213141516class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans = 0; for (int i = 0, j = n - 1; i &lt; j; ) { if (nums[i] + nums[j] &lt; target) { ans += j - i; i++; } else { j--; } } return ans; }}; 循环增长使字符串子序列等于另一个字符串贪心取就行。 Java 1234567891011class Solution { public boolean canMakeSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1.charAt(i) == str2.charAt(j) || (str1.charAt(i) + 1 - 'a') % 26 == str2.charAt(j) - 'a') { j++; } } return j == n; }} C++ 123456789101112class Solution {public: bool canMakeSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1[i] == str2[j] || (str1[i] + 1 - 'a') % 26 == str2[j] - 'a') { j++; } } return j == n; }}; 将三个组排序要将 \\(nums\\) 变为美丽数组，就要将 \\(nums\\) 变为非递减的形式，所以问题就变为求最长非递减子序列。 Java 动态规划： 12345678910111213141516class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), ans = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (nums.get(i) &gt;= nums.get(j)) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } return n - ans; }} 贪心 + 二分： 1234567891011121314151617class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), maxLen = 0; int[] aux = new int[n]; for (int x : nums) { int lo = 0, hi = maxLen - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (aux[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } aux[lo] = x; if (lo == maxLen) maxLen++; } return n - maxLen; }} 状态机 DP： 有点妙啊，\\(dp[i][j]\\) 表示将子数组 \\([0,i]\\) 变为以 \\([1,j]\\) 为结尾的美丽数组所需的最小修改次数，然后可以空间优化。 1234567891011class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int[] dp = {Integer.MAX_VALUE, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = Math.min(dp[i - 1], dp[i] + (x == i ? 0 : 1)); } } return dp[3]; }} C++ 123456789101112class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { int dp[4] = {INT_MAX, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = min(dp[i - 1], dp[i] + (x != i)); } } return dp[3]; }}; 范围中美丽整数的数目经典数位 DP 没什么好说的，主要是记忆化取模，边乘边取模。 Java 1234567891011121314151617181920212223242526class Solution { public int numberOfBeautifulIntegers(int low, int high, int k) { return f(0, 10, 0, true, false, high + &quot;&quot;, k, new Integer[10][20][k]) - f(0, 10, 0, true, false, low - 1 + &quot;&quot;, k, new Integer[10][20][k]); } private int f(int i, int diff, int mod, boolean isLimit, boolean isNum, String s, int k, Integer[][][] dp) { if (i == s.length()) { return isNum &amp;&amp; diff == 10 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff][mod] != null) { return dp[i][diff][mod]; } int res = 0; if (!isNum) res += f(i + 1, diff, mod, false, false, s, k, dp); int lo = isNum ? 0 : 1, hi = isLimit ? s.charAt(i) - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += f(i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true, s, k, dp); } if (!isLimit &amp;&amp; isNum) { dp[i][diff][mod] = res; } return res; }} C++ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int numberOfBeautifulIntegers(int low, int high, int k) { string s; const int BASE = 10; int dp[10][20][k]; auto f = [&amp;](auto self, int i, int diff, int mod, bool isLimit, bool isNum) { if (i == s.size()) { return isNum &amp;&amp; diff == 0 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff + BASE][mod] != -1) { return dp[i][diff + BASE][mod]; } int res = 0; if (!isNum) res += self(self, i + 1, diff, mod, false, false); int lo = isNum ? 0 : 1, hi = isLimit ? s[i] - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += self(self, i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true); } if (!isLimit &amp;&amp; isNum) dp[i][diff + BASE][mod] = res; return res; }; auto calc = [&amp;](int x) { s = to_string(x); memset(dp, -1, sizeof(dp)); return f(f, 0, 0, 0, true, false); }; return calc(high) - calc(low - 1); }};","link":"/2023/08/21/%E7%AC%AC%20111%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 359 场力扣周赛","text":"判别首字母缩略词Java 123456789101112class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { int n = words.size(), m = s.length(); if (n != m) return false; for (int i = 0; i &lt; n; i++) { if (words.get(i).charAt(0) != s.charAt(i)) { return false; } } return true; }} C++ 12345678910111213class Solution {public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) { int m = words.size(), n = s.size(); if (m != n) return false; for (int i = 0; i &lt; n; i++) { if (words[i][0] != s[i]) { return false; } } return true; }}; k-avoiding 数组的最小总和贪心。 Java 123456class Solution { public int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }} C++ 1234567class Solution {public: int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }}; 销售利润最大化不从动态规划的角度思考，我首先用的是对左端点排序。如果用动态规划，那么根据转移方程就会对右端点排序，处理方式也比对左端点排序简单一些。还可以不排序做，使用桶存储相同 \\(end\\) 的 \\(offer\\)，分别处理每个桶。 Java 1234567891011121314class Solution { public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) { Collections.sort(offers, (a, b) -&gt; a.get(1) - b.get(1)); offers.add(List.of(n - 1, n - 1, 0)); int m = offers.size(), i = 0; int[] leftMax = new int[n + 1]; for (var offer : offers) { int s = offer.get(0), e = offer.get(1), g = offer.get(2); for (; i &lt;= e; i++) leftMax[i + 1] = leftMax[i]; leftMax[e + 1] = Math.max(leftMax[e + 1], leftMax[s] + g); } return leftMax[n]; }} C++ 1234567891011121314151617class Solution {public: int maximizeTheProfit(int n, vector&lt;vector&lt;int&gt;&gt;&amp; offers) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; groups(n); for (auto &amp;offer : offers) { groups[offer[1]].emplace_back(offer[0], offer[2]); } vector&lt;int&gt; f(n + 1); for (int end = 0; end &lt; n; end++) { f[end + 1] = f[end]; for (auto &amp;[start, gold] : groups[end]) { f[end + 1] = max(f[end + 1], f[start] + gold); } } return f[n]; }}; 找出最长等值子数组Java 滑动窗口： 12345678910111213141516171819class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int lo = 0, hi = 0, ans = 0; while (hi &lt; n) { map.merge(nums.get(hi++), 1, Integer::sum); if (hi - lo - map.get(nums.get(lo)) &gt; k) { map.merge(nums.get(lo++), -1, Integer::sum); } ans = Math.max(ans, map.get(nums.get(lo))); } while (lo + 1 &lt; n) { map.merge(nums.get(lo++), -1, Integer::sum); ans = Math.max(ans, map.get(nums.get(lo))); } return ans; }} 滑动窗口（优化）： 优化一：观察到 \\(1\\leq nums[i]\\leq nums.lenth\\)，所以可以用数组模拟哈希表。 优化二：滑动窗口直接枚举右端点，这样可以枚举到所有情况。但是如何保证删除的元素数量小于等于 \\(k\\) 呢？当左端点的值 \\(nums[i]\\) 不能构成等值数组，则将左端点右移。为什么这样可以保证？当 \\(nums[i]\\neq nums[j]\\) 时，移动左端点不影响答案；当 \\(nums[i]=nums[j]\\) 时，移动左端点可以保证删除的元素数量小于等于 \\(k\\)。 1234567891011121314class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; int[] map = new int[n + 1]; for (int i = 0, j = 0; j &lt; n; j++) { map[nums.get(j)]++; if (j - i + 1 - map[nums.get(i)] &gt; k) { map[nums.get(i++)]--; } ans = Math.max(ans, map[nums.get(j)]); } return ans; }} C++ 分组 + 双指针： 123456789101112131415161718192021class Solution {public: int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); for (int i = 0; i &lt; n; i++) { pos[nums[i]].push_back(i); } for (auto &amp;ps : pos) { int left = 0; for (int right = 0; right &lt; ps.size(); right++) { while (ps[right] - ps[left] - right + left &gt; k) { left++; } ans = max(ans, right - left + 1); } } return ans; }};","link":"/2023/08/21/%E7%AC%AC%20359%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 315","text":"tcdr模拟。 Java 123456789public static void solve() { String s = io.next(); var sb = new StringBuilder(); Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); for (char c : s.toCharArray()) { if (!set.contains(c)) sb.append(c); } io.println(sb.toString());} C++ 12345678void solve() { string s; cin &gt;&gt; s; s.erase(remove_if(s.begin(), s.end(), [&amp;](char c) { return set{'a', 'e', 'i', 'o', 'u'}.count(c); }), s.end()); cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;} The Middle Day模拟。 Java 1234567891011121314151617public static void solve() { int m = io.nextInt(); int[] d = new int[m]; int tot = 0; for (int i = 0; i &lt; m; i++) { d[i] = io.nextInt(); tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { io.println(i + 1 + &quot; &quot; + mid); return; } mid -= d[i]; }} C++ 123456789101112131415161718void solve() { int m; cin &gt;&gt; m; int tot = 0; vector&lt;int&gt; d(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; d[i]; tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot;\\n&quot;; return; } mid -= d[i]; }} Flavors模拟。 Java 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] buckets = new List[n + 1]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int f = io.nextInt(), s = io.nextInt(); buckets[f].add(s); } int ans = 0, max1 = 0, max2 = 0; for (var bucket : buckets) { if (bucket.isEmpty()) continue; Collections.sort(bucket, (a, b) -&gt; b - a); int a = bucket.get(0); if (a &gt; max1) { max2 = max1; max1 = a; } else if (a &gt; max2) { max2 = a; } if (bucket.size() &lt; 2) continue; int b = bucket.get(1); ans = Math.max(ans, a + b / 2); } ans = Math.max(ans, max1 + max2); io.println(ans);} C++ 12345678910111213141516171819202122232425void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; buckets(n + 1); for (int i = 0; i &lt; n; i++) { int f, s; cin &gt;&gt; f &gt;&gt; s; buckets[f].push_back(s); } int ans = 0, max1 = 0, max2 = 0; for (auto &amp;bucket : buckets) { if (bucket.empty()) continue; nth_element(bucket.begin(), bucket.begin() + 1, bucket.end(), greater()); if (bucket[0] &gt; max1) { max2 = max1; max1 = bucket[0]; } else if (bucket[0] &gt; max2) { max2 = bucket[0]; } if (bucket.size() &lt; 2) continue; ans = max(ans, bucket[0] + bucket[1] / 2); } ans = max(ans, max1 + max2); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} Magical Cookies算是暴力吧。首先最多执行 \\(m+n\\) 次操作，然后每次操作将所有行和列遍历，判断是否可以标记。如果不优化，那么遍历的复杂度是 \\(O(mn)\\)，总时间复杂度就是 \\(O(mn(m+n))\\)，会超时。可以维护剩余的行数 \\(r\\) 和剩余的列数 \\(c\\)，那么如果某行的某颜色的数量等于列数，那么就说明可以标记该行，列同理。这样我们就可以只维护行列中的每个颜色有多少饼干，而不需要维护位置关系，从而将遍历的时间复杂度降为 \\(O(26(m+n))\\)。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] arr = new String[m]; for (int i = 0; i &lt; m; i++) { arr[i] = io.next(); } int[][] row = new int[m][26]; int[][] col = new int[n][26]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { row[i][arr[i].charAt(j) - 'a']++; col[j][arr[i].charAt(j) - 'a']++; } } int r = m, c = n; boolean[] vr = new boolean[m]; boolean[] vc = new boolean[n]; for (int k = 0; k &lt; m + n; k++) { List&lt;int[]&gt; mr = new ArrayList&lt;&gt;(); List&lt;int[]&gt; mc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { if (vr[i]) continue; for (int j = 0; j &lt; 26; j++) { if (row[i][j] == c &amp;&amp; c &gt;= 2) { mr.add(new int[]{i, j}); } } } for (int i = 0; i &lt; n; i++) { if (vc[i]) continue; for (int j = 0; j &lt; 26; j++) { if (col[i][j] == r &amp;&amp; r &gt;= 2) { mc.add(new int[]{i, j}); } } } for (int[] p : mr) { r--; vr[p[0]] = true; for (int i = 0; i &lt; n; i++) { col[i][p[1]]--; } } for (int[] p : mc) { c--; vc[p[0]] = true; for (int i = 0; i &lt; m; i++) { row[i][p[1]]--; } } } io.println(r * c);} Prerequisites首先找到第 \\(1\\) 本书的所有前置书，然后对所有书进行拓扑排序，将之前找到的前置书按拓扑排序的倒序打印即可。或者直接 DFS。。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(); int[] indegree = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); for (int j = 0; j &lt; c; j++) { int q = io.nextInt() - 1; g[i].add(q); indegree[q]++; } } boolean[] mark = new boolean[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty()) { int x = q.poll(); for (int y : g[x]) { if (mark[y]) continue; mark[y] = true; q.offer(y); } } for (int i = 0; i &lt; n; i++) { if (indegree[i] == 0) { q.offer(i); } } Deque&lt;Integer&gt; ans = new ArrayDeque&lt;&gt;(); while (!q.isEmpty()) { int x = q.poll(); if (mark[x]) ans.push(x); for (int y : g[x]) { if (--indegree[y] == 0) { q.offer(y); } } } while (!ans.isEmpty()) io.print(ans.pop() + 1 + &quot; &quot;); io.println();} C++ 123456789101112131415161718192021222324252627282930313233void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; j++) { int q; cin &gt;&gt; q; q--; adj[i].push_back(q); } } vector&lt;bool&gt; mark(n); auto dfs = [&amp;](auto self, int x) { if (mark[x]) { return; } for (auto y : adj[x]) { self(self, y); } mark[x] = true; if (x != 0) { std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; } }; dfs(dfs, 0); cout &lt;&lt; &quot;\\n&quot;;} Shortcuts动态规划，调试好久。。如果所有点都选，那么答案最多为 \\(10^{9}\\)，所以可以确定不选的点不会超过 \\(30\\)。然后定义状态 \\(dp[i][j]\\) 表示到达第 \\(i\\) 个点并且总共跳过 \\(j\\) 个点的最短距离。如何想到定义该状态呢，因为答案和具体选哪几个点无关，只和最短距离以及跳过多少个点有关，大概是这样吧。 Java 1234567891011121314151617181920212223242526272829public static void solve() { int c = 30; int n = io.nextInt(); int[] x = new int[n]; int[] y = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } double[][] dp = new double[n][c]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][0] = 0; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; c; j++) { for (int k = i + 1; k &lt; n &amp;&amp; k - i - 1 + j &lt; c; k++) { int nj = j + k - i - 1; dp[k][nj] = Math.min(dp[k][nj], dp[i][j] + Math.sqrt((x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]))); } } } double ans = Integer.MAX_VALUE; for (int i = 0; i &lt; c; i++) { ans = Math.min(ans, dp[n - 1][i] + (i == 0 ? 0 : 1 &lt;&lt; (i - 1))); } io.println(ans);}","link":"/2023/08/21/AtCoder%20Beginner%20Contest%20315/"},{"title":"Educational Codeforces Round 153 (Rated for Div. 2)","text":"Not a Substring构造题。如果 \\(s\\) 中存在连续相同的括号，则可以构造交替出现的括号；如果 \\(s\\) 是交替出现的括号，那么就构造连续的括号，此时包含的唯一交替的括号就是 \\(()\\)，特判一下即可。 123456789101112131415161718public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = false; for (int i = 1; i &lt; n; i++) { if (s[i] == s[i - 1]) { ok = true; break; } } if (new String(s).equals(&quot;()&quot;)) { io.println(&quot;NO&quot;); return; } io.println(&quot;YES&quot;); if (ok) io.println(&quot;()&quot;.repeat(n)); else io.println(&quot;(&quot;.repeat(n) + &quot;)&quot;.repeat(n));} Fancy Coins数学题。假设最终使用 \\(x\\) 枚价值为 \\(1\\) 的硬币，\\(y\\) 枚价值为 \\(k\\) 的硬币。如果 \\(x\\) 大于等于 \\(k\\)，我们总是将其合成为价值为 \\(k\\) 的硬币，所以可以保证 \\(x\\) 小于 \\(k\\)。显然 \\(x=m\\bmod k\\)，\\(y=\\frac{m}{k}\\)。那么需要补充多少花色硬币呢？易知，需要补充 \\(\\max(0,x-a_{1})\\) 个价值为 \\(1\\) 的花色硬币，和 \\(\\max (0,y-a_{k}-\\max (0,\\frac{a_{1}-x}{k}))\\) 个价值为 \\(k\\) 的花色硬币。 12345public static void solve() { int m = io.nextInt(), k = io.nextInt(), a1 = io.nextInt(), ak = io.nextInt(); int ans = Math.max(0, m % k - a1) + Math.max(0, m / k - ak - Math.max(0, a1 - m % k) / k); io.println(ans);} Game on Permutation一开始的想法是，如果某个元素左边恰好只有一个小于它的元素，那么该位置就是胜位。然而暴力找每个位置左边比它小的元素个数的时间复杂度是 \\(O(n^{2})\\)，赛时就不知道怎么优化。其实我们可以知道，给定一个序列，胜位是固定不变的。所以可以考虑维护左边的最小元素（表示下一步是否可以下棋）和最小的胜位（如果大于最小胜位，则当前位必输），然后就可以很方便的模拟出答案。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] p = new int[n]; int ans = 0, min = n + 1, minWin = n + 1; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); if (min &lt; p[i] &amp;&amp; p[i] &lt;= minWin) { ans++; minWin = Math.min(minWin, p[i]); } min = Math.min(min, p[i]); } io.println(ans);} Balanced String不会不会。。o(╥﹏╥)o","link":"/2023/08/21/Educational%20Codeforces%20Round%20153%20(Rated%20for%20Div.%202)/"},{"title":"Project #0 - C++ Primer","text":"项目准备项目地址：Project #0 - C++ Primer。 准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。 Task #1 - Copy-On-Write Trie实现Get 函数 没有什么特别需要注意的，实现比较简单。 实现逻辑： 如果 root_ == nullptr 为真，则返回 nullptr。 沿着 Trie 树遍历，如果节点不存在，则返回 nullptr。 如果目标节点不是 TrieNodeWithValue 类型，则返回 nullptr。 否则，返回目标节点的值。 Put 函数 一开始比较疑惑的点是，智能指针存储的都是 const 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？ 其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 const 指针就能做到。 本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 key.empty() 和 root_ == nullptr。 实现逻辑： 如果 key.empty() 为真： 如果 root_ == nullptr 为真，则使用 value​ 构造 Trie 树并返回。 否则，使用 root_-&gt;children_ 和 value 构造 Trie 树并返回。 根据 root_ == nullptr 条件初始化新 Trie 树的 root。 沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）： 如果克隆完所有字符，则返回新 Trie 树。 否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。 Remove 函数 需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意： ① 节点不包含值需要转换为 TrieNode 类型，也就是说拷贝的时候需要调用 TrieNode::Clone()。 ② 如果节点满足 children_.empty() &amp;&amp; !is_value_node_ 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 erase 父节点中 map 的 key。 实现逻辑： 如果 root_ == nullptr 为真，则返回 *this。 如果 key.empty() 为真，则调用 root_-&gt;TrieNode::Clone() 克隆，并返回新 Trie 树。 沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 *this。 将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。 否则，依次克隆栈中的元素，然后返回新 Trie 树。 补充C++ 因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。 ① 使用 at 访问 const map 对象，因为 [] 运算符可能会自动添加键值。 123const map&lt;int,int&gt; m;cout &lt;&lt; m[1024]; // 错误，No viable overloaded operator[] for type 'const map&lt;int, int&gt;'cout &lt;&lt; m.at(1024); // 正确 ② = 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。 12345map&lt;int,int&gt; m;m[1024] = 1024;auto n = m;n[1024] = 2048;cout &lt;&lt; m[1024]; // 输出：1024 ③ 在 Java 中只要是对象就可以和 null 比较，而 C++ 中只有指针可以和 nullptr 比较。 GDB ① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击此处产生该问题的原因，以及相应的解决方案告诉我下载 libstdc++6-dbgsym，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。 ② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以在此查看该课程提供的 GDB 教程。以及可以阅读：GDB Tutorial: Finding Segmentation Faults。 ③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。 CMake 项目推荐使用 clang-14 作为编译器，解决方案在此。 Task #2 - Concurrent Key-Value Store实现因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 std::mutex 即可。读操作在获取 root_ 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 write_lock_ 上锁。Put 时记得使用 std::move()，因为值可能是不可复制的。 补充① 关于线程和锁的知识，推荐阅读 CS110 Lecture 10: Threads and Mutexes。 ② C++ 有个复制省略（Copy elision）的优化。 ③ 关于 C++ 模板的 FAQ、template 关键字的讨论 和 Dependent names 的定义。（好复杂啊）之所以查这些内容，是因为 CLion 给我生成了不同的表达式： 123auto value = root.template Get&lt;T&gt;(key);root = root.template Put(key, std::move(value));root = root.Remove(key); 以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 &lt;&gt; 来指定类型。然后何时使用 template 没怎么弄明白。 Task #3 - Debugging实现挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 Put 时打断点调试的，应该差不多吧。 补充无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：/usr/bin/ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案在此。 Task #4 - SQL String Functions实现文件的路径：./src/include/execution/expressions 和 ./src/planner/plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 std::tolower 或许有一些注意事项。注册函数时，需要保证参数是有效的，即参数只有一个并且是 VARCHAR 类型。 测试结果就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord 讨论。 修改之后通过！ 项目小结任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 key 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。","link":"/2023/08/26/Project%200%20-%20C++%20Primer/"},{"title":"Codeforces Round 894 (Div. 3)","text":"Gift Carpet从左到右每列贪心取即可。 12345678910111213141516171819202122public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] g = new String[m]; for (int i = 0; i &lt; m; i++) { g[i] = io.next(); } int idx = 0; String s = &quot;vika&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (g[j].charAt(i) == s.charAt(idx)) { idx++; break; } } if (idx == s.length()) { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Sequence Game构造题。当 \\(b_{i-1}&gt;b_{i}\\) 时，在两个数中间添加一个 \\(1\\) 即可。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(b[0]); for (int i = 1; i &lt; n; i++) { if (b[i] &lt; b[i - 1]) ans.add(1); ans.add(b[i]); } io.println(ans.size()); for (int x : ans) io.print(x + &quot; &quot;); io.println();} Flower City Fence阅读理解。题目中的“对角线对称”这个概念根本不用管，就是不断对区间做加法，然后判断是否和原数组相等，可以使用差分 + 前缀和解决。看完题解，发现其实也可以 \\(O(1)\\) 空间解决，因为数组是非递增的，按顺序遍历就行，具体见代码。 123456789101112131415public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } for (int i = 0, j = n; i &lt; n; i++) { for (; j &gt; 0 &amp;&amp; a[j - 1] &lt;= i; j--) ; if (a[i] != j) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Ice Cream Balls题目描述很有问题，其实就是问从一个长度为 \\(m\\) 的序列中选两个值组成集合，使得不同集合的数目恰好为 \\(n\\) 的 \\(m\\) 是多少。可以先二分求 \\(x\\)，使得 \\(C_{x}^{2}\\leq n\\) 且 \\(C_{x+1}^{2}&gt;n\\)。然后答案就是 \\(x+(n-C_{x}^{2})\\)，表示 \\([1,n-C_{x}^{2}]\\) 范围内的每个数各取两个，以及 \\([n-C_{x}^{2}+1,x]\\) 范围内的每个数各取一个。PS：读题很容易漏掉恰好两个字。 12345678910public static void solve() { long n = io.nextLong(); long lo = 2, hi = (long) 1e9 * 2; while (lo &lt;= hi) { long mid = lo + (hi - lo) / 2; if (mid * (mid - 1) / 2 &lt;= n) lo = mid + 1; else hi = mid - 1; } io.println(hi + (n - hi * (hi - 1) / 2));} Kolya and Movie Theatre做这道题时漏掉“开业前一天去过电影院”这个条件，导致想了半天。答案要求最多看 \\(m\\) 部电影的最大娱乐价值，首先我们可以观察到娱乐值的下降幅度只与最后一次去电影院的日期 \\(x\\) 有关，即下降幅度为 \\(x\\cdot d\\)。所以我们可以从前往后枚举 \\(x\\)，并且维护最大长度为 \\(m\\) 的优先队列，来保证最多看 \\(m\\) 部电影。需要注意电影的娱乐值可能是负数，而我们只需要在优先队列中存储正数即可。 123456789101112131415public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = io.nextInt(); PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); long sum = 0L, ans = 0L; for (int i = 0; i &lt; n; i++) { if (a[i] &lt;= 0) continue; q.offer(a[i]); sum += a[i]; if (q.size() &gt; m) sum -= q.poll(); ans = Math.max(ans, sum - (long) d * (i + 1)); } io.println(ans);} Magic Will Save the World初见时想到的是二分时间 + 动态规划，赛后优化发现可以直接动态规划做。我是用背包做的，\\(dp[i][j]\\) 表示前 \\(i\\) 个怪物使用 \\(j\\) 点法术值能够击败的怪物总强度最大是多少，然后枚举水法术值计算答案。但是其实可以不用这样，我们只需要知道怪物的子集的所有可能强度是多少，然后枚举所有能够到达的强度即可。（C++ 位图很方便） 12345678910111213141516171819202122public static void solve() { int w = io.nextInt(), f = io.nextInt(), n = io.nextInt(); int sum = 0; int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); sum += s[i]; } boolean[] dp = new boolean[sum + 1]; dp[0] = true; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= s[i]; j--) { dp[j] = dp[j] || dp[j - s[i]]; } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt;= sum; i++) { if (!dp[i]) continue; ans = Math.min(ans, Math.max((i + w - 1) / w, (sum - i + f - 1) / f)); } io.println(ans);} The Great Equalizer很容易就可以得出结论，设备的输出值是数组的最大值 + 排序后相邻元素的最大差值，但是不知道怎么维护。使用 C++ 的 multiset 很容易写，详细见大佬的代码。","link":"/2023/08/26/Codeforces%20Round%20894%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 317","text":"Potions二分。 12345678910111213141516public static void solve() { int n = io.nextInt(), h = io.nextInt(), x = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); } x = x - h; int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (p[mid] &lt; x) lo = mid + 1; else hi = mid - 1; } io.println(lo + 1);} MissingNo.求和公式。 12345678910111213public static void solve() { int n = io.nextInt(); int sum = 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); sum += a; min = Math.min(min, a); max = Math.max(max, a); } io.println((min + max) * (max - min + 1) / 2 - sum);} Remembering the Days暴力 DFS。 12345678910111213141516171819202122232425262728293031private static int ans = Integer.MIN_VALUE;public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, w = io.nextInt(); g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { dfs(i, 0, g, vis); } io.println(ans);}private static void dfs(int x, int dis, List&lt;int[]&gt;[] g, boolean[] vis) { vis[x] = true; ans = Math.max(ans, dis); for (int[] t : g[x]) { int y = t[0], w = t[1]; if (!vis[y]) { dfs(y, dis + w, g, vis); } } vis[x] = false;} President01 背包，比赛时转移方程弄错了一个细节，本来以为和答案是等价的，赛后改下就过了。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); int sum = 0; int[] x = new int[n]; int[] y = new int[n]; int[] z = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); z[i] = io.nextInt(); sum += z[i]; } long[] dp = new long[sum + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= z[i]; j--) { if (dp[j - z[i]] == Long.MAX_VALUE) continue; dp[j] = Math.min(dp[j], dp[j - z[i]] + Math.max(0, (y[i] - x[i] + 1) / 2)); } } long ans = Long.MAX_VALUE; for (int i = (sum + 1) / 2; i &lt;= sum; i++) { ans = Math.min(ans, dp[i]); } io.println(ans);} Avoid Eye Contact模拟题，比赛时想复杂了，直接模拟就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void solve() { int h = io.nextInt(), w = io.nextInt(); String[] a = new String[h]; for (int i = 0; i &lt; h; i++) { a[i] = io.next(); } int s = -1, g = -1; boolean[][] mark = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { char c = a[i].charAt(j); if (c == 'S') { s = i * w + j; } else if (c == 'G') { g = i * w + j; } else if (c == '#') { mark[i][j] = true; } else if (c == '^') { mark[i][j] = true; for (int k = i - 1; k &gt;= 0 &amp;&amp; a[k].charAt(j) == '.'; k--) { mark[k][j] = true; } } else if (c == 'v') { mark[i][j] = true; for (int k = i + 1; k &lt; h &amp;&amp; a[k].charAt(j) == '.'; k++) { mark[k][j] = true; } } else if (c == '&lt;') { mark[i][j] = true; for (int k = j - 1; k &gt;= 0 &amp;&amp; a[i].charAt(k) == '.'; k--) { mark[i][k] = true; } } else if (c == '&gt;') { mark[i][j] = true; for (int k = j + 1; k &lt; w &amp;&amp; a[i].charAt(k) == '.'; k++) { mark[i][k] = true; } } } } int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; int[] dis = new int[h * w]; Arrays.fill(dis, -1); dis[s] = 0; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(s); while (!q.isEmpty()) { int z = q.poll(); int x = z / w, y = z % w; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= h || ny &lt; 0 || ny &gt;= w || mark[nx][ny]) continue; int nz = nx * w + ny; if (dis[nz] != -1) continue; dis[nz] = dis[z] + 1; q.offer(nz); } } io.println(dis[g]);}","link":"/2023/08/28/AtCoder%20Beginner%20Contest%20317/"},{"title":"Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2)","text":"Increasing and Decreasing比赛时漏看第三个条件，搞半天。而且似乎倒着减会比较容易做（差不多）。 123456789101112131415public static void solve() { int x = io.nextInt(), y = io.nextInt(), n = io.nextInt(); int z = (1 + n - 1) * (n - 1) / 2; if (z &gt; y - x) { io.println(-1); return; } io.print(x + &quot; &quot;); int d = x + y - x - z; for (int i = n - 1; i &gt;= 1; i--) { d += i; io.print(d + &quot; &quot;); } io.println();} Swap and Reverse找规律。第一个操作表明奇数下标相互连通，偶数下标相互连通。第二个操作，如果 \\(k\\) 是奇数，则连通性不会改变，分别对奇偶字母排序，然后构造即可；如果 \\(k\\) 是偶数，则奇数下标和偶数下标相互连通，对所有字母排序即可。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); if (k % 2 == 0) { Arrays.sort(s); io.println(new String(s)); } else { PriorityQueue&lt;Character&gt; list1 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; list2 = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) list1.add(s[i]); else list2.add(s[i]); } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) sb.append(list1.poll()); else sb.append(list2.poll()); } io.println(sb.toString()); }} Divisor Chain比赛时瞎猜 AC 的，当时是想从 \\(1\\) 开始构造到 \\(x\\)，过程比答案复杂。正解是从 \\(x\\) 一直减去最低有效位的一（必定是除数），直到 \\(x\\) 等于 \\(2\\) 的幂（只剩一个一），然后让 \\(x\\) 一直减去 \\(\\frac{x}{2}\\) 即可。 123456789101112131415161718public static void solve() { int x = io.nextInt(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(x); while ((x &amp; (x - 1)) != 0) { x &amp;= (x - 1); ans.add(x); } while (x != 1) { x /= 2; ans.add(x); } io.println(ans.size()); for (int y : ans) { io.print(y + &quot; &quot;); } io.println();} Matrix Cascade使用差分数组维护从上到下的翻转次数，需要注意的是正负需要分开存，正数每层左移一位，负数每层右移一位。PS：这题 \\(p\\) 和 \\(q\\) 总是写错，Debug 很久。以及大佬的代码看不懂。 1234567891011121314151617181920212223242526272829303132public static void solve() { int n = io.nextInt(); char[][] a = new char[n][]; for (int i = 0; i &lt; n; i++) { a[i] = io.next().toCharArray(); } int ans = 0; int[] p = new int[n + 1]; int[] q = new int[n + 1]; int[] sum = new int[n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (a[i][j] - '0' != sum[j + 1] % 2) { ans++; p[j] ^= 1; q[j + 1] ^= 1; } } p[0] ^= p[1]; for (int j = 1; j &lt; n; j++) { p[j] = p[j + 1]; } q[n] ^= q[n - 1]; for (int j = n - 1; j &gt; 0; j--) { q[j] = q[j - 1]; } for (int j = 0; j &lt; n; j++) { sum[j + 1] = sum[j] ^ p[j] ^ q[j]; } } io.println(ans);} Guess Game有点难以描述，超出能力范围了。这是一个比较好理解的做法，分别考虑每一位。从最低位开始，如果前缀相同，那么就计算当前位 \\(0\\) 和 \\(1\\) 的个数，只有爱丽丝拿 \\(1\\)，鲍勃拿 \\(1\\) 或 \\(0\\) 的情况，当前位才会多走一轮。初始时，设置答案为 \\(n \\times n\\)，因为每个组合至少会走一轮。最后需要使用快速幂求 \\(n\\) 的逆元。 1234567891011121314151617181920212223242526272829303132333435363738private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); long ans = (long) n * n; for (int t = 0; t &lt; 30; t++) { for (int l = 0, r = 0; l &lt; n; l = r) { int[] cnt = new int[2]; while (r &lt; n &amp;&amp; a[l] / 2 == a[r] / 2) { cnt[a[r] % 2]++; r++; } ans += (long) cnt[1] * (cnt[1] + cnt[0]); } for (int i = 0; i &lt; n; i++) { a[i] /= 2; } } ans = ans % MOD * pow(n, MOD - 2) % MOD * pow(n, MOD - 2) % MOD; io.println(ans);}private static int pow(int a, int n) { long res = 1, x = a; while (n != 0) { if (n % 2 == 1) { res = (res * x) % MOD; } x = (x * x) % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/08/28/Harbour.Space%20Scholarship%20Contest%202023-2024%20(Div.%201%20+%20Div.%202)/"},{"title":"第 360 场力扣周赛","text":"距离原点最远的点核心：要距离原点最远，那么可选的位置肯定是向同一个方向移动。 123456789101112class Solution { public int furthestDistanceFromOrigin(String moves) { int n = moves.length(), dis = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { char c = moves.charAt(i); if (c == 'L') dis--; else if (c == 'R') dis++; else cnt++; } return Math.max(cnt - dis, cnt + dis); }} 找出美丽数组的最小和和上周一样的题目。 123456class Solution { public long minimumPossibleSum(int n, int target) { long m = Math.min(target / 2, n); return (m * (m + 1) + (target * 2 + n - m - 1) * (n - m)) / 2; }} 使子序列的和等于目标的最少操作次数比赛时思路满天飞，各种乱写。其实最后的思路是对的，但是基于之前的代码改写，导致有很多 Bug。赛后 15 分钟 AC。从低位到高位枚举 \\(target\\) 中的 \\(1\\)，假设当前 \\(1\\) 对应的值为 \\(x\\)，那么 \\(nums\\) 中所有小于等于 \\(x\\) 的值都可以用来填补 \\(x\\)，如果不够那么肯定需要将下一个大于 \\(x\\) 的值分解为 \\(x\\)。（更优的做法） 123456789101112131415161718192021class Solution { public int minOperations(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int n = nums.size(); int idx = 0, sum = 0, ans = 0; for (int i = target; i != 0; ) { int x = i &amp; -i; i -= x; while (idx &lt; n &amp;&amp; nums.get(idx) &lt;= x) { sum += nums.get(idx++); } sum -= x; if (sum &lt; 0) { if (idx == n) return -1; ans += Integer.numberOfTrailingZeros(nums.get(idx) / x); sum += nums.get(idx++); } } return ans; }} 在传球游戏中最大化函数值参考大佬的题解。 方法一：倍增 DP 因为 CPU 缓存的原因，数组开成 new int[35][n] 会更快。因为这样转移的时候只从上一行转移，具有空间局部性；而下面的代码是从左边一列转移，不具有空间局部性。 1234567891011121314151617181920212223242526272829class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); int[][] f = new int[n][35]; long[][] w = new long[n][35]; for (int i = 0; i &lt; n; i++) { f[i][0] = receiver.get(i); w[i][0] = i; } for (int j = 1; j &lt; 35; j++) { for (int i = 0; i &lt; n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; w[i][j] = w[i][j - 1] + w[f[i][j - 1]][j - 1]; } } long ans = 0L; for (int i = 0; i &lt; n; i++) { long cur = 0L; int pos = i; for (int j = 0; j &lt; 35; j++) { if ((k &gt;&gt; j &amp; 1) == 0) continue; cur += w[pos][j]; pos = f[pos][j]; } ans = Math.max(ans, cur + pos); } return ans; }} 方法二：内向基环树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[receiver.get(i)]++; reverse[receiver.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[receiver.get(x)] == 0) { q.offer(receiver.get(x)); } } // 计算每个环的前缀和，并记录每个节点在哪个环的哪个位置 int[] cirNum = new int[n]; int[] cirPos = new int[n]; boolean[] vis = new boolean[n]; List&lt;List&lt;Long&gt;&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { List&lt;Long&gt; cir = new ArrayList&lt;&gt;(); cir.add(0L); // 前缀和的冗余节点 // 存储环的节点，并记录每个节点在哪个环的哪个位置 for (int cur = i; !vis[cur]; cur = receiver.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cirPos[cur] = cir.size(); cir.add((long) cur); } // 重复存储环的节点，方便计算从任意节点开始和结束的价值和 for (int t = cir.size() - 1, j = 1; t &gt; 0; t--, j++) { cir.add(cir.get(j)); } // 计算前缀和 for (int j = 1; j &lt; cir.size(); j++) { cir.set(j, cir.get(j) + cir.get(j - 1)); } circles.add(cir); } } // 对环内的每个节点向环外进行 dfs，从而计算出以每个节点作为起点的价值和 long ans = 0L; // 存储环外节点的前缀和 List&lt;Long&gt; outSum = new ArrayList&lt;&gt;(); outSum.add(0L); for (int i = 0; i &lt; n; i++) { // 注意传递 k + 1，表示总节点数量 if (in[i] != 0) ans = Math.max(ans, dfs(i, circles.get(cirNum[i]), cirPos[i], reverse, in, outSum, k + 1)); } return ans; } private long dfs(int x, List&lt;Long&gt; cir, int pos, List&lt;Integer&gt;[] reverse, int[] in, List&lt;Long&gt; outSum, long k) { long res = 0L; int outLen = outSum.size() - 1; if (outLen &lt; k) { int n = cir.size() / 2; // 因为 cir 多存储了 n - 1 个环内节点，以及一个冗余节点，所以 cir.size() / 2 就是环的长度 res = (k - outLen) / n * cir.get(n) + cir.get(pos + (int) ((k - outLen) % n) - 1) - cir.get(pos - 1); } res += outSum.get(outLen) - outSum.get((int) Math.max(0L, outLen - k)); for (int y : reverse[x]) { if (in[y] != 0) continue; outSum.add(outSum.get(outLen) + y); res = Math.max(res, dfs(y, cir, pos, reverse, in, outSum, k)); outSum.remove(outLen + 1); } return res; }}","link":"/2023/08/28/%E7%AC%AC%20360%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Homework #1 - SQL","text":"作业准备项目地址：Homework #1 - SQL。 准备工作：阅读 Chapters 1-2 27 3-5，学习 Lecture #01 #02，以及阅读课堂笔记。 Q1 [0 points] (q1_sample):Ctrl + C，Ctrl +V。 Q2 [5 points] (q2_not_the_same_title):查询只涉及 titles 表，比较简单。 1234567891011121314SELECT premiered, primary_title || ' (' || original_title || ')'FROM titlesWHERE primary_title != original_title AND type = 'movie' AND genres LIKE '%Action%'ORDER BY premiered DESC, primary_titleLIMIT 10; Q3 [5 points] (q3_longest_running_tv):题目描述很不清晰啊，类型都不知道具体是什么。 12345678910111213SELECT primary_title, IIF(ended IS NULL, 2023, ended) - premiered AS runtimeFROM titlesWHERE primary_title IS NOT NULL AND type = 'tvSeries'ORDER BY runtime DESC, primary_titleLIMIT 20; Q4 [10 points] (q4_directors_in_each_decade):唯一要注意的就是使用 DISTINCT。 12345678910111213SELECT CAST(born / 10 * 10 AS TEXT) || 's' AS decade, COUNT(DISTINCT(people.person_id)) AS num_directorsFROM people INNER JOIN crew USING(person_id)WHERE category = 'director' AND born &gt;= 1900GROUP BY decadeORDER BY decade; Q5 [10 points] (q5_german_type_ratings):德语的缩写是 de。 12345678910111213141516SELECT t.type, ROUND(AVG(r.rating), 2) AS avg_rating, MIN(r.rating), MAX(r.rating)FROM akas as a INNER JOIN ratings as r USING(title_id) INNER JOIN titles as t USING(title_id)WHERE a.language = 'de' AND a.types IN ('imdbDisplay', 'original')GROUP BY t.typeORDER BY avg_rating; Q6 [10 points] (q6_who_played_a_batman):坑点就是模糊查询时 Batman 两边要加上双引号，即 &quot;Batman&quot;。以及在连接 people 和 crew 表时，顺序很重要，如果使用 crew INNRE JOIN people USING(person_id) 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。 12345678910111213crew INNER JOIN people USING(person_id)QUERY PLAN|--SCAN crew USING INDEX ix_crew_person_id|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCTpeople INNER JOIN crew USING(person_id)QUERY PLAN|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCT 12345678910111213141516171819202122232425WITH t AS ( SELECT DISTINCT(person_id), name FROM people INNER JOIN crew USING(person_id) WHERE category = 'actor' AND characters LIKE '%&quot;Batman&quot;%')SELECT name, ROUND(AVG(rating), 2) AS avg_ratingFROM t INNER JOIN crew USING(person_id) INNER JOIN ratings USING(title_id)GROUP BY person_idORDER BY avg_rating DESCLIMIT 10; Q7 [15 points] (q7_born_with_prestige):SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。 123456789SELECT COUNT(DISTINCT(person_id))FROM titles INNER JOIN people ON titles.premiered = people.born INNER JOIN crew USING(person_id)WHERE primary_title = 'The Prestige' AND category IN ('actor', 'actress'); 12345QUERY PLAN|--USE TEMP B-TREE FOR count(DISTINCT)|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?) Q8 [15 points] (q8_directing_rose.sql):比官解快一秒。注意使用 Rose% 而不是 Rose %。 12345678910111213141516171819SELECT DISTINCT(name)FROM crew INNER JOIN people USING(person_id)WHERE category = 'director' AND title_id IN ( SELECT title_id FROM crew INNER JOIN people USING(person_id) WHERE category = 'actress' AND name LIKE 'Rose%' )ORDER BY name; Q9 [15 points] (q9_ode_to_the_dead):这就是窗口函数么，学习了。 123456789101112131415161718192021222324252627282930313233343536373839WITH t AS ( SELECT category, name, died, primary_title, runtime_minutes, DENSE_RANK() OVER( PARTITION BY category ORDER BY died, name ) AS rank_died_name, DENSE_RANK() OVER( PARTITION BY category, person_id ORDER BY runtime_minutes DESC, title_id ) AS rank_runtime_title FROM crew INNER JOIN people USING(person_id) INNER JOIN titles USING(title_id) WHERE died IS NOT NULL AND runtime_minutes IS NOT NULL)SELECT category, name, died, primary_title, runtime_minutes, rank_died_nameFROM tWHERE rank_died_name &lt;= 5 AND rank_runtime_title = 1ORDER BY category, rank_died_name; Q10 [15 points] (q10_all_played_by_leo):不会。。json_each 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。 123456789101112131415161718192021222324252627WITH t1(characters) AS ( SELECT characters FROM people INNER JOIN crew USING(person_id) WHERE name = 'Leonardo DiCaprio' AND born = 1974),t2(value) AS ( SELECT DISTINCT(value) FROM t1, json_each(t1.characters) WHERE value != '' AND value NOT LIKE '%SELF%' ORDER BY value)SELECT GROUP_CONCAT(value)FROM t2; 作业小结最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）","link":"/2023/08/29/Homework%201%20-%20SQL/"},{"title":"Pinely Round 2 (Div. 1 + Div. 2)","text":"Channel如果同时在线人数到达 \\(n\\)，就表示所有人都阅读过；否则，如果总上线人数大于等于 \\(n\\)，则有可能所有人阅读过；否则，不可能所有人阅读过。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), a = io.nextInt(), q = io.nextInt(); String s = io.next(); int cur = a, tot = a; for (int i = 0; i &lt; q &amp;&amp; cur &lt; n; i++) { if (s.charAt(i) == '+') { cur++; tot++; } else { cur--; } } if (cur == n) { io.println(&quot;YES&quot;); } else if (tot &gt;= n) { io.println(&quot;MAYBE&quot;); } else { io.println(&quot;NO&quot;); }} Split Sort对于每个 \\(p_{i}=k+1\\) 和 \\(p_{j}=k\\) 并且 \\(i&lt;j\\)，那么就一定要选一次 \\(x=k+1\\)。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt() - 1; } int[] map = new int[n]; for (int i = 0; i &lt; n; i++) { map[p[i]] = i; } int ans = 0; for (int i = 1; i &lt; n; i++) { if (map[i] &lt; map[i - 1]) { ans++; } } io.println(ans);} MEX Repetition每执行一次操作，就会去除最后一个数，并将 \\(MEX\\) 添加到序列头部。所以可以通过在数组末尾加上原始数组的 \\(MEX\\)，将操作看成是向左移动循环数组的起始索引。求原始数组的 \\(MEX\\) 可以使用求和公式。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); long sum = 0L; int[] a = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } a[n] = (int) ((long) (1 + n) * n / 2 - sum); k = k % (n + 1); for (int i = 0; i &lt; n; i++) { io.print(a[(-k + n + 1 + i) % (n + 1)] + &quot; &quot;); } io.println();} Two-Colored Dominoes横放的牌只会对列有影响，竖放的牌只会对行有影响，所以分别处理。按行遍历竖放的牌，每当遇到 \\(U\\) 就染上和上次相反的颜色，如果该行只包含奇数个 \\(U\\)，就返回 \\(-1\\)。横放的牌同理。 123456789101112131415161718192021222324252627282930313233343536373839public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } final char[] aux = {'B', 'W'}; for (int i = 0; i &lt; n - 1; i++) { int xor = 0; for (int j = 0; j &lt; m; j++) { if (s[i][j] == 'U') { s[i][j] = aux[xor]; s[i + 1][j] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int j = 0; j &lt; m - 1; j++) { int xor = 0; for (int i = 0; i &lt; n; i++) { if (s[i][j] == 'L') { s[i][j] = aux[xor]; s[i][j + 1] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int i = 0; i &lt; n; i++) { io.println(new String(s[i])); }} Speedrun其实思路是知道的，就是不知道怎么写。这个解法看着有点懵，可能其他解法会更好理解一点。注意题目给定 \\(a_{i}&lt;b_{i}\\)。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); int[] h = new int[n]; for (int i = 0; i &lt; n; i++) { h[i] = io.nextInt(); } List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, idx -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1; g[a].add(b); } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从 h[i] 开始） long[] dp = new long[n]; for (int i = n - 1; i &gt;= 0; i--) { for (int j : g[i]) { dp[i] = Math.max(dp[i], dp[j] + (h[j] - h[i] + k) % k); } } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从零开始） long max = 0L; for (int i = 0; i &lt; n; i++) { dp[i] += h[i]; max = Math.max(max, dp[i]); } // 按照 h[i] 的大小，从小到大枚举起点 Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; h[i] - h[j]); long ans = Long.MAX_VALUE; for (int i : aux) { ans = Math.min(ans, max - h[i]); // 如果起点大于 h[i]，那么任务 i 的完成时间需要加 k，从而导致 dp[i] + k // 其实只要枚举入度为 0 的任务就行，但是即使任务 i 不是入度为 0 任务也没有关系，因为对答案没有影响 max = Math.max(max, dp[i] + k); } io.println(ans);}","link":"/2023/08/31/Pinely%20Round%202%20(Div.%201%20+%20Div.%202)/"},{"title":"Educational Codeforces Round 154 (Rated for Div. 2)","text":"Prime Deletion从 \\(1\\) 到 \\(9\\) 的序列中删除一些数（至少保留两位），使得结果为质数。可以发现 \\(13\\) 和 \\(31\\) 都是质数，所以判断 \\(1\\) 和 \\(3\\) 的先后顺序，然后输出即可。 12345678910111213public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; for (int i = 0; i &lt; n; i++) { if (s[i] == '1') { io.println(13); return; } else if(s[i] == '3') { io.println(31); return; } }} Two Binary Strings比赛时我是从左往右遍历记录不相等的数量，如果有不相等的，那么就需要一个 \\(0\\)，否则遇到 \\(1\\) 就输出 YES。和正解的思路是一样的，就是麻烦一点。正解是有相同的 \\(01\\) 出现时就输出 YES。 123456789101112public static void solve() { char[] a = io.next().toCharArray(); char[] b = io.next().toCharArray(); int n = a.length; for (int i = 0; i &lt; n - 1; i++) { if (a[i] == b[i] &amp;&amp; a[i] == '0' &amp;&amp; a[i + 1] == b[i + 1] &amp;&amp; a[i + 1] == '1') { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Queries for the Array比较简单的写法就是用一个标记数组做记录，递增会向左传递，递减会向右传递，然后判断是否冲突即可。更进一步观察，可以发现只需要记录最大的递增位置，和最小的递减位置。 1234567891011121314151617181920212223242526272829public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = true; int pos = -1, neg = n, cur = -1; for (char c : s) { if (c == '+') { cur++; } else if (c == '-') { if (cur-- == neg) { neg = n; } pos = Math.min(pos, cur); } else if (c == '0') { if (cur == pos || cur &lt;= 0) { ok = false; break; } neg = Math.min(neg, cur); } else { if (neg &lt;= cur) { ok = false; break; } pos = cur; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Sorting By Multiplication没想到啊。枚举负数前缀的长度：在负数前缀中，如果 \\(a[i]&lt;=a[i+1]\\)，就需要操作一次；在正数后缀中，如果 \\(a[i]&gt;=a[i+1]\\) 就需要操作一次。（下面的代码很妙啊，不需要加额外的判断语句。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int cnt = 0; for (int i = 0; i &lt; n - 1; i++) { if (a[i] &gt;= a[i + 1]) { cnt++; } } int ans = cnt; for (int i = 1; i &lt; n; i++) { if (a[i - 1] &gt;= a[i]) cnt--; ans = Math.min(ans, cnt + 1); if (a[i - 1] &lt;= a[i]) cnt++; } io.println(ans);}","link":"/2023/09/04/Educational%20Codeforces%20Round%20154%20(Rated%20for%20Div.%202)/"},{"title":"AtCoder Beginner Contest 318","text":"Full Moon模拟。 1234public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); io.println(n &lt; m ? 0 : (n - m) / p + 1);} Overlapping sheets比赛时没什么思路，想到扫描线，就用扫描线 + 区间合并来做了。结果一看题解，暴力标记每个点，没想到。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; int[][] g = new int[100][100]; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(), b = io.nextInt(); int c = io.nextInt(), d = io.nextInt(); for (int x = a; x &lt; b; x++) { for (int y = c; y &lt; d; y++) { if (g[x][y]++ == 0) ans++; } } } io.println(ans);} Blue Spring看到大佬的解法后，感觉我模拟的方式好蠢啊。当时我是枚举是否要买 \\(d\\) 张票，有点麻烦，原来枚举买当日的票更简单。 1234567891011121314public static void solve() { int n = io.nextInt(), d = io.nextInt(), p = io.nextInt(); int[] f = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { f[i] = io.nextInt(); } Arrays.sort(f); long ans = Long.MAX_VALUE, sum = 0L; for (int i = 0; i &lt;= n; i++) { sum += f[i]; ans = Math.min(ans, sum + (long) (n - i + d - 1) / d * p); } io.println(ans);} General Weighted Max Matching动态规划有点不太会，赛时瞎搞 AC 的。记忆化搜索会很好写，然后 DP 的话，我是用三层循环解决的，下面的解法优化掉一层循环。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[][] d = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { d[i][j] = io.nextInt(); } } long[] dp = new long[1 &lt;&lt; n]; for (int k = 2; k &lt; 1 &lt;&lt; n; k++) { int i = Integer.numberOfTrailingZeros(k &amp; -k); dp[k] = dp[k ^ (1 &lt;&lt; i)]; for (int j = i + 1; j &lt; n; j++) { if ((k &gt;&gt; j &amp; 1) == 1) { dp[k] = Math.max(dp[k], dp[k ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j)] + d[i][j]); } } } io.println(dp[(1 &lt;&lt; n) - 1]);} Sandwiches比较显然的做法是把相同的数分为一组，然后组内枚举中间的数。对于每个中间的数，让答案加上 \\(L\\times R\\)，其中 \\(L\\) 和 \\(R\\) 分别是左右两边相等的数的个数，枚举时可以一次性枚举间隔内所有数。 第二个解法是参考大佬的代码得到的，相当于枚举右端点吧。对于每个右端点，它的贡献可以根据下面代码中的公式得出，感觉比较巧妙。 12345678910111213public static void solve() { int n = io.nextInt(); int[] cnt = new int[n]; long[] sum = new long[n]; long ans = 0L; for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; ans += (long) i * cnt[a] - sum[a] - (long) (1 + cnt[a]) * cnt[a] / 2; cnt[a]++; sum[a] += i; } io.println(ans);} Octopus有点抽象，不是很懂。大概是枚举了 \\(N^{2}\\) 个极限位置，然后分别对每个位置判断可行性。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int N = io.nextInt(); long[] X = new long[N]; long[] L = new long[N]; for (int i = 0; i &lt; N; i++) { X[i] = io.nextLong(); } for (int i = 0; i &lt; N; i++) { L[i] = io.nextLong(); } List&lt;Long&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { pos.add(X[i] - L[j]); pos.add(X[i] + L[j] + 1); } } Collections.sort(pos); long ans = 0L; for (int i = 0; i &lt; pos.size() - 1; i++) { long[] dis = new long[N]; for (int j = 0; j &lt; N; j++) { dis[j] = Math.abs(pos.get(i) - X[j]); } Arrays.sort(dis); boolean ok = true; for (int j = 0; j &lt; N; j++) { if (dis[j] &gt; L[j]) { ok = false; break; } } if (ok) { ans += pos.get(i + 1) - pos.get(i); } } io.println(ans);}","link":"/2023/09/04/AtCoder%20Beginner%20Contest%20318/"},{"title":"第 112 场力扣夜喵双周赛","text":"判断通过操作能否让字符串相等 I同下。 判断通过操作能否让字符串相等 II模拟。也可以手动比较，就是适用性不好。（PS：想出一个写法，结果被自己 Hack 掉了~） 1234567891011class Solution { public boolean checkStrings(String s1, String s2) { int n = s1.length(); int[][] c1 = new int[2][26], c2 = new int[2][26]; for (int i = 0; i &lt; n; i++) { c1[i &amp; 1][s1.charAt(i) - 'a']++; c2[i &amp; 1][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(c1, c2); }} 几乎唯一子数组的最大和滑动窗口。 12345678910111213141516171819class Solution { public long maxSum(List&lt;Integer&gt; nums, int m, int k) { int n = nums.size(); long sum = 0L, ans = 0L; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge(nums.get(i), 1, Integer::sum); sum += nums.get(i); if (i &gt;= k - 1) { if (map.size() &gt;= m) ans = Math.max(ans, sum); if (map.merge(nums.get(i - k + 1), -1, Integer::sum) == 0) { map.remove(nums.get(i - k + 1)); } sum -= nums.get(i - k + 1); } } return ans; }} 统计一个字符串的 k 子序列美丽值最大的数目因为和选择的顺序没有关系，所以贪心的选择出现次数最大的字母就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { private static final long MOD = (long) 1e9 + 7; public int countKSubsequencesWithMaxBeauty(String s, int k) { char[] ss = s.toCharArray(); int[] cnt = new int[26]; for (char c : ss) { cnt[c - 'a']++; } TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((a, b) -&gt; b - a); for (int i = 0; i &lt; 26; i++) { map.merge(cnt[i], 1, Integer::sum); } long ans = 1L; for (var e : map.entrySet()) { int key = e.getKey(), val = e.getValue(); if (val &gt;= k) { return (int) (ans * comb(val, k) % MOD * pow(key, k) % MOD); } k -= val; ans = (ans * pow(key, val)) % MOD; } return 0; } private long pow(long x, int n) { long res = 1L; while (n != 0) { if ((n &amp; 1) == 1) res = (res * x) % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; } private long comb(long n, int k) { long res = n; for (int i = 2; i &lt;= k; i++) { res = res * --n / i; } return res % MOD; }}","link":"/2023/09/04/%E7%AC%AC%20112%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 361 场力扣周赛","text":"统计对称整数的数目模拟。 12345678910111213141516171819202122class Solution { public int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i &lt;= high; i++) { int x = i, n = 0; int[] aux = new int[10]; for (; x != 0; x /= 10) { aux[n++] = x % 10; } if (n % 2 == 0) { int sum = 0; for (int j = 0; j &lt; n / 2; j++) { sum += aux[j] - aux[j + n / 2]; } if (sum == 0) { ans++; } } } return ans; }} 生成特殊数字的最少操作比较简洁的暴力写法，当然从个位开始找 \\(25,75,50,00,0\\) 更快。 1234567891011121314151617class Solution { public int minimumOperations(String num) { int n = num.length(), ans = n; for (int i = 0; i &lt; n; i++) { if (num.charAt(i) == '0') { ans = Math.min(ans, n - 1); } for (int j = i + 1; j &lt; n; j++) { int x = (num.charAt(i) - '0') * 10 + num.charAt(j) - '0'; if (x % 25 == 0) { ans = Math.min(ans, n - i - 2); } } } return ans; }} 统计趣味子数组的数目最开始的思路是，找到所有满足 \\(nums[i]\\bmod modulo=k\\) 的下标放入新的列表，然后在新列表中枚举左端点 \\(i\\)，此时满足条件的右端点就是 \\(i+k-1+j\\times modulo\\)。暴力解决的时间复杂度 \\(O(n^{2})\\)，所以可以倒序枚举左端点，顺便记录间隔为 \\(modulo\\) 的后缀和。但是，这样解决还需要特判 \\(k=0\\) 的情况，总之很麻烦。 更好的做法是利用同余的性质。将所有 \\(nums[i]\\bmod modulo=k\\) 的数字看作 \\(1\\)，其他数字看作 \\(0\\)，这样我们要求的就是满足 \\((sum[r+1]-sum[l])\\bmod modulo=k\\) 的所有子数组的数目。我们可以枚举右端点，找到满足 \\((sum[r+1]-k)\\equiv sum[l]\\pmod{modulo}\\) 的左端点的个数，使用前缀和 + 哈希表即可。 12345678910111213141516class Solution { public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) { long ans = 0L; int n = nums.size(), sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int x : nums) { if (x % modulo == k) { sum = (sum + 1) % modulo; } ans += map.getOrDefault((sum - k + modulo) % modulo, 0); map.merge(sum, 1, Integer::sum); } return ans; }} 边权重均等查询树上倍增求最近公共祖先，同时维护边权的计数。详细见灵神题解。（发现汪佬的写法更简单，在 DFS 的同时进行倍增，以及通过拷贝数组来维护边权的计数信息。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution { private static final int M = 14; public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2] - 1; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] depth = new int[n]; int[][] cnt = new int[n][26]; int[][] parent = new int[M][n]; dfs(0, -1, g, depth, parent, cnt); // 查询 int k = queries.length; int[] ans = new int[k]; while (k-- != 0) { int x = queries[k][0], y = queries[k][1]; int z = lca(x, y, depth, parent), max = 0; for (int i = 0; i &lt; 26; i++) { max = Math.max(max, cnt[x][i] + cnt[y][i] - 2 * cnt[z][i]); } ans[k] = depth[x] + depth[y] - 2 * depth[z] - max; } return ans; } // DFS 的同时进行倍增，以及维护边权的计数 private void dfs(int x, int fa, List&lt;int[]&gt;[] g, int[] depth, int[][] parent, int[][] cnt) { for (int i = 1; 1 &lt;&lt; i &lt;= depth[x]; i++) { parent[i][x] = parent[i - 1][parent[i - 1][x]]; } for (int[] t : g[x]) { int y = t[0], w = t[1]; if (y != fa) { parent[0][y] = x; System.arraycopy(cnt[x], 0, cnt[y], 0, 26); cnt[y][w]++; depth[y] = depth[x] + 1; dfs(y, x, g, depth, parent, cnt); } } } // 求最近公共祖先 private int lca(int x, int y, int[] depth, int[][] parent) { if (depth[x] &gt; depth[y]) { int t = x; x = y; y = t; } // 先向上跳到相同深度 int step = depth[y] - depth[x]; for (int i = 0; i &lt; 32; i++) { if ((step &gt;&gt; i &amp; 1) != 0) { y = parent[i][y]; } } // 尽量向上跳 if (x != y) { for (int i = M - 1; i &gt;= 0; i--) { int px = parent[i][x], py = parent[i][y]; if (px != py) { x = px; y = py; } } x = parent[0][x]; } return x; }}","link":"/2023/09/04/%E7%AC%AC%20361%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 362 场力扣周赛","text":"与车相交的点差点又想区间合并做，看下数据范围，直接暴力，更好的做法是差分数组。 123456789101112131415class Solution { public int numberOfPoints(List&lt;List&lt;Integer&gt;&gt; nums) { int[] d = new int[102]; for (var num : nums) { d[num.get(0)]++; d[num.get(1) + 1]--; } int ans = 0; for (int i = 1; i &lt;= 100; i++) { d[i] += d[i - 1]; if (d[i] &gt; 0) ans++; } return ans; }} 判断能否在给定时间到达单元格题目说恰好第 \\(t\\) 秒到达，我还以为之前都不能到达，结果可以。那么特殊情况就是起点和终点相同，并且 \\(t=1\\)。 1234567class Solution { public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx &amp;&amp; sy == fy &amp;&amp; t == 1) return false; int a = Math.abs(sx - fx), b = Math.abs(sy - fy); return Math.max(a, b) &lt;= t; }} 将石头分散到网格图的最少移动次数方法一：回溯 记录所有等于零和大于一的位置，然后 DFS 搜索每个零从哪个位置获取一。 12345678910111213141516171819202122232425262728293031class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); else if (grid[i][j] &gt; 1) b.add(new int[]{i, j}); } } dfs(0, grid, a, b, 0); return ans; } private void dfs(int i, int[][] grid, List&lt;int[]&gt; a, List&lt;int[]&gt; b, int cnt) { if (i == a.size()) { ans = Math.min(ans, cnt); return; } int[] p = a.get(i); for (int j = 0; j &lt; b.size(); j++) { int[] q = b.get(j); if (grid[q[0]][q[1]] &gt; 1) { grid[q[0]][q[1]]--; dfs(i + 1, grid, a, b, cnt + Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1])); grid[q[0]][q[1]]++; } } }} 方法二：状压 DP 不是很懂，具体解释可以看大佬的题解。 123456789101112131415161718192021222324252627282930class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); for (int k = 2; k &lt;= grid[i][j]; k++) b.add(new int[]{i, j}); } } int n = a.size(); int[] f = new int[1 &lt;&lt; n]; for (int i = 1; i &lt; 1 &lt;&lt; n; i++) { f[i] = Integer.MAX_VALUE; int m = Integer.bitCount(i); for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j &amp; 1) == 1) { f[i] = Math.min(f[i], f[i ^ (1 &lt;&lt; j)] + distance(a.get(m - 1), b.get(j))); } } } return f[(1 &lt;&lt; n) - 1]; } private int distance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); }} 字符串转换KMP + 矩阵快速幂，详细见灵神题解，学习 KMP 看代码随想录，还有各种其他解法可以看题解区（很不错！）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { private static final int MOD = (int) 1e9 + 7; public int numberOfWays(String s, String t, long k) { int n = s.length(); char[] text = (s + s.substring(0, n - 1)).toCharArray(); char[] pattern = t.toCharArray(); int c = kmp(text, pattern); // f[0][0] = s.equals(t) ? 1 : 0; // f[0][1] = s.equals(t) ? 0 : 1; // f[i][0] = f[i - 1][0] * (c - 1) + f[i - 1][1] * c; // f[i][1] = f[i - 1][0] * (n - c) + f[i - 1][1] * (n - c - 1); long[][] m = {{c - 1, c}, {n - c, n - c - 1}}; m = pow(m, k); return s.equals(t) ? (int) m[0][0] : (int) m[0][1]; } private int kmp(char[] text, char[] pattern) { int m = text.length, n = pattern.length; int[] next = new int[n]; for (int i = 1, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) { j = next[j - 1]; } if (pattern[i] == pattern[j]) j++; next[i] = j; } int cnt = 0; for (int i = 0, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) { j = next[j - 1]; } if (text[i] == pattern[j]) j++; if (j == n) { cnt++; j = next[j - 1]; } } return cnt; } private long[][] pow(long[][] a, long n) { long[][] res = {{1, 0}, {0, 1}}; while (n != 0) { if ((n &amp; 1) == 1) res = mul(res, a); a = mul(a, a); n &gt;&gt;= 1; } return res; } private long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % MOD; } } return c; }}","link":"/2023/09/11/%E7%AC%AC%20362%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 896 (Div. 2)","text":"Make It Zero挺简单的一道题，偶数长度的数组操作两次就可以，如果是奇数长度，则额外操作两次。写的时候，把 \\(n\\) 错写成 \\(n-1\\)，找 BUG 花了一倍的时间。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } if (n % 2 == 0) { io.println(2); io.println(1 + &quot; &quot; + n); io.println(1 + &quot; &quot; + n); return; } io.println(4); io.println(1 + &quot; &quot; + (n - 1)); io.println(1 + &quot; &quot; + (n - 1)); io.println((n - 1) + &quot; &quot; + n); io.println((n - 1) + &quot; &quot; + n);} 2D Traveling\\(a\\) 和 \\(b\\) 的最短距离有两种情况，一个是 \\(a\\) 和 \\(b\\) 的曼哈顿距离，另一个是 \\(a\\) 和 \\(b\\) 经过 \\(k\\) 的曼哈顿距离，该情况只要求 \\(k\\) 个点中距离 \\(a\\) 和距离 \\(b\\) 最近的距离就行。比赛时遇到个坑点，两个 Long.MAX_VALUE 相加会溢出，所以初始时除以二。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(), a = io.nextInt(), b = io.nextInt(); long[] x = new long[n], y = new long[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } long ak = Long.MAX_VALUE / 2, bk = Long.MAX_VALUE / 2; for (int i = 0; i &lt; k; i++) { ak = Math.min(ak, Math.abs(x[i] - x[a - 1]) + Math.abs(y[i] - y[a - 1])); bk = Math.min(bk, Math.abs(x[i] - x[b - 1]) + Math.abs(y[i] - y[b - 1])); } long ab = Math.abs(x[b - 1] - x[a - 1]) + Math.abs(y[b - 1] - y[a - 1]); io.println(Math.min(ab, ak + bk));} Fill in the Matrix比赛时代码很乱，赛后总是可以优化成比较简单的形式。分类讨论，\\(n\\) 和 \\(m\\) 的大小关系，可以直接得出最大美丽值，需要注意特判 \\(m=1\\) 的情况。然后就是构造，当 \\(n\\leq m-1\\) 时，让一个从 \\(0\\) 开始的数组循环左移来构造行，这样可以保证得到最大美丽值；当 \\(n&gt;m-1\\) 时，前 \\(m-1\\) 行与之前一样构造，之后多余的行只需要和最后一行相同即可（保证不会影响美丽值）。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), m = io.nextInt(); if (m == 1) { io.println(0); } else if (n &lt;= m - 1) { io.println(n + 1); } else { io.println(m); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &lt; Math.min(n, m - 1)) { io.print((j + i) % m + &quot; &quot;); } else { io.print(j + &quot; &quot;); } } io.println(); }} Candy Party (Easy Version)找 BUG 花了半个小时，将判断 hi 是否是二的幂写成 hi % 2 != 0，修改为 Long.bitCount(hi) != 1 后通过，也可以写成 (hi &amp; hi - 1) != 0。因为每个人都需要发送和接收糖果，计算每个人和平均糖果数的差值 \\(x\\)，如果 \\(x\\) 的二进制位不是由连续的 \\(1\\) 组成，那么就无解，否则总是有唯一的 \\(lo\\) 和 \\(hi\\)（都是二的幂），使得 \\(hi-lo=|x|\\)。这样可以计算出每个人发送和接收多少糖果，如果最后相互抵消，则存在满足题目要求的交换方案。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); long lo = x &amp; -x, hi = x + lo; if (Long.bitCount(hi) != 1) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 0; i &lt; 32; i++) { if (cnt[i] != 0) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Candy Party (Hard Version)考虑什么人可以不发送或者不接收糖果，必定是持有糖果数与平均糖果数的差值为二的幂的人，它们比原来多出一种选择，就是只执行一次发送或接收。具体操作见代码，有点说不清。最后大概是从高位到低位遍历，如果当前位不满足条件，就将低一位的差值与平均糖果数为二的幂的数分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; int[] in = new int[32], out = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); if ((x &amp; x - 1) == 0) { int r = Long.numberOfTrailingZeros(x); if (a[i] &lt; avg) in[r]++; else out[r]++; continue; } long lo = x &amp; -x, hi = x + lo; if ((hi &amp; hi - 1) != 0) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 31; i &gt;= 0; i--) { cnt[i] += out[i] - in[i]; if (i == 0) break; in[i - 1] -= cnt[i]; out[i - 1] += cnt[i]; if (in[i - 1] &lt; 0 || out[i - 1] &lt; 0) { io.println(&quot;NO&quot;); return; } } io.println(cnt[0] == 0 ? &quot;YES&quot; : &quot;NO&quot;);}","link":"/2023/09/11/Codeforces%20Round%20896%20(Div.%202)/"},{"title":"Project #1 - Buffer Pool","text":"项目准备项目地址：Project #1 - Buffer Pool 准备工作：阅读 Chapter 12.1-12.4 13.2-13.3 24.2，学习 Lecture #03 #04，以及阅读课堂笔记。 项目结构buffer_pool_manager pages_ 数组相当于缓冲池，frame_id 是该数组的下标，也就唯一标识一个 Page，即标识一个缓冲页面。一个 Page 可以存储不同的物理页面，Page 的数据成员 page_id_ 唯一标识一个物理页面。因为不管是 FetchPage，还是 DeletePage 等函数，我们都是针对实际的物理页面做操作，所以 buffer_pool_manager 中的函数的形参都是提供 page_id。 lru_k_replacer 该类提供缓冲页面的淘汰策略，即淘汰某个 fram_id 对应的缓冲页面。一个缓冲页面会有一个对应的 LRUKNode，它负责记录该缓冲页面的访问历史。 page_guard 主要有三个类：BasicPageGuard，ReadPageGuard 和 WritePageGuard。BasicPageGuard 的作用是保证缓冲页面在使用完后会进行 UnpinPage 操作。而 ReadPageGuard 和 WritePageGuard，它们和 BasicPageGuard 是组合关系，它们的作用在 BasicPageGuard 的基础上保证页面在使用完后会解除读写锁。 Task #1 - LRU-K Replacement Policy实现① 一开始以为 current_timestamp_ 自动就是当前时间戳，调试时发现一直是 \\(0\\)，我真笨。可以直接从 \\(0\\) 开始手动模拟时间戳，调用 RecordAccess 时，让当前时间戳加 \\(1\\) 即可。 ② 在 Evict 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 frame，结果淘汰的是第一次访问时间最早的 frame。 ③ 在 ListNode 中使 history_ 的长度不超过 k_，如果超过就调用 pop_front()，这样每次获取之前第 k_ 个访问记录只需要调用 front() 函数。 ④ 在 RecordAccess 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 BufferPoolManager 构造函数的实现如下： 12345678// we allocate a consecutive memory space for the buffer poolpages_ = new Page[pool_size_];replacer_ = std::make_unique&lt;LRUKReplacer&gt;(pool_size, replacer_k);// Initially, every page is in the free list.for (size_t i = 0; i &lt; pool_size_; ++i) { free_list_.emplace_back(static_cast&lt;int&gt;(i));} 上述代码说明 frame_id 是小于 pool_size 的，所以大于等于 pool_size 的 fram_id 都应该抛出异常。（或许小于零的也应该抛出异常） 补充① 测试时将 DISABLED_SampleTest 改为 SampleTest。 ② 忘记 C++ 的 = 是拷贝，传引用加上 &amp;： 1auto node = node_store_.at(frame_id); // 错误：拷贝 ③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。 Task #2 - Buffer Pool Manager实现① NewPage 和 FetchPage 有很多逻辑相同的部分，可以加个辅助函数来获取 frame_id。 ② 注意，在 FetchPage 时，如果页面在内存中并且 pin_count_ = 0，则需要将其设置为不可淘汰的。 ③ 在 UnpinPage 中，更新 is_dirty 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。 ④ 在 FlushPage 中，注释表示 REGARDLESS of the dirty flag，应该说的是函数调用者，我们在实现时可以根据 is_dirty 来判断是否实际刷盘。 补充① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。 ② 实现 FetchPage 时，有个情况我忘记调用 RecordAccess，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。 Task #3 - Read/Write Page Guards实现① 使用移动构造和移动赋值后，需要清除 that 的元数据。 ② 移动赋值的调用者，也就是 this，如果其 page_ != nullptr，那么需要先将其 Drop，再进行赋值操作。 ③ 实现读写页面守卫的移动构造函数，可以直接赋值 std::move(that.guard_)，相当于调用之前实现的 BasicPageGuard 的移动赋值运算符。 ④ 实现读写页面守卫的 Drop 时，需要注意在调用 guard_.Drop() 之后再解锁页面，所以在 Drop 之前需要保存一下指向页面的指针。 ⑤ 在实现 BufferPoolManager 中的 FetchPageRead 和 FetchPageWrite 时，为页面加读写锁。 ⑥ 和 PageGuard 有关的 FetchPage 函数会返回一个 PageGuard 对象，但是如果所有缓存页已经被 pin，那么该返回什么。一开始我是直接拿 nullptr 构造 PageGuard，但是发现不对，因为 PageGuard 对象并没有检查 page_ == nullptr 的函数，所以页面必须被 Fetch 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管） Leaderboard Task (Optional)准备性能分析 看到CMU 15-445 2023 P1 优化攻略中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 perf 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。 Brendan Gregg’s Homepage How to use flamegraphs for performance profiling profiling 与性能优化总结 speedscope LRU-K（对优化似乎没有帮助） 关于 LRU-K 的论文：The LRU-K Page Replacement Algorithm For Database Disk Buffering。 LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析） 解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂） LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。 LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\\(K\\geq 2\\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。 实现更新：以下内容存在一些错误，将会在下一节纠正。 ① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。 ② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 frame_id，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我） ③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 bpm-bench 测试），结果发现是我理解有问题。尝试使用读写锁在 BufferPoolManager 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 Unknown 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 FetchPage 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。 ④ 参考CMU 15-445 2023 P1 优化攻略，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 ResetMemory 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。 ⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 BufferPoolManager 之前析构 DiskManager，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。 ⑥ 本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 LRUKNode 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 Evict 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性） Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 61 ALEX 111924 104867 261 484 5123 32 ALEX 102401 96293 4886 5221 57123 2 ALEX 120664 123402 182590 248050 2663116 12 ALEX 143562 133514 3813 8132 85169 重做实现纠错 在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 page_table_），但是，如果在刷盘过程中，有另一个线程读取该页面，它在 page_table_ 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误，错误在 disk_manager_memory.h 中被检测： 1234if (page_id &gt;= static_cast&lt;int&gt;(data_.size()) || page_id &lt; 0) { LOG_WARN(&quot;page not exist&quot;); return;} 所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 page_id 和 frame_id，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 page_table_ 的锁，以确保在其他线程 FetchPage 时，表中已有该 page_id）。这时如果有其他线程 Fetch 该 page_id，不会直接从磁盘读，而是读这个表拿到之前的 frame_id，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 FetchPage 该 page_id 时，会发生已淘汰又被 pin 的情况，还会发生其他很复杂的情况） 如何优化 既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 README（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）： ① 缓存页面的访问规则 读写页面时必须 pin 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 pin） 在读页面时，可以释放页面的读锁，因为已经拿到页面的 pin。 在写页面时，必须拿到 pin 和写锁，并且需要检查 pincount_ == 1，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 unpin，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 pin，但是没有关系，因为当前线程拿到写锁，其他线程 pin 之后还需要拿锁才能读写页面。 我们的项目和上面的描述不一样，但是无伤大雅，基本上 PageGuard 和 FetchPage 等函数已经提供了这些功能。 ② 缓冲池管理器的内部锁定 访问 page_table_ 前需要拿到 page_table 的读写锁（文中称作 BufMappingLock）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 pin。在修改 page_table_，或者修改缓存页面头部字段（应该是指 Page 的除 data_ 以外的成员变量，在本项目中就是 page_id_、pin_count_ 和 is_dirty_），或者从磁盘读物理页面到缓存页面时，需要拿到 page_table_ 的写锁。 可以将 BufMappingLock 拆分为 NUM_BUFFER_PARTITIONS 个锁，每个锁负责映射的一部分。每个 page_id_ 属于哪个分区，由 page_id_ 的哈希值的低比特位决定（其实就是有多个 page_table_，每个 page_id 会根据哈希函数来确定存放在哪个 page_table_ 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。 为空闲列表和页面替换提供独占的自旋锁 buffer_strategy_lock ，当拿到该锁时，不应该去获取任何其他锁。 每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 BufMappingLock 锁）。 BM_IO_IN_PROGRESS 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 BufMappingLock 锁吧）。 缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。 ③ 后台线程刷盘 按照淘汰顺序扫描页面，选择 is_dirty_ == true &amp;&amp; pin_count_ == 0 的页面，然后 pin 该页面并刷盘，最后回收到空闲列表。 还有一些优化方式，没看懂就不翻译了。 总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。 尝试实现 重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。 ① FetchPage 在判断 page_id 是否在 page_table_ 时，需要使用 page_table_ 的独占锁。并且如果页面不在 page_table_ 中，则在函数返回 nullptr 或修改 page_table_ 之前不能释放该锁，以防止多次 FetchPage 同一个 page_id 时，多次从 free_list_ 中获取页面或者多次淘汰页面。 ② 因为在 FetchPage 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 pin 的，所以之后设置 pin_count_ 时，不能直接设置为 1，而是进行 ++ 操作。 第一次重构没有拆分 BufMappingLock，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 unique_lock 作为参数，并且 atomic_flag 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。不搞了，像个小丑，没意思。 Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 26 ALEX 92024 80293 5082 5287 57971 调试① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。 ② 优化时容易出问题的点就是 NewPage 和 FetchPage，以及 UnpinPage。像是 FlushPage、FlushAllPage 以及 DeletePage 都可以暂时不管（可以直接 return），这样比较方便调试。 补充① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。 ② 遇到 Reference to non-static member function must be called 问题，解决方案在此。 ③ MySQL Buffer Pool 的实现 15.5.1 Buffer Pool。 ④ Linus Torvalds 发表的一篇评论：do not use spinlocks in user space, unless you actually know what you’re doing。 ⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。 ⑥ 发现一个感觉不错的博客：MC++。 测试结果测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。 优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。 每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行： 123456789#!/bin/bashmake lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)./test/lru_k_replacer_test./test/buffer_pool_manager_test./test/page_guard_testmake formatmake check-lintmake check-clang-tidy-p1make submit-p1 项目小结① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。 ② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，bpm 优化也就是简单减少锁的粒度，lru 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。 ③ 我好菜啊！！！前三个任务花了两天，优化花了好几天。 更新：发现 Lecture #06 就是讲 BufferPool 优化的（课堂笔记），不知道能不能在这用上，等做完所有 Project 再来试试。","link":"/2023/09/12/Project%201%20-%20Buffer%20Pool/"},{"title":"Codeforces Round 897 (Div. 2)","text":"green_gold_dog, array and permutation让最小值减去最大值，就一定可以得到 \\(n\\) 个不同的差值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; a[i] - a[j]); int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { int t = aux[i]; ans[t] = n - i; } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} XOR Palindromes算是简单的分类讨论，比赛时写的稀烂。 123456789101112131415161718public static void solve() { int n = io.nextInt(), cnt = 0; char[] s = io.next().toCharArray(); for (int i = 0; i &lt; n / 2; i++) { if (s[i] != s[n - i - 1]) { cnt++; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt;= n; i++) { if (i &lt; cnt || i &gt; n - cnt || (i - cnt) % 2 == 1 &amp;&amp; n % 2 == 0) { sb.append('0'); } else { sb.append('1'); } } io.println(sb);} Salyg1n and the MEX Game比赛调试一小时，疯狂超时，结果是限制太强的原因。（浪费时间。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); } Arrays.sort(s); int x = n; for (int i = 0; i &lt; n ; i++) { if (s[i] != i) { x = i; break; } } while (x != -1) { io.println(x); io.flush(); x = io.nextInt(); }} Cyclic Operations做了一个多小时 AC，有点像之前做的内向基环树，该题每个点都有个出边，所以至少有一个环。首先要特判 \\(k=1\\) 的情况，该情况每个位置都必须自成一个环，即 \\(a_{i}=i\\)；其他情况所有环的长度都必须为 \\(k\\)，这样可以保证答案存在。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[b[i]]++; } Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } while (!q.isEmpty()) { int x = q.poll(); if (--in[b[x]] == 0) { q.offer(b[x]); } } int cnt = 0; boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { if (in[i] == 0 || vis[i]) continue; int len = 0; for ( ; !vis[i]; i = b[i]) { vis[i] = true; len++; } if (len != k) { io.println(&quot;NO&quot;); return; } cnt++; } if (k == 1 &amp;&amp; cnt != n) { io.println(&quot;NO&quot;); } else { io.println(&quot;YES&quot;); }} Salyg1n and Array (simple version)注意，\\(n\\) 和 \\(k\\) 都是偶数！手推的话可能可以做出来吧。 12345678910111213141516public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } for (; i &lt;= n; i++) { io.println(&quot;? &quot; + (i - k + 1)); io.flush(); ans ^= io.nextInt(); } io.println(&quot;! &quot; + ans); io.flush();} Salyg1n and Array (hard version)技巧性有点强，真想不到。就是如果多出一部分，可以通过两次异或算出来。 123456789101112131415161718public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } int t = n - i + 1; io.println(&quot;? &quot; + (n - k + 1 - t / 2)); io.flush(); ans ^= io.nextInt(); io.println(&quot;? &quot; + (n - k + 1)); io.flush(); ans ^= io.nextInt(); io.println(&quot;! &quot; + ans); io.flush();}","link":"/2023/09/17/Codeforces%20Round%20897%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 320","text":"Leyland Number模拟。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(); int x = 1; for (int i = 0; i &lt; b; i++) { x *= a; } int y = 1; for (int i = 0; i &lt; a; i++) { y *= b; } io.println(x + y);} Longest Palindrome模拟。 123456789101112131415public static void solve() { String s = io.next(); int n = s.length(); int ans = 1; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { String a = s.substring(i, j + 1); String b = new StringBuilder(a).reverse().toString(); if (a.equals(b)) { ans = Math.max(ans, j - i + 1); } } } io.println(ans);} Slot Strategy 2 (Easy)暴力枚举每个转盘的时间。 1234567891011121314151617181920212223public static void solve() { int n = 3, m = io.nextInt(); int ans = Integer.MAX_VALUE; String[] s = new String[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.next(); } for (int i = 0; i &lt; n * m; i++) { char a = s[0].charAt(i % m); for (int j = 0; j &lt; n * m; j++) { if (i == j) continue; char b = s[1].charAt(j % m); for (int k = 0; k &lt; n * m; k++) { if (i == k || j == k) continue; char c = s[2].charAt(k % m); if (a == b &amp;&amp; b == c) { ans = Math.min(ans, Math.max(i, Math.max(j, k))); } } } } io.println(ans == Integer.MAX_VALUE ? -1 : ans);} Relative PositionDFS 模拟，需要注意给的不是一棵树，所以在 DFS 时要使用访问数组，而不能用父结点。 1234567891011121314151617181920212223242526272829303132333435public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1, x = io.nextInt(), y = io.nextInt(); g[a].add(new int[]{b, x, y}); g[b].add(new int[]{a, -x, -y}); } long[] X = new long[n]; long[] Y = new long[n]; Arrays.fill(X, Long.MAX_VALUE); Arrays.fill(Y, Long.MAX_VALUE); boolean[] vis = new boolean[n]; dfs(0, vis, g, 0, 0, X, Y); for (int i = 0; i &lt; n; i++) { if (X[i] != Long.MAX_VALUE &amp;&amp; Y[i] != Long.MAX_VALUE) { io.println(X[i] + &quot; &quot; + Y[i]); } else { io.println(&quot;undecidable&quot;); } }}private static void dfs(int i, boolean[] vis, List&lt;int[]&gt;[] g, long x, long y, long[] X, long[] Y) { X[i] = x; Y[i] = y; vis[i] = true; for (int[] t : g[i]) { int j = t[0]; if (vis[j]) continue; long nx = t[1] + x, ny = t[2] + y; dfs(j, vis, g, nx, ny, X, Y); }} Somen Nagashi还是模拟，可以一边输入一边处理，减少代码量。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); long[] ans = new long[n], re = new long[n]; PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;((a, b) -&gt; Long.compare(re[a], re[b])); for (int i = 0; i &lt; n; i++) { q.offer(i); } while (m-- != 0) { int t = io.nextInt(), w = io.nextInt(), s = io.nextInt(); while (!p.isEmpty() &amp;&amp; re[p.peek()] &lt;= t) q.offer(p.poll()); if (q.isEmpty()) continue; int x = q.peek(); ans[x] += w; re[x] = t + s; p.offer(q.poll()); } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }}","link":"/2023/09/17/AtCoder%20Beginner%20Contest%20320/"},{"title":"第 113 场力扣夜喵双周赛","text":"使数组成为递增数组的最少右移次数直接从最小值开始判断数组是否递增，或者可以找到第一个递减的位置，然后再判断数组是否递增（因为如果数组满足条件，则其最多只有一个递减段）。 12345678910111213141516class Solution { public int minimumRightShifts(List&lt;Integer&gt; nums) { int n = nums.size(), idx = -1, min = 101; for (int i = 0; i &lt; n; i++) { if (nums.get(i) &lt; min) { min = nums.get(i); idx = i; } } for (int i = 0; i &lt; n - 1; i++) { int x = (idx + i) % n, y = (x + 1) % n; if (nums.get(x) &gt; nums.get(y)) return -1; } return (n - idx) % n; }} 删除数对后的最小数组长度贪心，比赛时我是用双指针做的，前半部分和后半部分进行匹配（当时边界想了很久，真笨！）。其他做法，参考题解：【小羊肖恩】数学 + 贪心：解决较长数组脑筋急转弯问题的关键。（因为 HashMap 很慢，所以用双指针会更快。） 方法一：贪心 1234567891011class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), i = 0; for (int j = (n + 1) / 2; j &lt; n; j++) { if (nums.get(i) &lt; nums.get(j)) { i++; } } return n - i * 2; }} 方法二：贪心 + 数学 12345678910class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), max = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { max = Math.max(max, map.merge(x, 1, Integer::sum)); } return 2 * max &lt;= n ? n % 2 : n - (n - max) * 2; }} 统计距离为 k 的点对枚举 \\(x_{1}\\oplus x_{2}\\) 的值为 \\(p\\)，可以得到 \\(y_{1}\\oplus y_{2}\\) 的值为 \\(k-p\\)。可以使用 HashMap 对前缀中的值计数来求解，需要注意循环的顺序，如果调换顺序会使代码变复杂，会花费更多的时间计算答案。 1234567891011121314class Solution { public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates, int k) { int ans = 0; Map&lt;List&lt;Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;(); for (var c : coordinates) { int x = c.get(0), y = c.get(1); for (int i = 0; i &lt;= k; i++) { ans += map.getOrDefault(List.of(x ^ i, y ^ (k - i)), 0); } map.merge(c, 1, Integer::sum); } return ans; }} 可以到达每一个节点的最少边反转次数换根 DP，关键是要想到建立反向边，并为边添加相应的边权。 12345678910111213141516171819202122232425262728293031323334class Solution { public int[] minEdgeReversals(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(new int[]{v, 0}); g[v].add(new int[]{u, 1}); } int[] ans = new int[n]; ans[0] = dfs(0, -1, g); dfs2(0, -1, g, ans); return ans; } private int dfs(int x, int fa, List&lt;int[]&gt;[] g) { int res = 0; for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; res += dfs(y, x, g) + w; } return res; } private void dfs2(int x, int fa, List&lt;int[]&gt;[] g, int[] ans) { for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; ans[y] = ans[x] + (w == 0 ? 1 : -1); dfs2(y, x, g, ans); } }}","link":"/2023/09/17/%E7%AC%AC%20113%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 363 场力扣周赛","text":"计算 K 置位下标对应元素的和模拟。 1234567891011class Solution { public int sumIndicesWithKSetBits(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i++) { if (Integer.bitCount(i) == k) { ans += nums.get(i); } } return ans; }} 让所有学生保持开心的分组方法数比赛时又写复杂了，当时是想到所有相同的数都必须同时选，所以加了一层循环来跳过相同的数。但是相同的数天然的不满足判断条件，所以不需要这样写。这题唯一需要注意的就是特判全都不选的情况，以及全都选的情况必定满足，可以直接加到答案里（以减少判断代码）。 12345678910111213class Solution { public int countWays(List&lt;Integer&gt; nums) { Collections.sort(nums); int n = nums.size(), ans = 1; if (nums.get(0) &gt; 0) ans++; for (int i = 0; i &lt; n - 1; i++) { if (i + 1 &gt; nums.get(i) &amp;&amp; i + 1 &lt; nums.get(i + 1)) { ans++; } } return ans; }} 最大合金数比赛时又又写复杂了，当时是把所有的库存都清除了再二分的，其实可以直接二分！！ 12345678910111213141516171819class Solution { public int maxNumberOfAlloys(int n, int k, int budget, List&lt;List&lt;Integer&gt;&gt; composition, List&lt;Integer&gt; stock, List&lt;Integer&gt; cost) { int ans = 0; for (var cur : composition) { int lo = 0, hi = (int) 2e8; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; long cnt = 0L; for (int i = 0; i &lt; n; i++) { cnt += Math.max((long) cur.get(i) * mid - stock.get(i), 0L) * cost.get(i); } if (cnt &lt;= budget) lo = mid + 1; else hi = mid - 1; } ans = Math.max(ans, hi); } return ans; }} 完全子集的最大元素和注意题目的描述是每对元素的乘积都是完全平方数。朴素的想法就是对下标进行质因数分解，将所有出现次数为奇数质因数相乘，其结果作为桶的下标，把所有同类的数放在同一个桶里面，然后对每个桶求和取最大值，这样的时间复杂度是 \\(O(n\\sqrt{n})\\)。但是有 \\(O(n)\\) 的解法，如下所示。 1234567891011121314class Solution { public long maximumSum(List&lt;Integer&gt; nums) { long ans = 0L; int n = nums.size(); for (int i = 1; i &lt;= n; i++) { long sum = 0L; for (int j = 1; i * j * j &lt;= n; j++) { sum += nums.get(i * j * j - 1); } ans = Math.max(ans, sum); } return ans; }}","link":"/2023/09/17/%E7%AC%AC%20363%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 321","text":"321-like Checker模拟。 1234567891011public static void solve() { int n = io.nextInt(); String s = String.valueOf(n); for (int i = 0; i &lt; s.length() - 1; i++) { if (s.charAt(i) &lt;= s.charAt(i + 1)) { io.println(&quot;No&quot;); return; } } io.println(&quot;Yes&quot;);} Cutoff比赛时是暴力做的，赛后这个 \\(O(1)\\) 还想了半天。不多解释，代码还是比较好理解的。 12345678910111213141516public static void solve() { int n = io.nextInt(), x = io.nextInt(); int min = 101, max = -1, sum = 0; for (int i = 0; i &lt; n - 1; i++) { int t = io.nextInt(); sum += t; min = Math.min(min, t); max = Math.max(max, t); } int t = x - (sum - min - max); if (t &gt; max) { io.println(-1); } else { io.println(t &lt;= min ? 0 : t); }} 321-like Searcher原来是使用十个二进制位来表示对应数字是否存在，通过暴力枚举算出所有可能的数，最后排序获取对应的位置即可，真的没想到。 123456789101112131415public static void solve() { int k = io.nextInt(); List&lt;Long&gt; ans = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; 1 &lt;&lt; 10; i++) { long x = 0L; for (int j = 9; j &gt;= 0; j--) { if ((i &gt;&gt; j &amp; 1) == 1) { x = x * 10 + j; } } ans.add(x); } Collections.sort(ans); io.println(ans.get(k - 1));} Set Menu二分，状态真差，把加法和乘法混淆了。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); long[] sum = new long[m + 1]; for (int i = 0; i &lt; m; i++) { sum[i + 1] = sum[i] + b[i]; } long ans = 0L; for (int i = 0; i &lt; n; i++) { int x = p - a[i]; int lo = 0, hi = m - 1; while (lo &lt;= hi) { int mid= lo + (hi - lo) / 2; if (b[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } ans += ((long) lo * a[i] + sum[lo]) + (long) (m - lo) * p; } io.println(ans);}","link":"/2023/09/27/AtCoder%20Beginner%20Contest%20321/"},{"title":"第 364 场力扣周赛","text":"最大二进制奇数模拟。 12345678910111213141516class Solution {public: string maximumOddBinaryNumber(string s) { int n = s.size(), cnt = 0; for (char c : s) { if (c == '1') cnt++; } string ans; for (int i = 0; i &lt; n - 1; i++) { if (i &lt; cnt - 1) ans.push_back('1'); else ans.push_back('0'); } ans.push_back('1'); return ans; }}; 美丽塔 I同下。 美丽塔 II枚举以每个位置作为山顶，可以得到的最大高度和。通过使用单调栈 + 前后缀分解，可以 \\(O(n)\\) 的时间算出答案。 1234567891011121314151617181920212223242526class Solution {public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { int n = maxHeights.size(); vector&lt;long long&gt; left(n + 1), right(n + 1); stack&lt;int&gt; stk; stk.push(-1); for (int i = 0; i &lt; n; i++) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); left[i + 1] = left[stk.top() + 1] + 1LL * maxHeights[i] * (i - stk.top()); stk.push(i); } stk = stack&lt;int&gt;(); stk.push(n); for (int i = n - 1; i &gt;= 0; i--) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); right[i] = right[stk.top()] + 1LL * maxHeights[i] * (stk.top() - i); stk.push(i); } long long ans = 0; for (int i = 0; i &lt; n; i++) { ans = max(ans, left[i] + right[i]); } return ans; }}; 统计树中的合法路径数目树型 DP，对于每个节点，计算以该节点为根的子树中，经过该节点的有效路径数，我们只需要维护子树中不包含质数的路径数和只包含一个质数的路径数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { private static final int N = (int) 1e5; private static final boolean[] np = new boolean[N + 1]; static { np[0] = np[1] = true; for (int i = 2; i &lt;= N / i; i++) { if (!np[i]) { for (int j = i; j &lt;= N / i; j++) { np[j * i] = true; } } } } long ans = 0L; public long countPaths(int n, int[][] edges) { List&lt;Integer&gt;[] g = new List[n + 1]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { g[e[0]].add(e[1]); g[e[1]].add(e[0]); } dfs(1, 0, g); return ans; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g) { int zero = 0, one = 0; if (np[x]) zero = 1; else one = 1; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g); ans += (long) zero * t[1] + (long) one * t[0]; if (np[x]) { zero += t[0]; one += t[1]; } else { one += t[0]; } } return new int[]{zero, one}; }}","link":"/2023/09/27/%E7%AC%AC%20364%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 899 (Div. 2)","text":"Increasing Sequence模拟，注意最后答案要减一。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int b = 1; for (int i = 0; i &lt; n; i++) { if (b == a[i]) b += 2; else b += 1; } io.println(b - 1);} Sets and Union比赛时写复杂了，就是枚举不选哪个数，使用位运算会很简单。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); long xor = 0L; long[] s = new long[n]; for (int i = 0; i &lt; n; i++) { int k = io.nextInt(); for (int j = 0; j &lt; k; j++) { s[i] |= 1L &lt;&lt; io.nextInt(); } xor |= s[i]; } int ans = 0; for (int i = 1; i &lt;= 50; i++) { if ((xor &gt;&gt; i &amp; 1) != 1) continue; long res = 0L; for (int j = 0; j &lt; n; j++) { if ((s[j] &gt;&gt; i &amp; 1) != 1) { res |= s[j]; } } ans = Math.max(ans, Long.bitCount(res)); } io.println(ans);} Card Game思维题，没想出来。不管前两张牌如何操作，都必定可以拿到之后的所有正数牌，然后对前两张牌分类讨论即可。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } long ans = 0L; for (int i = 2; i &lt; n; i++) { ans += Math.max(0, a[i]); } ans += Math.max(0, a[0] + Math.max(0, n &gt; 1 ? a[1] : 0)); io.println(ans);} Tree XOR很典的换根 DP，因为第三题花费太长时间，导致差几分钟 AC。只要相邻的两个节点值不相同，它们就需要做一次操作。先以一个节点为根做 DFS，并记录所有节点的子树大小，和以该节点为根的成本。然后再做一次 DFS，换根计算代价的差值。（比赛时犯蠢，在换根的过程中打印答案，但是遍历不能保证从 \\(1\\) 到 \\(n\\) 的顺序，所以是错的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static long[] ans;private static int[] value, sz;private static List&lt;Integer&gt;[] g;public static void solve() { int n = io.nextInt(); value = new int[n]; for (int i = 0; i &lt; n; i++) { value[i] = io.nextInt(); } g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1; g[u].add(v); g[v].add(u); } sz = new int[n]; ans = new long[n]; dfs1(0, -1); dfs2(0, -1); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs1(int x, int fa) { sz[x] = 1; for (int y : g[x]) { if (y == fa) continue; dfs1(y, x); sz[x] += sz[y]; ans[0] += (long) sz[y] * (value[x] ^ value[y]); }}private static void dfs2(int x, int fa) { for (int y : g[x]) { if (y == fa) continue; ans[y] = ans[x] + (long) (sz[0] - sz[y] - sz[y]) * (value[x] ^ value[y]); dfs2(y, x); }}","link":"/2023/09/27/Codeforces%20Round%20899%20(Div.%202)/"},{"title":"Educational Codeforces Round 155 (Rated for Div. 2)","text":"Rigged!模拟。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] s = new int[n]; int[] e = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); e[i] = io.nextInt(); } for (int i = 1; i &lt; n; i++) { if (s[i] &gt;= s[0] &amp;&amp; e[i] &gt;= e[0]) { io.println(-1); return; } } io.println(s[0]);} Chips on the Board有两种情况，每行都放一个或者每列都放一个，然后模拟即可。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] b = new int[n]; long suma = 0L; int mina = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); suma += a[i]; mina = Math.min(mina, a[i]); } long sumb = 0L; int minb = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); sumb += b[i]; minb = Math.min(minb, b[i]); } io.println(Math.min(suma + (long) minb * n, sumb + (long) mina * n));} Make it Alternating所有连续重复数的个数就是最少操作次数，然后就是简单的应用组合数学。 1234567891011121314151617181920private static final int MOD = 998244353;public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; long cnt = n, sum = 1L; for (int i = 0; i &lt; n; ) { int j = i + 1; while (j &lt; n &amp;&amp; s[j] == s[j - 1]) { j++; } sum = sum * (j - i) % MOD; cnt--; i = j; } for (long i = 1; i &lt;= cnt; i++) { sum = sum * i % MOD; } io.println(cnt + &quot; &quot; + sum);} Sum of XOR Functions固定右端点，然后分别考虑每一位，计算答案，公式如下： $$ \\sum_{r=1}^{n}\\sum_{l=1}^{r}f(l,r)\\cdot (r-l+1) =\\sum_{r=1}^{n}\\sum_{i=0}^{31}\\sum_{l=1}^{r}(f_{i}(1,r)\\oplus f_{i}(1,l-1))\\cdot (r-(l-1)) $$ 可以发现对于每一位，\\(f_{i}(1,r)\\oplus f_{i}(1,l-1)\\) 的值不是 \\(1\\) 就是 \\(0\\)，只有当值为 \\(1\\) 时才会对答案有贡献。如果 \\(f_{i}(1,r)=1\\)，那么右端点 \\(r\\) 的第 \\(i\\) 位对答案的贡献为 \\((cnt[i][0]\\cdot r-sum[i][0])\\cdot 2^{i}\\)（其中 \\(cnt[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的个数，\\(sum[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的区间长度之和），另一种情况同理。 12345678910111213141516171819202122private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] s = new int[n + 1]; for (int i = 0; i &lt; n; i++) { s[i + 1] = s[i] ^ io.nextInt(); } long ans = 0L; long[][] cnt = new long[32][2]; long[][] sum = new long[32][2]; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt; 32; j++) { int x = s[i] &gt;&gt; j &amp; 1; ans = (ans + (cnt[j][x ^ 1] * i - sum[j][x ^ 1]) % MOD * (1 &lt;&lt; j)) % MOD; cnt[j][x]++; sum[j][x] += i; } } io.println(ans);}","link":"/2023/09/27/Educational%20Codeforces%20Round%20155%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 900 (Div. 3)","text":"How Much Does Daytona Cost?所有长度为 \\(1\\) 的子数组，包含的元素必定是众数，所以只需判断 \\(k\\) 是否存在于数组中。 12345678910public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean ok = false; for (int i = 0; i &lt; n; i++) { if (k == io.nextInt()) { ok = true; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Aleksa and Stack两个奇数相加得到偶数，两个奇数相乘得到奇数，奇数不会被偶数整除，所以构造一个全是奇数的序列即可。 1234567public static void solve() { int n = io.nextInt(); for (int i = 0; i &lt; n; i++) { io.print(i * 2 + 1 + &quot; &quot;); } io.println();} Vasilije in Cacak只要 \\(x\\) 在最小值和最大值之间，就总是可以被表示出来。 12345678public static void solve() { int n = io.nextInt(), k = io.nextInt(); long x = io.nextLong(); long a = (long) (1 + k) * k / 2; long b = (long) (n - k + 1 + n) * k / 2; if (x &gt;= a &amp;&amp; x &lt;= b) io.println(&quot;YES&quot;); else io.println(&quot;NO&quot;);} Reverse Madness数组被 \\(l\\) 和 \\(r\\) 分段，每一段都是相互独立的，可以单独考虑段内的反转情况。可以发现段内反转总是中心对称的，每个元素是否反转，取决于该元素位置被反转次数的奇偶性，可以用两边向中间求累加和的方式统计，也可以用差分数组。（比赛时我没有统计奇偶性，而是抵消相邻的反转的相同部分） 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[] l = new int[k]; for (int i = 0; i &lt; k; i++) { l[i] = io.nextInt() - 1; } int[] r = new int[k]; for (int i = 0; i &lt; k; i++) { r[i] = io.nextInt() - 1; } int q = io.nextInt(); int[] cnt = new int[n]; for (int i = 0; i &lt; q; i++) { cnt[io.nextInt() - 1]++; } for (int i = 0; i &lt; k; i++) { int sum = 0; for (int a = l[i]; a &lt;= (l[i] + r[i]) / 2; a++) { int b = r[i] + l[i] - a; sum += cnt[a] + cnt[b]; if (sum % 2 == 1) { char c = s[a]; s[a] = s[b]; s[b] = c; } } } io.println(new String(s));} Iva &amp; Pav比较简单的做法是，计算每个比特位的前缀和，然后对每个查询二分答案的位置，将二分位置的值和 \\(k\\) 比较来判断二分的走向。比赛时我是用下面的方法做的，就是没想到二分，其实也可以不用二分，但是没看明白为什么，代码在此。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } // next[i][j] 表示 a[i] 的第 j 位等于 0 的下一个位置 int[][] next = new int[n + 1][32]; Arrays.fill(next[n], n); for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; 32; j++) { next[i][j] = next[i + 1][j]; if ((a[i] &gt;&gt; j &amp; 1) == 0) { next[i][j] = i; } } } int q = io.nextInt(); while (q-- != 0) { int l = io.nextInt() - 1, k = io.nextInt(); if (a[l] &lt; k) { io.print(&quot;-1 &quot;); continue; } int lo = l, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; int cur = 0; for (int i = 0; i &lt; 32; i++) { if (next[mid][i] &gt; mid &amp;&amp; next[mid][i] == next[l][i]) { cur |= 1 &lt;&lt; i; } } if (cur &gt;= k) lo = mid + 1; else hi = mid - 1; } io.print(hi + 1 + &quot; &quot;); } io.println();}","link":"/2023/09/27/Codeforces%20Round%20900%20(Div.%203)/"},{"title":"CodeTON Round 6 (Div. 1 + Div. 2, Rated, Prizes!)","text":"MEXanized Array分类讨论，一开始以为不能有重复，花了很多时间。（菜） 12345public static void solve() { int n = io.nextInt(), k = io.nextInt(), x = io.nextInt(); if (n &lt; k || x &lt; k - 1) io.println(-1); else io.println((k - 1) * k / 2 + (n - k) * (x == k ? k - 1 : x));} Friendly Arrays又看错题了，其实是道很简单的题。 123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); int a = 0; for (int i = 0; i &lt; n; i++) { a ^= io.nextInt(); } int b = 0; for (int i = 0; i &lt; m; i++) { b |= io.nextInt(); } int min = a, max = a; if (n % 2 == 0) { min = a ^ (a &amp; b); } else { max = a | b; } io.println(min + &quot; &quot; + max);} Colorful Table一个数可以向外扩展到大于等于它的的数的位置，我们可以按 \\(k\\) 的大小记录左右端点，然后按照从大到小遍历，来扩展边界，最后计算答案。注意，排除不在数组中的数。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean[] mark = new boolean[k]; int[] l = new int[k], r = new int[k]; Arrays.fill(l, n); Arrays.fill(r, -1); for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; mark[a] = true; l[a] = Math.min(l[a], i); r[a] = i; } for (int i = k - 2; i &gt;= 0; i--) { l[i] = Math.min(l[i], l[i + 1]); r[i] = Math.max(r[i], r[i + 1]); } for (int i = 0; i &lt; k; i++) { if (!mark[i]) io.print(0 + &quot; &quot;); else io.print(2 * (r[i] - l[i] + 1) + &quot; &quot;); } io.println();} Prefix Purchase又又犯蠢了，题目都没读明白。如果右边有更小的数，那么肯定选更小的数是更优的，可以从右向左遍历，将右边的最小值传递到当前位置。然后就是依次处理每个位置，细节见代码。 1234567891011121314151617181920void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; c(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c[i]; } int k; cin &gt;&gt; k; for (int i = n - 2; i &gt;= 0; i--) { c[i] = min(c[i], c[i + 1]); } int m = k; for (int i = 0; i &lt; n; i++) { int x = i == 0 ? c[i] : c[i] - c[i - 1]; if (x != 0) m = min(m, k / x); k -= x * m; cout &lt;&lt; m &lt;&lt; &quot; \\n&quot;[i == n - 1]; }}","link":"/2023/09/27/CodeTON%20Round%206%20(Div.%201%20+%20Div.%202,%20Rated,%20Prizes!)/"},{"title":"Project #2 - B+Tree","text":"项目准备项目地址：Project #2 - B+Tree 准备工作：阅读 Chapter 14.5 24.5 14.1-14.4 18.10.2，学习 Lecture #07 #08 #09，以及阅读课堂笔记。 Task #1 - B+Tree Pages实现① 第一个比较迷惑的点就是 max_size_ 的含义，对官方提供的B+Tree进行插入操作，发现叶子节点的 size_ 不会到达 max_size_。难道叶子节点实际只能包含 max_size_ - 1 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 max_size_ 时，进行分裂，内部节点在插入前大小达到 max_size_ 时进行分裂。所以对于内部节点，max_size_ 表示它能包含的指针数量；对于叶子节点，max_size_ 表示它能包含的键值对数量。 ② GetMinSize 的实现，同样参考官方示例，对于非叶子节点，返回 (max_size_ + 1) / 2；对于叶子节点，返回 max_size_ / 2。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。 补充① 如何理解 MappingType array_[0]，注释表示它是 Flexible array member for page data，参见维基百科Flexible array member。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。 ② 在内部节点和叶子节点中，array_ 的唯一区别就是在搜索内部节点时不能使用 array[0]_.first，因为它并不能准确表示 array_[0].second 中 key 的范围（向 array_[0].second 中插入一个更小的 key，它就失效了）。 Task #2a - B+Tree Insertion and Search for Single Values实现① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \\(O(n)\\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。 ② 可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Search 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 -index - 1（方便之后插入，类似 Java 中的 BinarySearch）。具体的实现逻辑： 内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 index - 1。 叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 -index - 1，否则返回 index。 ③ 特别注意 PageGuard 的使用，只有当操作完页面之后，才对其进行 Drop 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 Drop，这样可以尽早释放页面的锁以及 Unpin 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 Drop 上个页面（使用 Context）。注意拿锁和 Drop 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。 ④ 获取页面需要进行类型转换，如果只读不写就使用 page_guard.h 中提供的 As 函数，只有需要写页面时才使用 AsMut 函数，因为该函数会将页面置为脏页。先将其转换为 BPlusTreePage，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 BPlusTree 类中已经为我们提供了别名： 12using InternalPage = BPlusTreeInternalPage&lt;KeyType, page_id_t, KeyComparator&gt;;using LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;; 一开始我没有注意，在对内部节点转换时，误将其 page_id_t 转为 ValueType，导致完全误解了整个项目的结构。 ⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Split 函数，来实现分裂。 叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（BufferPoolManager，Context），我将分裂函数的参数设计为 BPlusTreeInternalPage &amp;new_page，它会返回将插入到上层的 key，即新节点的第一个 key。 内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 array_[GetMinSize() - 1] 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 array_[0].first，因为分裂的时候复制了）。 ⑥ 同理，在内部页面和叶子页面类中可以添加 Insert 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 page_id 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为 const std::optional&lt;KeyType&gt; &amp;opt 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 Search 的实现，当 index ≥ 0 时返回 false，否则继续插入。 调试调试时可以先使用可视化网站查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（解决方案）： 123#!/bin/bashmake b_plus_tree_printer -j$(nproc){ echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; } | ./bin/b_plus_tree_printer 在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN - Drawing an empty tree 错误，原因是我们没有实现 b_plus_tree.cpp 中的 IsEmpty 函数。 补充① 如何使用 upper_bound 和 lower_bound（Java 选手表示踩了很多坑），可以看看 cppreference 的示例代码，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。 ② 测试时忽略 iterators 的测试。 ③ GetValue 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 BufferPoolManager 的实现）。 Task #2b - B+Tree Deletions实现① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 page_id。 ② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。 ③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 next_page_id_。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 DeletePage 操作，在 DeletePage 之前需要 Drop/Unpin 页面。有个疑问，DeletePage 之前 Drop 之后，如果有线程 Fetch，那么删除页面的操作就会失败。） 调试实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 pop_back() 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。 Task #3 - An Iterator for Leaf Scans基本上没有难度，遇到唯一的错误就是把 GetSize 打成了 GetMaxSize（因为用的自动补全）。 Task #4 - Concurrent Index① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 MixTest2，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 2 3，将 total_keys 修改为 1000，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。 ② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN - page not exist，发现是 BufferPoolManager 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 FetchPageBasic/Read/Write 返回 nullptr 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（但是重构了个寂寞，效率没变，难受啊） ③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 Fetch 和 Drop 的顺序就 OK。 (Optional) Leaderboard Task① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。 ② 优化暂时搁置。 Rank Submission Name read_qps write_qps total_qps 36 ALEX 200376 603 200980 测试结果Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。 Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。 12345678910#!/bin/bashmake b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)./test/b_plus_tree_insert_test./test/b_plus_tree_sequential_scale_test./test/b_plus_tree_delete_test./test/b_plus_tree_concurrent_testmake formatmake check-lintmake check-clang-tidy-p2make submit-p2 项目小结开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 MaxSize 和 MinSize，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 key。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧）","link":"/2023/09/29/Project%202%20-%20B+Tree/"},{"title":"AtCoder Beginner Contest 322","text":"First ABC 2123456public static void solve() { int n = io.nextInt(); String s = io.next(); int ans = s.indexOf(&quot;ABC&quot;); io.println(ans &lt; 0 ? -1 : ans + 1);} Prefix and Suffix1234567891011121314public static void solve() { int n = io.nextInt(), m = io.nextInt(); String s = io.next(), t = io.next(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (s.charAt(i) != t.charAt(i)) { ans |= 2; } if (s.charAt(i) != t.charAt(m - n + i)) { ans |= 1; } } io.println(ans);} Festival1234567891011121314151617public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] ans = new int[n]; Arrays.fill(ans, -1); for (int i = 0; i &lt; m; i++) { int x = io.nextInt() - 1; ans[x] = 0; } for (int i = n - 2; i &gt;= 0; i--) { if (ans[i] == -1) { ans[i] = ans[i + 1] + 1; } } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }} Polyomino模拟题，使用位运算似乎更简单，题解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public static void solve() { char[][][] G = new char[3][4][4]; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 4; j++) { G[i][j] = io.next().toCharArray(); } } io.println(dfs(0, G, new char[4][4]) ? &quot;Yes&quot; : &quot;No&quot;);}private static boolean dfs(int i, char[][][] G, char[][] C) { if (C == null) return false; if (i == 3) return check(C); for (int j = 0; j &lt; 4; j++) { for (int dx = -3; dx &lt;= 3; dx++) { for (int dy = -3; dy &lt;= 3; dy++) { char[][] T = move(dx, dy, G[i]); if (T == null) continue; if (dfs(i + 1, G, add(T, C))) return true; } } G[i] = rotate(G[i]); } return false;}private static char[][] rotate(char[][] A) { char[][] B = new char[4][4]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { B[i][j] = A[3 - j][i]; } } return B;}private static char[][] move(int dx, int dy, char[][] G) { char[][] res = new char[4][4]; for (int i = 0; i &lt; 4; i++) { Arrays.fill(res[i], '.'); } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { int nx = i + dx, ny = j + dy; if(G[i][j] == '#') { if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4) { return null; } res[nx][ny] = G[i][j]; } } } return res;}private static char[][] add(char[][] T, char[][] C) { char[][] res = new char[4][4]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (C[i][j] == '#' &amp;&amp; T[i][j] == '#') return null; if (C[i][j] == '#' || T[i][j] == '#') res[i][j] = '#'; else res[i][j] = '.'; } } return res;}private static boolean check(char[][] C) { for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (C[i][j] != '#') return false; } } return true;} Product Development动态规划，\\(dp[i][j]\\) 表示从前 \\(i\\) 个计划中选择开发计划，使得参数到达 \\(j\\)，需要的最小成本，其中 \\(j\\) 表示 \\(a_{1},a_{2},\\dots,a_{k}\\) 的某个取值，通过将序列看作 \\(p+1\\) 进制数，可以将一个序列转换为某个数值（在这里就是 \\(j\\)）。 12345678910111213141516171819202122232425262728293031323334public static void solve() { int n = io.nextInt(), k = io.nextInt(), p = io.nextInt(); int[] pw = new int[k + 1]; pw[0] = 1; for (int i = 1; i &lt;= k; i++) { pw[i] = pw[i - 1] * (p + 1); } long[] dp = new long[pw[k]]; Arrays.fill(dp, -1L); dp[0] = 0; for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); int[] a = new int[k]; for (int j = 0; j &lt; k; j++) { a[j] = io.nextInt(); } for (int s = pw[k] - 1; s &gt;= 0; s--) { int t = 0; for (int j = 0; j &lt; k; j++) { int cur = s / pw[j] % (p + 1); int nxt = Math.min(p, cur + a[j]); t += nxt * pw[j]; } if (dp[s] != -1 &amp;&amp; (dp[t] == -1 || dp[t] &gt; dp[s] + c)) { dp[t] = dp[s] + c; } } } io.println(dp[pw[k] - 1]);}","link":"/2023/10/02/AtCoder%20Beginner%20Contest%20322/"},{"title":"Codeforces Round 901 (Div. 2)","text":"Jellyfish and Undertale每个工具对答案的贡献为 \\(\\min(a-1,x_{i})\\)，并且答案可能会爆 \\(long\\)，状态好差，WA 两次。 12345678public static void solve() { int a = io.nextInt(), b = io.nextInt(), n = io.nextInt(); long ans = b; for (int i = 0; i &lt; n; i++) { ans += Math.min(a - 1, io.nextInt()); } io.println(ans);} Jellyfish and Game数学题。当 \\(k\\bmod 2=1\\) 时，先手会得到 \\(\\min(0,maxb-mina)\\)；反之，后手此时必然有最小价值的苹果 \\(\\min(mina,minb)\\)，而先手此时会有最大价值的苹果 \\(\\max(maxa,maxb)\\)，做一次交换即可。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); long suma = 0L; int mina = Integer.MAX_VALUE, maxa = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int x = io.nextInt(); suma += x; mina = Math.min(mina, x); maxa = Math.max(maxa, x); } int minb = Integer.MAX_VALUE, maxb = Integer.MIN_VALUE; for (int i = 0; i &lt; m; i++) { int x = io.nextInt(); minb = Math.min(minb, x); maxb = Math.max(maxb, x); } if (k % 2 == 1) { io.println(suma + Math.max(0, maxb - mina)); } else { io.println(suma + Math.max(0, maxb - mina) - Math.max(maxa, maxb) + Math.min(mina, minb)); }} Jellyfish and Green Apple完了，官方解法看不懂，下面是我的解法，就是一直乘二求余，贪心的拆分。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), m = io.nextInt(); int x = n % m, y = m / gcd(n, m); if ((y &amp; (y - 1)) != 0) { io.println(-1); return; } long ans = 0L; while (x != 0) { ans += x; x *= 2; x %= m; } io.println(ans);}private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} 下面是官解，大概懂了。\\(\\frac{a}{b}\\) 表示最终每个人得到的苹果价值的小数部分（可以表示为 \\(\\sum_{i\\in S}\\frac{1}{2^{i}}\\)），因为 \\(b\\) 必须是二的幂，所以 \\(a\\) 中 \\(1\\) 的个数就表示这个人所需的最小苹果片数（就是集合 \\(S\\) 中元素的个数），乘以 \\(m\\) 就表示最后总共的苹果片数，然后减去最开始的 \\(n\\) 片就是需要进行操作的次数（因为每次操作会增加 \\(1\\) 片）。（这个题解很详细，提供了另一种视角） 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); n %= m; int x = gcd(n, m), a = n / x, b = m / x; if ((b &amp; (b - 1)) != 0) { io.println(-1); } else { io.println((long) Integer.bitCount(a) * m - n); }}private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} Jellyfish and Mex其实是很简单的动态规划，但就是动不起来啊。定义 \\(dp[i]\\) 为将 \\(MEX\\) 变为 \\(i\\) 需要的最小代价，然后从大到小转移即可。 12345678910111213141516171819202122private static final int N = 5001;public static void solve() { int n = io.nextInt(); int[] cnt = new int[N]; for (int i = 0; i &lt; n; i++) { int x = io.nextInt(); if (x &lt; n) cnt[x]++; } int mex = 0; while (cnt[mex] &gt; 0) mex++; long[] dp = new long[mex + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[mex] = 0; for (int i = mex - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt;= mex; j++) { dp[i] = Math.min(dp[i], dp[j] + (long) (cnt[i] - 1) * j + i); } } io.println(dp[0]);}","link":"/2023/10/02/Codeforces%20Round%20901%20(Div.%202)/"},{"title":"第 365 场力扣周赛","text":"有序三元组中的最大值 I同下。 有序三元组中的最大值 II方法一：枚举 j 比赛时第一想法是枚举 \\(j\\)，然后取左边和右边的最大值计算答案。 123456789101112131415161718class Solution { public long maximumTripletValue(int[] nums) { int n = nums.length; int[] pre = new int[n + 1]; int[] suf = new int[n + 1]; for (int i = 0; i &lt; n; i++) { pre[i + 1] = Math.max(pre[i], nums[i]); } for (int i = n - 1; i &gt;= 0; i--) { suf[i] = Math.max(suf[i + 1], nums[i]); } long ans = 0L; for (int j = 1; j &lt; n - 1; j++) { ans = Math.max(ans, (long) (pre[j] - nums[j]) * suf[j + 1]); } return ans; }} 方法二：枚举 k 参考灵神的题解，可以枚举 \\(k\\)，使空间复杂度降为 \\(O(1)\\)。主要想法就是枚举时，维护前缀最大差值。 123456789101112class Solution { public long maximumTripletValue(int[] nums) { long ans = 0; int maxDiff = 0, preMax = 0; for (int x : nums) { ans = Math.max(ans, (long) maxDiff * x); maxDiff = Math.max(maxDiff, preMax - x); preMax = Math.max(preMax, x); } return ans; }} 无限数组的最短子数组比赛时思路很快出来，但是实现的时候漏掉一些边界条件，导致 WA 多次，本来有机会进第一页的。比较直接的想法是枚举起始位置，然后利用前缀和二分结束的位置，如果满足条件就记入答案。也可以使用哈希表来优化，避免二分。这里贴一下灵神的滑动窗口解法，时间复杂度 \\(O(n)\\)，空间复杂度 \\(O(1)\\)。 12345678910111213141516171819class Solution { public int minSizeSubarray(int[] nums, int target) { int n = nums.length; long sum = 0L, pre = 0L; for (int x : nums) sum += x; int q = (int) (target / sum), r = (int) (target % sum); int lo = 0, hi = 0, ans = Integer.MAX_VALUE; while (hi &lt; 2 * n) { pre += nums[hi++ % n]; while (pre &gt; r) { pre -= nums[lo++ % n]; } if (pre == r) { ans = Math.min(ans, hi - lo); } } return ans == Integer.MAX_VALUE ? -1 : ans + q * n; }} 有向图访问计数看完题目就知道是内向基环树，直接修改上次的代码，轻松通过，本题是上次的简化版。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { public int[] countVisitedNodes(List&lt;Integer&gt; edges) { int n = edges.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[edges.get(i)]++; reverse[edges.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[edges.get(x)] == 0) { q.offer(edges.get(x)); } } // 记录每个节点在哪个环 int[] cirNum = new int[n]; boolean[] vis = new boolean[n]; List&lt;Integer&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { int cnt = 0; for (int cur = i; !vis[cur]; cur = edges.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cnt++; } circles.add(cnt); } } // 对环内的每个节点向环外进行 dfs int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { if (in[i] != 0) dfs(i, reverse, in, circles.get(cirNum[i]), ans); } return ans; } private void dfs(int x, List&lt;Integer&gt;[] reverse, int[] in, int len, int[] ans) { ans[x] = len; for (int y : reverse[x]) { if (in[y] != 0) continue; dfs(y, reverse, in, len + 1, ans); } }} 有个非常简单的写法，参考题解。 12345678910111213141516171819202122232425262728class Solution { public int[] countVisitedNodes(List&lt;Integer&gt; edges) { int n = edges.size(); int[] ans = new int[n]; int[] vis = new int[n]; for (int i = 0; i &lt; n; i++) { if (ans[i] == 0) { int cnt = 0, cirLen = 0, totLen = 0, pos = i; while (vis[pos] == 0) { vis[pos] = ++cnt; pos = edges.get(pos); } if (ans[pos] == 0) { cirLen = cnt - vis[pos] + 1; totLen = cnt; } else { totLen = cnt + ans[pos]; } pos = i; while (ans[pos] == 0) { ans[pos] = Math.max(totLen--, cirLen); pos = edges.get(pos); } } } return ans; }}","link":"/2023/10/02/%E7%AC%AC%20365%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 366 场力扣周赛","text":"分类求和并作差数学性质，\\([1,n]\\) 中能被 \\(m\\) 整除的数有 \\(\\lfloor \\frac{n}{m}\\rfloor\\) 个。 12345class Solution { public int differenceOfSums(int n, int m) { return (1 + n) * n / 2 - (1 + (n / m)) * (n / m) * m; }} 最小处理时间排序 + 贪心。 1234567891011class Solution { public int minProcessingTime(List&lt;Integer&gt; processorTime, List&lt;Integer&gt; tasks) { Collections.sort(processorTime); Collections.sort(tasks, (a , b) -&gt; b - a); int n = processorTime.size(), ans = 0; for (int i = 0; i &lt; n; i++) { ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4)); } return ans; }} 执行操作使两个字符串相等方法一：动态规划 今天脑子有点笨啊，本来做出来了，但是我将 dp 的初始值设置为 Integer.MAX_VALUE，将 dfs 不满足条件时的返回值也设置为该值，而判断是否记忆化的条件也设置为该值，所以所有不满足条件的方案都没有记忆化上。 我经常会写出从上到下记忆化的代码，但是每次都比从下到上的记忆化慢，经过分析，原因如下：从下到上的记忆化，只要该节点计算过，就会直接返回；而从上到下的记忆化，只有在当前节点的值比记忆化的值大时，才会直接返回，也就是说，这样的代码只会将所有大于记忆化的值的方案给剪枝掉，所有小于记忆化的值的方案会重复计算。 12345678910111213141516171819202122232425262728293031class Solution { public int minOperations(String s1, String s2, int x) { int n = s1.length(); int[][][] dp = new int[n][n + 1][2]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n + 1; j++) { Arrays.fill(dp[i][j], -1); } } int ans = dfs(0, 0, 0, s1, s2, x, dp); return ans &gt;= (int) 1e9 ? -1 : ans; } private int dfs(int i, int c, int r, String s1, String s2, int x, int[][][] dp) { if (i == s1.length()) { if (c % 2 == 0 &amp;&amp; r == 0) { return -c / 2 * x; } return (int) 1e9; } if (dp[i][c][r] != -1) return dp[i][c][r]; int res = 0; if ((s1.charAt(i) == s2.charAt(i)) == (r == 0)) { res = dfs(i + 1, c, 0, s1, s2, x, dp); } else { res = dfs(i + 1, c + 1, 0, s1, s2, x, dp) + x; res = Math.min(res, dfs(i + 1, c, 1, s1, s2, x, dp) + 1); } return dp[i][c][r] = res; }} 方法二：动态规划 时间复杂度 \\(O(n)\\)，空间复杂度 \\(O(1)\\) 的解法，其实比赛时第一眼差不多就想到这种解法，但是没有细想。 1234567891011121314151617class Solution { public int minOperations(String s1, String s2, int x) { int n = s1.length(); int pre = -1, cnt = 0; int dp0 = (int) 1e9, dp1 = 0; for (int i = 0; i &lt; n; i++) { if (s1.charAt(i) != s2.charAt(i)) { cnt ^= 1; int t = dp1; dp1 = Math.min(dp1 + (cnt == 1 ? x : 0), dp0 + i - pre); dp0 = t; pre = i; } } return cnt == 1 ? -1 : dp1; }} 对数组执行操作使平方和最大挺简单一道题，T3 卡太久，脑子短路没时间做这题。对于每一位，每次操作其实就是交换两个数之间的 \\(0\\) 和 \\(1\\)，我们应该总是把 \\(1\\) 交换到更大的数上，这样平方和最大。所以统计每一位的 \\(1\\) 的个数，贪心的组合成最大的数，然后取平方加入答案即可。 1234567891011121314151617181920212223242526class Solution { private static final int MOD = (int) 1e9 + 7; public int maxSum(List&lt;Integer&gt; nums, int k) { int[] cnt = new int[30]; for (int x : nums) { for (int i = 0; i &lt; 30; i++) { cnt[i] += x &gt;&gt; i &amp; 1; } } long ans = 0L; while (k-- != 0) { int x = 0; for (int i = 0; i &lt; 30; i++) { if (cnt[i] &gt; 0) { cnt[i]--; x |= 1 &lt;&lt; i; } } ans = (ans + (long) x * x) % MOD; } return (int) ans; }}","link":"/2023/10/09/%E7%AC%AC%20366%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round)","text":"Goals of Victory所有效率之和等于零。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n - 1; i++) { sum += io.nextInt(); } io.println(-sum);} Helmets in Night Light贪心选择最小花费的通知，注意维护已经被通知的下标，根据该下标判断是否需要加 \\(p\\)，并且如果某个人通知其他人的成本大于 \\(p\\)，则他不会通知其他人。发现大佬的解法好简单，取一个最小值，维护一个剩余人数即可。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; b[i] - b[j]); long ans = p; int r = n - 1; for (int i : aux) { int x = Math.min(r, a[i]); ans += (long) x * Math.min(p, b[i]); r -= x; } io.println(ans);} Joyboard分类讨论，注意被 \\(n\\) 整除的数。 1234567public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); if (k == 3) io.println(Math.max(0, m - n - m / n + 1)); else if (k == 2) io.println(m / n + Math.min(n - 1, m)); else if (k == 1) io.println(1); else io.println(0);} Effects of Anti Pimples很容易的想到计算选择每个索引位置，能够得到的最大分数，时间复杂度为 \\(O(n\\log{n})\\)。然后计算每个位置有多少种方案，比赛时我以为选择一个索引位置，默认就选择了它的所有倍数位置，导致不会做。其实只要排序，然后每个位置的方案数就是它左边的数选或不选的方案数，这样可以保证不会重复计算，所以快速幂计算方案数（可以在遍历的时候计算方案数），再乘以得分累加到答案即可。 123456789101112131415161718192021222324private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { dp[i] = io.nextInt(); } dp[0] = Integer.MAX_VALUE; for (int i = 1; i &lt;= n; i++) { for (int j = 2 * i; j &lt;= n; j += i) { dp[i] = Math.max(dp[i], dp[j]); } } Arrays.sort(dp); long ans = 0L, pow = 1L; for (int i = 0; i &lt; n; i++) { ans = (ans + dp[i] * pow) % MOD; pow = pow * 2 % MOD; } io.println(ans);} Autosynthesis方法一：内向基环树 对于每个 \\(i\\)，建立一条从 \\(i\\) 指向 \\(a_{i}\\) 的边，最终会得到多个内向基环树。规则一：入度为零的节点不会被选择；规则二：如果一个节点的所有入度节点都被选择，那么它不会被选择；规则三：如果一个节点不被选择，那么它指向的节点会被选择。（以上规则可以使用拓扑序 + 染色法实现） 如图，数组为 \\([2,3,4,5,6,3,3,4]\\)，剩余索引 \\([1,5,7,8]\\)，剩余元素 \\([2,6,3,4]\\)，选择索引 \\([2,6,3,4]\\)。应用规则一，得出索引 \\([1,7,8]\\) 不被选择；应用规则三，得出索引 \\([2,3,4]\\) 被选择；应用规则二，得出索引 \\([5]\\) 不被选择；应用规则三，得出索引 \\([6]\\) 被选择。 特殊情况，如果内向基环树没有环外节点，无法应用上述规则，那么需要单独对环交替染色，若此时环的长度为奇数，则没有解，其他情况均有解。也就是说，当且仅当内向基环树没有环外节点，且环的长度为奇数时，无解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[a[i]]++; } // 拓扑序染色（-1 表示不选择，1 表示选择） int[] col = new int[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); col[i] = -1; } } while (!q.isEmpty()) { int x = q.poll(), y = a[x]; if (col[y] != 0) continue; if (--in[y] == 0 || col[x] == -1) { q.offer(y); col[y] = -col[x]; } } // 单独处理没有环外节点的基环树 for (int i = 0; i &lt; n; i++) { if (col[i] != 0) continue; int j = i, pre = -1; while (col[j] == 0) { col[j] = -pre; pre = col[j]; j = a[j]; } if (col[j] == pre) { io.println(-1); return; } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (col[i] == -1) ans.add(a[i] + 1); } io.println(ans.size()); for (int x : ans) { io.print(x + &quot; &quot;); } io.println();} 方法二：外向基环树 好像有建立外向基环树的解法，没时间看，在此。","link":"/2023/10/09/Codeforces%20Round%20902%20(Div.%202,%20based%20on%20COMPFEST%2015%20-%20Final%20Round)/"},{"title":"JDK-8299339 : HashMap merge and compute methods can cause odd resizing pathologies","text":"贴一下去年发现的 Bug，嘿嘿。 导致 Bug 的示例代码如下： 12345678910111213public class Main { public static void main(String[] args) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(2); map.merge(1, 1, Integer::sum); map.merge(2, 1, Integer::sum); map.forEach((k, v) -&gt; { map.merge(k, -1, Integer::sum); System.out.println(k); }); }} Java Bug DataBase 链接，里面比较详细的讨论了发生的问题，由于当时急着发出去，我的评论有点乱，而且是中文翻译为英文的，有点拉。","link":"/2023/10/09/JDK-8299339%20HashMap%20merge%20and%20compute%20methods%20can%20cause%20odd%20resizing%20pathologies/"},{"title":"Educational Codeforces Round 156 (Rated for Div. 2)","text":"Sum of Three当 n &lt;= 6 || n == 9 时，不能凑出三个不同的不能被 \\(3\\) 整除的正整数，其他情况均可以通过以下方式凑出。 1234567891011121314public static void solve() { int n = io.nextInt(); if (n &lt;= 6 || n == 9) { io.println(&quot;NO&quot;); return; } int a = 1, b = 2, c = n - 3; if (c % 3 == 0) { c -= 2; b += 2; } io.println(&quot;YES&quot;); io.println(a + &quot; &quot; + b + &quot; &quot; + c);} Fear of the Dark可以分为四种情况：点 \\(O\\) 和 点 \\(P\\) 在圆 \\(A\\) 内/上；点 \\(O\\) 和 点 \\(P\\) 在圆 \\(B\\) 内/上；点 \\(O\\) 和 点 \\(P\\) 分别在圆 \\(A\\) 和圆 \\(B\\) 内/上，并且圆 \\(A\\) 和圆 \\(B\\) 相切/相交；点 \\(O\\) 和 点 \\(P\\) 分别在圆 \\(B\\) 和圆 \\(A\\) 内/上，并且圆 \\(A\\) 和圆 \\(B\\) 相切/相交。 方法一：浮点二分 12345678910111213141516171819202122public static void solve() { double px = io.nextInt(), py = io.nextInt(); double ax = io.nextInt(), ay = io.nextInt(); double bx = io.nextInt(), by = io.nextInt(); double lo = 0, hi = 1e4; while (hi - lo &gt; 1e-9) { double mid = lo + (hi - lo) / 2; boolean oToA = dist(0, 0, ax, ay) &lt;= mid; boolean aToP = dist(ax, ay, px, py) &lt;= mid; boolean oToB = dist(0, 0, bx, by) &lt;= mid; boolean bToP = dist(bx, by, px, py) &lt;= mid; boolean aToB = dist(ax, ay, bx, by) &lt;= 2 * mid; if ((oToA &amp;&amp; aToP) || (oToB &amp;&amp; bToP) || (oToA &amp;&amp; aToB &amp;&amp; bToP) || (oToB &amp;&amp; aToB &amp;&amp; aToP)) hi = mid; else lo = mid; } io.println(hi);}private static double dist(double x1, double y1, double x2, double y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));} 方法二：直接计算 123456789101112131415161718192021public static void solve() { double px = io.nextInt(), py = io.nextInt(); double ax = io.nextInt(), ay = io.nextInt(); double bx = io.nextInt(), by = io.nextInt(); double oToA = dist(0, 0, ax, ay); double aToP = dist(ax, ay, px, py); double oToB = dist(0, 0, bx, by); double bToP = dist(bx, by, px, py); double aToB = dist(ax, ay, bx, by); double ans = Math.max(oToA, aToP); ans = Math.min(ans, Math.max(oToB, bToP)); ans = Math.min(ans, Math.max(oToA, Math.max(aToB / 2, bToP))); ans = Math.min(ans, Math.max(oToB, Math.max(aToB / 2, aToP))); io.println(ans);}private static double dist(double x1, double y1, double x2, double y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));} Decreasing String二分删除的字符数 \\(p\\)，可以通过计算得到 \\(q=pos-\\frac{(n+(n-p+1))\\cdot p}{2}\\)，则答案为 \\(s_{1+p}[q]\\)，可以使用单调栈删除字符，然后获取答案即可。 1234567891011121314151617181920212223public static void solve() { String s = io.next(); long pos = io.nextLong(); int n = s.length(); int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if ((long) (n + n - mid + 1) * mid / 2 &lt; pos) lo = mid + 1; else hi = mid - 1; } int p = hi, q = (int) (pos - (long) (n + n - hi + 1) * hi / 2); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { while (p &gt; 0 &amp;&amp; !sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - 1) &gt; s.charAt(i)) { sb.deleteCharAt(sb.length() - 1); p--; } sb.append(s.charAt(i)); } io.print(sb.charAt(q - 1));} Monocarp and the Set很容易想到当 s[0] == '?' 时，方案数为 \\(0\\)，并且 &gt; 和 &lt; 符号的位置放什么数都是确定的，也就是说只有 ? 位置对答案有贡献。分别考虑每个 ? 位置（从位置 \\(1\\) 开始，因为位置 \\(0\\) 不能是 ?），假设该位置的下标为 \\(i\\)，那么它是第 \\(i+2\\) 个的数（因为添加第 \\(1\\) 个数时，不会记录字符到 \\(s\\) 中，并且下标从 \\(0\\) 开始，所以加 \\(2\\)），第 \\(i+2\\) 个数必须要大于前 \\(i+1\\) 个数的最小值，小于前 \\(i+1\\) 个数的最大值。我们可以将前 \\(i+1\\) 个数排成有序的序列，然后根据大小将第 \\(i+2\\) 个数插入到序列中，总共有 \\(i+2\\) 个插入位置，但在限制条件下，我们只能选择 \\(i\\) 个位置进行插入，对所有 ? 位置累乘 \\(i\\) 即可得到当前字符串的插入方案数。 看半天才懂，很多题解只提到插入法，根本没提到有序序列，只要知道是根据大小插入就很简单了。也就是说，插入时根本不关心当前是什么数，只关心当前数在前面数的最大值和最小值之间。在将所有的数插入完成后，所有 ? 位置是什么数就随之确定，也就确定了一种方案。 12345678910111213141516171819202122232425262728293031323334353637383940private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 1L; for (int i = 1; i &lt; n - 1; i++) { if (s[i] == '?') ans = ans * i % MOD; } query(s, ans); while (m-- != 0) { int i = io.nextInt() - 1; char c = io.next().charAt(0); if (i != 0 &amp;&amp; s[i] == '?') { ans = ans * pow(i, MOD - 2) % MOD; } s[i] = c; if (i != 0 &amp;&amp; s[i] == '?') { ans = ans * i % MOD; } query(s, ans); }}private static void query(char[] s, long ans) { if (s[0] == '?') io.println(0); else io.println(ans);}private static int pow(int a, int n) { long res = 1L, x = a; while (n != 0) { if ((n &amp; 1) == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/10/10/Educational%20Codeforces%20Round%20156%20(Rated%20for%20Div.%202)/"},{"title":"第 115 场力扣夜喵双周赛","text":"上一个遍历的整数模拟。 1234567891011121314151617class Solution { public List&lt;Integer&gt; lastVisitedIntegers(List&lt;String&gt; words) { int idx = -1; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; aux = new ArrayList&lt;&gt;(); for (String word : words) { if (word.equals(&quot;prev&quot;)) { if (idx &lt; 0) ans.add(-1); else ans.add(aux.get(idx--)); } else { aux.add(Integer.valueOf(word)); idx = aux.size() - 1; } } return ans; }} 最长相邻不相等子序列 I贪心。 1234567891011class Solution { public List&lt;String&gt; getWordsInLongestSubsequence(int n, String[] words, int[] groups) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i == n - 1 || groups[i] != groups[i + 1]) { ans.add(words[i]); } } return ans; }} 最长相邻不相等子序列 II和最长递增子序列有点像，处理的时候记录一下路径就好。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;String&gt; getWordsInLongestSubsequence(int n, String[] words, int[] groups) { int pos = 0; int[] from = new int[n]; int[] maxLen = new int[n]; Arrays.fill(maxLen, 1); for (int i = 1; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (maxLen[i] &lt; maxLen[j] + 1 &amp;&amp; groups[i] != groups[j] &amp;&amp; words[i].length() == words[j].length()) { int cnt = 0; for (int k = 0; k &lt; words[i].length(); k++) { if (words[i].charAt(k) != words[j].charAt(k) &amp;&amp; ++cnt &gt; 1) { break; } } if (cnt == 1) { maxLen[i] = maxLen[j] + 1; from[i] = j; if (maxLen[i] &gt; maxLen[pos]) { pos = i; } } } } } int m = maxLen[pos]; LinkedList&lt;String&gt; ans = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { ans.addFirst(words[pos]); pos = from[pos]; } return ans; }} 和带限制的子多重集合的数目明显是多重背包问题，求背包中物品重量在 \\([l,r]\\) 之间的方案数，朴素的转移方程为： $$ dp[i][j]=\\sum_{k=0}^{cnt[i]}{(dp[i-1][j-k\\cdot w[i]])} $$ 这样做的时间复杂度为 \\(O(rn)\\)，其中 \\(n\\) 为 \\(nums\\) 的长度。在题目的数据范围下，复杂度达到 \\(4\\cdot 1e8\\) 数量级，会导致超时。优化方式如下，当 \\(j\\geq(cnt[i]+1)\\cdot w[i]\\) 且 \\(w[i]\\neq 0\\) 时，有： $$ dp[i][j-w[i]]=dp[i-1][j-w[i]]+dp[i-1][j-2\\cdot w[i]]+\\cdots+dp[i-1][j-(cnt[i]+1)\\cdot w[i]] $$ $$ dp[i][j]=dp[i-1][j]+dp[i-1][j-w[i]]+\\cdots+dp[i-1][j-cnt[i]\\cdot w[i]] $$ 然后错位相减，得到： $$ dp[i][j]=dp[i][j-w[i]]+(dp[i-1][j]-dp[i-1][j-(cnt[i]+1)\\cdot w[i]]) $$ 当 \\(j\\geq(cnt[i]+1)\\cdot w[i]\\) 且 \\(w[i]=0\\) 时，直接使用朴素转移方程，得到： $$ dp[i][j]=\\sum_{k=0}^{cnt[i]}{(dp[i-1][j])} $$ 同理可得，当 \\(w[i]\\leq j&lt;(cnt[i]+1)\\cdot w[i]\\) 时，错位相减得到： $$ dp[i][j]=dp[i][j-w[i]]+dp[i-1][j] $$ 当 \\(j&lt;w[i]\\) 时，直接使用朴素转移方程，得到： $$ dp[i][j]=dp[i-1][j] $$ 这样做的时间复杂度为 \\(O(r\\sqrt{S})\\)，其中 \\(S\\) 表示 \\(nums\\) 的元素和，\\(\\sqrt{S}\\) 表示 \\(nums\\) 中不同元素的最大数量。不同元素的最大数量满足 \\(\\frac{(0+(x-1))\\cdot x}{2}\\leq S\\)，解得 \\(x\\leq \\frac{1+\\sqrt{1+8\\cdot S}}{2}\\)。还有一些常数级别的优化，比如减少遍历的上界等。 12345678910111213141516171819202122232425262728293031323334353637class Solution { private static final int MOD = (int) 1e9 + 7; public int countSubMultisets(List&lt;Integer&gt; nums, int l, int r) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { map.merge(x, 1, Integer::sum); } int zero = map.getOrDefault(0, 0); map.remove(0); int m = map.size(); int[] f = new int[r + 1]; int[] g = new int[r + 1]; f[0] = zero + 1; for (var e : map.entrySet()) { int w = e.getKey(), c = e.getValue(); System.arraycopy(f, 0, g, 0, r + 1); for (int j = w; j &lt;= r; j++) { f[j] = (f[j - w] + f[j]) % MOD; if (j - (c + 1) * w &gt;= 0) { f[j] = (f[j] - g[j - (c + 1) * w] + MOD) % MOD; } } } int ans = 0; for (int i = l; i &lt;= r; i++) { ans = (ans + f[i]) % MOD; } return ans; }} 分开处理，先做前缀和，再倒序减去某个前缀和，就可以不使用辅助数组 \\(g\\)： 1234567891011121314151617181920212223242526272829303132333435class Solution { private static final int MOD = (int) 1e9 + 7; public int countSubMultisets(List&lt;Integer&gt; nums, int l, int r) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { map.merge(x, 1, Integer::sum); } int zero = map.getOrDefault(0, 0); map.remove(0); int m = map.size(); int[] f = new int[r + 1]; f[0] = zero + 1; for (var e : map.entrySet()) { int w = e.getKey(), c = e.getValue(); for (int j = w; j &lt;= r; j++) { f[j] = (f[j - w] + f[j]) % MOD; } for (int j = r; j &gt;= (c + 1) * w; j--) { f[j] = (f[j] - f[j - (c + 1) * w] + MOD) % MOD; } } int ans = 0; for (int i = l; i &lt;= r; i++) { ans = (ans + f[i]) % MOD; } return ans; }}","link":"/2023/10/16/%E7%AC%AC%20115%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 367 场力扣周赛","text":"找出满足差值条件的下标 I同下。 最短且字典序最小的美丽子字符串滑动窗口。 1234567891011121314151617181920212223242526class Solution { public String shortestBeautifulSubstring(String s, int k) { int n = s.length(); int lo = s.indexOf('1'); if (lo &lt; 0) { return &quot;&quot;; } String ans = &quot;&quot;; int hi = lo, cnt = 0; while (hi &lt; n) { cnt += s.charAt(hi++) - '0'; while (cnt &gt; k || s.charAt(lo) == '0') { cnt -= s.charAt(lo++) - '0'; } if (cnt == k) { String t = s.substring(lo, hi); if (ans.isEmpty() || t.length() &lt; ans.length() || t.length() == ans.length() &amp;&amp; t.compareTo(ans) &lt; 0) { ans = t; } } } return ans; }} 找出满足差值条件的下标 II维护最大值和最小值就行。 1234567891011121314151617181920212223class Solution { public int[] findIndices(int[] nums, int indexDifference, int valueDifference) { int n = nums.length; int minIndex = 0, maxIndex = 0; for (int j = indexDifference; j &lt; n; j++) { int i = j - indexDifference; if (nums[i] &gt; nums[maxIndex]) { maxIndex = i; } else if (nums[i] &lt; nums[minIndex]) { minIndex = i; } if (nums[maxIndex] - nums[j] &gt;= valueDifference) { return new int[]{maxIndex, j}; } if (nums[j] - nums[minIndex] &gt;= valueDifference) { return new int[]{minIndex, j}; } } return new int[]{-1, -1}; }} 构造乘积矩阵前后缀分解，将二维数组看作一维数组。 1234567891011121314151617181920212223242526class Solution { private static final int MOD = 12345; public int[][] constructProductMatrix(int[][] grid) { int n = grid.length, m = grid[0].length; int[][] p = new int[n][m]; long suf = 1; for (int i = n - 1; i &gt;= 0; i--) { for (int j = m - 1; j &gt;= 0; j--) { p[i][j] = (int) suf; suf = suf * grid[i][j] % MOD; } } long pre = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { p[i][j] = (int) (p[i][j] * pre % MOD); pre = pre * grid[i][j] % MOD; } } return p; }}","link":"/2023/10/16/%E7%AC%AC%20367%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 324","text":"Same12345678public static void solve() { int n = io.nextInt(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) { set.add(io.nextInt()); } io.println(set.size() == 1 ? &quot;Yes&quot; : &quot;No&quot;);} 3-smooth Numbers123456public static void solve() { long n = io.nextLong(); while (n % 2 == 0) n /= 2; while (n % 3 == 0) n /= 3; io.println(n == 1 ? &quot;Yes&quot; : &quot;No&quot;);} Error Correction额，很简单的题，赛时花费很长时间，代码写得很乱。 123456789101112131415161718192021222324252627282930313233public static void solve() { int n = io.nextInt(); String t = io.next(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int k = 0; k &lt; n; k++) { String s = io.next(); int i = 0; for (; i &lt; s.length() &amp;&amp; i &lt; t.length(); i++) { if (s.charAt(i) != t.charAt(i)) { break; } } int j = 0; for (; j &lt; s.length() &amp;&amp; j &lt; t.length(); j++) { if (s.charAt(s.length() - 1 - j) != t.charAt(t.length() - 1 - j)) { break; } } boolean ok = s.length() == t.length() &amp;&amp; i + j &gt;= t.length() - 1; ok |= s.length() == t.length() + 1 &amp;&amp; i + j &gt;= t.length(); ok |= s.length() == t.length() - 1 &amp;&amp; i + j &gt;= t.length() - 1; if (ok) { ans.add(k + 1); } } io.println(ans.size()); ans.forEach(i -&gt; io.print(i + &quot; &quot;)); io.println();} Square Permutation还是直接使用字符串更简单，要不然还要拆位。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); Arrays.sort(s); long max = (long) Math.pow(10, n); int ans = 0; for (long i = 0; i * i &lt; max; i++) { StringBuilder sb = new StringBuilder(String.valueOf(i * i)); while (sb.length() &lt; n) { sb.append(&quot;0&quot;); } char[] t = sb.toString().toCharArray(); Arrays.sort(t); if (Arrays.equals(s, t)) { ans++; } } io.println(ans);} Joint Two Strings记录每个字符串的子序列匹配目标字符串的最大前后缀的长度，因为答案和下标无关，所以使用排序 + 二分计算答案。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); String t = io.next(); int[] prefix = new int[n]; int[] suffix = new int[n]; for (int k = 0; k &lt; n; k++) { String s = io.next(); for (int i = 0; i &lt; s.length() &amp;&amp; prefix[k] &lt; t.length(); i++) { if (s.charAt(i) == t.charAt(prefix[k])) { prefix[k]++; } } for (int i = 0; i &lt; s.length() &amp;&amp; suffix[k] &lt; t.length(); i++) { if (s.charAt(s.length() - 1 - i) == t.charAt(t.length() - 1 - suffix[k])) { suffix[k]++; } } } Arrays.sort(suffix); long ans = 0L; for (int i = 0; i &lt; n; i++) { int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (prefix[i] + suffix[mid] &gt;= t.length()) hi = mid - 1; else lo = mid + 1; } ans += n - lo; } io.println(ans);} Beautiful Path二分答案，将除法转化为乘法，因为顶点的边限制 \\(u&lt;v\\)，所以从 \\(1\\) 到 \\(n\\) 处理顶点就是拓扑序，并且一定没有环，拓扑序动态规划求最长路径即可。（额，昨天刚做拓扑序动态规划求最长路径，竟然还没做出这题。） 1234567891011121314151617181920212223242526272829303132333435363738public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n]; List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, b = io.nextInt(), c = io.nextInt(); g[u].add(new int[]{v, b, c}); in[v]++; } double lo = 0, hi = 1e4; while (hi - lo &gt;= 1e-10) { double mid = lo + (hi - lo) / 2; if (check(g, in.clone(), mid)) lo = mid; else hi = mid; } io.println(lo);}private static boolean check(List&lt;int[]&gt;[] g, int[] in, double x) { int n = g.length; double[] dist = new double[n]; Arrays.fill(dist, Long.MIN_VALUE); dist[0] = 0; for (int u = 0; u &lt; n; u++) { for (int[] t : g[u]) { int v = t[0], b = t[1], c = t[2]; if (dist[v] &lt; dist[u] + b - c * x) { dist[v] = dist[u] + b - c * x; } } } return dist[n - 1] &gt;= 0;}","link":"/2023/10/16/AtCoder%20Beginner%20Contest%20324/"},{"title":"AtCoder Beginner Contest 325","text":"Takahashi san12345public static void solve() { String s = io.next(); io.next(); io.println(s + &quot; san&quot;);} World Meeting比赛时用滑窗没有做出来，原来要滑两倍的数组长度啊。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] cnt = new int[24]; for (int i = 0; i &lt; n; i++) { int w = io.nextInt(), x = io.nextInt(); cnt[x] += w; } int ans = 0; for (int i = 0; i &lt; 24; i++) { int sum = 0; for (int j = 0; j &lt; 9; j++) { sum += cnt[(i + j) % 24]; } ans = Math.max(ans, sum); } io.println(ans);} Sensors直接 DFS 或者并查集都行。 1234567891011121314151617181920212223242526272829303132public static void solve() { int h = io.nextInt(), w = io.nextInt(); boolean[][] g = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { String s = io.next(); for (int j = 0; j &lt; w; j++) { if (s.charAt(j) == '#') { g[i][j] = true; } } } int ans = 0; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { if (g[i][j]) { ans++; dfs(i, j, g); } } } io.println(ans);}private static void dfs(int x, int y, boolean[][] g) { if (x &lt; 0 || x &gt;= g.length || y &lt; 0 || y &gt;= g[0].length || !g[x][y]) return; g[x][y] = false; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { dfs(x + i, y + j, g); } }} Printing Machine贪心，对于每个时刻，我们选择已经进入传送带的，右端点最小的产品。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); long[][] aux = new long[n][]; for (int i = 0; i &lt; n; i++) { long t = io.nextLong(), d = io.nextLong(); aux[i] = new long[]{t, t + d}; } Arrays.sort(aux, (a, b) -&gt; Long.compare(a[0], b[0])); int i = 0, ans = 0; Queue&lt;Long&gt; q = new PriorityQueue&lt;&gt;(); for (long t = 0; ; t++) { if (q.isEmpty()) { if (i == n) break; t = aux[i][0]; } while (i &lt; n &amp;&amp; aux[i][0] == t) { q.offer(aux[i++][1]); } while (!q.isEmpty() &amp;&amp; q.peek() &lt; t) { q.poll(); } if (!q.isEmpty()) { ans++; q.poll(); } } io.println(ans);}","link":"/2023/10/24/AtCoder%20Beginner%20Contest%20325/"},{"title":"第 368 场力扣周赛","text":"元素和最小的山形三元组 I同下。 元素和最小的山形三元组 II前后缀分解。 1234567891011121314151617181920class Solution { public int minimumSum(int[] nums) { int n = nums.length; int[] pre = new int[n + 1], suf = new int[n + 1]; pre[0] = suf[n] = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { pre[i + 1] = Math.min(pre[i], nums[i]); } for (int i = n - 1; i &gt;= 0; i--) { suf[i] = Math.min(suf[i + 1], nums[i]); } int ans = Integer.MAX_VALUE; for (int i = 1; i &lt; n - 1; i++) { if (nums[i] &gt; pre[i] &amp;&amp; nums[i] &gt; suf[i + 1]) { ans = Math.min(ans, pre[i] + nums[i] + suf[i + 1]); } } return ans == Integer.MAX_VALUE ? -1 : ans; }} 合法分组的最少组数贪心，不太会，直接看题解。 1234567891011121314151617181920212223242526class Solution { public int minGroupsForValidAssignment(int[] nums) { Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int x : nums) { cnt.merge(x, 1, Integer::sum); } int k = nums.length; for (int x : cnt.values()) { k = Math.min(k, x); } for (; ; k--) { int ans = 0; for (int x : cnt.values()) { if (x / k &lt; x % k) { ans = 0; break; } ans += (x + k) / (k + 1); } if (ans &gt; 0) { return ans; } } }} 得到 K 个半回文串的最少修改次数直接记忆化搜索就能搞定，特别注意子字符串的长度要求至少为 \\(2\\)。当然还可以预处理出所有因子，也可以将记忆化搜索转化为自底向上的动态规划。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public int minimumChanges(String s, int k) { int n = s.length(); int[][] change = new int[n][n]; for (int i = 0; i &lt; n - 1; i++) { for (int j = i + 1; j &lt; n; j++) { change[i][j] = calc(s.substring(i, j + 1)); } } int[][] dp = new int[n][k]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], -1); } return dfs(0, s, n, k - 1, change, dp); } private int calc(String s) { int n = s.length(), res = n; for (int d = 1; d &lt; n; d++) { if (n % d == 0) { int cnt = 0; for (int k = 0; k &lt; d; k++) { for (int i = k, j = n - d + k; i &lt; j; i += d, j -= d) { if (s.charAt(i) != s.charAt(j)) { cnt++; } } } res = Math.min(res, cnt); } } return res; } private int dfs(int i, String s, int n, int k, int[][] change, int[][] dp) { if (k == 0) { return change[i][n - 1]; } if (dp[i][k] != -1) { return dp[i][k]; } int res = n; for (int j = i + 1; j &lt; n - 2 * k; j++) { res = Math.min(res, dfs(j + 1, s, n, k - 1, change, dp) + change[i][j]); } return dp[i][k] = res; }}","link":"/2023/10/24/%E7%AC%AC%20368%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 904 (Div. 2)","text":"Simple Design12345678910111213141516public static void solve() { int x = io.nextInt(), k = io.nextInt(); while (sum(x) % k != 0) { x++; } io.println(x);}private static int sum(int x) { int res = 0; while (x != 0) { res += x % 10; x /= 10; } return res;} Haunted House好难啊，做得很慢。对于每个 \\(i\\)，如果它是满足条件的，那么 \\([n-i,n-1]\\) 需要全为 \\(0\\)，它的最少操作次数为 \\([n-i,n-1]\\) 中所有值为 \\(1\\) 的下标和，减去 \\([0,n-i-1]\\) 中最近的值为 \\(0\\) 的对应个数的下标和。我们可以使用双指针 \\(O(n)\\) 的计算所有 \\(i\\)，具体见代码。指针 \\(j\\) 枚举每个下标，同时求出后缀的下标和，指针 \\(i\\) 指向指针 \\(j\\) 需要的最远的 \\(0\\) 的下标位置，同时求出后缀值为 \\(0\\) 的下标和，它们的差值就是 \\(j\\) 的最少操作次数。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); String s = io.next(); long sum = 0L; int i, j, cnt = 0; for (i = n - 1, j = n - 1; i &gt;= 0; j--) { cnt++; sum += j; for (; i &gt;= 0 &amp;&amp; cnt &gt; 0; i--) { if (s.charAt(i) == '0') { cnt--; sum -= i; } } io.print(cnt &gt; 0 ? &quot;-1 &quot; : sum + &quot; &quot;); } io.println(&quot;-1 &quot;.repeat(j + 1));} 发现一个超级简单的写法，基本思路就是从低到高放置 \\(0\\)，操作次数即为 \\(0\\) 的移动次数，废话不多说，代码很好懂。 123456789101112131415public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 0L; int l = n - 1, r = n - 1; for (; l &gt;= 0; l--) { if (s[l] == '0') { ans += r - l; r--; io.print(ans + &quot; &quot;); } } io.println(&quot;-1 &quot;.repeat(r + 1));} Medium Design最小值一定在位置 \\(1\\) 或位置 \\(m\\)，我们可以考虑处理区间不包含 \\(1\\) 和不包含 \\(m\\) 两种情况下，能够得到的最大值，根据简单的推导可以知道问题是等价的。如何计算最大值，根据题解所说似乎是扫描线算法，使用 \\((l,1)\\) 表示进入某个区间，\\((r,-1)\\) 表示离开某个区间，注意初始时我们将每个左端点减 \\(1\\)，表示从区间 \\(0\\) 开始算，\\((l,r)\\) 是左闭右开区间，所以 \\(r\\) 表示离开某个区间，然后每当处理完某个端点就更新答案。（其实也可以使用差分哈希表进行区间求和） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] l = new int[n]; int[] r = new int[n]; for (int i = 0; i &lt; n; i++) { l[i] = io.nextInt() - 1; r[i] = io.nextInt(); } // 第一次扫描，不包含第一个位置 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (l[i] != 0) { list.add(new int[]{l[i], 1}); list.add(new int[]{r[i], -1}); } } list.sort((a, b) -&gt; a[0] - b[0]); int ans = sweep(list); // 第二次扫描，不包含最后一个位置 list.clear(); for (int i = 0; i &lt; n; i++) { if (r[i] != m) { list.add(new int[]{l[i], 1}); list.add(new int[]{r[i], -1}); } } list.sort((a, b) -&gt; a[0] - b[0]); ans = Math.max(ans, sweep(list)); io.println(ans);}private static int sweep(List&lt;int[]&gt; list) { // cnt 表示在多少个区间内 // lst 表示上次处理的端点 int res = 0, cnt = 0, lst = 0; for (int[] t : list) { if (t[0] &gt; lst) { res = Math.max(res, cnt); } cnt += t[1]; lst = t[0]; } return res;} Counting Rhyme一对数 \\(x,y\\) 不能同时被数组中的数整除，即 \\(\\gcd(x,y)\\) 不能被数组中的数整除。我们首先可以计算出数组中有多少对数它们的 \\(\\gcd=1,2,3\\dots,n\\)，然后排除掉能够被数组中的数整除的 \\(\\gcd\\)，剩下的 \\(\\gcd\\) 对应的对数之和就是答案。第一步可以使用动态规划求解，转移方程如下： $$ sum = cnt[i]+cnt[2\\times i]+\\cdots+cnt[k\\times i] \\\\ dp[i]= \\frac{sum\\times (sum-1)}{2}-(dp[2\\times i]+dp[3\\times i]+\\cdots+dp[k\\times i]) $$ 第二步切记不能枚举数组中的数来排除，这样在所有值都为 \\(1\\) 的样例下时间复杂度会达到 \\(O(n^{2})\\)，除非将数组去重，或者像下面代码一样枚举。最后计算答案即可。本题的另一种解法是 GCD 卷积，暂时不学。 123456789101112131415161718192021222324252627282930313233public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] cnt = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); cnt[a[i]]++; } long[] dp = new long[n + 1]; for (int i = n; i &gt; 0; i--) { long tot = 0L; for (int j = i; j &lt;= n; j += i) { tot += cnt[j]; dp[i] -= dp[j]; } dp[i] += tot * (tot - 1) / 2; } for (int i = 1; i &lt;= n; i++) { if (cnt[i] != 0) { for (int j = i; j &lt;= n; j += i) { dp[j] = 0; } } } long ans = 0L; for (int i = 1; i &lt;= n; i++) { ans += dp[i]; } io.println(ans);}","link":"/2023/10/24/Codeforces%20Round%20904%20(Div.%202)/"},{"title":"Codeforces Round 905 (Div. 2)","text":"Chemistry只要奇数字母的个数不大于 \\(k+1\\) 即可，因为回文串最多有一个奇数字母。 1234567891011121314151617public static void solve() { int n = io.nextInt(), k = io.nextInt(); String s = io.next(); int[] cnt = new int[26]; for (int i = 0; i &lt; n; i++) { cnt[s.charAt(i) - 'a']++; } int sum = 0; for (int x : cnt) { if (x % 2 == 1) { sum++; } } io.println(sum - 1 &gt; k ? &quot;NO&quot; : &quot;YES&quot;);} Raspberries当 \\(k=2,3,5\\) 时，因为 \\(k\\) 是质数，如果所有数的乘积能够被 \\(k\\) 整除，必定存在一个数能够被 \\(k\\) 整除，所以单独计算每个数即可。当 \\(k=4\\) 时，需要计算存在一个数能被 \\(4\\) 整除的最少操作数，还需要计算存在两个能被 \\(2\\) 整除的数的最少操作数，答案为两者的最小值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); int cnt = 0; int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); if (a[i] % 2 == 0) { cnt++; } } int ans = k; for (int i = 0; i &lt; n; i++) { ans = Math.min(ans, (k - a[i] % k) % k); } if (k == 4) { ans = Math.min(ans, Math.max(0, 2 - cnt)); } io.println(ans);} You Are So Beautiful如果某个子数组作为子序列只出现过一次，因为子数组本身就是子序列，所以没有其他方式能够构成该子数组，即子数组的左端点左边没有和它相同的数，右端点的右边也没有和它相同的数。我们可以使用集合 + 前缀和的方式预先计算每个位置及其左边满足条件的左端点个数，然后倒序处理数组，对每个满足条件的右端点，都将其对应的左端点的个数添加到答案。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int[] prefix = new int[n + 1]; for (int i = 0; i &lt; n; i++) { prefix[i + 1] = prefix[i] + (set.add(a[i]) ? 1 : 0); } set.clear(); long ans = 0L; for (int i = n - 1; i &gt;= 0; i--) { if (set.add(a[i])) { ans += prefix[i + 1]; } } io.println(ans);} Dances (Easy version)题目真难读，简单版只会在数组 \\(a\\) 中添加一个 \\(1\\)，然后计算最少操作数，可以使用排序 + 双指针进行处理。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; a[0] = 1; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(a); Arrays.sort(b); int k = 0; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { k++; j++; } } io.println(k);} Dances (Hard Version)困难版，计算在数组中分别添加 \\([1,m]\\) 需要的最少操作数。通过观察可以发现（真发现不了），改变 \\(a[0]\\) 最多只会使操作次数加 \\(1\\)，所以我们可以二分该边界值，然后计算答案即可。 12345678910111213141516171819202122232425262728293031323334353637public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(b); int k = calc(a, b, 1); int lo = 1, hi = m; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (calc(a, b, mid) == k) lo = mid + 1; else hi = mid - 1; } io.println((long) m * k + (m - lo + 1));}private static int calc(int[] a, int[] b, int x) { a[0] = x; a = a.clone(); Arrays.sort(a); int n = a.length, k = 0; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { k++; j++; } } return k;} 竟然还有更简单的方法，首先计算 \\(a\\) 中 \\(n-1\\) 个数对应 \\(b\\) 中 \\(n\\) 个数的最少删除次数，并同时维护 \\(b\\) 中不满足 \\(a[i]&lt;b[j]\\) 的最后一个值，该值就是操作次数的分界点，直接计算答案即可。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; a[0] = Integer.MAX_VALUE; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(a); Arrays.sort(b); int k = 0, val = m + 1; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { val = b[j]; k++; j++; } } io.println((long) m * (k - 1) + Math.max(0, m - val + 1));}","link":"/2023/10/24/Codeforces%20Round%20905%20(Div.%202)/"},{"title":"动态规划","text":"本文内容参考《算法导论》，OI Wiki。 基础知识动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。 适合应用动态规划方法求解的最优化问题应该具备两个要素：最优子结构和重叠子问题。 最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 重叠子问题：如果问题的递归算法会反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。 子问题图 子问题图是一个有向图，每个顶点唯一的对应一个子问题。若求子问题 \\(x\\) 的最优解时需要直接用到子问题 \\(y\\) 的最优解，那么在子问题图中就会有一条从子问题 \\(x\\) 的顶点到子问题 \\(y\\) 的顶点的有向边。 自顶向下动态规划处理子问题图中顶点的顺序为拓扑序，自底向上动态规划处理子问题图中顶点的顺序为逆拓扑序。 通常情况下，动态规划算法的运行时间与子问题图中顶点和边的数量呈线性关系。 选择自顶向下，还是自底向上 通常情况下，如果每个子问题都必须至少求解一次，自底向上动态规划算法会更快，因为没有递归调用的开销，而且对于某些问题，可以利用表的访问模式降低时空开销。如果子问题空间中的某些子问题完全不必求解，自顶向下动态规划算法会更快，因为它只会求解那些必要的子问题。 背包 DP题目：有 \\(n\\) 种物品和一个容量为 \\(W\\) 的背包，每种物品有数量 \\(k_{i}\\)、重量 \\(w_{i}\\) 和价值 \\(v_{i}\\) 三种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。 0-1 背包 每种物品只能取一次，即 \\(k_{i}=1\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max{(dp[i-1][j],dp[i-1][j-w[i]]+v[i])} $$ 空间优化（倒序枚举）： $$ dp[j]=\\max{(dp[j],dp[j-w[i]]+v[i])} $$ 完全背包 每种物品可以取无限次，即 \\(k_{i}=\\infty\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max_{k=0}^{\\infty}{dp[i-1][j-k\\cdot w[i]]+k\\cdot v[i]} $$ 方程优化： $$ dp[i][j]=\\max{(dp[i-1][j],dp[i][j-w[i]]+v[i])} $$ 空间优化（正序枚举）： $$ dp[j]=\\max(dp[j],dp[j-w[i]]+v[i]) $$ 多重背包 每种物品可以取 \\(k_{i}\\) 次，即 \\(k_{i}\\in\\mathbb{N}\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max_{k=0}^{k[i]}{dp[i-1][j-k\\cdot w[i]]+k\\cdot v[i]} $$ 二进制分组优化：将每种物品的 \\(k_{i}\\) 拆分为多个组，每组的数量为 \\(2^{0},2^{1},\\dots,2^{\\lfloor{\\log{k_{i}+1}}\\rfloor -1}\\)，如果 \\(k_{i}+1\\) 不是二的幂，就将多余的数量作为一组，最后将 \\(k_{i}\\) 拆出来的每组都看作数量为 \\(1\\) 的新物品，从而转化为 0-1 背包。可以证明，如果选择 \\(x\\) 次第 \\(i\\) 种物品，其中 \\(x\\in[0,k_{i}]\\)，则该选择方式总是可以由分组后的新物品的某个组合表示。 例题 线性 DP：1143. 最长公共子序列，300. 最长递增子序列，72. 编辑距离。 背包 DP：416. 分割等和子集，322. 零钱兑换，2902. 和带限制的子多重集合的数目。 区间 DP：516. 最长回文子序列，1000. 合并石头的最低成本。 树形 DP：2646. 最小化旅行的价格总和，834. 树中距离之和，2867. 统计树中的合法路径数目。 状压 DP：526. 优美的排列，Mondriaan’s Dream。 数位 DP：233. 数字 1 的个数，1012. 至少有 1 位重复的数字。 概率 DP：D. Bag of mice，E - Roulettes。","link":"/2023/10/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"排序算法","text":"本文内容参考 sorting-algorithms，《算法》，《算法导论》。（强迫症，最后还是把描述性的文字删了，只贴代码） 验证算法的正确性，可以使用：912. 排序数组，148. 排序链表，164. 最大间距。 简单概述理想的排序算法 稳定性：相同键不会重新排序。 原地排序：不使用额外空间存储排序数据。 最坏情况 \\(O(n\\log{n})\\) 次比较，\\(O(n)\\) 次交换。 适应性：当数据接近排序或唯一键很少时，时间复杂度为 \\(O(n)\\)。 如何看待常数因子的改进方案 摘抄自《算法》的一段内容：在每一节中，我们会将书中的每个算法都看做某种应用的关键。但在整体上，我们希望学习的是为每种应用找到最合适的算法。我们并不是在推荐读者一定要实现所有提到的改进方法，而是提醒大家不要对算法初始实现的性能盖棺定论。研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。实现那些只能把运行时间缩短某个常数因子的改进措施可能并不值得。你需要用实验来检验一项改进，正如本书练习所演示的那样。 冒泡排序 稳定性：稳定。 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n)\\)。 1234567891011121314private static void bubbleSort(int[] nums) { int n = nums.length, pos; for (int i = n - 1; i &gt; 0; i = pos) { pos = 0; for (int j = 0; j &lt; i; j++) { // 稳定性的关键 if (nums[j] &gt; nums[j + 1]) { swap(nums, j, j + 1); // 将最后交换的位置，作为下次冒泡的上界 pos = j; } } }} 选择排序 稳定性：不稳定。 时间复杂度：\\(O(n^{2})\\)。元素的交换次数最少的排序算法。 空间复杂度：\\(O(1)\\)。 123456789101112private static void selectionSort(int[] nums) { int n = nums.length; for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } if (minIndex != i) swap(nums, minIndex, i); }} 插入排序 稳定性：稳定。 时间复杂度：\\(O(n^{2})\\)。元素的交换次数等于逆序数。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n)\\)。 1234567891011private static void insertionSort(int[] nums) { int n = nums.length; for (int i = 1; i &lt; n; i++) { int j = i - 1, t = nums[i]; // 稳定性的关键 for (; j &gt;= 0 &amp;&amp; nums[j] &gt; t; j--) { nums[j + 1] = nums[j]; } nums[j + 1] = t; }} 希尔排序 稳定性：不稳定。 时间复杂度：使用 Knuth 增量序列 \\(O(n^{\\frac{3}{2}})\\)，。Knuth 增量序列：\\(1,4,13,40,\\dots,\\frac{3^{k}-1}{2}\\)，相当于首项为 \\(1\\)，公比为 \\(3\\) 的数列的前缀和。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n\\log{n})\\)。 1234567891011121314private static void insertionSort(int[] nums) { int n = nums.length, h = 1; while (h &lt; n / 3) h = 3 * h + 1; while (h &gt;= 1) { for (int i = h; i &lt; n; i++) { int j = i - h, t = nums[i]; for (; j &gt;= 0 &amp;&amp; nums[j] &gt; t; j -= h) { nums[j + h] = nums[j]; } nums[j + h] = t; } h /= 3; }} 归并排序 稳定性：稳定的。 时间复杂度：\\(O(n\\log{n})\\)。 空间复杂度：排序数组 \\(O(n)\\)；自顶向下排序链表 \\(O(\\log{n})\\)（递归的空间），自底向上排序链表 \\(O(1)\\)。 顺序访问数据，缓存友好。 实现一：自顶向下（数组） 123456789101112131415161718192021222324252627private static void mergeSort(int[] nums) { int n = nums.length; int[] aux = new int[n]; mergeSort(nums, aux, 0, n - 1);}private static void mergeSort(int[] nums, int[] aux, int lo, int hi) { if (lo &gt;= hi) return; int mid = lo + (hi - lo) / 2; mergeSort(nums, aux, lo, mid); mergeSort(nums, aux, mid + 1, hi); merge(nums, aux, lo, mid, hi);}private static void merge(int[] nums, int[] aux, int lo, int mid, int hi) { for (int i = lo; i &lt;= hi; i++) { aux[i] = nums[i]; } int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; // 稳定性的关键 else if (aux[i] &lt;= aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; }} 实现二：自底向上（数组） 1234567891011121314151617181920212223private static void mergeSort(int[] nums) { int n = nums.length; int[] aux = new int[n]; for (int len = 1; len &lt; n; len += len) { for (int i = 0; i + len &lt; n; i += len &lt;&lt; 1) { merge(nums, aux, i, i + len - 1, Math.min(n - 1, i + (len &lt;&lt; 1) - 1)); } }}private static void merge(int[] nums, int[] aux, int lo, int mid, int hi) { for (int i = lo; i &lt;= hi; i++) { aux[i] = nums[i]; } int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; // 稳定性的关键 else if (aux[i] &lt;= aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; }} 实现三：自顶向下（链表） 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static ListNode mergeSort(ListNode head) { if (head == null || head.next == null) { return head; } // 分为两个子链表 ListNode mid = middleNode(head); ListNode next = mid.next; mid.next = null; head = mergeSort(head); next = mergeSort(next); return merge(head, next);}// 返回合并链表的头节点private static ListNode merge(ListNode head1, ListNode head2) { ListNode dummy = new ListNode(), curr = dummy; while (head1 != null &amp;&amp; head2 != null) { // 稳定性的关键 if (head1.val &lt;= head2.val) { curr.next = head1; head1 = head1.next; } else { curr.next = head2; head2 = head2.next; } curr = curr.next; } curr.next = head1 != null ? head1 : head2; return dummy.next;}// 调用保证 head != null，并且如果有两个中间节点，则返回前一个（不然会无限递归）// 使用 fast = head.next 可以保证返回前一个中间节点// 使用 fast = head 可以保证返回后一个中间节点private static ListNode middleNode(ListNode head) { if (head == null) return head; ListNode slow = head, fast = head.next; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;} 实现四：自底向上（链表） 下面这个是没有提前计算链表长度，没有断开链表的解法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static ListNode mergeSort(ListNode head) { if (head == null || head.next == null) return head; int len = 1; ListNode dummy = new ListNode(-1, head); while (true) { // 两个子链表的头节点的前一个节点 ListNode prev1, prev2; prev1 = prev2 = dummy; while (true) { for (int i = 0; i &lt; len &amp;&amp; prev2 != null; i++) { prev2 = prev2.next; } if (prev2 == null || prev2.next == null) break; prev1 = prev2 = merge(prev1, prev2, len); } // 如果该轮没有进行合并操作，则排序完成 if (prev1 == dummy) break; len += len; } return dummy.next;}// 返回合并链表的尾节点private static ListNode merge(ListNode prev1, ListNode prev2, int len) { // 判断条件：第一个链表未结束 &amp;&amp; 第二个链表未结束（考虑长度不足的情况） while (prev1 != prev2 &amp;&amp; len != 0 &amp;&amp; prev2.next != null) { // 稳定性的关键 if (prev1.next.val &gt; prev2.next.val) { // 将 prev2.next 插入到 prev1 之后 ListNode temp = prev2.next; prev2.next = prev2.next.next; temp.next = prev1.next; prev1.next = temp; len--; } prev1 = prev1.next; } // 使 prev2 指向合并链表的尾节点 while (len-- != 0 &amp;&amp; prev2.next != null) prev2 = prev2.next; return prev2;} 快速排序 稳定性：不稳定。 时间复杂度：期望 \\(O(n\\log{n})\\)。 空间复杂度：期望 \\(O(\\log{n})\\)。 如果使用三路快排，数据包含大量重复元素时，时间复杂度为 \\(O(n)\\)。 实现一：二路快排 1234567891011121314151617181920212223242526272829private static void quickSort(int[] nums) { int n = nums.length; quickSort(nums, 0, n - 1);}private static void quickSort(int[] nums, int lo, int hi) { if (lo &gt;= hi) return; int index = partition(nums, lo, hi); quickSort(nums, lo, index - 1); quickSort(nums, index + 1, hi);}private static int partition(int[] nums, int lo, int hi) { // 三数取中 int mid = median3(nums, lo, lo + (hi - lo) / 2, hi); swap(nums, lo, mid); int key = nums[lo]; int i = lo, j = hi + 1; while (true) { // 和切分元素相等的元素也会停顿并交换 while (nums[++i] &lt; key &amp;&amp; i != hi); while (nums[--j] &gt; key); if (i &gt;= j) break; swap(nums, i, j); } swap(nums, lo, j); return j;} 实现二：三路快排 12345678910111213141516171819202122232425private static final Random RANDOM = new Random();private static void quickSort(int[] nums) { int n = nums.length; quickSort(nums, 0, n - 1);}private static void quickSort(int[] nums, int lo, int hi) { if (lo &gt;= hi) return; // 随机选择 int randomIndex = lo + RANDOM.nextInt(hi - lo + 1); swap(nums, randomIndex, lo); int key = nums[lo]; int lt = lo, gt = hi, i = lo + 1; while (i &lt;= gt) { if (nums[i] &lt; key) swap(nums, i++, lt++); else if (nums[i] &gt; key) swap(nums, i, gt--); else i++; } quickSort(nums, lo, lt - 1); quickSort(nums, gt + 1, hi);} 堆排序 稳定性：不稳定。 时间复杂度：\\(O(n\\log{n})\\)。 空间复杂度：\\(O(1)\\)。 随机访问数据，缓存不友好。 12345678910111213141516171819202122232425262728public static void heapSort(int[] nums) { int n = nums.length; // 建堆 - 时间复杂度 O(n) for (int i = n / 2 - 1; i &gt;= 0; i--) { sink(nums, i, n - 1); } // 排序 - 时间复杂度 O(nlog(n)) for (int i = n - 1; i &gt; 0; ) { swap(nums, 0, i--); sink(nums, 0, i); }}private static void sink(int[] nums, int i, int n) { int t = nums[i]; while (2 * i + 1 &lt;= n) { int j = 2 * i + 1; if (j + 1 &lt;= n &amp;&amp; nums[j + 1] &gt; nums[j]) { j++; } if (t &gt;= nums[j]) break; nums[i] = nums[j]; i = j; } nums[i] = t;} 计数排序 稳定性：稳定。 时间复杂度：\\(O(n+k)\\)。 空间复杂度：\\(O(n+k)\\)。 12345678910111213141516171819202122// 元素取值范围 [0,k)private static int[] countingSort(int[] nums, int k) { int n = nums.length; int[] cnt = new int[k]; int[] res = new int[n]; // 计数 for (int x : nums) { cnt[x]++; } // 前缀和 for (int i = 1; i &lt; k; i++) { cnt[i] += cnt[i - 1]; } // 排序（倒序遍历，保证稳定性） for (int i = n - 1; i &gt;= 0; i--) { res[--cnt[nums[i]]] = nums[i]; } return res;} 基数排序 稳定性：稳定。 时间复杂度：\\(O(d\\cdot (n+k))\\)。 空间复杂度：\\(O(n+k)\\)。 12345678910111213141516171819202122232425262728293031323334353637// 元素最多有 d 位private static int[] radixSort(int[] nums, int d) { int n = nums.length; int[] cnt = new int[10]; int[] aux = new int[n]; int divisor = 1; for (int i = 0; i &lt; d; i++) { countingSort(nums, cnt, aux, divisor); Arrays.fill(cnt, 0); divisor *= 10; int[] t = nums; nums = aux; aux = t; } return nums;}private static void countingSort(int[] nums, int[] cnt, int[] aux, int divisor) { int n = nums.length; // 计数 for (int x : nums) { cnt[x / divisor % 10]++; } // 前缀和 for (int i = 1; i &lt; 10; i++) { cnt[i] += cnt[i - 1]; } // 排序（倒序遍历，保证稳定性） for (int i = n - 1; i &gt;= 0; i--) { aux[--cnt[nums[i] / divisor % 10]] = nums[i]; }} 桶排序 稳定性：取决于桶内的排序策略。 时间复杂度：期望 \\(O(n)\\)。（输入数据均匀分布时） 空间复杂度：\\(O(n+m)\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static void bucketSort(int[] nums) { int n = nums.length; if (n &lt;= 1) return; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int x : nums) { min = Math.min(min, x); max = Math.max(max, x); } // 小心除以零 int inter = Math.max(1, (max - min) / (n - 1)); int bucketSize = (max - min) / inter + 1; List&lt;Integer&gt;[] buckets = new List[bucketSize]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int x : nums) { int i = (x - min) / inter; buckets[i].add(x); // 插入排序 int j = buckets[i].size() - 1; for (; j &gt; 0 &amp;&amp; buckets[i].get(j - 1) &gt; x; j--) { buckets[i].set(j, buckets[i].get(j - 1)); } buckets[i].set(j, x); } int idx = 0; for (var bucket : buckets) { for (int x : bucket) { nums[idx++] = x; } }}","link":"/2023/10/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"字符串","text":"本文内容参考《算法》，《算法导论》，OI Wiki。 字符串匹配例题 28. 找出字符串中第一个匹配项的下标。 暴力 时间复杂度：最坏 \\(O(NM)\\)，平均 \\(O(N)\\)。 空间复杂度：\\(O(1)\\)。 12345678910111213private static int bruteForce(String text, String pattern) { int i, j; int n = text.length(), m = pattern.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { if (text.charAt(i) == pattern.charAt(j)) { j++; } else { i -= j; j = 0; } } return j == m ? i - m : -1;} KMP 时间复杂度：\\(O(N)\\)。 空间复杂度：\\(O(M)\\)。 12345678910111213141516171819202122232425262728293031private static int kmp(String text, String pattern) { int n = text.length(), m = pattern.length(); if (m &gt; n) return -1; // 处理模式串 // next[i] 表示 pattern 的子串 [0, i] 的最长相等前后缀的长度 int[] next = new int[m]; for (int i = 1, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j)) { j = next[j - 1]; } if (pattern.charAt(i) == pattern.charAt(j)) { j++; } next[i] = j; } // 匹配文本串 for (int i = 0, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; text.charAt(i) != pattern.charAt(j)) { j = next[j - 1]; } if (text.charAt(i) == pattern.charAt(j)) { j++; } if (j == m) { return i - m + 1; } } return -1;} Boyer-Moore 时间复杂度：最坏 \\(O(NM)\\)，平均 \\(O(\\frac{N}{M})\\)。 空间复杂度：\\(O(R)\\)。 1System.out.println(&quot;TODO&quot;); Rabin-Karp 时间复杂度：\\(O(N)\\)。 空间复杂度：\\(O(1)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041private static final int P = 13331;// MOD = 2^64private static int rabinKarp(String text, String pattern) { int n = text.length(), m = pattern.length(); if (m &gt; n) return -1; long PM = pow(P, m - 1); long patHash = hash(pattern, m); long txtHash = hash(text, m); if (txtHash == patHash) { return 0; } for (int i = m; i &lt; n; i++) { txtHash = txtHash - text.charAt(i - m) * PM; txtHash = txtHash * P + text.charAt(i); if (txtHash == patHash) { return i - m + 1; } } return -1;}private static long pow(int a, int n) { long res = 1L, x = a; for (; n != 0; x *= x, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res *= x; } } return res;}private static long hash(String s, int m) { long h = 0L; for (int i = 0; i &lt; m; i++) { h = h * P + s.charAt(i); } return h;} 字符串哈希例题 E. Compress Words（这题使用 \\(MOD=2^{64}\\) 一直在第 65 个测试点 WA，看来还是模质数比较好）。 实现 时间复杂度：预处理 \\(O(N)\\)，获取哈希值 \\(O(1)\\)。 空间复杂度：\\(O(N)\\)。 123456789101112131415161718192021222324252627282930313233343536373839404142class StringHash { private final int K = 2; private static final long[] b = {131, 13331}; private static final long[] m = {1_000_000_007, 998244353}; private int index; private final long[][] h, p; public StringHash(int n) { h = new long[K][n + 1]; p = new long[K][n + 1]; for (int i = 0; i &lt; K; i++) { p[i][0] = 1; } } public StringHash(char[] s) { this(s.length); for (char c : s) add(c); } public void add(char c) { for (int j = 0; j &lt; K; j++) { p[j][index + 1] = p[j][index] * b[j] % m[j]; h[j][index + 1] = (h[j][index] * b[j] + c) % m[j]; } index++; } public long[] get(int l, int r) { long[] res = new long[K]; for (int i = 0; i &lt; K; i++) { long t = h[i][r + 1] - h[i][l] * p[i][r - l + 1]; res[i] = (t % m[i] + m[i]) % m[i]; } return res; } public int length() { return index; }} 字典树（Trie）例题 208. 实现 Trie (前缀树)。 1803. 统计异或值在范围内的数对有多少。 实现 时间复杂度：插入和查找都是 \\(O(k)\\)，其中 \\(k\\) 为字符串的长度。 空间复杂度：\\(O(nR)\\)，其中 \\(n\\) 为节点总数，\\(R\\) 为字母表大小。 12345678910111213141516171819202122232425262728293031323334353637class Trie { private static final int R = 26; private final Node root; private static class Node { boolean exist; Node[] next = new Node[R]; } public Trie() { root = new Node(); } public void insert(String word) { Node node = root; for (int i = 0; i &lt; word.length(); i++) { int idx = word.charAt(i) - 'a'; if (node.next[idx] == null) { node.next[idx] = new Node(); } node = node.next[idx]; } node.exist = true; } public boolean search(String word) { Node node = root; for (int i = 0; i &lt; word.length(); i++) { int idx = word.charAt(i) - 'a'; if (node.next[idx] == null) { return false; } node = node.next[idx]; } return node.exist; }} AC 自动机例题 P5357 【模板】AC 自动机（二次加强版）。 实现 时间复杂度：插入 \\(O(k)\\)，构建 \\(O(nR)\\)，查询 \\(O(k+n)\\)，其中 \\(k\\) 为字符串的长度。 空间复杂度：\\(O(nR)\\)，其中 \\(n\\) 为节点总数，\\(R\\) 为字母表大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class AhoCorasickAutomaton { private static final int R = 26; private final Node root; // 按插入顺序存储模式串尾字符对应的节点 private final List&lt;Node&gt; patternNodes; // 所有节点按层次遍历顺序存储（代码没有存根节点） private final List&lt;Node&gt; levelOrderNodes; private static class Node { int cnt; // 节点出现在文本串中的次数，懒更新 Node fail; // 节点的失配指针，指向当前节点的最长后缀节点 Node[] next = new Node[R]; } public AhoCorasickAutomaton() { root = new Node(); patternNodes = new ArrayList&lt;&gt;(); levelOrderNodes = new ArrayList&lt;&gt;(); } // 插入模式串 public void insert(String pattern) { Node node = root; for (int i = 0; i &lt; pattern.length(); i++) { int idx = pattern.charAt(i) - 'a'; if (node.next[idx] == null) { node.next[idx] = new Node(); } node = node.next[idx]; } patternNodes.add(node); } // 构建失配指针和 Trie 图 public void build() { // 将根节点的直接子节点入队，并构建节点的失配指针和 Trie 图 // 提前入队是因为根节点和其直接子节点与其他节点的处理逻辑不同 root.fail = root; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; R; i++) { if (root.next[i] == null) { root.next[i] = root; } else { root.next[i].fail = root; q.offer(root.next[i]); } } // 层次遍历，构建失配指针和 Trie 图 while (!q.isEmpty()) { Node node = q.poll(); levelOrderNodes.add(node); for (int i = 0; i &lt; R; i++) { if (node.next[i] == null) { node.next[i] = node.fail.next[i]; } else { node.next[i].fail = node.fail.next[i]; q.offer(node.next[i]); } } } } // 查询每个模式串在文本串中的出现次数 public void query(String text, int[] cnt) { // 懒更新出现次数 Node node = root; for (int i = 0; i &lt; text.length(); i++) { int idx = text.charAt(i) - 'a'; node = node.next[idx]; node.cnt++; } // 倒序层次遍历，进一步沿着失配指针传递出现次数 // 倒序遍历是因为失配指针必然在更上层，所以从下向上传递可以保证正确性 for (int i = levelOrderNodes.size() - 1; i &gt;= 0; i--) { node = levelOrderNodes.get(i); node.fail.cnt += node.cnt; } // 获取每个模式串的出现次数 for (int i = 0; i &lt; patternNodes.size(); i++) { cnt[i] += patternNodes.get(i).cnt; } }} 正则表达式例题 10. 正则表达式匹配。使用动态规划或者构造非确定有限状态自动机（NFA）。 实现 时间复杂度：构造 NFA \\(O(m)\\)，匹配 \\(O(nm)\\)，其中 \\(m\\) 为正则表达式的长度，\\(n\\) 为文本串的长度。 空间复杂度：构造 NFA \\(O(m)\\)，匹配 \\(O(m)\\)。 1System.out.println(&quot;TODO&quot;);","link":"/2023/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"数学","text":"本文内容参考《算法导论》，OI Wiki。（数学好难，暂时搁置） 快速幂例题 P1226 【模板】快速幂。 509. 斐波那契数。 整数时间复杂度：\\(O(\\log{n})\\)。 1234567891011private static final long MOD = 1_000_000_007;private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;} 矩阵时间复杂度：\\(O(\\log{n})\\)。 1234567891011121314151617181920212223private static final int MOD = 1_000_000_007;private static long[][] pow(long[][] x, long n) { long[][] res = {{1, 0}, {0, 1}}; for (; n != 0; x = mul(x, x), n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = mul(res, x); } } return res;}private static long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) { c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % MOD; } } } return c;} 数论例题 204. 计数质数。 2521. 数组乘积中的不同质因数数目。 2447. 最大公因数等于 K 的子数组数目。 1250. 检查「好数组」。 判断质数时间复杂度 \\(O(n\\sqrt{n})\\)。 1234567private static boolean isPrime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i++) { if (x % i == 0) return false; } return true;} 质数筛法埃氏筛时间复杂度 \\(O(n\\log{\\log{n}})\\)，筛掉质数的倍数，每个合数都会被筛它的质因数的个数次。 123456789101112private static boolean[] sieveOfEratosthenes(int n) { boolean[] np = new boolean[n + 1]; np[0] = np[1] = true; for (int i = 2; i &lt;= n / i; i++) { if (np[i]) continue; for (int j = i; j &lt;= n / i; j++) { np[j * i] = true; } } return np;} 欧拉筛时间复杂度 \\(O(n)\\)，每个合数都只被它的最小质因数筛掉。 123456789101112131415private static boolean[] sieveOfEuler(int n) { int cnt = 0; int[] p = new int[n + 1]; boolean[] np = new boolean[n + 1]; np[0] = np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) p[cnt++] = i; for (int j = 0; p[j] &lt;= n / i; j++) { np[p[j] * i] = true; if (i % p[j] == 0) break; } } return np;} 分解质因数时间复杂度 \\(O(\\sqrt{n})\\)。 1234567891011private static Map&lt;Integer, Integer&gt; primeFactors(int x) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 2; i &lt;= x / i; i++) { while (x % i == 0) { x /= i; map.merge(i, 1, Integer::sum); } } if (x &gt; 1) map.merge(x, 1, Integer::sum); return map;} 欧拉函数欧拉函数 \\(\\phi(n)\\)，表示 \\([1,n]\\) 范围内和 \\(n\\) 互质的数的个数，有如下性质： 若 \\(\\gcd(a,b)=1\\)，则 \\(\\phi(a\\times b)=\\phi(a)\\times \\phi(b)\\)。 若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，其中 \\(p_{i}\\) 为质数，则 \\(\\phi(n)=n\\times\\prod_{i=1}^{k}(1-\\frac{1}{p_{i}})\\)。 我们可以使用分解质因数求解某个数的欧拉函数，时间复杂度为 \\(O(\\sqrt{n})\\)；也可以使用欧拉筛来求解 \\([1,n]\\) 范围内所有数的欧拉函数，时间复杂度为 \\(O(n)\\)。在欧拉筛中，每个合数都是被它的最小质因子筛掉，设 \\(p\\) 是 \\(n\\) 的最小质因子，则 \\(n=n^{\\prime}\\times p\\)，分类讨论： 如果 \\(n^{\\prime}\\bmod p\\neq 0\\)，因为 \\(p\\) 是质数，所以 \\(\\gcd(n^{\\prime},p)=1\\)，则 \\(\\phi(n)=\\phi(n^{\\prime})\\times \\phi(p)=\\phi(n^{\\prime})\\times (p-1)\\)。 如果 \\(n^{\\prime}\\bmod p=0\\)，则 \\(\\phi(n)=p\\times n^{\\prime}\\times\\prod_{i=1}^{k}(1-\\frac{1}{p_{i}})=p\\times \\phi(n^{\\prime})\\)。 123456789101112131415161718192021222324private static int[] sieveOfEuler(int n) { int cnt = 0; int[] p = new int[n + 1]; int[] phi = new int[n + 1]; boolean[] np = new boolean[n + 1]; phi[1] = 1; np[0] = np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) { p[cnt++] = i; phi[i] = i - 1; } for (int j = 0; p[j] &lt;= n / i; j++) { np[p[j] * i] = true; if (i % p[j] == 0) { phi[p[j] * i] = p[j] * phi[i]; break; } phi[p[j] * i] = (p[j] - 1) * phi[i]; } } return phi;} 最大公约数欧几里得算法时间复杂度 \\(O(\\log{\\max(a,b)})\\)。求得最大公约数之后，使用 \\(\\gcd(a,b)\\times\\operatorname{lcm}(a,b)=a\\times b\\) 公式可以得到最小公倍数。 1234private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} 扩展欧几里得算法常用于求解 \\(ax+by=\\gcd(a,b)\\) 的一组解。 1234567891011121314private static int x, y;private static int exgcd(int a, int b) { if (b == 0) { x = 1; y = 0; return a; } int d = exgcd(b, a % b); int t = x - a / b * y; x = y; y = t; return d;} 其他知识约数个数若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，则 \\(d_{n}=\\prod_{i=1}^{k}(c_{i}+1)\\)。 约数之和若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，则 \\(s_{n}=\\prod_{i=1}^{k}\\sum_{j=0}^{c_{i}}{p_{i}^{j}}\\)。 裴蜀定理若 \\(a,b\\) 是整数，则对于任意的整数 \\(x,y\\)，\\(ax+by\\) 总是 \\(\\gcd(a,b)\\) 的倍数，并且存在整数 \\(x,y\\)，使得 \\(ax+by=\\gcd(a,b)\\)。特别的，若存在整数 \\(x,y\\) 使得 \\(ax+by=1\\)，则 \\(\\gcd(a,b)=1\\)，即 \\(a,b\\) 互质。 费马小定理若 \\(p\\) 是质数，\\(\\gcd(a,p)=1\\)，则 \\(a^{p-1}\\equiv 1\\pmod{p}\\)。 欧拉定理若 \\(\\gcd(a,n)=1\\)，则 \\(a^{\\phi(n)}\\equiv 1\\pmod{n}\\)。 模乘法逆元若 \\(p\\) 是质数，根据费马小定理，有 \\(a\\times a^{-1}\\equiv 1\\equiv a^{p-1}\\pmod{p}\\)，得到 \\(a^{-1}\\equiv a^{p-2}\\pmod{p}\\)。 若 \\(b\\) 是任意整数，求 \\(a\\) 的逆元，等价于求 \\(ax\\equiv 1\\pmod{b}\\) 的解，等价于求 \\(ax+by=1\\) 的解。如果 \\(\\gcd(a,b)=1\\)，则可以使用扩展欧几里得算法求解该方程。如果 \\(\\gcd(a,b)\\neq 1\\)，根据裴蜀定理可知方程无解（或者可以将方程变换为 \\(\\frac{a}{g}x+\\frac{b}{g}y=\\frac{1}{g}\\)，等式左边是整数，右边不是整数，方程无解），即逆元不存在。 线性同余方程求 \\(ax\\equiv c\\pmod{b}\\) 的解，等价于求 \\(ax+by=c\\) 的解，同样的，当 \\(\\gcd(a,b)\\mid c\\) 时方程有解。使用扩展欧几里得算法可以求出 \\(ax+by=\\gcd(a,b)\\) 的解，然后将方程变换为 \\(a\\frac{c}{\\gcd(a,b)}x_{0}+b\\frac{c}{\\gcd(a,b)}y_{0}=c\\)，可以得到方程的解。","link":"/2023/10/26/%E6%95%B0%E5%AD%A6/"},{"title":"数据结构","text":"本文内容参考 OI Wiki。 并查集例题 P3367 【模板】并查集。 实现123456789101112131415161718192021222324252627282930313233343536373839class UnionFind { private final int[] f, s; private int c; public UnionFind(int n) { c = n; f = new int[n]; s = new int[n]; for (int i = 0; i &lt; n; i++) { f[i] = i; s[i] = 1; } } public int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x]; } public void union(int x, int y) { int rx = find(x), ry = find(y); if (rx == ry) return; f[ry] = rx; s[rx] += s[ry]; c--; } public boolean connected(int x, int y) { return find(x) == find(y); } public int size(int x) { return s[find(x)]; } public int count() { return c; }} 树状数组例题 #130. 树状数组 1 ：单点修改，区间查询。 #131. 树状数组 2 ：区间修改，单点查询。 #132. 树状数组 3 ：区间修改，区间查询。 实现单点修改，区间查询123456789101112131415161718192021222324252627class BIT { private final int n; private final long[] t; public BIT(int n) { this.n = n; t = new long[n + 1]; } public void add(int i, int k) { for (; i &lt;= n; i += i &amp; -i) { t[i] += k; } } public long sum(int x) { long res = 0; for (; x &gt; 0; x &amp;= x - 1) { res += t[x]; } return res; } public long get(int l, int r) { return sum(r) - sum(l - 1); }} 区间修改，单点查询1234567891011121314151617181920212223242526272829303132class BIT { private final int n; private final long[] t; public BIT(int n) { this.n = n; t = new long[n + 1]; } private void add(int i, int k) { for (; i &lt;= n; i += i &amp; -i) { t[i] += k; } } public void add(int l, int r, int k) { add(l, k); add(r + 1, -k); } public long sum(int x) { long res = 0L; for (int i = x; i &gt; 0; i &amp;= i - 1) { res += t[i]; } return res; } public long get(int x) { return sum(x); }} 区间修改，区间查询123456789101112131415161718192021222324252627282930313233343536class BIT { private final int n; private final long[] t1, t2; public BIT(int n) { this.n = n; t1 = new long[n + 1]; t2 = new long[n + 1]; } private void add(int i, int k) { long p = (long) k * i; for (; i &lt;= n; i += i &amp; -i) { t1[i] += k; t2[i] += p; } } public void add(int l, int r, int k) { add(l, k); add(r + 1, -k); } public long sum(int x) { long s1 = 0, s2 = 0; for (int i = x; i &gt; 0; i &amp;= i - 1) { s1 += t1[i]; s2 += t2[i]; } return s1 * (x + 1) - s2; } public long get(int l, int r) { return sum(r) - sum(l - 1); }} 线段树例题 P3372 【模板】线段树 1。 P3373 【模板】线段树 2。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class SegmentTree { private final int n; private final long[] t, z; public SegmentTree(int[] a) { n = a.length; t = new long[4 * n]; z = new long[4 * n]; build(a, 1, 1, n); } private void build(int[] a, int i, int l, int r) { if (l == r) { t[i] = a[l - 1]; return; } int mid = l + (r - l) / 2; build(a, 2 * i, l, mid); build(a, 2 * i + 1, mid + 1, r); t[i] = t[2 * i] + t[2 * i + 1]; } private void lazy(int i, int lo, int hi, long k) { t[i] += k * (hi - lo + 1); z[i] += k; } private void down(int i, int lo, int hi) { if (z[i] == 0) { return; } int mid = lo + (hi - lo) / 2; lazy(2 * i, lo, mid, z[i]); lazy(2 * i + 1, mid + 1, hi, z[i]); z[i] = 0; } public void add(int l, int r, int k) { if (l &gt; r) return; add(1, 1, n, l, r, k); } private void add(int i, int lo, int hi, int l, int r, int k) { if (lo &gt;= l &amp;&amp; hi &lt;= r) { lazy(i, lo, hi, k); return; } down(i, lo, hi); int mid = lo + (hi - lo) / 2; if (l &lt;= mid) add(2 * i, lo, mid, l, r, k); if (r &gt; mid) add(2 * i + 1, mid + 1, hi, l, r, k); t[i] = t[2 * i] + t[2 * i + 1]; } public long get(int l, int r) { if (l &gt; r) return 0L; return get(1, 1, n, l, r); } private long get(int i, int lo, int hi, int l, int r) { if (lo &gt;= l &amp;&amp; hi &lt;= r) { return t[i]; } down(i, lo, hi); long res = 0L; int mid = lo + (hi - lo) / 2; if (l &lt;= mid) res += get(2 * i, lo, mid, l, r); if (r &gt; mid) res += get(2 * i + 1, mid + 1, hi, l, r); return res; }} 稀疏表（Sparse Table）例题 P3865 【模板】ST 表。 实现1System.out.println(&quot;TODO&quot;);","link":"/2023/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"AtCoder Beginner Contest 326","text":"2UP3DOWN12345678public static void solve() { int x = io.nextInt(), y = io.nextInt(); if (y - x &gt;= -3 &amp;&amp; y - x &lt;= 2) { io.println(&quot;Yes&quot;); } else { io.println(&quot;No&quot;); }} 326-like Numbers123456789public static void solve() { int n = io.nextInt(); for (; ; n++) { if (n / 100 * (n / 10 % 10) == n % 10) { io.println(n); return; } }} Peak1234567891011121314151617public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); int ans = 0; for (int i = 0, j = 0; j &lt; n; j++) { while (a[j] - a[i] &gt;= m) { i++; } ans = Math.max(ans, j - i + 1); } io.println(ans);} ABC Puzzle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(); char[] r = io.next().toCharArray(); char[] c = io.next().toCharArray(); int[] row = new int[n]; int[] col = new int[n]; char[][] ans = new char[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(ans[i], '.'); } boolean ok = dfs(0, 0, r, c, ans, row, col, 0); if (!ok) { io.println(&quot;No&quot;); return; } io.println(&quot;Yes&quot;); for (int i = 0; i &lt; n; i++) { io.println(new String(ans[i])); }}private static boolean dfs(int x, int y, char[] r, char[] c, char[][] ans, int[] row, int[] col, int cnt) { int n = r.length; if (x == n) { return cnt == 3 * n; } if (n - 1 - y &gt;= 3 - Integer.bitCount(row[x])) { if (dfs(x + (y + 1) / n, (y + 1) % n, r, c, ans, row, col, cnt)) { return true; } } for (int i = 0; i &lt; 3; i++) { if ((row[x] &gt;&gt; i &amp; 1) == 1 || (col[y] &gt;&gt; i &amp; 1) == 1) { continue; } if (row[x] == 0 &amp;&amp; r[x] != 'A' + i) { continue; } if (col[y] == 0 &amp;&amp; c[y] != 'A' + i) { continue; } row[x] |= 1 &lt;&lt; i; col[y] |= 1 &lt;&lt; i; ans[x][y] = (char) ('A' + i); if (dfs(x + (y + 1) / n, (y + 1) % n, r, c, ans, row, col, cnt + 1)) { return true; } row[x] ^= 1 &lt;&lt; i; col[y] ^= 1 &lt;&lt; i; ans[x][y] = '.'; } return false;} Revenge of “The Salary of AtCoder Inc.”概率 DP，答案为 \\(\\sum_{i=1}^{n}{A_{i}P_{i}}\\)，而 \\(P_{i}=\\frac{1}{N}\\sum_{j=0}^{i-1}{P_{j}}=P_{i-1}+\\frac{1}{N}P_{i-1}\\)。（这么简单，真没想到） 1234567891011121314151617181920212223private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); long invn = pow(n, MOD - 2); long ans = 0L, p = invn; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); ans = (ans + p * a) % MOD; p = (p + invn * p) % MOD; } io.println(ans);}private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;}","link":"/2023/10/29/AtCoder%20Beginner%20Contest%20326/"},{"title":"第 116 场力扣夜喵双周赛","text":"子数组不同元素数目的平方和 I同下。 使二进制字符串变美丽的最少修改次数长度为偶数的字符串要满足条件，那么将数组分为长度为 \\(2\\) 的各个小段，使各个子数组满足条件一定是最优的。 123456789class Solution { public int minChanges(String s) { int n = s.length(), ans = 0; for (int i = 0; i &lt; n; i += 2) { ans += (s.charAt(i) ^ s.charAt(i + 1)) &amp; 1; } return ans; }} 和为目标值的最长子序列的长度0-1 背包，转移方程为 \\(dp[i][j]=\\max(dp[i-1][j],dp[i-1][j-nums[i]]+1)\\)，注意初始化为 \\(-1\\)，并在转移时判断有效性。 12345678910111213141516class Solution { public int lengthOfLongestSubsequence(List&lt;Integer&gt; nums, int target) { int n = nums.size(); int[] dp = new int[target + 1]; Arrays.fill(dp, -1); dp[0] = 0; for (int x : nums) { for (int j = target; j &gt;= x; j--) { if (dp[j - x] != -1) { dp[j] = Math.max(dp[j], dp[j - x] + 1); } } } return dp[target]; }} 子数组不同元素数目的平方和 II动态规划 + 线段树，刚学的线段树就用上了，但是不太熟练，忘记我的线段树板子是从下标一开始操作，并且没有特判，如果操作的右端点比左端点小，那么就会导致数组越界，之后得修改一下板子。假设以 \\(i\\) 为右端点的所有子数组的不同计数的平方和为 \\(dp[i]\\)，考虑如何转移到 \\(dp[i+1]\\)。 如果在 \\([0,i]\\) 中和 \\(nums[i+1]\\) 相等的数为 \\(nums[j]\\)，则添加 \\(nums[i+1]\\) 会使左端点在 \\([j+1,i]\\) 范围内的子数组的不同计数加 \\(1\\)，而左端点在 \\([0,j]\\) 范围内子数组的不同计数不变，最后不要忘记加上左端点在 \\(i+1\\) 的子数组的不同计数的平方。我们可以得到如下转移方程，其中 \\(x_{i,j}\\) 表示子数组 \\(nums[i,j]\\) 的不同计数。 $$ \\begin{align} dp[i] &=x_{0,i}^{2}+x_{1,i}^{2}+\\cdots+x_{i,i}^{2} \\\\ dp[i+1] &=x_{0,i}^{2}+\\cdots+x_{j,i}^{2}+(x_{j+1,i}+1)^{2}+\\cdots+(x_{i,i}+1)^{2}+x_{i+1,i+1}^{2} \\end{align} $$ 然后我们将 \\(dp[i]\\) 代入到 \\(dp[i+1]\\) 中，得到： $$ dp[i+1]=dp[i]+2\\sum_{k=j+1}^{i}x_{k,i}+(i-j)+x_{i+1,i+1}^{2} $$ 首先我们需要得到每个数，它左边第一个相同的数的位置，这可以在遍历的过程中使用哈希表得到。然后我们需要维护以当前位置为右端点，所有左端点表示的子数组的不同计数（区间修改），并且需要快速的求区间和，那么就可以使用线段树，这样我们只需要花费 \\(O(\\log{n})\\) 的时间进行转移。转移之后，不要忘记更新左端点在 \\([j+1,i+1]\\) 范围内的子数组的不同计数。 12345678910111213141516171819class Solution { private static final int MOD = (int) 1e9 + 7; public int sumCounts(int[] nums) { int n = nums.length; long ans = 0L, sum = 0L; var st = new SegmentTree(n); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= n; i++) { int j = map.getOrDefault(nums[i - 1], 0); map.put(nums[i - 1], i); sum = (sum + 2 * st.get(j + 1, i) + i - j) % MOD; ans = (ans + sum) % MOD; st.add(j + 1, i, 1); } return (int) ans; }}","link":"/2023/10/29/%E7%AC%AC%20116%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 369 场力扣周赛","text":"找出数组中的 K-or 值模拟。 123456789101112131415class Solution { public int findKOr(int[] nums, int k) { int ans = 0; for (int i = 0; i &lt; 31; i++) { int cnt = 0; for (int x : nums) { cnt += x &gt;&gt; i &amp; 1; } if (cnt &gt;= k) { ans |= 1 &lt;&lt; i; } } return ans; }} 数组的最小相等和分类讨论。所有 \\(0\\) 都必须被替换为正整数，那么首先将所有 \\(0\\) 替换为 \\(1\\)。如果两个数组中都有 \\(0\\)，则此时得到的最大的数组和就应该是答案，因为较小的一方总是可以使用更大的正整数替换 \\(0\\)，使得两个数组的元素和相等。如果某个数组的和不等于最大和，并且数组中不包含 \\(0\\)，那么就无法使两个数组的元素和相等。 123456789101112131415161718class Solution { public long minSum(int[] nums1, int[] nums2) { int cnt1 = 0, cnt2 = 0; long sum1 = 0L, sum2 = 0L; for (int x : nums1) { if (x == 0) cnt1++; sum1 += x; } for (int x : nums2) { if (x == 0) cnt2++; sum2 += x; } long max = Math.max(sum1 + cnt1, sum2 + cnt2); if (sum1 != max &amp;&amp; cnt1 == 0) return -1; if (sum2 != max &amp;&amp; cnt2 == 0) return -1; return max; }} 使数组变美的最小增量运算数按照灵神的题解，每个位置的状态就是它右边有多少个数小于 \\(k\\)，加上这个维度就可以做记忆化搜索，然后转递推真的很妙。题解区还有其他的状态定义方式，可以看看。代码就贴灵神的。（这题感觉很不错，没有见过的类型） 123456789101112class Solution { public long minIncrementOperations(int[] nums, int k) { long f0 = 0, f1 = 0, f2 = 0; for (int x : nums) { long inc = f0 + Math.max(k - x, 0); f0 = Math.min(inc, f1); f1 = Math.min(inc, f2); f2 = inc; } return f0; }} 收集所有金币可获得的最大积分当我们遍历到某个节点时，它的状态就是需要除以多少次 \\(2\\)，由数据范围可知每个节点最多有 \\(15\\) 个状态。我们可以从子问题的最优解推出原问题的最优解，并且子问题可以独立求解，符合最优子结构；如果当前节点处于某个状态，它可能是由不同的路径转移得到的，即存在重叠子问题。所以我们可以使用树型 DP 求解该问题，列出如下状态转移方程： $$ dp[x][i]=\\max(\\sum_{y}{dp[y][i]}+(coins[x]>>i)-k,\\sum_{y}{dp[y][i + 1]}+(coins[x]>>(i+1))) $$ 其中 \\(dp[i][j]\\) 表示到达节点 \\(i\\)，需要除以 \\(2^{j}\\)，该状态下以节点 \\(i\\) 为根的子树能够得到的最大积分。 1234567891011121314151617181920212223242526272829303132class Solution { public int maximumPoints(int[][] edges, int[] coins, int k) { int n = coins.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, t -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } return dfs(0, -1, g, coins, k)[0]; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] coins, int k) { int[] sum1 = new int[15]; int[] sum2 = new int[15]; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g, coins, k); for (int i = 0; i &lt; 14; i++) { sum1[i] += t[i]; sum2[i] += t[i + 1]; } } for (int i = 0; i &lt; 14; i++) { sum1[i] = Math.max(sum1[i] + (coins[x] &gt;&gt; i) - k, sum2[i] + (coins[x] &gt;&gt; (i + 1))); } return sum1; }}","link":"/2023/10/29/%E7%AC%AC%20369%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 907 (Div. 2)","text":"Sorting with Twos因为每次只能操作区间 \\([1,2^{m}]\\)，所以 \\([2^{m}+1,2^{m+1}]\\) 内的所有数是同时进行操作的，它们需要满足非递减的性质，最后不要忘记结尾不能操作的数也需要满足条件。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { a[i] = io.nextInt(); } for (int i = 1; 1 &lt;&lt; i &lt;= n; i++) { int j = Math.min(1 &lt;&lt; (i + 1), n); for (int k = (1 &lt;&lt; i) + 1; k &lt; j; k++) { if (a[k] &gt; a[k + 1]) { io.println(&quot;NO&quot;); return; } } } io.println(&quot;YES&quot;);} Deja Vu如果一个数能够被 \\(2^{i}\\) 整除，那么操作之后，它只能被所有小于等于 \\(2^{i-1}\\) 的二的幂整除。所以预处理所有修改，只保留满足递减顺序的修改，然后模拟即可。或者也可以直接修改，不用预处理，在修改之前判断一下是否比上次小就行。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), q = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int mask = 0; for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); if (mask == 0 || (1 &lt;&lt; x) &lt;= (mask &amp; -mask)) { mask |= 1 &lt;&lt; x; } } for (int i = 0; i &lt; n; i++) { for (int j = 30; j &gt;= 0; j--) { if ((mask &gt;&gt; j &amp; 1) == 1 &amp;&amp; a[i] % (1 &lt;&lt; j) == 0) { a[i] += 1 &lt;&lt; (j - 1); } } } for (int i = 0; i &lt; n; i++) { io.print(a[i] + &quot; &quot;); } io.println();} Smilo and Monsters比赛时我是排序 + 相向双指针模拟的，先干前面的怪物，如果计数和最后一个的怪物群数量相等，则使用终极攻击，比较麻烦的是双指针到达同一个位置时，需要特判一些情况。然后下面的解法，很简洁啊。似乎总是可以使用普通攻击干掉怪物总数的一半向上取整，并且使用终极攻击干掉总数的一半向下取整。然后排序数组并倒序遍历，使得一次终极攻击干掉尽可能多的怪物，这样就得到最少攻击次数。 1234567891011121314151617public static void solve() { int n = io.nextInt(); int[] a = new int[n]; long sum = 0L; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } Arrays.sort(a); long ans = (sum + 1) / 2; sum /= 2; for (int i = n - 1; i &gt;= 0 &amp;&amp; sum &gt; 0; i--) { sum -= a[i]; ans++; } io.println(ans);} Suspicious logarithms\\(f(x)\\) 表示 \\(x\\) 的二进制表示中最高位的 \\(1\\) 所在的位数 \\(y\\)，而 \\(g(x)\\) 表示满足 \\(y^{z}&lt;= x\\) 条件的最大的 \\(z\\)。可以发现如果 \\(y=2,x=10^{18}\\)，则 \\(z=59\\)。我们可以枚举所有 \\(y\\in[2,59]\\)，对于特定的 \\(y\\)，枚举不同的 \\(z\\) 覆盖的区间范围。得到各个区间范围内所有数的 \\(z\\) 值，我们就可以在 \\(O(\\log{(r-l+1)})\\) 的时间复杂度内执行查询。为了避免乘法溢出，在进行比较时需要使用除法。其他人代码有直接使用 \\(\\log\\) 的，也比较简单啊，我还以为很麻烦，结果溢出没想到换除法。当然也可以维护前缀和，然后二分区间位置来进行查询。 12345678910111213141516171819202122232425262728293031323334private static final int MOD = (int) 1e9 + 7;private static final List&lt;long[]&gt;[] list = new List[60];static { Arrays.setAll(list, k -&gt; new ArrayList&lt;&gt;()); for (int f = 2; f &lt; 60; f++) { long l = 1L &lt;&lt; f, r = (1L &lt;&lt; f + 1) - 1; long k = f, g = 1; while (k &lt;= l / f) { k *= f; g++; } for (; l &lt;= r; l = k + 1, g++) { k = k &lt;= r / f ? k * f - 1 : r; list[f].add(new long[]{l, k, g}); } }}public static void solve() { long ans = 0L; long l = io.nextLong(), r = io.nextLong(); int i = 63 - Long.numberOfLeadingZeros(l); int j = 63 - Long.numberOfLeadingZeros(r); for (; i &lt;= j; i++) { for (long[] t : list[i]) { ans = (ans + (Math.max(0, Math.min(t[1], r) - Math.max(t[0], l) + 1)) * t[2]) % MOD; } } io.println(ans);} A Growing Tree每个节点的编号是添加该节点时树的大小，因为修改操作不会影响还未添加到树上的节点，所以我们对每个修改操作添加一个编号（时间），表示修改所影响的范围。我们可以使用单点修改、区间查询的树状数组维护修改操作的编号，然后按照 DFS 序遍历树，每当遍历到一个节点，使用树状数组进行单点修改，因为遍历是 DFS 序，所以当前节点的祖先节点已经进行过修改操作，那么当前节点的答案就是所有大于等于该节点编号的修改操作之和。 那么有没有可能该答案会包含其他满足编号大于当前节点的非祖先节点的修改操作呢，不会包含，因为遍历是 DFS 序，DFS 返回时会取消对节点的修改操作，所以每当遍历到一个节点，修改操作只会包含其祖先节点的修改操作。特别注意，数组开 \\(q+2\\) 的大小，因为初始时有一个根节点，所以节点数量最多为 \\(q+1\\)，然后编号从 \\(1\\) 开始。 12345678910111213141516171819202122232425262728293031323334353637public static void solve() { int q = io.nextInt(), sz = 1; List&lt;int[]&gt;[] queries = new List[q + 2]; Arrays.setAll(queries, k -&gt; new ArrayList&lt;&gt;()); List&lt;Integer&gt;[] g = new List[q + 2]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; q; i++) { int t = io.nextInt(); if (t == 1) { int v = io.nextInt(); g[v].add(++sz); } else { int v = io.nextInt(), x = io.nextInt(); queries[v].add(new int[]{sz, x}); } } var bit = new BIT(sz); long[] ans = new long[sz + 1]; dfs(1, sz, g, queries, bit, ans); for (int i = 1; i &lt;= sz; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs(int x, int sz, List&lt;Integer&gt;[] g, List&lt;int[]&gt;[] queries, BIT bit, long[] ans) { for (int[] q : queries[x]) { bit.add(q[0], q[1]); } ans[x] = bit.get(x, sz); for (int y : g[x]) { dfs(y, sz, g, queries, bit, ans); } for (int[] q : queries[x]) { bit.add(q[0], -q[1]); }}","link":"/2023/10/31/Codeforces%20Round%20907%20(Div.%202)/"},{"title":"图论","text":"本文内容参考《算法》，《算法导论》，OI Wiki。 拓扑排序例题 B3644 【模板】拓扑排序 / 家谱树。 实现 时间复杂度为 \\(O(n+m)\\)。 12345678910111213141516171819202122232425262728293031323334private static int[] topologicalSort(int n, int[][] edges) { int[] in = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); in[v]++; } Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } int idx = 0; int[] res = new int[n]; while (!q.isEmpty()) { int x = q.poll(); res[idx++] = x; for (int y : g[x]) { if (--in[y] == 0) { q.offer(y); } } } // 拓扑排序不存在 assert idx == n; return res;} 最小生成树例题 P3366 【模板】最小生成树。 Prim实现一：朴素版本 时间复杂度为 \\(O(n^{2})\\)。 12345678910111213141516171819202122232425262728293031323334353637383940private static int prim(int n, int[][] edges) { int[][] g = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(g[i], Integer.MAX_VALUE); g[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; if (g[u][v] &gt; w) { g[u][v] = g[v][u] = w; } } int[] d = new int[n]; Arrays.fill(d, Integer.MAX_VALUE); boolean[] vis = new boolean[n]; int res = 0; d[0] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) { t = j; } } // 不是连通图，最小生成树不存在 assert d[t] != Integer.MAX_VALUE; vis[t] = true; res += d[t]; for (int j = 0; j &lt; n; j++) { d[j] = Math.min(d[j], g[t][j]); } } return res;} 实现二：优先队列优化 时间复杂度为 \\(O(m\\log{m})\\)。 12345678910111213141516171819202122232425262728293031323334353637private static int prim(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] d = new int[n]; Arrays.fill(d, Integer.MAX_VALUE); boolean[] vis = new boolean[n]; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]); int res = 0, cnt = 0; d[0] = 0; q.offer(new int[]{0, 0}); while (!q.isEmpty()) { int u = q.poll()[0]; if (vis[u]) continue; vis[u] = true; res += d[u]; if (++cnt == n) break; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (!vis[v] &amp;&amp; d[v] &gt; w) { d[v] = w; q.offer(new int[]{v, d[v]}); } } } // 不是连通图，最小生成树不存在 assert cnt == n; return res;} Kruskal 时间复杂度为 \\(O(m\\log{m})\\)。 123456789101112131415161718private static int kruskal(int n, int[][] edges) { Arrays.sort(edges, (a, b) -&gt; a[2] - b[2]); int cnt = 1, res = 0; UnionFind uf = new UnionFind(n); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; if (uf.connected(u, v)) continue; uf.union(u, v); res += w; if (++cnt == n) break; } // 不是连通图，最小生成树不存在 assert cnt == n; return res;} 最短路例题 P4779 【模板】单源最短路径（标准版）。 B3647 【模板】Floyd。 Dijkstra 使用场景：解决边权非负的单源最短路问题。 实现一：朴素版本 时间复杂度为 \\(O(n^{2})\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static final int INF = (int) 1e9;private static int dijkstra(int n, int[][] edges) { int[][] g = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(g[i], INF); g[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u][v] = Math.min(g[u][v], w); } int[] d = new int[n]; Arrays.fill(d, INF); boolean[] vis = new boolean[n]; d[0] = 0; while (true) { int t = -1; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; (t == -1 || d[t] &gt; d[i])) { t = i; } } if (t == n - 1 || d[t] == INF) { break; } vis[t] = true; for (int i = 0; i &lt; n; i++) { d[i] = Math.min(d[i], d[t] + g[t][i]); } } return d[n - 1] == INF ? -1 : d[n - 1];} 实现二：优先队列优化 时间复杂度为 \\(O(m\\log{m})\\)。 123456789101112131415161718192021222324252627282930313233private static final int INF = (int) 1e9;private static int dijkstra(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); } int[] d = new int[n]; Arrays.fill(d, INF); boolean[] vis = new boolean[n]; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]); d[0] = 0; q.offer(new int[]{0, 0}); while (!q.isEmpty()) { int u = q.poll()[0]; if (u == n - 1) break; if (vis[u]) continue; vis[u] = true; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (d[v] &gt; d[u] + w) { d[v] = d[u] + w; q.offer(new int[]{v, d[v]}); } } } return d[n - 1] == INF ? -1 : d[n - 1];} Bellman-Ford 时间复杂度为 \\(O(nm)\\)。 使用场景：解决任意边权的单源最短路问题；判断是否存在负环；解决有边数限制的单源最短路问题。 实现一：朴素版本 1234567891011121314151617private static final int INF = (int) 1e9;private static int bellmanFord(int n, int[][] edges) { int[] d = new int[n]; Arrays.fill(d, INF); d[0] = 0; for (int i = 0; i &lt; n; i++) { for (var e : edges) { int u = e[0], v = e[1], w = e[2]; d[v] = Math.min(d[v], d[u] + w); } } // d[n - 1] == INF 时，最短路不存在 return d[n - 1];} 实现二：队列优化（不能存在负环） 123456789101112131415161718192021222324252627282930313233343536private static final int INF = (int) 1e9;private static int spfa(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); } int[] d = new int[n]; Arrays.fill(d, INF); Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); boolean[] on = new boolean[n]; d[0] = 0; q.offer(0); on[0] = true; while (!q.isEmpty()) { int u = q.poll(); on[u] = false; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (d[v] &gt; d[u] + w) { d[v] = d[u] + w; if (!on[v]) { q.offer(v); on[v] = true; } } } } // d[n - 1] == INF 时，最短路不存在 return d[n - 1];} Floyd-Warshall 时间复杂度为 \\(O(n^{3})\\)。 使用场景：解决任意边权的多源最短路问题。 123456789101112131415161718192021222324private static final int INF = (int) 1e9;private static int[][] floyd(int n, int[][] edges) { int[][] dp = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], INF); dp[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; dp[u][v] = Math.min(dp[u][v], w); } for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (dp[i][k] != INF &amp;&amp; dp[k][j] != INF) { dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]); } } } } return dp;} 最近公共祖先例题 P3379 【模板】最近公共祖先（LCA）。 倍增 预处理时间复杂度为 \\(O(n\\log{n})\\)，查询时间复杂度为 \\(O(\\log{n})\\)。 原理：\\(f[i][j]\\) 表示节点 \\(j\\) 的第 \\(2^{i}\\) 个祖先，当利用倍增得到 \\(f\\) 时，对于任意两个节点 \\(x,y\\)，先将较深的节点向上跳到相同深度，然后两个节点贪心的向上跳到 \\(\\operatorname{lca}\\) 下方距离它最近的节点，最后得到的节点就是 \\(\\operatorname{lca}\\) 的直接子节点。（在进行倍增时，根节点的父节点可以是任何值，因为该值不会影响算法的正确性） 123456789101112131415161718192021222324252627282930313233343536private static void dfs(int x, int fa, List&lt;Integer&gt;[] g, int[][] f, int[] d) { f[0][x] = fa; for (int i = 1; 1 &lt;&lt; i &lt;= d[x]; i++) { f[i][x] = f[i - 1][f[i - 1][x]]; } for (int y : g[x]) { if (y != fa) { d[y] = d[x] + 1; dfs(y, x, g, f, d); } }}private static int lca(int x, int y, int[][] f, int[] d) { if (d[x] &gt; d[y]) { int t = x; x = y; y = t; } int diff = d[y] - d[x]; for (int i = 0; i &lt; 31; i++) { if ((diff &gt;&gt; i &amp; 1) == 1) { y = f[i][y]; } } if (x != y) { for (int i = 30; i &gt;= 0; i--) { if (f[i][x] != f[i][y]) { x = f[i][x]; y = f[i][y]; } } x = f[0][x]; } return x;} Tarjan 离线查询算法，时间复杂度为 \\(O((n+m)\\log{n})\\)。更精确的复杂度分析可以使用反阿克曼函数。 原理：每当处理完一个子树，就将该子树的根节点和其父节点合并，特别注意合并的方向是 \\(f[y]=x\\)。然后我们会遍历包含当前节点 \\(x\\) 的查询，如果另一个节点 \\(y\\) 访问过，则 \\(\\operatorname{lca}(x,y)=\\operatorname{find}(y)\\)。至于为什么是这样，可以通过分类讨论得到。注意 \\(q\\) 需要像无向图一样，为单个查询存储双向边。 12345678910111213141516private static void tarjan(int x, List&lt;Integer&gt;[] g, boolean[] vis, UnionFind uf, List&lt;int[]&gt;[] q, int[] ans) { vis[x] = true; for (int y : g[x]) { if (!vis[y]) { tarjan(y, g, vis, uf, q, ans); uf.union(x, y); // 注意 f[y] = x } } for (int[] t : q[x]) { int y = t[0], i = t[1]; if (vis[y]) { ans[i] = uf.find(y); } }} 树链剖分 预处理时间复杂度为 \\(O(n)\\)，查询时间复杂度为 \\(O(\\log{n})\\)。 原理：将树划分为若干重链，树中的每条路径不会包含超过 \\(\\log{n}\\) 条不同的重链，所以查询的时间复杂度为 \\(O(\\log{n})\\)。第一次 DFS 得到每个节点的父节点，深度，以及根据子树大小得到每个节点的重子节点。第二次 DFS 通过优先遍历重子节点，再遍历轻子节点，从而得到每个节点所在重链的头节点。然后就可以进行查询，通过比较 \\(x,y\\) 所在重链的头节点，来向上跳跃，最终得到 \\(\\operatorname{lca}\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static void dfs1(int x, int fa, List&lt;Integer&gt;[] g, int[] f, int[] d, int[] s, int[] h) { f[x] = fa; s[x] = 1; h[x] = -1; for (int y : g[x]) { if (y != fa) { d[y] = d[x] + 1; dfs1(y, x, g, f, d, s, h); s[x] += s[y]; if (h[x] == -1 || s[h[x]] &lt; s[y]) { h[x] = y; } } }}private static void dfs2(int x, int head, List&lt;Integer&gt;[] g, int[] f, int[] h, int[] t) { t[x] = head; if (h[x] == -1) { return; } dfs2(h[x], head, g, f, h, t); for (int y : g[x]) { if (y != f[x] &amp;&amp; y != h[x]) { dfs2(y, y, g, f, h, t); } }}private static int lca(int x, int y, int[] f, int[] d, int[] t) { while (t[x] != t[y]) { if (d[t[x]] &gt; d[t[y]]) { x = f[t[x]]; } else { y = f[t[y]]; } } return d[x] &lt; d[y] ? x : y;} 强连通分量例题 P2863 [USACO06JAN] The Cow Prom S。 Tarjan 时间复杂度为 \\(O(n+m)\\)。 原理：\\(dfn[x]\\) 表示节点 \\(x\\) 的 DFS 编号；\\(low[x]\\) 表示节点 \\(x\\) 能够到达的节点的最小的 DFS 编号。我们将图看作一棵树，并定义四种边，那么强连通分量的根节点就是该分量中第一个被遍历到的节点，满足 \\(dfn[x]=low[x]\\)，所以，过程很复杂，难以描述，直接看 wiki 吧。（注意使用的时候，将 \\(dfn\\) 初始化为 \\(-1\\)，并且对所有节点调用该算法前，需要判断 \\(dfn=-1\\) 是否成立） 1234567891011121314151617181920212223242526private static int dfnCnt, sccCnt;private static void tarjan(int x, List&lt;Integer&gt;[] g, int[] dfn, int[] low, Deque&lt;Integer&gt; stk, boolean[] on, int[] scc, int[] size) { dfn[x] = low[x] = dfnCnt++; stk.push(x); on[x] = true; for (int y : g[x]) { if (dfn[y] == -1) { tarjan(y, g, dfn, low, stk, on, scc, size); low[x] = Math.min(low[x], low[y]); } else if (on[y]) { low[x] = Math.min(low[x], dfn[y]); } } if (dfn[x] == low[x]) { for (int y = -1; y != x; ) { y = stk.pop(); on[y] = false; scc[y] = sccCnt; size[sccCnt]++; } sccCnt++; }}","link":"/2023/10/31/%E5%9B%BE%E8%AE%BA/"},{"title":"Project #3 - Query Execution","text":"项目准备项目地址：Project #3 - Query Execution。 准备工作：阅读 Chapter 15 16 22，学习 Lecture #10 #11 #12 #13 #14，以及阅读课堂笔记。 项目结构通过查看 sqllogictest.cpp，可以知道 SQL 语句的整个执行流程。首先调用 SQLLogicTestParser::Parse 将测试文件解析为多个测试记录，然后根据记录的类型分别处理。目前我们主要关注查询语句，只需查看 BustubInstance::ExecuteSqlTxn 函数的代码。如项目介绍描述的那样，代码分别执行 Binder,Planner,Optimize,ExecutionEngine。然后，本来想详细分析一下整个流程，但是由于时间原因，以及项目确实比较复杂，所以暂时搁置。 Task #1 - Access Method Executors实现① 遇到第一个问题，如何在 SeqScanExecutor 中遍历表，可以发现 exec_ctx 成员所属的类 ExecutorContext 中有一个 GetCatalog 方法，只要拿到 Catalog 就可以根据 plan_ 中的信息拿到 TableHeap 的迭代器 TableIterator。然后第二个问题就是如何存储迭代器，TableIterator 是不可复制的，我们可以使用 unique_ptr 来存储迭代器，并使用 make_unique 初始化。（注意，不能在构造函数初始化，一定要在 Init 函数中初始化，不然多次全表扫描会出问题！） ② 实现 Insert 时报错 “The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table”，并且可以看到 Next 函数的注释中表示 “tuple The integer tuple indicating the number of rows inserted into the table”。说实话有点难以理解，我一开始以为每次调用 Next 会像迭代器模式一样，只执行一次插入，但是这样实现就会报上面的错误。然后通过查看 Discord 的讨论，发现是一次性插入所有记录，因为只要返回 true 就会打印插入的行数，返回 false 就不会打印。当插入零行时，还必须打印一个零，这说明，Next 必定要先返回 true，再返回 false。并且在构造 tuple 时需要使用 BIGINT 类型，不然会报其他错误（明明注释说的是 INTEGER 额）。 ③ 在 Insert 的同时需要更新索引，一开始我是直接用普通的 tuple 作为 InsertEntry 的参数，结果在测试 p3.05-index-scan.slt 时报 stack buffer overflow 错误。通过 Debug 发现，在 InsertEntry 时会调用 GenericKey 类的 SetFromKey 函数，该函数会将 tuple 的数据拷贝到该类的 data_ 成员中，作为索引的 key 使用。所以传入的 tuple 必须只包含 key，那么如何确定 tuple 中的哪个数据是 key 呢。可以发现 Tuple 类中有 KeyFromTuple 函数，它的会生成只包含 key 的 tuple，因为需要的索引的 key，那么该函数必定需要传入和索引相关的模式，以及 key 所在列的下标，这些信息可以在 IndexInfo 中找到。（之前我有点迷糊，当成 MySQL 默认使用主键索引了，BusTub 使用的是 TableHeap，也就是说表默认是没有索引的） ④ 实现时不要使用 GetTableOid 函数，因为线上测试的函数名是 TableOid，可能是因为我 fork 的版本太新了，仓库的代码和测试代码不一样，所以只能直接使用 table_oid_ 成员。 ⑤ 实现 update 时要注意，在创建新 tuple 时，使用的是 child_executor_-&gt;GetOutputSchema()，而不是 GetOutputSchema()。 ⑥ 实现 index_scan 时，会使用到 b_plus_tree_index.h 中定义的别名，如 BPlusTreeIndexIteratorForTwoIntegerColumn。 ⑧ 在 IndexScan 的提示中有这么一句话，“do not emit tuples that are deleted”，但是当从表中删除 tuple 时，也会从索引中删除对应的 key，所以应该不会遍历到已经删除的 key 才对，也就是说此时应该不用特判 TupleMeta 中的 is_deleted_ 成员。 ⑨ 测试 p3.06-empty-table.slt 时，遇到 B+Tree 迭代器实现问题。当 B+Tree 的为 empty 时，获取迭代器我原来是抛出异常，现在改为返回一个默认构造的迭代器。 补充① 当没有显示声明复制/移动构造函数或复制/移动运算符，以及析构函数时，编译器才会隐式生成这些函数（其他更复杂的情况可以查看 cppreference.com）。 ② 创建 TupleMeta 时，会将 insertion_txn 和 deletion_txn_ 都初始化为 INVALID_TXN_ID，提示表示这些成员会在以后切换到 MVCC 存储时使用，有点遗憾没能体验一下。 ③ vector 的 reserve 只会影响 capacity 的大小，而不会影响 size，讨论在此。 ④ 重载前置和后置 ++ 的区别，前置 ++ 的重载声明为 operator++()，后置 ++ 的重载声明为 operator++(int)。 ⑤ 为什么应该将移动构造声明为 noexcept，可以阅读 Friendly reminder to mark your move constructors noexcept。 Task #2 - Aggregation &amp; Join Executors实现① 一开始实现真摸不着头脑，AggregationPlanNode 里面怎么这么多东西。group_bys 是指 GROUP BY 时对列的求值表达式，aggregates 是指使用聚合函数时对列的求值表达式，agg_types 是指聚合函数的类型。例如：GROUP BY DAY(col)、MIN(col1 + col2)。我们使用 InsertCombine 函数向哈希表插入值，参数可以使用 MakeAggregateKey 和 MakeAggregateValue 函数获得。 ② 根据项目介绍，AggregationExecutor::Next 返回的 tuple 应该包含 key 和 value（我没看到，找错好难）。特别需要注意，当哈希表为空时，应该返回什么：如果是对某列进行 GROUP BY 操作，那么就返回 false，因为有个测试用例有注释 no groups, no output；否则，返回 true，并且 tuple 存储聚合函数的默认值。（可以通过判断 key 模式的列数是否为零，或者 value 模式的列数是否等于 plan_ 输出模式的列数，来判断当前是否对某列进行 GROUP BY 操作） ③ 实现 NestedLoopJoinExecutor：外层循环遍历左表，内层循环遍历右表，只有当右表遍历完，才会获取下一个左表中的元组。但是，因为每找到一个匹配就会返回，所以我们应该将左表的元组作为数据成员，并且添加一个标志表示右表是否遍历完。每当右表遍历完成，都需要重置标志，获取左表中的下一个元组，并且重新 Init 右表。我们调用 EvaluateJoin 判断元组是否匹配，如果匹配，就将两个元组合并为一个元组。特别注意，如果当前是左连接，并且左元组没有匹配任何右元组，仍然需要返回一个为右元组填充 null 值的合并元组。比较迷惑的是怎么表示 null，我的想法是根据列类型获取对应的 null 值，但是找不到这样的函数，所以我就直接返回 BUSTUB_INT32_NULL 了。突然看到聚合执行器里用到 ValueFactory::GetNullValueByType 函数，太久没写项目给忘了。我还遇到一个 BUG，调试半天，发现我没有在 Init 函数中初始化 SeqScanExecutor 的迭代器，导致重复调用 Init 时不会重置迭代器。 ④ 实现 HashJoin：根据提示我们可以参考 SimpleAggregationHashTable 的实现建立一个哈希表，我们创建一个 JoinKey 类作为键，然后创建一个 hash&lt;bustub::JoinKey&gt; 类，直接复制 aggregation_plan.h 中的代码改个名字就行（不然 C++ 真不熟，又要搞半天）。在哈希表中，将 vector&lt;Tuple&gt; 作为值以处理哈希冲突。搞定哈希的方式之后，我们可以像 aggregation_executor.h 一样添加两个辅助函数 MakeLeftJoinKey 和 MakeRightJoinKey。然后直接在 Init 中对左表建立哈希表，在 Next 中遍历右表，类似 NestedLoopJoinExecutor 的实现，只不过此时需要维护更多的数据成员。特别需要注意如何处理左连接，因为我们是将左表建为哈希表，那么在遍历完右表后，还需要处理没有任何匹配的左表中的元组。这可以在匹配时将元组的地址存储在 unordered_set 中，然后在遍历完右表后再遍历一次左表，并检查 unordered_set 来判断是否输出。（之前我是将元组的 RID 存储到集合中作为标识，但是这是错误的，因为左表可能是临时表，其中元组的 RID 是无效的内容；我们也可以为右表建立哈希表而不是左表，这样对于左连接来说，更好处理） ⑤ 实现 Optimizing NestedLoopJoin to HashJoin：非常的神奇，参考 nlj_as_index_join.cpp 瞎改，感觉代码是一坨，但是竟然没有任何错误，直接通过测试（激动半天）。具体实现的话，一开始我以为传入的参数就是 NestedLoopJoin 计划节点，但是似乎不是，所以我们需要遍历当前计划的子节点，递归的进行优化。之前比较令我迷惑的一点，怎么判断表达式是否是某个类型，我查找很久 API 都没有找到类似的函数，然后想到 Project #0 中好像是直接做 dynamic_cast 转换，如果返回值为 nullptr 就表示类型不匹配，查看 nlj_as_index_join.cpp 发现果然是这样。搞定表达式类型判断之后，就可以根据 ColumnValueExpression::GetTupleIdx 值来交换左右表达式，并返回转换后的节点。 Task #3 - Sort + Limit Executors and Top-N OptimizationEasy！只有两点需要注意：一个是每次调用 Init 时都要初始化所有数据成员，不然下次调用会包含上次调用的数据；第二个是 C++ 的 priority_queue 默认是大顶堆，并且比较器和 Java 中的用法完全相反。 Optional Leaderboard Tasks① 初次提交。 ② 之后优化。 Rank Submission Name Q1 Q2 Q3 Time 123 ALEX 740 30000 4839 4754 测试结果 123456789101112131415161718192021222324252627282930#!/bin/bashmake sqllogictest -j$(nproc)./bin/bustub-sqllogictest ../test/sql/p3.00-primer.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.01-seqscan.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.02-insert.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.04-delete.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.03-update.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.05-index-scan.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.06-empty-table.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.07-simple-agg.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.08-group-agg-1.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.09-group-agg-2.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.10-simple-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.11-multi-way-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.12-repeat-execute.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.14-hash-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.15-multi-way-hash-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.16-sort-limit.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.17-topn.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.18-integration-1.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.19-integration-2.slt --verbosemake formatmake check-lintmake check-clang-tidy-p3make submit-p3 项目小结项目难度主要在项目理解上，常常是不理解某些变量的实际含义，或者知道该怎么做，却找不到对应的 API，或者对返回值理解有错误，而函数文档也不清晰。最后，看到实现的代码能够执行各种 SQL 语句，感觉还是很不错的。","link":"/2023/11/03/Project%203%20-%20Query%20Execution/"},{"title":"2023 OceanBase 数据库大赛","text":"比赛信息 大赛报名。 MiniOB-2023 赛题。 2023 OceanBase 数据库大赛FAQ。 使用 Docker 搭建开发环境 启动报错 Docker Desktop - Unexpected WSL error，搜索半天解决方案，结果是没开 Windows Hypervisor Platform，解决方案在此。 如何在 CLion 中使用 Docker。 遇到 CLion 的 Bug，在 CLion 内置的 Docker 终端无法进行输入，我们直接使用 Docker 客户端打开终端。 终端使用上下左右方向键显示奇怪的编码，似乎是因为默认使用的是 shell，它不支持方向键，我们可以使用 bash 来解决问题，解决方案。 使用 build 构建项目时，报错 $'\\r': command not found，这是 Windows 的换行符和 Linux 不同导致的。为了避免在 clone 时进行换行符的转换，可以添加 autocrlf=false 到全局配置文件，或者可以在克隆的命令中添加该参数，更多详细的设置方法可以参考 GitHub 文档。","link":"/2023/11/03/2023%20OceanBase%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E8%B5%9B/"},{"title":"Educational Codeforces Round 157 (Rated for Div. 2)","text":"Treasure Chest至少走 \\(\\max(x,y)\\) 步，因为最多能扛起箱子 \\(k\\) 秒，所以会往回走 \\(\\max(0,y-x-k)\\) 步。 1234public static void solve() { int x = io.nextInt(), y = io.nextInt(), k = io.nextInt(); io.println(Math.max(x, y) + Math.max(0, y - x - k));} Points and Minimum Distance排序，然后将数组分为左右两部分，分别代表 \\(x,y\\) 坐标序列。可以证明，这是最优的。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[2 * n]; for (int i = 0; i &lt; 2 * n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); io.println(a[n - 1] - a[0] + a[2 * n - 1] - a[n]); for (int i = 0; i &lt; n; i++) { io.println(a[i] + &quot; &quot; + a[i + n]); }} Torn Lucky Ticket对于每个字符串 \\(s_{i}\\)，我们枚举合并字符串的中心位置，这样就可以知道需要在前缀或后缀补上长度以及总和为多少的字符串，使得合并字符串为幸运的。因为合并字符串的中心位置可能不在当前字符串上，所以我们按照长度从小到大处理字符串，这样可以保证不漏掉任何情况。特别的，每个字符串都可以和自身连接成为幸运串。或者也可以进行预处理，这样就不用排序。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(); char[][] arr = new char[n][]; for (int i = 0; i &lt; n; i++) { arr[i] = io.next().toCharArray(); } Arrays.sort(arr, (s1, s2) -&gt; s1.length - s2.length); long ans = 0L; int[][] dp = new int[6][46]; for (char[] s : arr) { int m = s.length; int[] sum = new int[m + 1]; for (int j = 0; j &lt; m; j++) { sum[j + 1] = sum[j] + s[j] - '0'; } for (int j = m / 2 + 1; j &lt;= m; j++) { ans += dp[2 * j - m][Math.max(0, 2 * sum[j] - sum[m])]; ans += dp[2 * j - m][Math.max(0, sum[m] - 2 * sum[m - j])]; } dp[m][sum[m]]++; } io.println(ans + n);} XOR Construction首先构造满足第二个条件的数组 \\(b\\)，我们让 \\(b_{n}=0\\)，然后前面的每个元素 \\(b_{i}=a_{i}\\oplus a_{i+1}\\oplus\\cdots\\oplus a_{n-1}\\)，这样就得到满足第二个条件的数组，可以通过后缀异或得到。那么如何让 \\(b\\) 包含从 \\(0\\) 到 \\(n-1\\) 的每个数，因为数据保证总是可以构造出这样的序列，也就是说我们得到的数组 \\(b\\) 异或某个数，就能够得到目标数组。单独考虑每一位是否需要异或，可以发现，如果该位 \\(1\\) 的数量大于 \\(0\\) 的数量就需要进行异或操作。 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n - 1; i++) { a[i] = io.nextInt(); } for (int i = n - 2; i &gt;= 0; i--) { a[i] = a[i] ^ a[i + 1]; } int[] d = new int[30]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 30; j++) { d[j] += a[i] &gt;&gt; j &amp; 1; } } int mask = 0; for (int i = 0; i &lt; 30; i++) { if (d[i] &gt; n - d[i]) { mask |= 1 &lt;&lt; i; } } for (int i = 0; i &lt; n; i++) { io.print((a[i] ^ mask) + &quot; &quot;); } io.println();}","link":"/2023/11/04/Educational%20Codeforces%20Round%20157%20(Rated%20for%20Div.%202)/"},{"title":"第 370 场力扣周赛","text":"找到冠军 I如果某一列全为 \\(0\\)，则该列表示的队伍会成为冠军。 123456789101112131415class Solution { public int findChampion(int[][] grid) { int n = grid.length; for (int j = 0; j &lt; n; j++) { int cnt = 0; for (int i = 0; i &lt; n &amp;&amp; cnt == 0; i++) { cnt += grid[i][j]; } if (cnt == 0) { return j; } } return -1; }} 找到冠军 II相当于判断入度为 \\(0\\) 的节点是否只有一个。 12345678910111213141516class Solution { public int findChampion(int n, int[][] edges) { int[] in = new int[n]; for (var e : edges) { in[e[1]]++; } int ans = -1; for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { if (ans == -1) ans = i; else return -1; } } return ans; }} 在树上执行操作以后得到的最大分数树形 DP，要求最大分数，可以先求损失的最小分数，然后使用总分减去该分数即可。 123456789101112131415161718192021222324252627282930class Solution { public long maximumScoreAfterOperations(int[][] edges, int[] values) { int n = values.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } long ans = 0L; for (int x : values) { ans += x; } return ans - dfs(0, -1, g, values); } private long dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] values) { if (g[x].size() == 1 &amp;&amp; g[x].get(0) == fa) { return values[x]; } long res = 0L; for (int y : g[x]) { if (y != fa) { res += dfs(y, x, g, values); } } return Math.min(res, values[x]); }} 也可以直接正向做，对于每个节点有两种情况：选择当前节点，要求该节点的每个子树都是健康的；不选当前节点，该节点的所有子节点都可以选。 123456789101112131415161718192021222324252627282930class Solution { public long maximumScoreAfterOperations(int[][] edges, int[] values) { int n = values.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } long[] sum = new long[n]; return dfs(0, -1, g, values, sum); } private long dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] values, long[] sum) { sum[x] = values[x]; if (g[x].size() == 1 &amp;&amp; g[x].get(0) == fa) { return 0; } long dp0 = values[x], dp1 = 0; for (int y : g[x]) { if (y != fa) { dp0 += dfs(y, x, g, values, sum); dp1 += sum[y]; } } sum[x] += dp1; return Math.max(dp0, dp1); }} 平衡子序列的最大和离散化 + 树状数组优化 DP，直接看灵神代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 作者：灵茶山艾府// 链接：https://leetcode.cn/problems/maximum-balanced-subsequence-sum/solutions/2513121/shu-zhuang-shu-zu-you-hua-dp-by-endlessc-3zf4/class Solution { public long maxBalancedSubsequenceSum(int[] nums) { int n = nums.length; int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = nums[i] - i; } Arrays.sort(b); BIT t = new BIT(b.length + 1); for (int i = 0; i &lt; n; i++) { // j 为 nums[i]-i 离散化后的值（从 1 开始） int j = Arrays.binarySearch(b, nums[i] - i) + 1; long f = Math.max(t.preMax(j), 0) + nums[i]; t.update(j, f); } return t.preMax(b.length); }}// 树状数组模板（维护前缀最大值）class BIT { private long[] tree; public BIT(int n) { tree = new long[n]; Arrays.fill(tree, Long.MIN_VALUE); } public void update(int i, long val) { while (i &lt; tree.length) { tree[i] = Math.max(tree[i], val); i += i &amp; -i; } } public long preMax(int i) { long res = Long.MIN_VALUE; while (i &gt; 0) { res = Math.max(res, tree[i]); i &amp;= i - 1; } return res; }}","link":"/2023/11/07/%E7%AC%AC%20370%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 908 (Div. 2)","text":"Secret Sport因为题目保证存在合法的 \\(X\\) 和 \\(Y\\)，那么获胜者总是最后一个下棋者，因为如果不是最后一个，那么对局就不会结束。 12345public static void solve() { int n = io.nextInt(); String s = io.next(); io.println(s.charAt(n - 1));} Two Out of Three对于一组相同元素，它只能满足一个条件，如果满足两个条件，那么它必定会满足三个条件。所以至少要有两组出现次数大于等于 \\(2\\) 的元素，然后分别让其满足一个条件即可。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int k = 2; int[] b = new int[n]; Arrays.fill(b, 1); int[] cnt = new int[101]; for (int i = 0; i &lt; n &amp;&amp; k &lt;= 3; i++) { if (++cnt[a[i]] == 2) { b[i] = k++; } } if (k &lt;= 3) { io.println(-1); return; } for (int i = 0; i &lt; n; i++) { io.print(b[i] + &quot; &quot;); } io.println();} Anonymous Informant如果当前数组是通过移动得到，那么它的最后一个元素必定是由定点元素转移过来，所以我们只需要判断最后一个元素是否在 \\([1,n]\\) 范围内，然后不断地回滚左移操作，即不断地找到移动之前的最后一个元素位置，并进行判断即可。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int i = n - 1; while (b[i] != -1 &amp;&amp; b[i] &lt; n &amp;&amp; --k &gt; 0) { int j = (i - (b[i] + 1) + n) % n; b[i] = -1; i = j; } io.println(k == 0 || b[i] == -1 ? &quot;Yes&quot; : &quot;No&quot;);} Neutral Tonality我们总是可以构造一个数组 \\(c\\)，使得 \\(\\operatorname{LIS}(c)=\\operatorname{LIS}(a)\\)，方法为将数组 \\(b\\) 中的元素 \\(b_{i}\\)，插入到数组 \\(a\\) 中第一个满足 \\(a_{j}\\leq b_{i}\\) 的元素 \\(a_{j}\\) 之前，操作方式类似归并排序。 12345678910111213141516171819202122232425262728293031public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var b = new Integer[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b, ((e1, e2) -&gt; e2 - e1)); int i = 0, j = 0, k = 0; int[] ans = new int[n + m]; while (i &lt; n || j &lt; m) { if (i &gt;= n) { ans[k++] = b[j++]; } else if (j &gt;= m) { ans[k++] = a[i++]; } else if (a[i] &lt;= b[j]) { ans[k++] = b[j++]; } else { ans[k++] = a[i++]; } } for (int x : ans) { io.print(x + &quot; &quot;); } io.println();}","link":"/2023/11/08/Codeforces%20Round%20908%20(Div.%202)/"},{"title":"Project #4 - Concurrency Control","text":"项目准备项目地址：Project #4 - Concurrency Control。 准备工作：阅读 Chapter 18 19，学习 Lecture #15 #16 #17 #18 #19 #20，以及阅读课堂笔记。 项目结构项目的注释中有锁升级的矩阵图，但是没有兼容性的矩阵图，这里贴一下。 Task #1 - Lock Manager实现① 比较关键的一个问题是，LockRequestQueue 里面存什么。我之前漏掉 granted_ 成员，导致整个项目理解都有问题。一个请求会经历未获取锁、已获取锁，已释放锁三个过程，LockRequestQueue 存储所有没有被释放的锁请求，即前两个过程。因为之后能否获取锁，需要和之前已经获取的锁做兼容性判断。 ② 加锁阶段： 代码组织：我们可以根据请求的锁模式来分类讨论，也可以根据事务的锁模式来分类讨论，也可以根据事务是否有锁进行分类讨论。我最后是选择最后一种方式，这样写起来真的简洁。如果当前事务没有该资源的锁，则将请求入队，并且根据该资源是否被其他事务上锁，从而直接拿锁或者进行等待；否则，判断能否进行锁升级。 锁升级： 根据提示，首先判断请求的锁模式是否和事务的锁模式是否相同，如果相同则直接返回 true。我在这里有个比较疑惑的点，如果请求锁模式的级别低于当前持有的锁模式，应该也可以直接返回 true，但是注释中并没有提及，并且线上测试结果告诉我不行，必须抛出异常。似乎是设计的问题，讨论在此，而且这个讨论似乎说的也不完整。 然后判断是否可以锁升级，如果可以，我们需要释放之前的锁，并等待获取升级的锁。这两个步骤可以通过修改队列中的 LockRequest 实现，将锁模式修改为新的锁模式，将 granted_ 修改为 false，然后 cv_.wait() 即可。关键是条件变量的获取锁的条件如何编写。注意，一定要在等待之前从当前事务的锁集中移除原来的锁，因为线上测试会在等待时检查锁集。 获取锁：如何以 FIFO 的方式获取锁，并且使兼容的锁可以同时获取，以及使锁升级的优先级最高。遍历请求队列，如果当前事务是锁升级请求，则只需判断当前请求是否和已 granted_ 的请求兼容。如果当前事务不是锁升级请求，并且存在其他事务的锁升级请求，则直接返回 false，否则不仅需要判断当前请求是否和已 granted_ 的请求兼容，还需要判断当前请求是否和在该请求之前的未 granted_ 的请求兼容。 ③ 解锁阶段：按照注释模拟，需要注意从队列中移除完成的锁请求，并在最后执行 cv_.notify_all()。 ④ 事务的 ABORTED 状态：如果事务被中止，那么应该取消该事务所做的操作，事务中止之后会自动调用 TransactionManager::Abort 函数来进行解锁和还原所有写操作。但是如果事务在等待锁的过程中被中止，那么就需要我们手动重置，因为 Abort 函数不会清除未获取锁的请求。步骤如下：在使用条件变量时，额外判断当前事务的状态是否是 ABORTED，如果是则直接退出等待，并从队列中移除该请求，如果是锁升级还要记得重置 upgrading_，最后调用 cv_.notify_all() 并返回 false。 补充① 一个细节问题，在获取 map 中的 LockRequestQueue 时，我依赖 C++ 在使用 [] 访问会自动创建对象的特性，没有注意到 map 中存的是智能指针，这样默认是创建空指针，结果就会报各种奇怪的错误。 ② 表解锁同样需要改变事务的状态，一开始我天真的以为只需要在行解锁的时候改变就行，因为我以为加表锁必定会加行锁，但是不是这样的，可以只加表锁（或许全表扫描就是只加表锁而不加行锁）。 ③ 线上测试遇到神奇的错误，pthread_mutex_lock.c:94: _pthread_mutex_lock: Assertion ‘mutex-&gt;data.__owner == 0’ failed，而且不是每次测试都会发生。经过排查，发现又是自动补全的锅，导致重复执行 unlock() 操作，有关该错误的讨论在此。 ④ 目前似乎不需要使用事务锁，单个事务加锁/解锁是单线程的。 Task #2 - Deadlock Detection① 构建等待图，使用二重循环遍历 table_lock_map_ 和 row_lock_map_ 来向 waits_for_ 添加从 granted_ == false 请求到 granted_ == true 请求的边。其实这样单纯的加边是比较简单的，但是可能存在锁兼容的情况，这样构成的环是不会造成死锁的，导致误杀事务，不过测试能过就不改代码了。记得加锁。 ② 因为可以存在很多环，如果检测顺序不一样，中止的事务可能完全不同，所以 NOTES 中要求我们从最小的事务开始做 DFS，按照从小到大的顺序遍历相邻节点，如果找到环，则中止环中最大的事务。如果事务被中止，则应该从图中删掉连接该事务的边，或者也可以打标记。有坑！！！HasCycle 应该包含什么代码，之前我是把最小事务编号作为参数传递，然后从该事务开始做 DFS 来检测环。但是线上 GraphTest 测试会调用 HasCycle，按照线上测试代码的逻辑，HashCycle 应该包含整个环检测代码，包括排序 waits_for_，排序 GetEdgeList 得到的边集，以及 DFS。特别注意，不要在 HashCycle 中调用 txn_manager_ 的任何方法，因为 GraphTest 测试根本就没创建事务！！！我是调试半天找不到错，才反应过来，非常无语。 ③ 最后，从 HasCycle 返回时，删除中止事务的边，然后调用 TransactionManager::Abort 函数中止事务。在消除所有环之后清空 waits_for_。 Task #3 - Concurrent Query Execution① 非常非常无语！！！就是我在 Task#1 中提到的，高级锁可以包含低级锁的需求，不应该抛出异常，结果测试不给过，Task#3 又需要我兼容这种情况，那么只能在 Executor 代码中特判了。 ② 根据提示，should not acquire S/X table lock, grab IS/IX instead，只为表加 IS/IX 锁。 ③ 细节问题：行加锁之后再判断行是否删除，这个错误找很长时间才发现；死锁检测在调用 Abort 函数之前，先将事务状态设置为 ABORTED，否则当前事务可能会在之后的解锁过程中被唤醒，触发 LOCK_ON_SHRINKING 异常；实现 Abort 函数时，将恢复阶段放在解锁阶段之前，不然可能会有并发问题。 Leaderboard Task (Optional)① 初次提交。 Rank Submission Name Update QPS Count QPS Weighted QPS 59 ALEX 14 14 14 测试结果 12345678910111213#!/bin/bashmake lock_manager_test -j$(nproc)make deadlock_detection_test -j`nproc`make txn_integration_test -j`nproc`make -j`nproc` terrier-bench ./test/lock_manager_test./test/deadlock_detection_test./test/txn_integration_test./bin/bustub-terrier-bench --duration 30000make formatmake check-lintmake check-clang-tidy-p4make submit-p4 项目小结难点就在项目理解以及代码细节上，Task#1 和 Task#2 被队列和 HashCycle 的理解整晕了，然后要使代码能够在多线程情况下正常运行，一定要注意代码中逻辑的先后顺序！！！实现过程部分参考做个数据库：2022 CMU15-445 Project4 Concurrency Control，Task#1 的解释帮助很大。","link":"/2023/11/14/Project%204%20-%20Concurrency%20Control/"},{"title":"第 371 场力扣周赛","text":"找出强数对的最大异或值 I暴力。 高访问员工模拟。 最大化数组末位元素的最少操作次数两种情况，分类讨论。 找出强数对的最大异或值 II要找满足 \\(\\mid x-y\\mid\\leq\\min(x,y)\\) 的数对，可以排序化简公式，得到 \\(x\\leq y\\leq2x\\)。然后我们可以使用双指针，枚举 \\(y\\) 或者 \\(x\\) 都行，基本上就是把满足条件的数添加到 0-1 trie 树中，把不满足条件的从树中删除，一边枚举一边计算最大异或值。还可以使用哈希表做，参考灵茶山艾府的题解。","link":"/2023/11/14/%E7%AC%AC%20371%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"CUM 15-445 课程总结","text":"幻灯片和笔记，其他同学整理的笔记，Discord 讨论。 本来想做个课程总结和项目总结的，但是有点没心情做，排行榜优化也暂时搁置吧。:( Advanced SQL查询满足某个条件的记录数量： 12SELECT COUNT(*) FROM t WHERE xx;SELECT SUM(IF(xx, 1, 0)) FROM t; 查询满足某个条件的记录百分率： 1SELECT ROUND(AVG(IFNULL(xx, 0)), 2) FROM t; 窗口函数（文档：12.20 Window Functions）： 12SELECT ROW_NUMBER() OVER(PARTITION BY xx ORDER BY xx) FROM t;SELECT AVG(xx) OVER (PARTITION BY xx ORDER BY xx ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) 日期和时间函数（文档：12.7 Date and Time Functions）： 12SELECT DATE_FORMAT(xx, xx);SELECT DATEDIFF(xx, xx);","link":"/2023/11/15/CUM%2015-445%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"第 372 场力扣周赛","text":"使三个字符串相等等价于求字符串的最长公共前缀。 12345678910class Solution { public int findMinimumOperations(String s1, String s2, String s3) { int n = Math.min(s1.length(), Math.min(s2.length(), s3.length())); int i = 0; while (i &lt; n &amp;&amp; s1.charAt(i) == s2.charAt(i) &amp;&amp; s2.charAt(i) == s3.charAt(i)) { i++; } return i == 0 ? -1 : s1.length() + s2.length() + s3.length() - 3 * i; }} 区分黑球与白球将每个 \\(1\\) 右边 \\(0\\) 的个数累加就是需要交换的次数，或者累加每个 \\(0\\) 左边 \\(1\\) 的个数也行。 1234567891011class Solution { public long minimumSteps(String s) { long ans = 0L; int n = s.length(), cnt = 0; for (int i = n - 1; i &gt;= 0; i--) { if (s.charAt(i) == '0') cnt++; else ans += cnt; } return ans; }} 最大异或乘积要求 \\(\\max((a\\oplus x)\\times(b\\oplus x))\\)，可以得出异或只会在两者都为 \\(0\\) 的位上补 \\(1\\)，或者交换两者某位上的 \\(0\\) 和 \\(1\\)。此时 \\((a\\oplus x)+(b\\oplus x)=c\\)，\\(c\\) 为某个定值，从而问题可以转化为求函数 \\(y=x(c-x)\\) 的最大值，可以知道当 \\(x=\\frac{c}{2}\\) 时取到最大值，即我们需要让 \\((a\\oplus x)\\) 和 \\((b\\oplus x)\\) 尽可能相等。 123456789101112131415161718class Solution { private static final int MOD = (int) 1e9 + 7; public int maximumXorProduct(long a, long b, int n) { long p = a &gt;&gt; n &lt;&lt; n, q = b &gt;&gt; n &lt;&lt; n; for (int i = n - 1; i &gt;= 0; i--) { if ((a &gt;&gt; i &amp; 1) == (b &gt;&gt; i &amp; 1)) { p |= 1L &lt;&lt; i; q |= 1L &lt;&lt; i; } else if (p &lt; q) { p |= 1L &lt;&lt; i; } else { q |= 1L &lt;&lt; i; } } return (int) (p % MOD * (q % MOD) % MOD); }} 找到 Alice 和 Bob 可以相遇的建筑离线查询，可以预处理查询序列，然后使用单调栈 + 二分，或者使用最小堆；在线查询，可以使用线段树（暂时不学）。","link":"/2023/11/20/%E7%AC%AC%20372%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 330","text":"Counting Passes模拟。 12345678910public static void solve() { int n = io.nextInt(), l = io.nextInt(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (io.nextInt() &gt;= l) { ans++; } } io.println(ans);} Minimize Abs 1等价于求 \\(y=|x-a_{i}|\\) 在区间 \\([L,R]\\) 内的最小值对应的 \\(x\\)。 1234567891011121314public static void solve() { int n = io.nextInt(), l = io.nextInt(), r = io.nextInt(); for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); if (l &lt;= a &amp;&amp; a &lt;= r) { io.print(a + &quot; &quot;); } else if (a &lt; l) { io.print(l + &quot; &quot;); } else { io.print(r + &quot; &quot;); } } io.println();} Minimize Abs 2对于每个固定的 \\(x\\)，可以在 \\(O(1)\\) 时间内求出 \\(|y^{2}+(x^{2}-D)|\\) 的最小值（也可以二分），我们枚举 \\([0,\\lceil\\sqrt{D}\\rceil]\\) 范围内的所有 \\(x\\)。 12345678910111213141516public static void solve() { long d = io.nextLong(); long ans = Long.MAX_VALUE; long up = (long) Math.sqrt(d) + 1; for (long x = 0; x &lt;= up; x++) { long t = x * x - d; if (t &gt;= 0) { ans = Math.min(ans, t); } else { long y = (long) Math.sqrt(-t); ans = Math.min(ans, Math.abs(y * y + x * x - d)); ans = Math.min(ans, Math.abs((y + 1) * (y + 1) + x * x - d)); } } io.println(ans);} Counting Ls对行列计数，然后枚举交叉点。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } int[] row = new int[n]; int[] col = new int[n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i][j] == 'o') { row[i]++; col[j]++; } } } long ans = 0L; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i][j] == 'o' &amp;&amp; col[j] &gt; 1) { ans += (long) (col[j] - 1) * (row[i] - 1); } } } io.println(ans);} Mex and Update因为只有 \\(n\\) 个数，所以只需要考虑 \\([0,n]\\) 范围的数的增删，这样集合就可以存储单个数。比赛时没注意，使用的是区间，然后删除区间中的数，需要进行分裂，会麻烦很多，还需要排序以及考虑最左和最右的特殊区间。 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), q = io.nextInt(); int[] a = new int[n]; int[] cnt = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); if (a[i] &lt;= n) { cnt[a[i]]++; } } TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt;= n; i++) { if (cnt[i] == 0) { set.add(i); } } while (q-- != 0) { int i = io.nextInt() - 1, x = io.nextInt(); if (a[i] &lt;= n &amp;&amp; --cnt[a[i]] == 0) { set.add(a[i]); } a[i] = x; if (a[i] &lt;= n &amp;&amp; cnt[a[i]]++ == 0) { set.remove(a[i]); } io.println(set.first()); }}","link":"/2023/11/26/AtCoder%20Beginner%20Contest%20330/"},{"title":"第 118 场力扣夜喵双周赛","text":"查找包含给定字符的单词模拟。 1234567891011class Solution { public List&lt;Integer&gt; findWordsContaining(String[] words, char x) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) { if (words[i].contains(x + &quot;&quot;)) { ans.add(i); } } return ans; }} 最大化网格图中正方形空洞的面积分别求出行和列的最长连续线段，然后最大正方形面积就是两者最小值加一的平方。 1234567891011121314151617181920212223class Solution { public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) { Arrays.sort(hBars); Arrays.sort(vBars); int maxH = 0, maxV = 0; for (int i = 0, j = 0; j &lt; hBars.length; j++) { if (hBars[j] - hBars[i] == j - i) { maxH = Math.max(maxH, j - i + 1); } else { i = j; } } for (int i = 0, j = 0; j &lt; vBars.length; j++) { if (vBars[j] - vBars[i] == j - i) { maxV = Math.max(maxV, j - i + 1); } else { i = j; } } int len = Math.min(maxH, maxV) + 1; return len * len; }} 购买水果需要的最少金币数动态规划，\\(dp[i]\\) 表示获取 \\([i,n]\\) 范围内所有水果所需的最少金币数，有 \\(dp[i]=prices[i]+\\min_{j=i+1}^{2i+1}{dp[j]}\\)，时间复杂度 \\(O(n^{2})\\)。 12345678910111213class Solution { public int minimumCoins(int[] prices) { int n = prices.length; for (int i = (n + 1) / 2 - 1; i &gt; 0; i--) { int min = Integer.MAX_VALUE; for (int j = i + 1; j &lt;= 2 * i + 1; j++) { min = Math.min(min, prices[j - 1]); } prices[i - 1] += min; } return prices[0]; }} 单调队列优化，时间复杂度 \\(O(n)\\)。 12345678910111213141516171819class Solution { public int minimumCoins(int[] prices) { int n = prices.length; Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = n; i &gt; 0; i--) { while (!q.isEmpty() &amp;&amp; q.peekFirst() &gt; 2 * i + 1) { q.pollFirst(); } if (i &lt;= (n + 1) / 2 - 1) { prices[i - 1] += prices[q.peekFirst() - 1]; } while (!q.isEmpty() &amp;&amp; prices[q.peekLast() - 1] &gt;= prices[i - 1]) { q.pollLast(); } q.offerLast(i); } return prices[q.peekLast() - 1]; }} 找到最大非递减数组的长度单调队列优化 DP，随缘补题。","link":"/2023/11/26/%E7%AC%AC%20118%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 373 场力扣周赛","text":"循环移位后的矩阵相似检查模拟。有个性质，如果左移 \\(k\\) 位之后相等，则右移 \\(k\\) 位也必定相等。 12345678910111213class Solution { public boolean areSimilar(int[][] mat, int k) { int m = mat.length, n = mat[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] != mat[i][((j + (i % 2 == 0 ? 1 : -1) * k) % n + n) % n]) { return false; } } } return true; }} 统计美丽子字符串 I将元音字母看作 \\(1\\)，非元音字母看作 \\(-1\\)，使用前缀和 + 哈希表的技巧，可以得到若干个分组，每组中任意两个下标构成的子数组都满足条件一。然后我们可以暴力判断所有满足条件一的子数组的长度是否满足条件二，时间复杂度为 \\(O(n^{2})\\)。（补充：可以纯暴力做，不需要分组。） 123456789101112131415161718192021222324class Solution { public int beautifulSubstrings(String s, int k) { int n = s.length(), sum = 0; Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); map.computeIfAbsent(0, t -&gt; new ArrayList&lt;&gt;()).add(-1); for (int i = 0; i &lt; n; i++) { sum += set.contains(s.charAt(i)) ? 1 : -1; map.computeIfAbsent(sum, t -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = 0; for (var list : map.values()) { for (int j = 0; j &lt; list.size() ; j++) { for (int i = 0; i &lt; j; i++) { int len = (list.get(j) - list.get(i)) / 2; if (len * len % k == 0) { ans++; } } } } return ans; }} 交换得到字典序最小的数组如果 \\(|nums[i]-nums[j]|&lt;=limit\\)，那么就可以交换 \\(nums[i]\\) 和 \\(nums[j]\\)，该交换的性质具有传递性，所以我们可以对原数组进行排序，只要相邻元素的差值小于等于 \\(limit\\)，它们就在同一个可交换集合中。这样可以将原数组划分为若干可交换集合，然后对每个集合排序，从小到大排列即可。 12345678910111213141516171819202122232425262728293031class Solution { public int[] lexicographicallySmallestArray(int[] nums, int limit) { int n = nums.length; var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; nums[i] - nums[j]); int pre = -limit; List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(); for (int i : aux) { if (nums[i] - pre &gt; limit) { buckets.add(new ArrayList&lt;&gt;()); } buckets.get(buckets.size() - 1).add(i); pre = nums[i]; } int[] ans = new int[n]; for (var bucket : buckets) { List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); pos.addAll(bucket); Collections.sort(pos); for (int i = 0; i &lt; pos.size(); i++) { ans[pos.get(i)] = nums[bucket.get(i)]; } } return ans; }} 统计美丽子字符串 II朴素做法的瓶颈在 \\((\\frac{L}{2})^{2}\\bmod{k}=0\\) 的判断上，可以通过将条件二变换为 \\(L\\bmod{k^{\\prime}}=0\\)，然后使用前缀和以及下标模 \\(k^{\\prime}\\) 的值来分组，这样同组内的下标两两组合得到的必定是满足两个条件的子数组。灵神题解，时间复杂度 \\(O(n+\\sqrt{k})\\)。还有另一种枚举的做法，题解。","link":"/2023/11/26/%E7%AC%AC%20373%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 911 (Div. 2)","text":"Cover in Water只要存在三个连续的空格，就可以执行两次操作一，再多次执行操作二，来装满所有空格。 123456789101112131415public static void solve() { int n = io.nextInt(); String s = io.next(); String[] arr = s.split(&quot;#&quot;); int ans = 0; for (String t : arr) { int m = t.length(); if (m &gt;= 3) { io.println(2); return; } ans += m; } io.println(ans);} Laura and Operations注意题目说的是剩下一种类型的数字，而不是一个数字。如果剩下数字 \\(1\\)，那么首先将 \\(2\\) 和 \\(3\\) 抵消，如果 \\(2\\) 多于 \\(3\\)，那么多出的数量如果是偶数，就可以将该数量的一半执行操作，再做一次抵消，最后就只剩下 \\(1\\)；反之亦然。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (Math.abs(b - c) % 2 == 0) io.print(1); else io.print(0); io.print(&quot; &quot;); if (Math.abs(a - c) % 2 == 0) io.print(1); else io.print(0); io.print(&quot; &quot;); if (Math.abs(a - b) % 2 == 0) io.print(1); else io.print(0); io.println();} Anji’s Binary Tree做一次后序遍历即可。题目说的是选择任意字母替换，而不是选择其他节点上的字母替换。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); String s = io.next(); int[][] g = new int[n][]; for (int i = 0; i &lt; n; i++) { int l = io.nextInt() - 1, r = io.nextInt() - 1; g[i] = new int[]{l, r}; } io.println(dfs(0, g, s));}private static int dfs(int x, int[][] g, String s) { if (g[x][0] == -1 &amp;&amp; g[x][1] == -1) { return 0; } int res = Integer.MAX_VALUE; if (g[x][0] != -1) { res = Math.min(res, dfs(g[x][0],g, s) + (s.charAt(x) != 'L' ? 1 : 0)); } if (g[x][1] != -1) { res = Math.min(res, dfs(g[x][1],g, s) + (s.charAt(x) != 'R' ? 1 : 0)); } return res;} Small GCD\\(f(a,b,c)\\) 表示 \\(a,b,c\\) 中最小的两个数的 \\(\\gcd\\)，而我们要求出给定数组的所有不同下标构成的三元组的 \\(f\\) 之和。暴力的想法是枚举中间值，然后计算以该值为中心构成的三元组的 \\(\\gcd\\) 之和，时间复杂度为 \\(O(n^{2})\\)。正确的做法：由于数据范围比较小，我们可以首先计算出 \\([1,N]\\) 范围内每个数的所有约数，然后排序数组，对数组中的每个数枚举它的约数，从而计算出以该约数的倍数作为最大公约数的三元组的个数，然后利用容斥原理得到以该约数作为最大公约数的三元组的个数，最后可以计算出答案。 123456789101112131415161718192021222324252627282930313233343536373839private static final int N = 100000;private static final List&lt;Integer&gt;[] aux;static { aux = new List[N + 1]; Arrays.setAll(aux, k -&gt; new ArrayList&lt;&gt;()); for (int i = 1; i &lt;= N; i++) { for (int j = i; j &lt;= N; j += i) { aux[j].add(i); } }}public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); int[] c = new int[N + 1]; long[] f = new long[N + 1]; for (int i = 0; i &lt; n; i++) { for (int x : aux[a[i]]) { f[x] += (long) c[x] * (n - i - 1); c[x]++; } } long ans = 0L; for (int i = N; i &gt;= 1; i--) { for (int j = i + i; j &lt;= N; j += i) { f[i] -= f[j]; } ans += f[i] * i; } io.println(ans);} Transitive Graph似乎是和强连通分量相关的题目，有空可以补一下。","link":"/2023/11/27/Codeforces%20Round%20911%20(Div.%202)/"},{"title":"第 374 场力扣周赛","text":"需要添加的硬币的最小数量题目 输入长度为 \\(n\\) 的数组 \\(a\\) 和整数 \\(k\\)，输出需要向数组插入多少个数，使得数组的子序列能够表示 \\([1,k]\\) 范围内的所有整数。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq k\\leq 10^{5}\\)。 思路 从小到大遍历数组，假设当前能够表示的区间为 \\([0,s]\\)，此时遍历到数组中的数 \\(a_{i}\\)，我们可以表示区间 \\([a_{i},s+a_{i}]\\)。 如果 \\(a_{i}\\leq s+1\\)，那么就可以合并两个区间，得到 \\([0,s+a_{i}]\\)，然后继续遍历 \\(a_{i+1}\\)。 否则，需要向数组插入数 \\(s+1\\) 来保证区间连续，得到 \\([0,2s+1]\\)，然后再次遍历 \\(a_{i}\\)。 不断重复上述过程直到能够表示区间 \\([1,k]\\)。 排序数组的时间复杂度为 \\(O(n\\log{n})\\)，插入操作最多执行 \\(O(\\log{k})\\) 次。 统计完全子字符串题目 输入长度为 \\(n\\) 的由小写英文字母组成的字符串 \\(s\\) 和整数 \\(k\\)，输出满足以下两个条件的子字符串的个数。 每个字符恰好出现 \\(k\\) 次。 相邻字符在字母表中的距离小于等于 \\(2\\)。 数据范围：\\(1\\leq k\\leq n\\leq 10^{5}\\)。 思路 距离大于 \\(2\\) 的相邻字符可以将字符串分割成若干子串，对于每个子串 \\(t\\) 考虑满足条件一的子串 \\(t_{i}\\) 个数即可。我们可以枚举 \\(t_{i}\\) 包含多少个不同的字符（设为 \\(x\\)），对于每个 \\(x\\) 使用滑动窗口可以得到 \\(t\\) 中满足条件一的长度为 \\(kx\\) 的子串个数。时间复杂度为 \\(O(|\\Sigma| n)\\)，外层循环执行 \\(O(|\\Sigma|)\\) 次，内层循环滑窗执行 \\(O(n)\\) 次，滑窗的同时使用计数数组统计有多少个字符恰好出现 \\(k\\) 次，判断的时间复杂度为 \\(O(1)\\)。 统计感冒序列的数目题目 输入整数 \\(n\\) 和长度为 \\(m\\) 的按照升序排列的数组 \\(a\\)，数组 \\(a\\) 存储下标 \\([0,n-1]\\) 的子序列，输出所有不在数组 \\(a\\) 中的下标被选择的方案数，答案对 \\(10^{9}+7\\) 取余。下标 \\(i\\) 可以被选择，当且仅当下标 \\(i-1\\) 或者 \\(i+1\\) 被选择，数组 \\(a\\) 中的下标可以看作是被选择的。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq m\\leq n-1\\)，\\(0\\leq a_{i}\\leq n-1\\)。 思路 数组 \\(a\\) 中的下标将 \\([0,n-1]\\) 划分为多个子数组，首先考虑每个子数组内部的方案数：最左和最右的子数组只存在一种选择方案，其他子数组存在 \\(2^{x_{i}-1}\\) 种选择方案，\\(x_{i}\\) 为该子数组的长度。然后考虑子数组之间的方案数，最初我们有 \\(n-m\\) 个位置可以放置下标，假设各个子数组的长度分别为 \\(x_{0},x_{1},\\dots,x_{k}\\)，那么总共有 \\(\\prod_{i=0}^{k}{C(n-m-\\sum_{j=0}^{i-1}{x_{j}},x_{i})}=\\frac{(n-m)!}{\\prod_{i=0}^{k}{x_{i}!}}\\) 种放置方案。将两者相乘即可得到答案，计算过程需要使用逆元和快速幂。","link":"/2023/12/05/%E7%AC%AC%20374%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 119 场力扣夜喵双周赛","text":"消除相邻近似相等字符题目 输入长度为 \\(n\\) 的字符串 \\(s\\)，输出所需的最少操作次数，使得字符串 \\(s\\) 中的相邻字符在字母表中的距离大于 \\(1\\)。每次操作可以将字符串 \\(s\\) 中的某个字符修改为任意字符。 数据范围：\\(1\\leq n\\leq 100\\)。 思路 思路一：距离大于 \\(1\\) 的相邻字符可以将字符串 \\(s\\) 分割为若干子串，每个子串所需的最少操作次数为 \\(\\lfloor\\frac{l}{2}\\rfloor\\)，其中 \\(l\\) 表示子串的长度。 思路二：如果相邻字符距离小于等于 \\(1\\)，那么贪心的修改右边的字符即可。 两种思路原理是一样的，只是实现时略有不同。 关闭分部的可行集合数目题目 输入整数 \\(n\\) 表示有 \\(n\\) 个节点，长度为 \\(m\\) 表示无向边的数组 \\(e\\)（包含重边），以及整数 \\(d\\)。输出删除节点的方案数，使得剩余节点两两之间的最短路不超过 \\(d\\)。 数据范围：\\(1\\leq n\\leq 10\\)，\\(0\\leq m\\leq 1000\\)。其他数据不会影响时间复杂度，所以不列出。 思路 题目要求满足条件的方案数，首先想到枚举所有方案，总共有 \\(2^{n}\\) 个方案，然后对每个方案求删除节点后的多源最短路（Floyd 算法），如果剩余节点两两之间的最短路都不超过 \\(d\\)，那么答案就加一，总时间复杂度为 \\(O(m+2^{n}n^{3})\\)。因为是求最短路，所以重边可以只保留最小的那条边。","link":"/2023/12/10/%E7%AC%AC%20119%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 375 场力扣周赛","text":"统计最大元素出现至少 K 次的子数组题目 输入长度为 \\(n\\) 的数组 \\(a\\) 和整数 \\(k\\)，输出满足 \\(\\max(a)\\) 至少出现 \\(k\\) 次的子数组的数目。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq k\\leq 10^{5}\\)。 思路 首先计算出最大值，然后将所有最大值的下标放入列表 \\(l\\) 中，最后枚举右端点即可。假设列表的长度为 \\(m\\)，当前枚举到 \\(i\\)，当 \\(i&lt;m-1\\) 时，区间 \\([l[i],l[i+1]-1]\\) 范围内的右端点都对应 \\(l[i-k+1]+1\\) 数量的左端点，将它们相乘加入答案。特别的，当 \\(i=m-1\\) 时，取区间 \\([l[i],n-1]\\)。PS：也可以滑动窗口，使窗口内只包含 \\(k-1\\) 个最大值，这样计算答案的空间复杂度为 \\(O(1)\\)。 统计好分割方案的数目题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出将数组分割为若干不相交子数组的方案数。不相交表示子数组之间没有相同的元素，答案对 \\(10^{9}+7\\) 取余。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路 因为要求子数组之间没有相同元素，那么相同元素必定只会出现在一个子数组中，首先统计每个元素的最小和最大下标，这两个下标构成的区间是不可分割的。然后将所有不可分割的区间进行合并，最后剩余的区间数假设为 \\(m\\)，那么就会有 \\(2^{m-1}\\) 种分割方案（因为 \\(m\\) 个区间有 \\(m-1\\) 个分割位置，每个分割位置有分割或者不分割两种状态）。PS：① 可以边计数边做乘法，不使用快速幂；② 可以只统计最大下标，然后遍历数组时维护最大下标的最大值，如果当前下标等于该值，那么就可以做一次分割。（代码）","link":"/2023/12/10/%E7%AC%AC%20375%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 915 (Div. 2)","text":"Begginer’s Zelda题目输入一颗树，输出执行的最少操作次数，使得该树只有一个节点。每次操作可以选择树中的两个节点，将它们之间的路径压缩为一个节点，所有连接路径上节点的边都会连向新节点。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq u_{i},v_{i}\\leq n\\)，\\(u_{i}\\neq v_{i}\\)。 思路每次操作贪心的选择两个叶子节点（度数为 \\(1\\) 的节点都看作叶子），根据叶子节点的数量 \\(x\\) 的奇偶性分类讨论： 如果 \\(x\\) 为奇数，\\(x=1\\) 需要 \\(0\\) 次操作，\\(x=3\\) 需要 \\(2\\) 次操作，之后每增加两个叶子，都会使操作次数加 \\(1\\)，由于数据范围限制初始时叶子至少有 \\(2\\) 个，所以操作次数为 \\(\\frac{x+1}{2}\\)。 如果 \\(x\\) 为偶数，\\(x=2\\) 需要 \\(1\\) 次操作，\\(x=4\\) 需要 \\(2\\) 次操作，之后每增加两个叶子，都会使操作次数加 \\(1\\)，所以操作次数为 \\(\\frac{x}{2}\\)。 最后，可以将两种情况的公式合并为 \\(\\lfloor\\frac{x+1}{2}\\rfloor\\)。 Largest Subsequence题目输入长度为 \\(n\\) 的字符串 \\(s\\)，输出执行的最少操作次数，使得字符串有序。每次操作可以将字符串中字典序最大的子序列循环右移一位。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)。 思路首先使用单调栈求出字典序最大的子序列（非严格单调递减），然后通过观察可以发现，执行多次操作最终会将该子序列反转。相当于求最少右移次数，使得子序列反转，该次数等于子序列长度减去子序列中最大字符的数量。其次，还需要判断子序列反转之后，字符串是否有序。 Cyclic MEX题目输入一个包含 \\({0,1,2,\\dots,n-1}\\) 的排列 \\(p\\)，输出排列 \\(p\\) 的所有循环移动的最大代价。对于数组 \\(a\\)，它的代价为 \\(\\sum_{i=1}^{n}{\\operatorname{mex}([a_{1},a_{2},\\dots,a_{i}])}\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路观察每循环左移一次，代价是如何变化的： 排列 \\(2,3,6,7,0,1,4,5\\) 对应的代价为 \\(0,0,0,0,1,4,5,8\\)； 排列 \\(3,6,7,0,1,4,5,2\\) 对应的代价为 \\(0,0,0,1,2,2,2,8\\)； 排列 \\(6,7,0,1,4,5,2,3\\) 对应的代价为 \\(0,0,1,2,2,2,3,8\\)。 可以发现每当将数 \\(x\\) 移动到排列末尾，所有大于 \\(x\\) 的 \\(\\operatorname{mex}\\) 值都会变为 \\(x\\)，然后 \\(x\\) 位置对应的 \\(\\operatorname{mex}\\) 值为 \\(n\\)。 我们可以首先将排列移动为 \\(1,4,5,2,3,6,7,0\\) 形式，对应的代价为 \\(0,0,0,0,0,0,0,8\\)。然后使用单调递增栈维护左移的数构成的递增序列，栈中存储数的下标，模拟上述过程并维护最大代价。","link":"/2023/12/18/Codeforces%20Round%20915%20(Div.%202)/"},{"title":"第 376 场力扣周赛","text":"使数组成为等数数组的最小代价题目输入长度为 \\(n\\) 的整数数组 \\(a\\)，输出执行任意次操作后使得数组中的数全部相等并且是回文数的最小代价（要求该回文数小于 \\(10^{9}\\)）。每次操作可以将数组中的某个数（假设为 \\(a_{i}\\)）修改为任意正整数（假设为 \\(x\\)），对应的代价为 \\(|a_{i}-x|\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq10^{9}\\)。 思路如果没有限制是回文数，那么将数组排序之后按如下方式修改，代价是最小的（假设有序数组中的元素为 \\(a_{0},a_{1},\\dots,a_{n-1}\\)）： 当 \\(n\\) 为奇数时，将所有数修改为中位数 \\(a_{\\lfloor\\frac{n}{2}\\rfloor}\\)。 当 \\(n\\) 为偶数时，将所有数修改为区间 \\([a_{\\lfloor\\frac{n-1}{2}\\rfloor},a_{\\lfloor\\frac{n}{2}\\rfloor}]\\) 内的某个数。 首先使用反证法证明，最小代价可以通过将所有数修改为数组中的某个数取到。 假设将所有数修改为 \\(x\\)，\\(x\\) 在区间 \\((a_{i},a_{i+1})\\) 范围内，其中 \\(a_{i}\\) 和 \\(a_{i+1}\\) 表示数组中相邻的两个数。此时 \\(x\\) 左边有 \\(i+1\\) 个元素，右边有 \\(n-i\\) 个元素。将 \\(x\\) 修改为 \\(a_{i+1}\\) 会使代价增加 \\((i+1)\\times (a_{i+1}-x)\\)，并且使代价减少 \\((n-i)\\times(a_{i+1}-x)\\)。将 \\(x\\) 修改为 \\(a_{i}\\) 会使代价减少 \\((i+1)\\times (x-a_{i})\\)，并且使代价增加 \\((n-i)\\times(x-a_{i})\\)。 当 \\(i+1&lt;n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i+1}\\) 会使代价减少；当 \\(i+1&gt;n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i}\\) 会使代价减少；当 \\(i+1=n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i}\\) 或者 \\(a_{i+1}\\) 代价不变。 特别的，\\(x\\) 在区间 \\([1,a_{0})\\) 或者 \\((a_{n-1},+\\infty]\\) 范围内时，同理。 然后再使用反证法证明上述结论： 假设将数组中的数都修改为 \\(a_{i}\\) 时，代价最小，\\(a_{i}\\) 不满足上述条件。 当 \\(n\\) 为奇数时，由于 \\(a_{i}\\) 不是中位数： 当 \\(i&lt;\\lfloor\\frac{n}{2}\\rfloor\\) 时，有 \\(i+1&lt;n-1-i\\)，此时 \\(i\\) 每向中位数移动一位，代价都会减少 \\((n-1-i)-(i+1)&gt;0\\)。 反之亦然。 当 \\(n\\) 为偶数时，同理。 综上，得出按照上述方式修改代价最少，即 \\(x\\) 越靠近中位数代价越小。所以，如果需要将所有数修改为某个回文数，那么该回文数一定是最靠近中位数的回文数。PS：还是灵神的证明更简单。 该题有两种方法可以找到距离 \\(x\\) 的最近回文数： 方法一：将 \\(x\\) 的前半部分作为回文根，对称之后得到回文数 \\(y\\)。如果 \\(y&lt;x\\)，则将回文根加一再做对称得到回文数 \\(z\\)，然后取 \\(y\\) 和 \\(z\\) 中距离最近者；如果 \\(y&gt;x\\)，则将回文根减一再做对称得到回文数 \\(z\\)，然后取 \\(y\\) 和 \\(z\\) 中距离最近者；否则，\\(x\\) 本身就是回文数。注意，排除大于等于 \\(10^{9}\\) 的回文数，以及做加减法时可能会遇到回文根为 \\(100\\dots0\\) 或 \\(99\\dots9\\) 的特殊情况，此时做对称会得到错误答案，我们应该直接根据长度构造回文数。（这个代码还挺好看，把所有情况都直接循环枚举，就可以不用写那么多判断语句） 方法二：枚举出 \\([1,10^{9}]\\) 范围内的所有回文数，然后二分找到距离 \\(x\\) 最近的回文数。 执行操作使频率分数最大题目输入长度为 \\(n\\) 的整数数组 \\(a\\) 和一个整数 \\(k\\)，输出经过至多 \\(k\\) 次操作之后，数组中众数的最大频率。每次操作可以选择数组中的某个数 \\(a_{i}\\)，将其增加或者减少 \\(1\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)，\\(0\\leq k\\leq 10^{14}\\)。 思路排序 + 前缀和 + 滑动窗口。要使众数尽可能多，可以首先对数组排序，假设最终众数有 \\(x\\) 个，那么这 \\(x\\) 个数一定是在某个子数组中。使用滑动窗口，将尽可能多的数包含在窗口内，同时满足操作次数小于等于 \\(k\\)，如果大于 \\(k\\) 则将左端点右移。类似上一题，将窗口内的所有数都修改为窗口的中位数，所需的操作次数最少。窗口的操作次数可以使用前缀和 \\(O(1)\\) 的计算出来，假设窗口的左右端点的下标分别为 \\(i\\) 和 \\(j\\)，中位数的下标为 \\(k\\)，则窗口的操作次数为：\\((a_{k}\\times (k-i)-(s[k]-s[i]))+((s[j+1]-s[k+1])-a_{k}\\times (j-k))\\)。","link":"/2023/12/18/%E7%AC%AC%20376%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Educational Codeforces Round 160 (Rated for Div. 2)","text":"Swap and Delete题目输入长度为 \\(n\\) 的二进制字符串，输出执行操作需要的最小成本，使得对于操作之后得到的字符串 \\(t\\) 的每个字符 \\(t_{i}\\)，都有 \\(t_{i}\\neq s_{i}\\)，其中 \\(1\\leq i\\leq |t|\\)。有两种操作： 从字符串 \\(s\\) 中删除一个字符，操作的成本为 \\(1\\)。 交换字符串 \\(s\\) 中的两个字符，操作的成本为 \\(0\\)。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)。 思路由于只有删除操作会导致成本增加，所以我们只需要让字符串 \\(t\\) 尽可能长就好。首先对字符串 \\(s\\) 中的 \\(0\\) 和 \\(1\\) 计数，然后贪心的构造字符串 \\(t\\)，如果 \\(s_{i}=0\\)，则 \\(t_{i}=1\\)，反之亦然，直到不能增加长度为止。最后最小成本就是 \\(n-|t|\\)。 Game with Multiset题目输入一个整数 \\(m\\) 表示查询的次数，以及 \\(m\\) 行查询，每行包含两个整数 \\(t_{i}\\) 和 \\(v_{i}\\)。初始时你有一个空的多重集合（multiset）： 如果 \\(t_{i}=1\\)，将元素 \\(2^{v}\\) 加入集合。（\\(0\\leq v_{i}\\leq 29\\)） 如果 \\(t_{i}=2\\)，询问 \\(v_{i}\\) 是否可以表示为当前集合的某个子集之和，并输出 YES 或 NO。（\\(0\\leq v_{i}\\leq 10^{9}\\)） 数据范围：\\(1\\leq m\\leq 10^{5}\\)。 思路 方法一：使用数组对 \\(t_{i}=1\\) 的 \\(v_{i}\\) 计数，对于每个询问，从低到高遍历 \\(v_{i}\\) 的二进制 \\(1\\)。假设当前遍历到 \\(2^{k}\\)，如果集合中存在 \\(2^{k}\\) 则当前位可以被表示（假设集合中有 \\(c_{k}\\) 个 \\(2^{k}\\)），并且集合中剩余的 \\(2^{k}\\) 可以合并为 \\(\\frac{c_{k}-1}{2}\\) 个 \\(2^{k+1}\\)，然后遍历下一位，这样最终可以判断 \\(v_{i}\\) 是否能被集合表示。 方法二：使用数组对 \\(t_{i}=1\\) 的 \\(v_{i}\\) 计数，对于每个询问，从高到低遍历 \\(v_{i}\\) 的二进制 \\(1\\)。假设当前遍历到 \\(2^{k}\\)，则执行 \\(v_{i}=v_{i}-(\\min{(v_{i}&gt;&gt;k,c_{k})}&lt;&lt;k)\\) 操作（假设集合中有 \\(c_{k}\\) 个 \\(2^{k}\\)），表示将集合中的元素尽可能填补到 \\(v_{i}\\) 中，最终 \\(v_{i}\\) 还需要多少值，如果最终 \\(v_{i}=0\\) 则它可以被集合表示。 Array Collapse题目输入长度为 \\(n\\) 的数组 \\(p\\)，其中的元素互不相同。输出执行任意次操作能够得到的不同数组个数，结果对 \\(998244353\\) 取余。每次操作可以选择 \\(p\\) 的一个子数组（假设为 \\([i,j]\\)），将子数组中除最小值之外的所有数删除。 数据范围：\\(1\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq p_{i}\\leq 10^{9}\\)。 思路 方法一：使用分治 + 线段树的时间复杂度为 \\(O(n\\log{n})\\) 的思路，比赛时大概就是这个思路，不过想岔了一点。对于区间 \\([i,j]\\)，使用线段树找到区间最小值的下标，然后左右分治求不同数组的个数，最后将两者相乘。这个方法还有一些特殊情况需要维护，具体看代码。 方法二：参考灵神视频单调栈优化 DP，将 \\(f[i]\\) 定义为以 \\(p[i]\\) 结尾的子序列个数，然后利用动态规划转移，最后将所有 \\(f[i]\\) 求和得到答案。单调栈这个规律有点难想，具体看视频吧。","link":"/2023/12/21/Educational%20Codeforces%20Round%20160%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 916 (Div. 3)","text":"Three Activities题目输入长度为 \\(n\\) 的数组 \\(a,b,c\\)，输出 \\(a_{i}+b_{j}+c_{k}\\) 的最大值，要求 \\(i,j,k\\) 互不相同。 数据范围：\\(3\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i},b_{i},c_{i}\\leq 10^{8}\\)。 思路 方法一：可以发现答案只和数组 \\(a,b,c\\) 中最大的三个元素有关，首先建立三个数组对应的下标数组，对其降序排序。然后使用三重循环暴力枚举前三个元素的组合，要求 \\(i,j,k\\) 互不相同，最后取组合的最大值作为答案。 方法二：状压 DP，定义 \\(dp[i][j]\\) 表示 \\([0,i]\\) 范围内从 \\(j\\)（\\(0\\leq j\\leq 7\\)）所对应数组中各取一个元素，能够得到的元素和的最大值。例如，当 \\(j=3\\) 时，表示从 \\(a\\) 和 \\(b\\) 中取元素。可以使用倒序枚举的方式优化空间。 Game with Marbles (Hard Version)题目输入长度为 \\(n\\) 的数组 \\(a,b\\)，输出游戏结束时的得分 \\(s\\)。游戏内容为：玩家 \\(A,B\\) 每次可以选一个下标 \\(i\\)，如果当前轮到玩家 \\(A\\)，则进行 \\(s=s+(a_{i}-1)\\) 操作，否则进行 \\(s=s-(b_{i}-1)\\) 操作，不能重复选择同一个下标。游戏从玩家 \\(A\\) 开始，并且假设 \\(A,B\\) 双方都以最优的方式进行游戏。 数据范围：\\(2\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq a_{i},b_{i}\\leq 10^{9}\\)。 思路假设当前轮到玩家 \\(A\\)，选择下标 \\(i\\)，则答案会增加 \\(a_{i}-1\\)，并且 \\(b_{i}\\) 将会无效化。相当于每次选择对答案的贡献为 \\(a_{i}+b_{i}\\)，建立一个下标数组，按照该方式对数组降序排序。然后让玩家 \\(A,B\\) 依次选择数组中的下标，该游戏方式是最优的。","link":"/2023/12/21/Codeforces%20Round%20916%20(Div.%203)/"},{"title":"第 120 场力扣夜喵双周赛","text":"统计移除递增子数组的数目 II题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出子数组的数目，使得移除该子数组之后剩余的数是严格递增的，空数组也被认为是递增的。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 首先找到第一个满足 \\(a_{i}&gt;=a_{i+1}\\) 的下标 \\(i\\)。如果 \\(i=n-1\\)，则表示可以移除任意子数组，直接返回 \\(\\frac{n(n-1)}{2}\\)。否则，我们需要移除一个子数组使得剩余前缀和后缀分别递增，并且前缀的右端点小于后缀的左端点。可以使用双指针，一个指针枚举后缀的左端点 \\(j\\)，另一个指针从 \\(i\\) 开始左移，寻找满足条件的前缀的右端点 \\(i\\)，然后将 \\(i+2\\) 添加到答案中，重复此过程直到 \\(a_{j}&gt;=a_{j+1}\\)。","link":"/2023/12/26/%E7%AC%AC%20120%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 377 场力扣周赛","text":"移除栅栏得到的正方形田地的最大面积题目 输入整数 \\(m\\) 和 \\(n\\)，表示宽为 \\(m\\) 长为 \\(n\\) 的矩形，左上角为 \\((1,1)\\)，右下角为 \\((m,n)\\)。输入长度分别为 \\(p\\) 和 \\(q\\) 的数组 \\(a\\) 和 \\(b\\)，数组 \\(a\\) 中的数对矩形水平分割，数组 \\(b\\) 中的数对矩形垂直分割。输出从数组 \\(a\\) 和 \\(b\\) 中移除任意个数，所能够形成的最大正方形面积，结果对 \\(10^{9}+7\\) 取余。 数据范围：\\(3\\leq m,n\\leq 10^{9}\\)，\\(1\\leq p,q\\leq 600\\)，\\(1&lt;a_{i}&lt;m\\)，\\(1&lt;b_{i}&lt;n\\)。 思路 首先考虑对于宽来说，能够表示的长度是多少。显然，可以通过二重循环枚举出所有可能的长度。将宽能够表示的长度放入哈希表，然后同样使用二重循环枚举长能够表示的长度（假设当前枚举到长度 \\(x\\)），如果该长度在哈希表中，则说明可以形成长度为 \\(x\\) 的正方形。最后输出最大值即可。 转换字符串的最小成本 II题目 输入长度为 \\(n\\) 的字符串 \\(source\\) 和 \\(target\\)，以及长度为 \\(m\\) 的字符串数组 \\(original\\)、\\(changed\\) 和 \\(cost\\)。其中 \\(cost[i]\\) 表示将字符串 \\(original[i]\\) 替换为 \\(changed[i]\\) 的成本。输出将 \\(source\\) 转换为 \\(target\\) 所需的最小成本，如果无法转换则输出 \\(-1\\)。任意两个替换操作所替换的区间要么相同，要么不相交。 数据范围：\\(1\\leq n\\leq 1000\\)，\\(1\\leq m\\leq 100\\)，\\(1\\leq \\operatorname{len}(original[i])=\\operatorname{len}(changed[i])\\leq n\\)。 思路 首先使用哈希表将 \\(original\\) 和 \\(changed\\) 数组中的字符串映射为数字，每个数字都作为图中的一个顶点。对于每个下标 \\(i\\)，建立一条从顶点 \\(original[i]\\) 到顶点 \\(changed[i]\\) 的边，然后使用 Floyd 算法求出多源最短路径。最后使用动态规划，定义 \\(dp[i+1]\\) 为对 \\(source\\) 的前缀 \\([0,i]\\) 做替换使其和 \\(target\\) 的前缀 \\([0,i]\\) 相等，所需的最小代价。注意，外层循环枚举前缀的右端点 \\(i\\)，内层循环枚举 \\(original\\) 数组，总时间复杂度为 \\(O(m^{3}+n^{2}m)\\)。使用字典树会更快，参考灵神题解。","link":"/2023/12/26/%E7%AC%AC%20377%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 917 (Div. 2)","text":"Least Product题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出能够使 \\(\\prod_{i=1}^{n}{a_{i}}\\) 最小的最小操作次数。每次操作可以选择数组中的任意元素 \\(a_{i}\\)，如果 \\(a_{i}&lt;0\\)，则可以将其改为 \\([a_{i},0]\\) 中的任意整数，否则可以将其改为 \\([0,a_{i}]\\) 中的任意整数。 数据范围：\\(1\\leq n\\leq 100\\)，\\(-10^{9}\\leq a_{i}\\leq 10^{9}\\)。 思路 由于操作只会让所有元素乘积的绝对值变小，所以如果乘积是非正数，则不需要进行操作，否则只需进行一次操作，将任意一个元素改为 \\(0\\)。 Erase First or Second Letter题目 输入长度为 \\(n\\) 的字符串 \\(s\\)，输出进行任意次操作能够得到的不同非空字符串的个数。每次操作可以删除字符串的第一个字符或者第二个字符。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路 方法一：枚举剩余字符串的第一个字符下标 \\(i\\)，对于每个 \\(i\\) 都可以通过不断删除第二个字符得到 \\(n-i\\) 个不同的字符串。然后思考什么时候会出现相同的字符串，假设两次枚举的第一个字符分别为 \\(i\\) 和 \\(j\\)（\\(i&lt;j\\)），只有当 \\(s_{i}=s_{j}\\) 时才有可能出现相同字符串，进一步观察可以发现，对 \\(i\\) 操作得到的 \\(n-i\\) 个不同的字符串总是包含对 \\(j\\) 操作得到的 \\(n-j\\) 个不同的字符串。所以，假设字符串 \\(s\\) 中有 \\(m\\) 个不同的字符，每个字符第一次出现的位置分别为 \\(k_{0},k_{1},\\dots,k_{m-1}\\)，则答案为 \\(\\sum_{i=0}^{m-1}(n-k_{i})\\)。 方法二：枚举剩余字符串的第二个字符下标 \\(i\\)，对于每个 \\(i\\) 它的贡献为 \\([0,i-1]\\) 中不同字符的个数。 Watering an Array题目 输入长度为 \\(n\\) 的整数数组 \\(a\\)，长度为 \\(k\\) 的整数数组 \\(v\\)，以及整数 \\(d\\)。输出执行 \\(d\\) 次操作能够得到的最大分数。有两种类型的操作： 假设当前执行第 \\(i\\) 次操作，则将数组 \\(a\\) 的前缀 \\([a_{1},a_{b_{i}}]\\) 都加 \\(1\\)。其中 \\(b_{i}=v_{((i-1)\\bmod k)+1}\\)。 将 \\(a_{j}=j\\) 的元素个数加到分数中，然后将数组中的所有元素都置为 \\(0\\)。（下标从 \\(1\\) 开始） 数据范围：\\(1\\leq n\\leq 2000\\)，\\(1\\leq k\\leq 10^{5}\\)，\\(k\\leq d\\leq 10^{9}\\)，\\(0\\leq a_{i}\\leq n\\)，\\(1\\leq v_{i}\\leq n\\)。 思路 如果数组 \\(a\\) 中的元素都为 \\(0\\)，显然最大分数为 \\(\\lfloor\\frac{d}{2}\\rfloor\\)，对应的方案为交替执行两种操作。也就是说，解决问题的关键是确定何时第一次将数组 \\(a\\) 重置。这可以通过枚举实现，但是由于 \\(d\\) 很大，肯定不能直接枚举范围 \\([1,d]\\)。进一步观察可以发现，对前缀进行 \\(2n\\) 次加法，再重置最多得到 \\(n\\) 分，而先重置再交替执行操作，能够得到的分数大于等于 \\(n\\)，所以只需要枚举范围 \\([1,2n]\\)。 Yet Another Inversions Problem题目 输入长度为 \\(n\\) 的数组 \\(p\\)，表示 \\([1,2n-1]\\) 中所有奇数的一个排列。输入长度为 \\(k\\) 的数组 \\(q\\)，表示 \\([0,k-1]\\) 中所有整数的一个排列。定义长度为 \\(nk\\) 的数组 \\(a\\)，对于 \\(0\\leq i&lt;n\\) 和 \\(0\\leq j&lt;k\\)，有 \\(a_{i\\cdot k+j}=p_{i}\\cdot 2^{q_{j}}\\)。输出数组 \\(a\\) 的逆序数，结果对 \\(998244353\\) 取余。 数据范围：\\(1\\leq n,k\\leq 2\\cdot 10^{5}\\)，\\(1\\leq p_{i}\\leq 2n-1\\)，\\(0\\leq q_{i}&lt;k\\)。 思路 可以将数组看作 \\(n\\times k\\) 的矩阵，逆序数可以分为行内和行间。所有行的行内逆序数都是数组 \\(q\\) 的逆序数，使用归并排序或者树状数组即可求解，所以难点在如何快速求出行间的逆序数。首先尝试两两枚举所有行，然后观察对于确定的两个行，它们的逆序数有什么特点。由此可以发现，两行之间的逆序数大概是一个等差数列之和，项数和其他边界条件是由 \\(p_{i}\\) 和 \\(p_{j}\\) 的大小关系确定的。具体来说，假设 \\(p_{i}&lt;p_{j}\\)，等差数列是由满足 \\(p_{i}\\cdot 2^{z}&lt;p_{j}\\) 条件的最大的 \\(z\\) 确定的，确定 \\(z\\) 需要花费 \\(O(\\log{n})\\) 的时间。从而可以得到时间复杂度为 \\(O(n^{2}\\log{n}+k\\log{k})\\) 的朴素解法。（总是假设 \\(i&lt;j\\)） 下面解释等差数列是如何得到的，假设 \\(p_{i}\\cdot 2^{z}&lt;p_{j}\\)（\\(z\\geq0\\)），将对应的两行合并之后可以得到如下序列： $$ p_{i}\\cdot 2^{0},p_{i}\\cdot 2^{1},\\dots,p_{i}\\cdot 2^{z},p_{j}\\cdot 2^{0},p_{i}\\cdot 2^{z+1},p_{j}\\cdot 2^{1},\\dots,p_{i}\\cdot 2^{k-1},p_{j}\\cdot 2^{k-z-1},\\dots,p_{j}\\cdot 2^{k-1} $$ 要求逆序数，可以通过对每个 \\(p_{i}\\) 项前面有多少个 \\(p_{j}\\) 项计数，然后求和得到。可以发现，\\(p_{i}\\cdot 2^{z+1}\\) 前面有 \\(1\\) 个 \\(p_{j}\\) 项，\\(p_{i}\\cdot 2^{z+2}\\) 前面有 \\(2\\) 个 \\(p_{j}\\) 项，\\(p_{i}\\cdot 2^{k-1}\\) 前面有 \\(k-1-z\\) 个 \\(p_{j}\\) 项。得到逆序数为 \\(\\frac{(k-z)(k-1-z)}{2}\\)。 同理，假设 \\(p_{j}\\cdot 2^{z}&lt;p_{i}\\)（\\(z\\geq0\\)），将对应的两行合并之后可以得到如下序列： $$ p_{j}\\cdot 2^{0},p_{j}\\cdot 2^{1},\\dots,p_{j}\\cdot 2^{z},p_{i}\\cdot 2^{0},p_{j}\\cdot 2^{z+1},p_{i}\\cdot 2^{1},\\dots,p_{j}\\cdot 2^{k-1},p_{i}\\cdot 2^{k-z-1},\\dots,p_{i}\\cdot 2^{k-1} $$ 可以发现，\\(p_{i}\\cdot 2^{k-z-1}\\) 到 \\(p_{i}\\cdot 2^{k-1}\\) 的逆序数都为 \\(k\\)，总和为 \\(k(z+1)\\)。剩余部分的逆序数构成首项为 \\(z+1\\)，尾项为 \\(k-1\\)，公差为 \\(1\\) 的等差数列，总和为 \\(\\frac{(k+z)(k-1-z)}{2}\\)。得到逆序数为 \\(\\frac{(k+z)(k-1-z)}{2}+k(z+1)\\)。 如何降低时间复杂度？通过上述分析，可以知道对于任意 \\(p_{i}\\) 和 \\(p_{j}\\)，它们之间的逆序数是由 \\(z\\) 决定的。也就是说，如果给定 \\(p_{i}\\) 和 \\(z\\)（\\(z\\) 为任意整数），对于任意满足 \\(p_{i}\\cdot 2^{z}&lt;p_{j}&lt;p_{i}\\cdot 2^{z+1}\\) 条件的 \\(p_{j}\\) 来说，\\(p_{i}\\) 和 \\(p_{j}\\) 之间的逆序数都是相同的。注意，当 \\(z&lt;0\\) 时，对不等式变形得到 \\(p_{i}\\cdot 2^{-1}&lt;p_{j}\\cdot 2^{-z-1}&lt;p_{i}\\)，此时的 \\(z\\) 和上面逆序数公式中的 \\(z\\) 不同，并且需要处理整数除法的舍入问题（存在一些边界情况）。 要快速求出区间中 \\(p_{j}\\) 的个数，可以使用树状数组/线段树，从而可以得到 \\(O(n\\log{\\min(\\log{n},k)}+k\\log{k})\\) 的解决方案。外层循环枚举 \\(p_{i}\\)（倒序遍历数组 \\(p\\)，因为之前的讨论都基于 \\(i&lt;j\\) 的假设），内层循环枚举 \\(z\\)（大小由 \\(n\\) 和 \\(k\\) 限制），然后使用树状数组求区间和，之后可以 \\(O(1)\\) 时间内计算出该区间的 \\(p_{j}\\) 和当前枚举的 \\(p_{i}\\) 之间的逆序数。 PS：还有另一种写法，只需要对树状数组的前缀求和，而不是区间求和，写起来好像更简单，但是没看懂。好难，溜了。","link":"/2023/12/26/Codeforces%20Round%20917%20(Div.%202)/"},{"title":"数据复制","text":"复制指在多个节点上存储相同的数据，以降低访问延迟（数据分布在多个地理位置），提高容错性和吞吐量。如果复制的数据一成不变，那么只需要简单地将数据复制到每个节点。然而复制的挑战在于如何处理不断变化的数据（如何保证数据的一致性），下面讨论三种流行的应对复制数据变化的方法：主从复制、多主复制和无主复制。 主从复制 工作原理 主从复制也被称为单主复制，客户端必须将写请求发送给主节点，主节点首先将更改应用到本地，然后再将更改发送给所有从节点。客户端可以将读请求发送给主节点或者从节点。 同步和异步复制 同步复制 优点：如果主节点发生故障，则可以在从节点访问到最新数据。 缺点：如果从节点发生故障，则主节点会被阻塞直到从节点复制完成。 异步复制 优点：主节点不会被阻塞，系统的吞吐量更大。 缺点：如果主节点发生不可恢复的故障，则所有未被复制到从节点的更改都会丢失。 实践中，通常只将一个从节点设置为同步模式，其他从节点设置为异步模式。如果主节点发生故障，则可以在同步的从节点访问到最新数据；如果同步的从节点发生故障，则可以将另一个异步的从节点升级为同步模式。这种配置方式被称为半同步。 配置新的从节点 当需要提高系统的容错性或者替换失效的从节点时，就需要增加新的从节点。此时如何保证新的从节点和主节点的数据一致？简单地将数据从主节点复制到从节点是不行的，因为数据在不断变化，这样可能会丢失更改。或者可以对数据库加写锁，但是这会违反高可用的设计目标。 实际上，可以在不中断数据库服务的情况下完成新的从节点的配置。步骤如下：对主节点的数据创建一个一致性快照，将此快照复制到从节点，然后从节点向主节点请求快照之后的更改日志（根据快照中的 LSN 确定），获得日志之后重做日志的更改（这个步骤称为追赶）。 处理节点失效 从节点失效：追赶式恢复 如果从节点发生故障，然后顺利重启，或者主从节点之间的网络发生中断，则从节点可以通过向主节点请求故障期间的日志，并且将日志应用到本地来追赶主节点，从而恢复正常状态。 主节点失效：节点切换 如果主节点发生故障，选择某个从节点将其升级为主节点，同时更新客户端的主节点的信息。切换可以手动进行，也可以自动进行。 自动切换的步骤如下： 确认主节点失效（心跳检测）。 选举新的主节点（共识算法）。 重新配置系统使新主节点生效（修改客户端配置以及原主节点上线之后降级为从节点）。 切换过程存在的问题： 如果使用了异步复制，并且新的主节点并未和原主节点同步，则原主节点上线之后可能会尝试将未完成复制的更改发送到新的主节点，从而产生冲突。常见的解决方案是将未完成复制的更改丢弃，这会违背持久化的承诺。 如果有外部系统依赖于数据库的内容，丢弃数据的方案会产生很严重的问题（可能会导致数据泄露）。 在某些故障下，会发生两个节点同时都认为自己是主节点的情况（称为脑裂），这可能会导致数据丢失或者破坏。 如何设置合适的超时时间来检测主节点失效。 复制日志的实现 原书中描述的是基于语句的复制，基于预写日志的复制，基于行的逻辑日志的复制等。下面将预写日志改为物理日志，将语句和行归为逻辑日志。之所以这样，是因为根据我所看过的一些资料（包括 CMU-15445）都将语句归为逻辑日志，而基于行的复制根据书上的说法，它和存储引擎解耦，同时书上也称其为基于行的逻辑日志的复制，所以我将两者都归为逻辑日志。而把预写日志改为物理日志，是因为书上说预写日志描述的是数据的字节级更改，按照这个说法，明显是预写日志的物理日志模式（CMU-15445 中描述了预写日志的三个日志模式：物理日志，逻辑日志，混合日志）。 基于物理日志的复制 解释：主节点将物理日志发送给从节点。 缺点：由于物理日志描述的是数据的字节级更改，这种复制方案和存储引擎紧密耦合，此时主从节点必须使用相同版本的存储引擎。所以在进行数据库升级时，只能首先将主从节点停机，再进行升级。如果复制方案允许从节点的版本比主节点更高，则可以首先将从节点升级，然后将从节点作为新的主节点，从而实现不停机升级。 基于逻辑日志的复制 解释：分为基于语句的复制和基于行的复制，主节点将逻辑日志（和物理存储引擎解耦的日志格式）发送给从节点。 缺点：如果使用基于语句的复制，则某些语句可能在不同节点产生不同的执行结果。例如：语句使用非确定性函数（NOW，RAND），语句依赖于数据库现有数据，有副作用的语句（触发器、存储过程、用户定义的函数）。 优点：主从节点可以运行不同版本的存储引擎，甚至是不同的存储引擎。对于外部应用程序，逻辑日志格式也更容易解析。 基于触发器的复制 解释：之前的复制都是由 DBMS 实现的，但在某些情况下可能需要更高的灵活性，这时需要将复制交给应用程序实现。一种方法是让应用程序读取数据库日志从而获取数据更改，另一种方法是使用触发器和存储过程，当发生数据更改时自动执行存储过程，将数据更改记录到单独的表中，应用程序通过访问该表来获取数据更改。 分析：此复制方式开销更高，也更容易出错或者暴露一些限制，但是具有更高的灵活性。 复制滞后问题 如果使用异步复制，则会出现主节点和从节点的数据不一致的情况，这种不一致只是暂时的状态。如果停止写数据库，则从节点最终会追赶上主节点，这被称为最终一致性。虽然主从节点最终会保持一致，但是暂时的不一致会引发各种问题，下面将讨论相关问题和解决方案。 写后读 问题：用户写入数据之后立即读取这些数据，如果读请求被发送给滞后的从节点，则用户看不到刚才写入的数据。 解决：此时，我们需要保证写后读一致性（也称为读写一致性），该一致性要求用户能够立即看到自己最近写入的数据，但是不保证其他用户能够立即看到这些数据。系统可以通过跟踪用户最近写入的时间戳，来保证将读请求发送给包含对应数据的节点。 单调读 问题：用户执行两次相同的查询，对应的读请求分别被路由两个不同的从节点，并且第二次查询访问的从节点比第一次查询访问的从节点更滞后。这会导致用户首先看到新数据，然后看到旧数据，就好像数据被回滚一样。 解决：此时，我们需要保证单调读一致性，该一致性要求用户进行多次读取时，不会先读到新数据再读到旧数据，即读取的数据对应的时间戳是单调递增的。系统可以总是将同一用户的读请求路由到同一个节点来保证单调读。 前缀读 问题：存在因果关系的数据被划分到不同的分区，用户在读取数据时可能会先看到果后看到因。 解决：此时，我们需要保证前缀读一致性，该一致性要求按照写入数据的顺序读取数据。对于未分区的单主数据库而言，数据总是按照因果关系的顺序写入数据库[1]，在读取数据时也总是按照因果关系的顺序读取，因此不会发生该异常。但是，如果数据被划分到不同分区，不同分区独立运行，无法保证分区之间的从节点按照因果关系的顺序写入数据[2]，此时将会发生异常。简单的想法是在复制日志中记录时间戳，但是由于存在时钟偏差问题，该方法不可行。一种解决方案是将具有因果关系的写入都交给一个分区完成，但是这样做的效率很低。另一种解决方案是使用版本向量技术跟踪因果关系，这将在无主复制的检测并发写中进行讨论。PS：这部分是按照我的理解描述的，可能存在错误。 多主复制 工作原理 系统中包含多个主节点，每个主节点都可以接收写请求，并且需要将更改发送给其他主节点和自己的从节点。 使用场景 多数据中心：为了容忍数据中心级别的故障或者使数据库更接近用户，可以把数据库的副本存储在多个数据中心。如果使用主从复制，主节点只能存在于某个数据中心，所有写请求都必须经过该数据中心。如果使用多主复制，则可以为每个数据中心设置一个主节点，在数据中心内部使用主从复制，主节点之间通常使用异步复制进行同步。 多主复制相比主从复制在多数据中心场景下的优势：写入延迟更低，对网络性能的依赖更低，能够容忍数据中心失效。缺点是，如果使用异步复制，多个主节点同时更改相同的数据时会产生写冲突。 处理写冲突 冲突检测 如果使用异步复制，那么多个主节点可以同时更改相同的数据，并且只能在稍后的复制过程中检测到冲突。 如果使用同步复制，每次只能进行一个写请求，无法发挥多个主节点的优势，那还不如直接使用主从复制。 冲突避免 可以在应用层保证对相同数据的写请求路由到相同的数据中心，但是在某些时候需要改变事先指定的数据中心，例如在数据中心故障或者用户移动到其他位置导致离某个数据中心更近时，写请求将会被路由到其他数据中心。 冲突解决 可能的解决方式如下： 为每个写请求分配唯一的 ID（时间戳、随机数、UUID、哈希值），然后按照某种规则选择特定的写请求。 为每个节点分配唯一的 ID，然后按照某种规则确定优先级。 将多个写入的值合并。 保存冲突信息，然后在应用层解决冲突。 在应用层解决冲突是最合理的方式，可以在写入时调用用户定义的冲突处理程序解决，还可以保留多个写入值，然后在读取时调用程序或者通知用户解决。还有一些自动解决冲突的方法，包括使用无冲突的复制数据类型（CRDT）、可合并的持久数据结构、操作转换算法。 拓扑结构 复制的拓扑结构描述了写日志从一个节点传播到其他节点的通信路径，包括全部至全部型拓扑（完全图）、环形拓扑、星形拓扑等。在环形和星形拓扑中，写日志需要经过多个节点才能传播到所有节点，为了避免循环复制（自己的写日志被传播给自己，然后又进行一轮传播），在复制日志中都会记录已传播节点的标识符。 星形和环形拓扑的问题是单点故障会影响写日志的传播，这可以通过在故障时重新配置拓扑结构解决。而全部至全部型拓扑的问题是在传播时写日志的因果顺序无法保证（参考复制滞后问题中的前缀读）。 无主复制 工作原理 客户端并行地将写请求发送给多个节点，如果得到多数节点的确认，则认为写入成功。读取时也是并行地从多个节点上读取数据，此时可能得到多个不同的值（由于复制滞后），系统会使用某种机制确定新值以及更新旧值。 读修复和反熵 当节点失效之后重新上线，可以使用以下两种机制进行追赶。 读修复 解释：客户端并行读取多个节点，获取的数据中包含版本号，以判断数据的新旧，同时会更新包含旧数据的节点。 分析：该方法适合读密集的场景，不然包含旧数据的节点得不到更新。 反熵 解释：使用后台进程检测节点之间数据的差异，然后将新数据复制到包含旧数据的节点。 分析：和基于主节点的复制不同，此过程不保证按照特定的顺序复制数据，并且会引入明显的滞后。 读写仲裁（quorum） 如果有 \\(n\\) 个节点参与仲裁，写入时需要得到 \\(w\\) 个节点的确认，读取时至少查询 \\(r\\) 个节点，则只要 \\(w+r&gt;n\\)，读取的节点中就一定会包含最新值。满足该条件的读/写操作被称为仲裁读/写（或者法定票数读/写），可以将 \\(w\\) 和 \\(r\\) 看作是确认读/写操作是否有效的最低票数。 通常会将 \\(n\\) 设置为奇数，将 \\(w\\) 和 \\(r\\) 设置为 \\(\\frac{n+1}{2}\\)。当然也可以根据实际情况做调整，例如对于读多写少的负载，设置 \\(w=n\\) 和 \\(r=1\\) 比较合适，这样读取速度很快，但是只要有一个节点失效就会导致仲裁写失败。 通常读/写请求总是并行发送给所有节点，参数 \\(w\\) 和 \\(r\\) 只是决定要等待的节点数。如果可用的节点数小于 \\(w\\) 或 \\(r\\)，则读/写操作就会返回错误。 也可以将 \\(w\\) 和 \\(r\\) 设置为较小的值，使得 \\(w+r\\leq n\\)，不满足仲裁条件。此时可能读取到的值都是旧值，但是可用获得更低的延迟和更高的可用性。即使在 \\(w+r&gt;n\\) 的情况下，也可能存在只读取到旧值的边界条件。 如果需要更高的容错性，可用使用宽松的读写仲裁：写入和读取仍需要 \\(w\\) 和 \\(r\\) 个节点确认，但是可以利用 \\(n\\) 个节点之外的其它节点（参与仲裁的节点数量为 \\(n\\)，集群中的节点数量大于 \\(n\\)）。例如，当 \\(n\\) 个节点中的多数节点失效时，客户端会向额外的节点发送读/写请求，当失效节点重新上线时，将额外节点中的新值复制到这些滞后的节点。 检测并发写 和多主复制类似，无主复制同样存在写冲突。在多主复制的处理写冲突中介绍过，可以为每个写请求分配一个时间戳，然后选择保留时间戳最大的写请求，这被称为最后写入者获胜（last write wins，LWW）。LWW 可以实现最终一致性，代价是牺牲数据的持久性，因为小于最大时间戳的并发写入都会被覆盖，由于时钟偏差，该算法甚至可能覆盖非并发写入。是否使用该算法依据实际场景而定，例如在缓存系统中覆盖是可以接受的，则可以使用该算法。 我们可以使用版本向量技术来判断两个写操作是否并发。如果一个写操作发生在另一个写操作之前（依赖关系/因果关系），则后面的写操作可以覆盖前面的写操作。如果是并发的，就需要处理写冲突问题。算法的工作流程见书上，本质上就是通过在写之前读，来获取数据的当前值以及版本向量（该数据在所有节点上的版本号的集合），之后的写操作只会覆盖服务器中低版本的数据，从而并发写（高版本）的数据得到保留。PS：书上只是简单提了一下，还有很多细节没说。 首先因被写入数据库，然后因被读取，从而产生果，之后果才被写入数据库。 ↩︎ 参考注 1，分区之间的主节点总是按照因果关系的顺序写入数据，但是分区之间的从节点就无法保证写入顺序。 ↩︎","link":"/2023/12/27/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"},{"title":"数据分区","text":"分区/分片（动词）就是将数据拆分为多个子集，一个子集被称为一个分区[1]（名词）。使用数据分区的目的是提高可扩展性，不同分区可以存储在不同节点上，查询负载也随之分散到多个节点。在面对海量数据集或者非常高的查询压力，使用数据复制还不够，这时就需要使用数据分区。当分区和复制结合使用时（假设为主从复制），每个分区都会有自己的主节点和从节点，这种情况下单个节点也会存储多个分区的数据（作为某个分区的主节点和其他分区的从节点）。 分区方式 最好的情况是将数据和查询负载均匀分布到所有节点。如果分区不均匀，就会出现负载的倾斜，这会导致分区的效率下降。极端情况下，所有负载都集中在单个节点上，其他节点都处于空闲状态，此时这个节点被称为系统的热点。避免热点的最简单的方法是将记录随机分配给所有节点，但是由于不知道数据的分布情况，在查询时需要访问所有节点。下面将会介绍对键值数据和二级索引进行分区的方式。 这节的内容看得有点懵。按我的理解，键（key）也被称为关键字（keyword），它是一列或多列属性的集合，可以是唯一的或者不唯一的。但是按照书中的描述以及我在网上看到的定义来说，在“键值数据”这样的词中，似乎要求键必须是唯一的。书中在介绍完键值数据之后，又紧接着介绍二级索引，然后说二级索引在分区时的复杂性在于索引键的不唯一。但是书中接下来的讨论让我感觉，二级索引在分区时的复杂性在于如何创建二级索引，即是创建本地索引还是全局索引。 键值数据 基于区间的分区 解释：可以为每个分区分配一个关键字区间，区间可以由管理员手段选择，或者由数据库自动选择。 优点：分区内的数据可以按照关键字排序存储，从而支持区间查询。 缺点：如果查询集中访问某个范围内的数据，则会导致热点问题，解决方案是使用额外的内容作为关键字的第一列。 基于哈希的分区 解释：可以为每个分区分配一个哈希值区间，关键字根据哈希值进行分区，用于分区的哈希函数不需要很强的加密性。 分析：可以将关键字均匀的分配到多个分区，但是不能很好地支持关键字上的区间查询（查询时需要将请求发送给所有分区）。如果使用的是联合关键字，则可以只将关键字的第一列用于哈希分区，然后将其他列用作联合索引来对分区内的数据排序，从而可以在关键字的其他列上实现区间查询。 问答：为什么要将哈希值拆分为区间，而不直接使用取模操作？因为如果添加/删除节点，取模会导致大量的数据迁移。 负载倾斜与热点 虽然哈希分区可以减轻热点，但是无法完全避免。极端情况下，所有读/写操作都是针对一个关键字，则最终所有请求都会被路由到同一个分区。例如，发生热点事件时，会产生大量对相同关键字的读/写操作，此时哈希分区起不到作用。大多数系统至今仍无法自动消除这种高度倾斜的负载，而只能通过应用层来减轻倾斜程度。例如，如果某个关键字被认为是热点，则可以通过在关键字的开头或结尾添加随机数（有点像密码学中的盐值），从而将请求路由到不同分区。但是，此时读操作必须将多个分区中的数据合并，开销较大。 二级索引 基于文档的分区 解释：每个分区独自创建和维护二级索引，创建的是本地索引，而非全局索引。 缺点：如果要使用索引查询满足某个条件的数据，则需要将查询请求发送给所有分区，然后合并返回的结果。 基于词条的分区 解释：对所有数据创建全局索引，然后对索引进行分区，可以使用区间或哈希分区。 优点：进行单关键字查询时，只需要读取单个分区，因为相同的索引键都会被分配到相同的节点。 缺点：即使更新的是单个节点上的数据，可能也需要更新多个节点上的索引。如果选择同步更新，那么需要分布式事务的支持，写请求会被阻塞；如果选择异步更新，就意味着更新的滞后。 分区再平衡 在某些情况下，可能需要为数据库添加/删除节点，我们希望在添加/删除节点的过程中平衡所有节点的负载，这个迁移负载的过程被称为再平衡或者动态平衡。 再平衡的策略 固定数量的分区 解释：创建远超实际节点数的固定数量的分区，然后为每个节点分配多个分区。如果添加节点，则从每个现有节点中移动几个分区到新节点；如果删除节点，则将其中的分区均匀分配给剩余节点。也可以将硬件配置考虑进来，为性能更强的节点分配更多的分区。 分析：如果数据的规模不确定，就很难确定合适的分区数量。每个分区包含的数据量的上限是固定的，实际大小应该和集群中的数据总量成正比。如果分区数量太大，则每个分区包含的数据量太小，徒增管理开销；如果分区数量太小，则每个分区包含的数据量太大，再平衡和故障恢复的开销就更大（不是很懂为什么）。 动态分区 解释：为每个分区设置阈值，如果分区中的数据量太大或太小，就会进行分裂或合并（类似 B+ 树）。每个节点可以包含多个分区，当某个分区分裂时，可以将其中一半的数据转移到其他节点，以平衡负载。 分析：优点是分区的数量可以通过分裂和合并自动适配数据总量。对于空的数据库来说，需要进行预分裂，从而避免开始时只存在一个分区，导致负载不均衡的情况。 按节点比例分区 解释：为每个节点分配固定数量的分区。如果添加节点，则随机选择固定数量的现有分区进行分裂。 分析：随机选择可能会带来不公平的分裂，但是当每个节点包含的分区数量较大时，可以减少不公平的概率。 疑问：为什么书上说随机选择分区的前提是使用哈希分区，以及为什么说该方法符合一致性哈希。 请求路由 我们已经知道如何将数据分区，以及如何平衡节点上的分区，现在还有一个问题是，如何将请求路由到对应分区所在的节点。如果发生分区再平衡，分区和节点的对应关系还会随之变化，我们需要能够跟踪这些变化。有如下三种处理策略： 客户端将请求发送给任意节点，如果当前节点没有对应的分区，则将请求转发给其他节点，直到找到对应节点。 客户端将请求发送给路由层（负载均衡器），路由层负责将请求转发给对应节点。 客户端跟踪分区和节点之间的关系，直接将请求发送给对应节点。 不管使用哪种方法，核心问题是：作出路由决策的组件（节点、路由器、客户端）如何跟踪分区和节点的对应关系。有的分布式系统依靠独立的协调服务（例如 ZooKeeper）跟踪对应关系，有的使用 gossip 协议在节点之间同步对应关系，等等。 PS：数据分区这章看得有点痛苦，感觉书上的表述很乱，包括多个同义词混用，以及前后表述不一致。一些部分也讲得很模糊，没有一个实际的例子，单是看某句话感觉会有歧义，不知道实际上想表达的是什么。先这样吧，总感觉笔记上有很多问题。 这里讨论的数据分区和网络分区问题（一种节点间的网络故障）中的分区是不同的概念。 ↩︎","link":"/2023/12/29/%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/"},{"title":"Good Bye 2023","text":"Two Divisors 题目 输入两个整数 \\(a\\) 和 \\(b\\)，它们是 \\(x\\) 的最大除数，满足 \\(1\\leq a\\leq b&lt;x\\)。输出 \\(x\\) 的值。 数据范围：\\(1\\leq a\\leq b&lt;x\\leq 10^{9}\\)。 思路 首先 \\(b\\) 肯定等于 \\(x\\) 除以最小的质因数，然后 \\(a\\) 可能等于 \\(x\\) 除以两次最小的质因数，或者等于 \\(x\\) 除以次小的质因数。这可以根据 \\(b\\bmod a\\) 是否等于 \\(0\\) 来确定，如果是则 \\(x=b\\times\\frac{b}{a}\\)，否则 \\(x=b\\times\\frac{a}{\\gcd(a,b)}\\)。 Mathematical Problem 题目 输入奇数 \\(n\\)，输出 \\(n\\) 个不同的数，它们都是整数的平方，并且 \\(n\\) 个数的数位构成的多重集合都相同。 数据范围：\\(1\\leq n\\leq 99\\)。 思路 只需要在 \\(169,196,961\\) 的基础上添加 \\(0\\) 就可以构造出满足条件的 \\(n\\) 个数，方法直接看题解或者代码吧，反正 \\(169\\) 和 \\(961\\) 这两个数比较特殊，真不知道大家怎么做出来的。","link":"/2023/12/31/Good%20Bye%202023/"},{"title":"第 378 场力扣周赛","text":"找出出现至少三次的最长特殊子字符串 II 题目 输入长度为 \\(n\\) 的由小写字母组成的字符串 \\(s\\)。如果一个字符串仅由单一字符组成，则它被称为特殊字符串。输出在 \\(s\\) 中出现至少三次的最长特殊非空子字符串的长度，如果不存在则输出 \\(-1\\)。 数据范围：\\(3\\leq n\\leq 5\\times 10^{5}\\)。 思路 可以直接想到二分答案，时间复杂度为 \\(O(n\\log{n})\\)。不过该题有 \\(O(n)\\) 的做法，其实就是分类讨论。首先遍历一边数组，将数组按照字母分段，把对应的长度存到桶中。假设字符串 \\(s\\) 的最长特殊子字符串的长度为 \\(m\\)，则答案必定在 \\([m-2,m]\\) 范围内，枚举答案然后判断是否满足条件即可。当然还可以像灵神一样讨论得更细，但是不好理解。 回文串重新排列查询 题目 输入长度为偶数 \\(n\\) 的字符串 \\(s\\)，以及长度为 \\(m\\) 的二维数组 \\(q\\)，其中 \\(q_{i}=[a_{i},b_{i},c_{i},d_{i}]\\)。对于每个查询 \\(i\\)，可以将区间 \\([a_{i},b_{i}]\\) 和 \\([c_{i},d_{i}]\\) 中的字符重新排列，输出是否能让字符串 \\(s\\) 变为回文串。每个查询是独立的。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq m\\leq 10^{5}\\)，\\(0\\leq a_{i}\\leq b_{i}&lt;\\frac{n}{2}\\)，\\(\\frac{n}{2}\\leq c_{i}\\leq d_{i}&lt;n\\)。 思路 比赛时基本的思路是有的，就是没有实现出来。首先可以将后半段字符串反转，将原串当成两个字符串，这就将问题转化为判断操作之后两个字符串能否相等，从而简化实现。然后就是预处理前缀的字符计数（类似前缀和），最后对每个查询分类讨论，两个区间是相离、相交还是包含关系。个人觉得稍微复杂点的就是相交关系该如何判断，具体可以看题解区。","link":"/2023/12/31/%E7%AC%AC%20378%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"再见 2023","text":"时间过得好快！今年大概有 5 个月的时间都在搞算法，然后其他时间基本上每周都会打比赛，虽然对面试来说不应该花费这么多时间，但是我喜欢算法给我带来的反馈，以及比赛时能够高度集中注意力的状态。特别是绞尽脑汁然后 AC 的感觉，真的很棒。即使不会做，赛后也可以通过题解来学习。 力扣基本上可以稳定三题，上 2300 分之后就有点没状态，排名波动有点大。在打 CF 之前就听说，力扣分减 700 大概就是 CF 分，结果还真是这样。CF 思维题较多，前四题基本上不会使用很复杂的数据结构，如果能稳定四题就能到 1900 分吧。AtCoder 题目有点水，对我来说，基本上从 D 题开始才算正式进入比赛，但是经常简单题也没做出来。令人印象深刻的是，获得两次群主发的进步奖（总共 200 元）。 5 月份阅读完《OSTEP》，9、11 月份学习完课程 CMU 15-445，并且做完四个相关的项目，感觉还不错。12 月份阅读《DDIA》25%，然后摸鱼。6-8 月份，高数、线代、Linux、Java 虚拟机、Spring、设计模式雨露均沾，基本上没有特别深入的，当时有点急躁。总的来说，确实有做不少事，但是效率不高，目的不明确，缺乏实践，要做的事还有很多。","link":"/2023/12/31/%E5%86%8D%E8%A7%81%202023/"},{"title":"UNICODE 双向算法","text":"前段时间看到群友聊天，使用特殊的昵称能够让文字的顺序发生变化。我把昵称复制到 IDEA 里面，发现包含一个显示为 RLI 的字符。在网上查询之后，发现是 Unicode 为显示双向文本提供的一个特殊字符，功能是将之后的文本视为独立的从右到左的顺序。还有其他特殊的格式化字符，以及用于解析这些字符并正确显示文本顺序的 Unicode 双向算法。 1print(&quot;⁧;(&quot; 上面的文本在浏览器中会显示为 print(&quot;&quot;);，因为在第一个引号之后有一个 RLI 字符。如果在之后添加文字： 1print(&quot;⁧;(&quot;Hello World! 则会显示为 print(&quot;!Hello World&quot;);，具体的显示方式和双向算法的实现有关。介绍 Unicode 双向算法的两个网站：UNICODE BIDIRECTIONAL ALGORITHM，Unicode Bidirectional Algorithm basics。","link":"/2024/01/01/UNICODE%20%E5%8F%8C%E5%90%91%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"年度总结","slug":"年度总结","link":"/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"CMU 15-445","slug":"课程/CMU-15-445","link":"/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OceanBase","slug":"数据库/OceanBase","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"},{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"书籍","slug":"书籍","link":"/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"DDIA","slug":"书籍/DDIA","link":"/categories/%E4%B9%A6%E7%B1%8D/DDIA/"},{"name":"模板","slug":"基础/模板","link":"/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}