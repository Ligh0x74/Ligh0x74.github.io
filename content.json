{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 893 (Div. 2)","text":"Buttons优先选择公共按钮，当且仅当先手的按钮数量大于后手的按钮数量时，先手者胜。 12345public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (a + c % 2 &gt; b) io.println(&quot;First&quot;); else io.println(&quot;Second&quot;);} The Walkway模拟题，特别需要注意头尾的边界处理，加上哨兵真的会方便很多。可以假设位置 \\(1-d\\) 和位置 \\(n+1\\) 有卖家，这样就不用特判，可以直接处理！！！ 123456789101112131415161718192021222324252627public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] s = new int[m + 2]; for (int i = 1; i &lt;= m; i++) { s[i] = io.nextInt(); } s[0] = 1 - d; s[m + 1] = n + 1; int ans = m - 1, delta = Integer.MAX_VALUE, cnt = 0; for (int i = 1; i &lt;= m; i++) { int A = (s[i] - s[i - 1] - 1) / d; int B = (s[i + 1] - s[i] - 1) / d; int C = (s[i + 1] - s[i - 1] - 1) / d; int D = C - A - B; if (D &lt; delta) { delta = D; cnt = 1; } else if (D == delta) { cnt++; } ans += A; } ans += (s[m + 1] - s[m] - 1) / d + delta - 1; io.println(ans + &quot; &quot; + cnt);} Yet Another Permutation Problem构造题，首先需要发现什么公约数不可能出现，很明显不可能得到 \\(d_{i}=\\gcd (a_{i},a_{(i\\bmod n)+1})&gt; \\lfloor \\frac{n}{2}\\rfloor\\)。然后考虑所有小于等于 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 的数是否能被包含，可以发现对于每个 \\(a_{i}=x\\leq \\lfloor \\frac{n}{2}\\rfloor\\) 总有 \\(a_{(i\\bmod n)+1}=2\\cdot x\\leq n\\)，所以我们可以枚举所有奇数乘以二的幂来构造答案。 12345678910111213public static void solve() { int n = io.nextInt(), idx = 0; int[] ans = new int[n]; for (int i = 1; i &lt;= n; i += 2) { for (int j = i; j &lt;= n; j *= 2) { ans[idx++] = j; } } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} Trees and Segments难以描述，看代码吧，调试半天。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[][] prefix = new int[n + 1][k + 1]; int[][] suffix = new int[n + 1][k + 1]; // 枚举可以在 k 次操作内变为全 0 的子数组，并将其长度记录到所属的前后缀中 for (int i = 0; i &lt; n; i++) { int cnt1 = 0; for (int j = i; j &lt; n; j++) { cnt1 += s[j] - '0'; if (cnt1 &gt; k) break; prefix[j + 1][cnt1] = Math.max(prefix[j + 1][cnt1], j - i + 1); suffix[i][cnt1] = Math.max(suffix[i][cnt1], j - i + 1); } } // 在前缀 [0, i] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= k; j++) { prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i][j]); if (j &gt; 0) prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i + 1][j - 1]); } } // 在后缀 [i, n - 1] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= k; j++) { suffix[i][j] = Math.max(suffix[i][j], suffix[i + 1][j]); if (j &gt; 0) suffix[i][j] = Math.max(suffix[i][j], suffix[i][j - 1]); } } // 枚举连续 1 的起点和终点，并记录该连续 1 的长度对应的连续 0 的最长长度（注意包含长度为 0 的情况） int[] max0by1 = new int[n + 1]; Arrays.fill(max0by1, -1); max0by1[0] = suffix[0][k]; for (int i = 0; i &lt; n; i++) { int cnt0 = 0; for (int j = i; j &lt; n; j++) { cnt0 += (s[j] - '0') ^ 1; if (cnt0 &gt; k) break; max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], prefix[i][k - cnt0]); max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], suffix[j + 1][k - cnt0]); } } // 计算答案 int[] ans = new int[n + 1]; for (int a = 1; a &lt;= n; a++) { for (int i = 0; i &lt;= n; i++) { if (max0by1[i] == -1) continue; ans[a] = Math.max(ans[a], i + max0by1[i] * a); } } for (int i = 1; i &lt;= n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}","link":"/2023/08/16/Codeforces%20Round%20893%20(Div.%202)/"},{"title":"第 111 场力扣夜喵双周赛","text":"统计和小于目标的下标对数目使用排序 + 双指针优化。如果 \\(nums[lo]+nums[hi]&lt;target\\)，那么 \\([lo+1,hi]\\) 范围内的数都能与 \\(nums[lo]\\) 组成对，\\(lo\\) 加一；反之，\\([lo,hi-1]\\) 范围内的数都不能与 \\(nums[hi]\\) 组成对，\\(hi\\) 减一。 Java 123456789101112131415class Solution { public int countPairs(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int lo = 0, hi = nums.size() - 1, ans = 0; while (lo &lt; hi) { if (nums.get(lo) + nums.get(hi) &lt; target) { ans += hi - lo; lo++; } else { hi--; } } return ans; }} C++ 12345678910111213141516class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans = 0; for (int i = 0, j = n - 1; i &lt; j; ) { if (nums[i] + nums[j] &lt; target) { ans += j - i; i++; } else { j--; } } return ans; }}; 循环增长使字符串子序列等于另一个字符串贪心取就行。 Java 1234567891011class Solution { public boolean canMakeSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1.charAt(i) == str2.charAt(j) || (str1.charAt(i) + 1 - 'a') % 26 == str2.charAt(j) - 'a') { j++; } } return j == n; }} C++ 123456789101112class Solution {public: bool canMakeSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1[i] == str2[j] || (str1[i] + 1 - 'a') % 26 == str2[j] - 'a') { j++; } } return j == n; }}; 将三个组排序要将 \\(nums\\) 变为美丽数组，就要将 \\(nums\\) 变为非递减的形式，所以问题就变为求最长非递减子序列。 Java 动态规划： 12345678910111213141516class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), ans = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (nums.get(i) &gt;= nums.get(j)) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } return n - ans; }} 贪心 + 二分： 1234567891011121314151617class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), maxLen = 0; int[] aux = new int[n]; for (int x : nums) { int lo = 0, hi = maxLen - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (aux[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } aux[lo] = x; if (lo == maxLen) maxLen++; } return n - maxLen; }} 状态机 DP： 有点妙啊，\\(dp[i][j]\\) 表示将子数组 \\([0,i]\\) 变为以 \\([1,j]\\) 为结尾的美丽数组所需的最小修改次数，然后可以空间优化。 1234567891011class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int[] dp = {Integer.MAX_VALUE, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = Math.min(dp[i - 1], dp[i] + (x == i ? 0 : 1)); } } return dp[3]; }} C++ 123456789101112class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { int dp[4] = {INT_MAX, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = min(dp[i - 1], dp[i] + (x != i)); } } return dp[3]; }}; 范围中美丽整数的数目经典数位 DP 没什么好说的，主要是记忆化取模，边乘边取模。 Java 1234567891011121314151617181920212223242526class Solution { public int numberOfBeautifulIntegers(int low, int high, int k) { return f(0, 10, 0, true, false, high + &quot;&quot;, k, new Integer[10][20][k]) - f(0, 10, 0, true, false, low - 1 + &quot;&quot;, k, new Integer[10][20][k]); } private int f(int i, int diff, int mod, boolean isLimit, boolean isNum, String s, int k, Integer[][][] dp) { if (i == s.length()) { return isNum &amp;&amp; diff == 10 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff][mod] != null) { return dp[i][diff][mod]; } int res = 0; if (!isNum) res += f(i + 1, diff, mod, false, false, s, k, dp); int lo = isNum ? 0 : 1, hi = isLimit ? s.charAt(i) - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += f(i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true, s, k, dp); } if (!isLimit &amp;&amp; isNum) { dp[i][diff][mod] = res; } return res; }} C++ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int numberOfBeautifulIntegers(int low, int high, int k) { string s; const int BASE = 10; int dp[10][20][k]; auto f = [&amp;](auto self, int i, int diff, int mod, bool isLimit, bool isNum) { if (i == s.size()) { return isNum &amp;&amp; diff == 0 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff + BASE][mod] != -1) { return dp[i][diff + BASE][mod]; } int res = 0; if (!isNum) res += self(self, i + 1, diff, mod, false, false); int lo = isNum ? 0 : 1, hi = isLimit ? s[i] - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += self(self, i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true); } if (!isLimit &amp;&amp; isNum) dp[i][diff + BASE][mod] = res; return res; }; auto calc = [&amp;](int x) { s = to_string(x); memset(dp, -1, sizeof(dp)); return f(f, 0, 0, 0, true, false); }; return calc(high) - calc(low - 1); }};","link":"/2023/08/21/%E7%AC%AC%20111%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 359 场力扣周赛","text":"判别首字母缩略词Java 123456789101112class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { int n = words.size(), m = s.length(); if (n != m) return false; for (int i = 0; i &lt; n; i++) { if (words.get(i).charAt(0) != s.charAt(i)) { return false; } } return true; }} C++ 12345678910111213class Solution {public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) { int m = words.size(), n = s.size(); if (m != n) return false; for (int i = 0; i &lt; n; i++) { if (words[i][0] != s[i]) { return false; } } return true; }}; k-avoiding 数组的最小总和贪心。 Java 123456class Solution { public int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }} C++ 1234567class Solution {public: int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }}; 销售利润最大化不从动态规划的角度思考，我首先用的是对左端点排序。如果用动态规划，那么根据转移方程就会对右端点排序，处理方式也比对左端点排序简单一些。还可以不排序做，使用桶存储相同 \\(end\\) 的 \\(offer\\)，分别处理每个桶。 Java 1234567891011121314class Solution { public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) { Collections.sort(offers, (a, b) -&gt; a.get(1) - b.get(1)); offers.add(List.of(n - 1, n - 1, 0)); int m = offers.size(), i = 0; int[] leftMax = new int[n + 1]; for (var offer : offers) { int s = offer.get(0), e = offer.get(1), g = offer.get(2); for (; i &lt;= e; i++) leftMax[i + 1] = leftMax[i]; leftMax[e + 1] = Math.max(leftMax[e + 1], leftMax[s] + g); } return leftMax[n]; }} C++ 1234567891011121314151617class Solution {public: int maximizeTheProfit(int n, vector&lt;vector&lt;int&gt;&gt;&amp; offers) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; groups(n); for (auto &amp;offer : offers) { groups[offer[1]].emplace_back(offer[0], offer[2]); } vector&lt;int&gt; f(n + 1); for (int end = 0; end &lt; n; end++) { f[end + 1] = f[end]; for (auto &amp;[start, gold] : groups[end]) { f[end + 1] = max(f[end + 1], f[start] + gold); } } return f[n]; }}; 找出最长等值子数组Java 滑动窗口： 12345678910111213141516171819class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int lo = 0, hi = 0, ans = 0; while (hi &lt; n) { map.merge(nums.get(hi++), 1, Integer::sum); if (hi - lo - map.get(nums.get(lo)) &gt; k) { map.merge(nums.get(lo++), -1, Integer::sum); } ans = Math.max(ans, map.get(nums.get(lo))); } while (lo + 1 &lt; n) { map.merge(nums.get(lo++), -1, Integer::sum); ans = Math.max(ans, map.get(nums.get(lo))); } return ans; }} 滑动窗口（优化）： 优化一：观察到 \\(1\\leq nums[i]\\leq nums.lenth\\)，所以可以用数组模拟哈希表。 优化二：滑动窗口直接枚举右端点，这样可以枚举到所有情况。但是如何保证删除的元素数量小于等于 \\(k\\) 呢？当左端点的值 \\(nums[i]\\) 不能构成等值数组，则将左端点右移。为什么这样可以保证？当 \\(nums[i]\\neq nums[j]\\) 时，移动左端点不影响答案；当 \\(nums[i]=nums[j]\\) 时，移动左端点可以保证删除的元素数量小于等于 \\(k\\)。 1234567891011121314class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; int[] map = new int[n + 1]; for (int i = 0, j = 0; j &lt; n; j++) { map[nums.get(j)]++; if (j - i + 1 - map[nums.get(i)] &gt; k) { map[nums.get(i++)]--; } ans = Math.max(ans, map[nums.get(j)]); } return ans; }} C++ 分组 + 双指针： 123456789101112131415161718192021class Solution {public: int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); for (int i = 0; i &lt; n; i++) { pos[nums[i]].push_back(i); } for (auto &amp;ps : pos) { int left = 0; for (int right = 0; right &lt; ps.size(); right++) { while (ps[right] - ps[left] - right + left &gt; k) { left++; } ans = max(ans, right - left + 1); } } return ans; }};","link":"/2023/08/21/%E7%AC%AC%20359%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 315","text":"tcdr模拟。 Java 123456789public static void solve() { String s = io.next(); var sb = new StringBuilder(); Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); for (char c : s.toCharArray()) { if (!set.contains(c)) sb.append(c); } io.println(sb.toString());} C++ 12345678void solve() { string s; cin &gt;&gt; s; s.erase(remove_if(s.begin(), s.end(), [&amp;](char c) { return set{'a', 'e', 'i', 'o', 'u'}.count(c); }), s.end()); cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;} The Middle Day模拟。 Java 1234567891011121314151617public static void solve() { int m = io.nextInt(); int[] d = new int[m]; int tot = 0; for (int i = 0; i &lt; m; i++) { d[i] = io.nextInt(); tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { io.println(i + 1 + &quot; &quot; + mid); return; } mid -= d[i]; }} C++ 123456789101112131415161718void solve() { int m; cin &gt;&gt; m; int tot = 0; vector&lt;int&gt; d(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; d[i]; tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot;\\n&quot;; return; } mid -= d[i]; }} Flavors模拟。 Java 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] buckets = new List[n + 1]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int f = io.nextInt(), s = io.nextInt(); buckets[f].add(s); } int ans = 0, max1 = 0, max2 = 0; for (var bucket : buckets) { if (bucket.isEmpty()) continue; Collections.sort(bucket, (a, b) -&gt; b - a); int a = bucket.get(0); if (a &gt; max1) { max2 = max1; max1 = a; } else if (a &gt; max2) { max2 = a; } if (bucket.size() &lt; 2) continue; int b = bucket.get(1); ans = Math.max(ans, a + b / 2); } ans = Math.max(ans, max1 + max2); io.println(ans);} C++ 12345678910111213141516171819202122232425void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; buckets(n + 1); for (int i = 0; i &lt; n; i++) { int f, s; cin &gt;&gt; f &gt;&gt; s; buckets[f].push_back(s); } int ans = 0, max1 = 0, max2 = 0; for (auto &amp;bucket : buckets) { if (bucket.empty()) continue; nth_element(bucket.begin(), bucket.begin() + 1, bucket.end(), greater()); if (bucket[0] &gt; max1) { max2 = max1; max1 = bucket[0]; } else if (bucket[0] &gt; max2) { max2 = bucket[0]; } if (bucket.size() &lt; 2) continue; ans = max(ans, bucket[0] + bucket[1] / 2); } ans = max(ans, max1 + max2); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} Magical Cookies算是暴力吧。首先最多执行 \\(m+n\\) 次操作，然后每次操作将所有行和列遍历，判断是否可以标记。如果不优化，那么遍历的复杂度是 \\(O(mn)\\)，总时间复杂度就是 \\(O(mn(m+n))\\)，会超时。可以维护剩余的行数 \\(r\\) 和剩余的列数 \\(c\\)，那么如果某行的某颜色的数量等于列数，那么就说明可以标记该行，列同理。这样我们就可以只维护行列中的每个颜色有多少饼干，而不需要维护位置关系，从而将遍历的时间复杂度降为 \\(O(26(m+n))\\)。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] arr = new String[m]; for (int i = 0; i &lt; m; i++) { arr[i] = io.next(); } int[][] row = new int[m][26]; int[][] col = new int[n][26]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { row[i][arr[i].charAt(j) - 'a']++; col[j][arr[i].charAt(j) - 'a']++; } } int r = m, c = n; boolean[] vr = new boolean[m]; boolean[] vc = new boolean[n]; for (int k = 0; k &lt; m + n; k++) { List&lt;int[]&gt; mr = new ArrayList&lt;&gt;(); List&lt;int[]&gt; mc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { if (vr[i]) continue; for (int j = 0; j &lt; 26; j++) { if (row[i][j] == c &amp;&amp; c &gt;= 2) { mr.add(new int[]{i, j}); } } } for (int i = 0; i &lt; n; i++) { if (vc[i]) continue; for (int j = 0; j &lt; 26; j++) { if (col[i][j] == r &amp;&amp; r &gt;= 2) { mc.add(new int[]{i, j}); } } } for (int[] p : mr) { r--; vr[p[0]] = true; for (int i = 0; i &lt; n; i++) { col[i][p[1]]--; } } for (int[] p : mc) { c--; vc[p[0]] = true; for (int i = 0; i &lt; m; i++) { row[i][p[1]]--; } } } io.println(r * c);} Prerequisites首先找到第 \\(1\\) 本书的所有前置书，然后对所有书进行拓扑排序，将之前找到的前置书按拓扑排序的倒序打印即可。或者直接 DFS。。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(); int[] indegree = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); for (int j = 0; j &lt; c; j++) { int q = io.nextInt() - 1; g[i].add(q); indegree[q]++; } } boolean[] mark = new boolean[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty()) { int x = q.poll(); for (int y : g[x]) { if (mark[y]) continue; mark[y] = true; q.offer(y); } } for (int i = 0; i &lt; n; i++) { if (indegree[i] == 0) { q.offer(i); } } Deque&lt;Integer&gt; ans = new ArrayDeque&lt;&gt;(); while (!q.isEmpty()) { int x = q.poll(); if (mark[x]) ans.push(x); for (int y : g[x]) { if (--indegree[y] == 0) { q.offer(y); } } } while (!ans.isEmpty()) io.print(ans.pop() + 1 + &quot; &quot;); io.println();} C++ 123456789101112131415161718192021222324252627282930313233void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; j++) { int q; cin &gt;&gt; q; q--; adj[i].push_back(q); } } vector&lt;bool&gt; mark(n); auto dfs = [&amp;](auto self, int x) { if (mark[x]) { return; } for (auto y : adj[x]) { self(self, y); } mark[x] = true; if (x != 0) { std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; } }; dfs(dfs, 0); cout &lt;&lt; &quot;\\n&quot;;} Shortcuts动态规划，调试好久。。如果所有点都选，那么答案最多为 \\(10^{9}\\)，所以可以确定不选的点不会超过 \\(30\\)。然后定义状态 \\(dp[i][j]\\) 表示到达第 \\(i\\) 个点并且总共跳过 \\(j\\) 个点的最短距离。如何想到定义该状态呢，因为答案和具体选哪几个点无关，只和最短距离以及跳过多少个点有关，大概是这样吧。 Java 1234567891011121314151617181920212223242526272829public static void solve() { int c = 30; int n = io.nextInt(); int[] x = new int[n]; int[] y = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } double[][] dp = new double[n][c]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][0] = 0; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; c; j++) { for (int k = i + 1; k &lt; n &amp;&amp; k - i - 1 + j &lt; c; k++) { int nj = j + k - i - 1; dp[k][nj] = Math.min(dp[k][nj], dp[i][j] + Math.sqrt((x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]))); } } } double ans = Integer.MAX_VALUE; for (int i = 0; i &lt; c; i++) { ans = Math.min(ans, dp[n - 1][i] + (i == 0 ? 0 : 1 &lt;&lt; (i - 1))); } io.println(ans);}","link":"/2023/08/21/AtCoder%20Beginner%20Contest%20315/"},{"title":"Educational Codeforces Round 153 (Rated for Div. 2)","text":"Not a Substring构造题。如果 \\(s\\) 中存在连续相同的括号，则可以构造交替出现的括号；如果 \\(s\\) 是交替出现的括号，那么就构造连续的括号，此时包含的唯一交替的括号就是 \\(()\\)，特判一下即可。 123456789101112131415161718public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = false; for (int i = 1; i &lt; n; i++) { if (s[i] == s[i - 1]) { ok = true; break; } } if (new String(s).equals(&quot;()&quot;)) { io.println(&quot;NO&quot;); return; } io.println(&quot;YES&quot;); if (ok) io.println(&quot;()&quot;.repeat(n)); else io.println(&quot;(&quot;.repeat(n) + &quot;)&quot;.repeat(n));} Fancy Coins数学题。假设最终使用 \\(x\\) 枚价值为 \\(1\\) 的硬币，\\(y\\) 枚价值为 \\(k\\) 的硬币。如果 \\(x\\) 大于等于 \\(k\\)，我们总是将其合成为价值为 \\(k\\) 的硬币，所以可以保证 \\(x\\) 小于 \\(k\\)。显然 \\(x=m\\bmod k\\)，\\(y=\\frac{m}{k}\\)。那么需要补充多少花色硬币呢？易知，需要补充 \\(\\max(0,x-a_{1})\\) 个价值为 \\(1\\) 的花色硬币，和 \\(\\max (0,y-a_{k}-\\max (0,\\frac{a_{1}-x}{k}))\\) 个价值为 \\(k\\) 的花色硬币。 12345public static void solve() { int m = io.nextInt(), k = io.nextInt(), a1 = io.nextInt(), ak = io.nextInt(); int ans = Math.max(0, m % k - a1) + Math.max(0, m / k - ak - Math.max(0, a1 - m % k) / k); io.println(ans);} Game on Permutation一开始的想法是，如果某个元素左边恰好只有一个小于它的元素，那么该位置就是胜位。然而暴力找每个位置左边比它小的元素个数的时间复杂度是 \\(O(n^{2})\\)，赛时就不知道怎么优化。其实我们可以知道，给定一个序列，胜位是固定不变的。所以可以考虑维护左边的最小元素（表示下一步是否可以下棋）和最小的胜位（如果大于最小胜位，则当前位必输），然后就可以很方便的模拟出答案。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] p = new int[n]; int ans = 0, min = n + 1, minWin = n + 1; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); if (min &lt; p[i] &amp;&amp; p[i] &lt;= minWin) { ans++; minWin = Math.min(minWin, p[i]); } min = Math.min(min, p[i]); } io.println(ans);} Balanced String不会不会。。o(╥﹏╥)o","link":"/2023/08/21/Educational%20Codeforces%20Round%20153%20(Rated%20for%20Div.%202)/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}