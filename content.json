{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 893 (Div. 2)","text":"Buttons优先选择公共按钮，当且仅当先手的按钮数量大于后手的按钮数量时，先手者胜。 12345public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (a + c % 2 &gt; b) io.println(&quot;First&quot;); else io.println(&quot;Second&quot;);} The Walkway模拟题，特别需要注意头尾的边界处理，加上哨兵真的会方便很多。可以假设位置 \\(1-d\\) 和位置 \\(n+1\\) 有卖家，这样就不用特判，可以直接处理！！！ 123456789101112131415161718192021222324252627public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] s = new int[m + 2]; for (int i = 1; i &lt;= m; i++) { s[i] = io.nextInt(); } s[0] = 1 - d; s[m + 1] = n + 1; int ans = m - 1, delta = Integer.MAX_VALUE, cnt = 0; for (int i = 1; i &lt;= m; i++) { int A = (s[i] - s[i - 1] - 1) / d; int B = (s[i + 1] - s[i] - 1) / d; int C = (s[i + 1] - s[i - 1] - 1) / d; int D = C - A - B; if (D &lt; delta) { delta = D; cnt = 1; } else if (D == delta) { cnt++; } ans += A; } ans += (s[m + 1] - s[m] - 1) / d + delta - 1; io.println(ans + &quot; &quot; + cnt);} Yet Another Permutation Problem构造题，首先需要发现什么公约数不可能出现，很明显不可能得到 \\(d_{i}=\\gcd (a_{i},a_{(i\\bmod n)+1})&gt; \\lfloor \\frac{n}{2}\\rfloor\\)。然后考虑所有小于等于 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 的数是否能被包含，可以发现对于每个 \\(a_{i}=x\\leq \\lfloor \\frac{n}{2}\\rfloor\\) 总有 \\(a_{(i\\bmod n)+1}=2\\cdot x\\leq n\\)，所以我们可以枚举所有奇数乘以二的幂来构造答案。 12345678910111213public static void solve() { int n = io.nextInt(), idx = 0; int[] ans = new int[n]; for (int i = 1; i &lt;= n; i += 2) { for (int j = i; j &lt;= n; j *= 2) { ans[idx++] = j; } } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} Trees and Segments难以描述，看代码吧，调试半天。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[][] prefix = new int[n + 1][k + 1]; int[][] suffix = new int[n + 1][k + 1]; // 枚举可以在 k 次操作内变为全 0 的子数组，并将其长度记录到所属的前后缀中 for (int i = 0; i &lt; n; i++) { int cnt1 = 0; for (int j = i; j &lt; n; j++) { cnt1 += s[j] - '0'; if (cnt1 &gt; k) break; prefix[j + 1][cnt1] = Math.max(prefix[j + 1][cnt1], j - i + 1); suffix[i][cnt1] = Math.max(suffix[i][cnt1], j - i + 1); } } // 在前缀 [0, i] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= k; j++) { prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i][j]); if (j &gt; 0) prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i + 1][j - 1]); } } // 在后缀 [i, n - 1] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= k; j++) { suffix[i][j] = Math.max(suffix[i][j], suffix[i + 1][j]); if (j &gt; 0) suffix[i][j] = Math.max(suffix[i][j], suffix[i][j - 1]); } } // 枚举连续 1 的起点和终点，并记录该连续 1 的长度对应的连续 0 的最长长度（注意包含长度为 0 的情况） int[] max0by1 = new int[n + 1]; Arrays.fill(max0by1, -1); max0by1[0] = suffix[0][k]; for (int i = 0; i &lt; n; i++) { int cnt0 = 0; for (int j = i; j &lt; n; j++) { cnt0 += (s[j] - '0') ^ 1; if (cnt0 &gt; k) break; max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], prefix[i][k - cnt0]); max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], suffix[j + 1][k - cnt0]); } } // 计算答案 int[] ans = new int[n + 1]; for (int a = 1; a &lt;= n; a++) { for (int i = 0; i &lt;= n; i++) { if (max0by1[i] == -1) continue; ans[a] = Math.max(ans[a], i + max0by1[i] * a); } } for (int i = 1; i &lt;= n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}","link":"/2023/08/16/Codeforces%20Round%20893%20(Div.%202)/"},{"title":"第 111 场力扣夜喵双周赛","text":"统计和小于目标的下标对数目使用排序 + 双指针优化。如果 \\(nums[lo]+nums[hi]&lt;target\\)，那么 \\([lo+1,hi]\\) 范围内的数都能与 \\(nums[lo]\\) 组成对，\\(lo\\) 加一；反之，\\([lo,hi-1]\\) 范围内的数都不能与 \\(nums[hi]\\) 组成对，\\(hi\\) 减一。 Java 123456789101112131415class Solution { public int countPairs(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int lo = 0, hi = nums.size() - 1, ans = 0; while (lo &lt; hi) { if (nums.get(lo) + nums.get(hi) &lt; target) { ans += hi - lo; lo++; } else { hi--; } } return ans; }} C++ 12345678910111213141516class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans = 0; for (int i = 0, j = n - 1; i &lt; j; ) { if (nums[i] + nums[j] &lt; target) { ans += j - i; i++; } else { j--; } } return ans; }}; 循环增长使字符串子序列等于另一个字符串贪心取就行。 Java 1234567891011class Solution { public boolean canMakeSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1.charAt(i) == str2.charAt(j) || (str1.charAt(i) + 1 - 'a') % 26 == str2.charAt(j) - 'a') { j++; } } return j == n; }} C++ 123456789101112class Solution {public: bool canMakeSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1[i] == str2[j] || (str1[i] + 1 - 'a') % 26 == str2[j] - 'a') { j++; } } return j == n; }}; 将三个组排序要将 \\(nums\\) 变为美丽数组，就要将 \\(nums\\) 变为非递减的形式，所以问题就变为求最长非递减子序列。 Java 动态规划： 12345678910111213141516class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), ans = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (nums.get(i) &gt;= nums.get(j)) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } return n - ans; }} 贪心 + 二分： 1234567891011121314151617class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), maxLen = 0; int[] aux = new int[n]; for (int x : nums) { int lo = 0, hi = maxLen - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (aux[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } aux[lo] = x; if (lo == maxLen) maxLen++; } return n - maxLen; }} 状态机 DP： 有点妙啊，\\(dp[i][j]\\) 表示将子数组 \\([0,i]\\) 变为以 \\([1,j]\\) 为结尾的美丽数组所需的最小修改次数，然后可以空间优化。 1234567891011class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int[] dp = {Integer.MAX_VALUE, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = Math.min(dp[i - 1], dp[i] + (x == i ? 0 : 1)); } } return dp[3]; }} C++ 123456789101112class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { int dp[4] = {INT_MAX, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = min(dp[i - 1], dp[i] + (x != i)); } } return dp[3]; }}; 范围中美丽整数的数目经典数位 DP 没什么好说的，主要是记忆化取模，边乘边取模。 Java 1234567891011121314151617181920212223242526class Solution { public int numberOfBeautifulIntegers(int low, int high, int k) { return f(0, 10, 0, true, false, high + &quot;&quot;, k, new Integer[10][20][k]) - f(0, 10, 0, true, false, low - 1 + &quot;&quot;, k, new Integer[10][20][k]); } private int f(int i, int diff, int mod, boolean isLimit, boolean isNum, String s, int k, Integer[][][] dp) { if (i == s.length()) { return isNum &amp;&amp; diff == 10 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff][mod] != null) { return dp[i][diff][mod]; } int res = 0; if (!isNum) res += f(i + 1, diff, mod, false, false, s, k, dp); int lo = isNum ? 0 : 1, hi = isLimit ? s.charAt(i) - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += f(i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true, s, k, dp); } if (!isLimit &amp;&amp; isNum) { dp[i][diff][mod] = res; } return res; }} C++ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int numberOfBeautifulIntegers(int low, int high, int k) { string s; const int BASE = 10; int dp[10][20][k]; auto f = [&amp;](auto self, int i, int diff, int mod, bool isLimit, bool isNum) { if (i == s.size()) { return isNum &amp;&amp; diff == 0 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff + BASE][mod] != -1) { return dp[i][diff + BASE][mod]; } int res = 0; if (!isNum) res += self(self, i + 1, diff, mod, false, false); int lo = isNum ? 0 : 1, hi = isLimit ? s[i] - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += self(self, i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true); } if (!isLimit &amp;&amp; isNum) dp[i][diff + BASE][mod] = res; return res; }; auto calc = [&amp;](int x) { s = to_string(x); memset(dp, -1, sizeof(dp)); return f(f, 0, 0, 0, true, false); }; return calc(high) - calc(low - 1); }};","link":"/2023/08/21/%E7%AC%AC%20111%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 359 场力扣周赛","text":"判别首字母缩略词Java 123456789101112class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { int n = words.size(), m = s.length(); if (n != m) return false; for (int i = 0; i &lt; n; i++) { if (words.get(i).charAt(0) != s.charAt(i)) { return false; } } return true; }} C++ 12345678910111213class Solution {public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) { int m = words.size(), n = s.size(); if (m != n) return false; for (int i = 0; i &lt; n; i++) { if (words[i][0] != s[i]) { return false; } } return true; }}; k-avoiding 数组的最小总和贪心。 Java 123456class Solution { public int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }} C++ 1234567class Solution {public: int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }}; 销售利润最大化不从动态规划的角度思考，我首先用的是对左端点排序。如果用动态规划，那么根据转移方程就会对右端点排序，处理方式也比对左端点排序简单一些。还可以不排序做，使用桶存储相同 \\(end\\) 的 \\(offer\\)，分别处理每个桶。 Java 1234567891011121314class Solution { public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) { Collections.sort(offers, (a, b) -&gt; a.get(1) - b.get(1)); offers.add(List.of(n - 1, n - 1, 0)); int m = offers.size(), i = 0; int[] leftMax = new int[n + 1]; for (var offer : offers) { int s = offer.get(0), e = offer.get(1), g = offer.get(2); for (; i &lt;= e; i++) leftMax[i + 1] = leftMax[i]; leftMax[e + 1] = Math.max(leftMax[e + 1], leftMax[s] + g); } return leftMax[n]; }} C++ 1234567891011121314151617class Solution {public: int maximizeTheProfit(int n, vector&lt;vector&lt;int&gt;&gt;&amp; offers) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; groups(n); for (auto &amp;offer : offers) { groups[offer[1]].emplace_back(offer[0], offer[2]); } vector&lt;int&gt; f(n + 1); for (int end = 0; end &lt; n; end++) { f[end + 1] = f[end]; for (auto &amp;[start, gold] : groups[end]) { f[end + 1] = max(f[end + 1], f[start] + gold); } } return f[n]; }}; 找出最长等值子数组Java 滑动窗口： 12345678910111213141516171819class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int lo = 0, hi = 0, ans = 0; while (hi &lt; n) { map.merge(nums.get(hi++), 1, Integer::sum); if (hi - lo - map.get(nums.get(lo)) &gt; k) { map.merge(nums.get(lo++), -1, Integer::sum); } ans = Math.max(ans, map.get(nums.get(lo))); } while (lo + 1 &lt; n) { map.merge(nums.get(lo++), -1, Integer::sum); ans = Math.max(ans, map.get(nums.get(lo))); } return ans; }} 滑动窗口（优化）： 优化一：观察到 \\(1\\leq nums[i]\\leq nums.lenth\\)，所以可以用数组模拟哈希表。 优化二：滑动窗口直接枚举右端点，这样可以枚举到所有情况。但是如何保证删除的元素数量小于等于 \\(k\\) 呢？当左端点的值 \\(nums[i]\\) 不能构成等值数组，则将左端点右移。为什么这样可以保证？当 \\(nums[i]\\neq nums[j]\\) 时，移动左端点不影响答案；当 \\(nums[i]=nums[j]\\) 时，移动左端点可以保证删除的元素数量小于等于 \\(k\\)。 1234567891011121314class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; int[] map = new int[n + 1]; for (int i = 0, j = 0; j &lt; n; j++) { map[nums.get(j)]++; if (j - i + 1 - map[nums.get(i)] &gt; k) { map[nums.get(i++)]--; } ans = Math.max(ans, map[nums.get(j)]); } return ans; }} C++ 分组 + 双指针： 123456789101112131415161718192021class Solution {public: int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); for (int i = 0; i &lt; n; i++) { pos[nums[i]].push_back(i); } for (auto &amp;ps : pos) { int left = 0; for (int right = 0; right &lt; ps.size(); right++) { while (ps[right] - ps[left] - right + left &gt; k) { left++; } ans = max(ans, right - left + 1); } } return ans; }};","link":"/2023/08/21/%E7%AC%AC%20359%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 315","text":"tcdr模拟。 Java 123456789public static void solve() { String s = io.next(); var sb = new StringBuilder(); Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); for (char c : s.toCharArray()) { if (!set.contains(c)) sb.append(c); } io.println(sb.toString());} C++ 12345678void solve() { string s; cin &gt;&gt; s; s.erase(remove_if(s.begin(), s.end(), [&amp;](char c) { return set{'a', 'e', 'i', 'o', 'u'}.count(c); }), s.end()); cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;} The Middle Day模拟。 Java 1234567891011121314151617public static void solve() { int m = io.nextInt(); int[] d = new int[m]; int tot = 0; for (int i = 0; i &lt; m; i++) { d[i] = io.nextInt(); tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { io.println(i + 1 + &quot; &quot; + mid); return; } mid -= d[i]; }} C++ 123456789101112131415161718void solve() { int m; cin &gt;&gt; m; int tot = 0; vector&lt;int&gt; d(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; d[i]; tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot;\\n&quot;; return; } mid -= d[i]; }} Flavors模拟。 Java 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] buckets = new List[n + 1]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int f = io.nextInt(), s = io.nextInt(); buckets[f].add(s); } int ans = 0, max1 = 0, max2 = 0; for (var bucket : buckets) { if (bucket.isEmpty()) continue; Collections.sort(bucket, (a, b) -&gt; b - a); int a = bucket.get(0); if (a &gt; max1) { max2 = max1; max1 = a; } else if (a &gt; max2) { max2 = a; } if (bucket.size() &lt; 2) continue; int b = bucket.get(1); ans = Math.max(ans, a + b / 2); } ans = Math.max(ans, max1 + max2); io.println(ans);} C++ 12345678910111213141516171819202122232425void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; buckets(n + 1); for (int i = 0; i &lt; n; i++) { int f, s; cin &gt;&gt; f &gt;&gt; s; buckets[f].push_back(s); } int ans = 0, max1 = 0, max2 = 0; for (auto &amp;bucket : buckets) { if (bucket.empty()) continue; nth_element(bucket.begin(), bucket.begin() + 1, bucket.end(), greater()); if (bucket[0] &gt; max1) { max2 = max1; max1 = bucket[0]; } else if (bucket[0] &gt; max2) { max2 = bucket[0]; } if (bucket.size() &lt; 2) continue; ans = max(ans, bucket[0] + bucket[1] / 2); } ans = max(ans, max1 + max2); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} Magical Cookies算是暴力吧。首先最多执行 \\(m+n\\) 次操作，然后每次操作将所有行和列遍历，判断是否可以标记。如果不优化，那么遍历的复杂度是 \\(O(mn)\\)，总时间复杂度就是 \\(O(mn(m+n))\\)，会超时。可以维护剩余的行数 \\(r\\) 和剩余的列数 \\(c\\)，那么如果某行的某颜色的数量等于列数，那么就说明可以标记该行，列同理。这样我们就可以只维护行列中的每个颜色有多少饼干，而不需要维护位置关系，从而将遍历的时间复杂度降为 \\(O(26(m+n))\\)。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] arr = new String[m]; for (int i = 0; i &lt; m; i++) { arr[i] = io.next(); } int[][] row = new int[m][26]; int[][] col = new int[n][26]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { row[i][arr[i].charAt(j) - 'a']++; col[j][arr[i].charAt(j) - 'a']++; } } int r = m, c = n; boolean[] vr = new boolean[m]; boolean[] vc = new boolean[n]; for (int k = 0; k &lt; m + n; k++) { List&lt;int[]&gt; mr = new ArrayList&lt;&gt;(); List&lt;int[]&gt; mc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { if (vr[i]) continue; for (int j = 0; j &lt; 26; j++) { if (row[i][j] == c &amp;&amp; c &gt;= 2) { mr.add(new int[]{i, j}); } } } for (int i = 0; i &lt; n; i++) { if (vc[i]) continue; for (int j = 0; j &lt; 26; j++) { if (col[i][j] == r &amp;&amp; r &gt;= 2) { mc.add(new int[]{i, j}); } } } for (int[] p : mr) { r--; vr[p[0]] = true; for (int i = 0; i &lt; n; i++) { col[i][p[1]]--; } } for (int[] p : mc) { c--; vc[p[0]] = true; for (int i = 0; i &lt; m; i++) { row[i][p[1]]--; } } } io.println(r * c);} Prerequisites首先找到第 \\(1\\) 本书的所有前置书，然后对所有书进行拓扑排序，将之前找到的前置书按拓扑排序的倒序打印即可。或者直接 DFS。。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(); int[] indegree = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); for (int j = 0; j &lt; c; j++) { int q = io.nextInt() - 1; g[i].add(q); indegree[q]++; } } boolean[] mark = new boolean[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty()) { int x = q.poll(); for (int y : g[x]) { if (mark[y]) continue; mark[y] = true; q.offer(y); } } for (int i = 0; i &lt; n; i++) { if (indegree[i] == 0) { q.offer(i); } } Deque&lt;Integer&gt; ans = new ArrayDeque&lt;&gt;(); while (!q.isEmpty()) { int x = q.poll(); if (mark[x]) ans.push(x); for (int y : g[x]) { if (--indegree[y] == 0) { q.offer(y); } } } while (!ans.isEmpty()) io.print(ans.pop() + 1 + &quot; &quot;); io.println();} C++ 123456789101112131415161718192021222324252627282930313233void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; j++) { int q; cin &gt;&gt; q; q--; adj[i].push_back(q); } } vector&lt;bool&gt; mark(n); auto dfs = [&amp;](auto self, int x) { if (mark[x]) { return; } for (auto y : adj[x]) { self(self, y); } mark[x] = true; if (x != 0) { std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; } }; dfs(dfs, 0); cout &lt;&lt; &quot;\\n&quot;;} Shortcuts动态规划，调试好久。。如果所有点都选，那么答案最多为 \\(10^{9}\\)，所以可以确定不选的点不会超过 \\(30\\)。然后定义状态 \\(dp[i][j]\\) 表示到达第 \\(i\\) 个点并且总共跳过 \\(j\\) 个点的最短距离。如何想到定义该状态呢，因为答案和具体选哪几个点无关，只和最短距离以及跳过多少个点有关，大概是这样吧。 Java 1234567891011121314151617181920212223242526272829public static void solve() { int c = 30; int n = io.nextInt(); int[] x = new int[n]; int[] y = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } double[][] dp = new double[n][c]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][0] = 0; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; c; j++) { for (int k = i + 1; k &lt; n &amp;&amp; k - i - 1 + j &lt; c; k++) { int nj = j + k - i - 1; dp[k][nj] = Math.min(dp[k][nj], dp[i][j] + Math.sqrt((x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]))); } } } double ans = Integer.MAX_VALUE; for (int i = 0; i &lt; c; i++) { ans = Math.min(ans, dp[n - 1][i] + (i == 0 ? 0 : 1 &lt;&lt; (i - 1))); } io.println(ans);}","link":"/2023/08/21/AtCoder%20Beginner%20Contest%20315/"},{"title":"Educational Codeforces Round 153 (Rated for Div. 2)","text":"Not a Substring构造题。如果 \\(s\\) 中存在连续相同的括号，则可以构造交替出现的括号；如果 \\(s\\) 是交替出现的括号，那么就构造连续的括号，此时包含的唯一交替的括号就是 \\(()\\)，特判一下即可。 123456789101112131415161718public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = false; for (int i = 1; i &lt; n; i++) { if (s[i] == s[i - 1]) { ok = true; break; } } if (new String(s).equals(&quot;()&quot;)) { io.println(&quot;NO&quot;); return; } io.println(&quot;YES&quot;); if (ok) io.println(&quot;()&quot;.repeat(n)); else io.println(&quot;(&quot;.repeat(n) + &quot;)&quot;.repeat(n));} Fancy Coins数学题。假设最终使用 \\(x\\) 枚价值为 \\(1\\) 的硬币，\\(y\\) 枚价值为 \\(k\\) 的硬币。如果 \\(x\\) 大于等于 \\(k\\)，我们总是将其合成为价值为 \\(k\\) 的硬币，所以可以保证 \\(x\\) 小于 \\(k\\)。显然 \\(x=m\\bmod k\\)，\\(y=\\frac{m}{k}\\)。那么需要补充多少花色硬币呢？易知，需要补充 \\(\\max(0,x-a_{1})\\) 个价值为 \\(1\\) 的花色硬币，和 \\(\\max (0,y-a_{k}-\\max (0,\\frac{a_{1}-x}{k}))\\) 个价值为 \\(k\\) 的花色硬币。 12345public static void solve() { int m = io.nextInt(), k = io.nextInt(), a1 = io.nextInt(), ak = io.nextInt(); int ans = Math.max(0, m % k - a1) + Math.max(0, m / k - ak - Math.max(0, a1 - m % k) / k); io.println(ans);} Game on Permutation一开始的想法是，如果某个元素左边恰好只有一个小于它的元素，那么该位置就是胜位。然而暴力找每个位置左边比它小的元素个数的时间复杂度是 \\(O(n^{2})\\)，赛时就不知道怎么优化。其实我们可以知道，给定一个序列，胜位是固定不变的。所以可以考虑维护左边的最小元素（表示下一步是否可以下棋）和最小的胜位（如果大于最小胜位，则当前位必输），然后就可以很方便的模拟出答案。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] p = new int[n]; int ans = 0, min = n + 1, minWin = n + 1; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); if (min &lt; p[i] &amp;&amp; p[i] &lt;= minWin) { ans++; minWin = Math.min(minWin, p[i]); } min = Math.min(min, p[i]); } io.println(ans);} Balanced String不会不会。。o(╥﹏╥)o","link":"/2023/08/21/Educational%20Codeforces%20Round%20153%20(Rated%20for%20Div.%202)/"},{"title":"Project #0 - C++ Primer","text":"项目准备项目地址：Project #0 - C++ Primer。 准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。 Task #1 - Copy-On-Write Trie实现Get 函数 没有什么特别需要注意的，实现比较简单。 实现逻辑： 如果 root_ == nullptr 为真，则返回 nullptr。 沿着 Trie 树遍历，如果节点不存在，则返回 nullptr。 如果目标节点不是 TrieNodeWithValue 类型，则返回 nullptr。 否则，返回目标节点的值。 Put 函数 一开始比较疑惑的点是，智能指针存储的都是 const 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？ 其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 const 指针就能做到。 本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 key.empty() 和 root_ == nullptr。 实现逻辑： 如果 key.empty() 为真： 如果 root_ == nullptr 为真，则使用 value​ 构造 Trie 树并返回。 否则，使用 root_-&gt;children_ 和 value 构造 Trie 树并返回。 根据 root_ == nullptr 条件初始化新 Trie 树的 root。 沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）： 如果克隆完所有字符，则返回新 Trie 树。 否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。 Remove 函数 需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意： ① 节点不包含值需要转换为 TrieNode 类型，也就是说拷贝的时候需要调用 TrieNode::Clone()。 ② 如果节点满足 children_.empty() &amp;&amp; !is_value_node_ 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 erase 父节点中 map 的 key。 实现逻辑： 如果 root_ == nullptr 为真，则返回 *this。 如果 key.empty() 为真，则调用 root_-&gt;TrieNode::Clone() 克隆，并返回新 Trie 树。 沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 *this。 将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。 否则，依次克隆栈中的元素，然后返回新 Trie 树。 补充C++ 因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。 ① 使用 at 访问 const map 对象，因为 [] 运算符可能会自动添加键值。 123const map&lt;int,int&gt; m;cout &lt;&lt; m[1024]; // 错误，No viable overloaded operator[] for type 'const map&lt;int, int&gt;'cout &lt;&lt; m.at(1024); // 正确 ② = 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。 12345map&lt;int,int&gt; m;m[1024] = 1024;auto n = m;n[1024] = 2048;cout &lt;&lt; m[1024]; // 输出：1024 ③ 在 Java 中只要是对象就可以和 null 比较，而 C++ 中只有指针可以和 nullptr 比较。 GDB ① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击此处产生该问题的原因，以及相应的解决方案告诉我下载 libstdc++6-dbgsym，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。 ② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以在此查看该课程提供的 GDB 教程。以及可以阅读：GDB Tutorial: Finding Segmentation Faults。 ③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。 CMake 项目推荐使用 clang-14 作为编译器，解决方案在此。 Task #2 - Concurrent Key-Value Store实现因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 std::mutex 即可。读操作在获取 root_ 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 write_lock_ 上锁。Put 时记得使用 std::move()，因为值可能是不可复制的。 补充① 关于线程和锁的知识，推荐阅读 CS110 Lecture 10: Threads and Mutexes。 ② C++ 有个复制省略（Copy elision）的优化。 ③ 关于 C++ 模板的 FAQ、template 关键字的讨论 和 Dependent names 的定义。（好复杂啊）之所以查这些内容，是因为 CLion 给我生成了不同的表达式： 123auto value = root.template Get&lt;T&gt;(key);root = root.template Put(key, std::move(value));root = root.Remove(key); 以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 &lt;&gt; 来指定类型。然后何时使用 template 没怎么弄明白。 Task #3 - Debugging实现挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 Put 时打断点调试的，应该差不多吧。 补充无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：/usr/bin/ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案在此。 Task #4 - SQL String Functions实现文件的路径：./src/include/execution/expressions 和 ./src/planner/plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 std::tolower 或许有一些注意事项。注册函数时，需要保证参数是有效的，即参数只有一个并且是 VARCHAR 类型。 测试结果就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord 讨论。 修改之后通过！ 项目小结任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 key 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。","link":"/2023/08/26/Project%200%20-%20C++%20Primer/"},{"title":"Codeforces Round 894 (Div. 3)","text":"Gift Carpet从左到右每列贪心取即可。 12345678910111213141516171819202122public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] g = new String[m]; for (int i = 0; i &lt; m; i++) { g[i] = io.next(); } int idx = 0; String s = &quot;vika&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (g[j].charAt(i) == s.charAt(idx)) { idx++; break; } } if (idx == s.length()) { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Sequence Game构造题。当 \\(b_{i-1}&gt;b_{i}\\) 时，在两个数中间添加一个 \\(1\\) 即可。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(b[0]); for (int i = 1; i &lt; n; i++) { if (b[i] &lt; b[i - 1]) ans.add(1); ans.add(b[i]); } io.println(ans.size()); for (int x : ans) io.print(x + &quot; &quot;); io.println();} Flower City Fence阅读理解。题目中的“对角线对称”这个概念根本不用管，就是不断对区间做加法，然后判断是否和原数组相等，可以使用差分 + 前缀和解决。看完题解，发现其实也可以 \\(O(1)\\) 空间解决，因为数组是非递增的，按顺序遍历就行，具体见代码。 123456789101112131415public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } for (int i = 0, j = n; i &lt; n; i++) { for (; j &gt; 0 &amp;&amp; a[j - 1] &lt;= i; j--) ; if (a[i] != j) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Ice Cream Balls题目描述很有问题，其实就是问从一个长度为 \\(m\\) 的序列中选两个值组成集合，使得不同集合的数目恰好为 \\(n\\) 的 \\(m\\) 是多少。可以先二分求 \\(x\\)，使得 \\(C_{x}^{2}\\leq n\\) 且 \\(C_{x+1}^{2}&gt;n\\)。然后答案就是 \\(x+(n-C_{x}^{2})\\)，表示 \\([1,n-C_{x}^{2}]\\) 范围内的每个数各取两个，以及 \\([n-C_{x}^{2}+1,x]\\) 范围内的每个数各取一个。PS：读题很容易漏掉恰好两个字。 12345678910public static void solve() { long n = io.nextLong(); long lo = 2, hi = (long) 1e9 * 2; while (lo &lt;= hi) { long mid = lo + (hi - lo) / 2; if (mid * (mid - 1) / 2 &lt;= n) lo = mid + 1; else hi = mid - 1; } io.println(hi + (n - hi * (hi - 1) / 2));} Kolya and Movie Theatre做这道题时漏掉“开业前一天去过电影院”这个条件，导致想了半天。答案要求最多看 \\(m\\) 部电影的最大娱乐价值，首先我们可以观察到娱乐值的下降幅度只与最后一次去电影院的日期 \\(x\\) 有关，即下降幅度为 \\(x\\cdot d\\)。所以我们可以从前往后枚举 \\(x\\)，并且维护最大长度为 \\(m\\) 的优先队列，来保证最多看 \\(m\\) 部电影。需要注意电影的娱乐值可能是负数，而我们只需要在优先队列中存储正数即可。 123456789101112131415public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = io.nextInt(); PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); long sum = 0L, ans = 0L; for (int i = 0; i &lt; n; i++) { if (a[i] &lt;= 0) continue; q.offer(a[i]); sum += a[i]; if (q.size() &gt; m) sum -= q.poll(); ans = Math.max(ans, sum - (long) d * (i + 1)); } io.println(ans);} Magic Will Save the World初见时想到的是二分时间 + 动态规划，赛后优化发现可以直接动态规划做。我是用背包做的，\\(dp[i][j]\\) 表示前 \\(i\\) 个怪物使用 \\(j\\) 点法术值能够击败的怪物总强度最大是多少，然后枚举水法术值计算答案。但是其实可以不用这样，我们只需要知道怪物的子集的所有可能强度是多少，然后枚举所有能够到达的强度即可。（C++ 位图很方便） 12345678910111213141516171819202122public static void solve() { int w = io.nextInt(), f = io.nextInt(), n = io.nextInt(); int sum = 0; int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); sum += s[i]; } boolean[] dp = new boolean[sum + 1]; dp[0] = true; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= s[i]; j--) { dp[j] = dp[j] || dp[j - s[i]]; } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt;= sum; i++) { if (!dp[i]) continue; ans = Math.min(ans, Math.max((i + w - 1) / w, (sum - i + f - 1) / f)); } io.println(ans);} The Great Equalizer很容易就可以得出结论，设备的输出值是数组的最大值 + 排序后相邻元素的最大差值，但是不知道怎么维护。使用 C++ 的 multiset 很容易写，详细见大佬的代码。","link":"/2023/08/26/Codeforces%20Round%20894%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 317","text":"Potions二分。 12345678910111213141516public static void solve() { int n = io.nextInt(), h = io.nextInt(), x = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); } x = x - h; int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (p[mid] &lt; x) lo = mid + 1; else hi = mid - 1; } io.println(lo + 1);} MissingNo.求和公式。 12345678910111213public static void solve() { int n = io.nextInt(); int sum = 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); sum += a; min = Math.min(min, a); max = Math.max(max, a); } io.println((min + max) * (max - min + 1) / 2 - sum);} Remembering the Days暴力 DFS。 12345678910111213141516171819202122232425262728293031private static int ans = Integer.MIN_VALUE;public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, w = io.nextInt(); g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { dfs(i, 0, g, vis); } io.println(ans);}private static void dfs(int x, int dis, List&lt;int[]&gt;[] g, boolean[] vis) { vis[x] = true; ans = Math.max(ans, dis); for (int[] t : g[x]) { int y = t[0], w = t[1]; if (!vis[y]) { dfs(y, dis + w, g, vis); } } vis[x] = false;} President01 背包，比赛时转移方程弄错了一个细节，本来以为和答案是等价的，赛后改下就过了。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); int sum = 0; int[] x = new int[n]; int[] y = new int[n]; int[] z = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); z[i] = io.nextInt(); sum += z[i]; } long[] dp = new long[sum + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= z[i]; j--) { if (dp[j - z[i]] == Long.MAX_VALUE) continue; dp[j] = Math.min(dp[j], dp[j - z[i]] + Math.max(0, (y[i] - x[i] + 1) / 2)); } } long ans = Long.MAX_VALUE; for (int i = (sum + 1) / 2; i &lt;= sum; i++) { ans = Math.min(ans, dp[i]); } io.println(ans);} Avoid Eye Contact模拟题，比赛时想复杂了，直接模拟就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void solve() { int h = io.nextInt(), w = io.nextInt(); String[] a = new String[h]; for (int i = 0; i &lt; h; i++) { a[i] = io.next(); } int s = -1, g = -1; boolean[][] mark = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { char c = a[i].charAt(j); if (c == 'S') { s = i * w + j; } else if (c == 'G') { g = i * w + j; } else if (c == '#') { mark[i][j] = true; } else if (c == '^') { mark[i][j] = true; for (int k = i - 1; k &gt;= 0 &amp;&amp; a[k].charAt(j) == '.'; k--) { mark[k][j] = true; } } else if (c == 'v') { mark[i][j] = true; for (int k = i + 1; k &lt; h &amp;&amp; a[k].charAt(j) == '.'; k++) { mark[k][j] = true; } } else if (c == '&lt;') { mark[i][j] = true; for (int k = j - 1; k &gt;= 0 &amp;&amp; a[i].charAt(k) == '.'; k--) { mark[i][k] = true; } } else if (c == '&gt;') { mark[i][j] = true; for (int k = j + 1; k &lt; w &amp;&amp; a[i].charAt(k) == '.'; k++) { mark[i][k] = true; } } } } int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; int[] dis = new int[h * w]; Arrays.fill(dis, -1); dis[s] = 0; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(s); while (!q.isEmpty()) { int z = q.poll(); int x = z / w, y = z % w; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= h || ny &lt; 0 || ny &gt;= w || mark[nx][ny]) continue; int nz = nx * w + ny; if (dis[nz] != -1) continue; dis[nz] = dis[z] + 1; q.offer(nz); } } io.println(dis[g]);}","link":"/2023/08/28/AtCoder%20Beginner%20Contest%20317/"},{"title":"Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2)","text":"Increasing and Decreasing比赛时漏看第三个条件，搞半天。而且似乎倒着减会比较容易做（差不多）。 123456789101112131415public static void solve() { int x = io.nextInt(), y = io.nextInt(), n = io.nextInt(); int z = (1 + n - 1) * (n - 1) / 2; if (z &gt; y - x) { io.println(-1); return; } io.print(x + &quot; &quot;); int d = x + y - x - z; for (int i = n - 1; i &gt;= 1; i--) { d += i; io.print(d + &quot; &quot;); } io.println();} Swap and Reverse找规律。第一个操作表明奇数下标相互连通，偶数下标相互连通。第二个操作，如果 \\(k\\) 是奇数，则连通性不会改变，分别对奇偶字母排序，然后构造即可；如果 \\(k\\) 是偶数，则奇数下标和偶数下标相互连通，对所有字母排序即可。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); if (k % 2 == 0) { Arrays.sort(s); io.println(new String(s)); } else { PriorityQueue&lt;Character&gt; list1 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; list2 = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) list1.add(s[i]); else list2.add(s[i]); } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) sb.append(list1.poll()); else sb.append(list2.poll()); } io.println(sb.toString()); }} Divisor Chain比赛时瞎猜 AC 的，当时是想从 \\(1\\) 开始构造到 \\(x\\)，过程比答案复杂。正解是从 \\(x\\) 一直减去最低有效位的一（必定是除数），直到 \\(x\\) 等于 \\(2\\) 的幂（只剩一个一），然后让 \\(x\\) 一直减去 \\(\\frac{x}{2}\\) 即可。 123456789101112131415161718public static void solve() { int x = io.nextInt(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(x); while ((x &amp; (x - 1)) != 0) { x &amp;= (x - 1); ans.add(x); } while (x != 1) { x /= 2; ans.add(x); } io.println(ans.size()); for (int y : ans) { io.print(y + &quot; &quot;); } io.println();} Matrix Cascade使用差分数组维护从上到下的翻转次数，需要注意的是正负需要分开存，正数每层左移一位，负数每层右移一位。PS：这题 \\(p\\) 和 \\(q\\) 总是写错，Debug 很久。以及大佬的代码看不懂。 1234567891011121314151617181920212223242526272829303132public static void solve() { int n = io.nextInt(); char[][] a = new char[n][]; for (int i = 0; i &lt; n; i++) { a[i] = io.next().toCharArray(); } int ans = 0; int[] p = new int[n + 1]; int[] q = new int[n + 1]; int[] sum = new int[n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (a[i][j] - '0' != sum[j + 1] % 2) { ans++; p[j] ^= 1; q[j + 1] ^= 1; } } p[0] ^= p[1]; for (int j = 1; j &lt; n; j++) { p[j] = p[j + 1]; } q[n] ^= q[n - 1]; for (int j = n - 1; j &gt; 0; j--) { q[j] = q[j - 1]; } for (int j = 0; j &lt; n; j++) { sum[j + 1] = sum[j] ^ p[j] ^ q[j]; } } io.println(ans);} Guess Game有点难以描述，超出能力范围了。这是一个比较好理解的做法，分别考虑每一位。从最低位开始，如果前缀相同，那么就计算当前位 \\(0\\) 和 \\(1\\) 的个数，只有爱丽丝拿 \\(1\\)，鲍勃拿 \\(1\\) 或 \\(0\\) 的情况，当前位才会多走一轮。初始时，设置答案为 \\(n \\times n\\)，因为每个组合至少会走一轮。最后需要使用快速幂求 \\(n\\) 的逆元。 1234567891011121314151617181920212223242526272829303132333435363738private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); long ans = (long) n * n; for (int t = 0; t &lt; 30; t++) { for (int l = 0, r = 0; l &lt; n; l = r) { int[] cnt = new int[2]; while (r &lt; n &amp;&amp; a[l] / 2 == a[r] / 2) { cnt[a[r] % 2]++; r++; } ans += (long) cnt[1] * (cnt[1] + cnt[0]); } for (int i = 0; i &lt; n; i++) { a[i] /= 2; } } ans = ans % MOD * pow(n, MOD - 2) % MOD * pow(n, MOD - 2) % MOD; io.println(ans);}private static int pow(int a, int n) { long res = 1, x = a; while (n != 0) { if (n % 2 == 1) { res = (res * x) % MOD; } x = (x * x) % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/08/28/Harbour.Space%20Scholarship%20Contest%202023-2024%20(Div.%201%20+%20Div.%202)/"},{"title":"第 360 场力扣周赛","text":"距离原点最远的点核心：要距离原点最远，那么可选的位置肯定是向同一个方向移动。 123456789101112class Solution { public int furthestDistanceFromOrigin(String moves) { int n = moves.length(), dis = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { char c = moves.charAt(i); if (c == 'L') dis--; else if (c == 'R') dis++; else cnt++; } return Math.max(cnt - dis, cnt + dis); }} 找出美丽数组的最小和和上周一样的题目。 123456class Solution { public long minimumPossibleSum(int n, int target) { long m = Math.min(target / 2, n); return (m * (m + 1) + (target * 2 + n - m - 1) * (n - m)) / 2; }} 使子序列的和等于目标的最少操作次数比赛时思路满天飞，各种乱写。其实最后的思路是对的，但是基于之前的代码改写，导致有很多 Bug。赛后 15 分钟 AC。从低位到高位枚举 \\(target\\) 中的 \\(1\\)，假设当前 \\(1\\) 对应的值为 \\(x\\)，那么 \\(nums\\) 中所有小于等于 \\(x\\) 的值都可以用来填补 \\(x\\)，如果不够那么肯定需要将下一个大于 \\(x\\) 的值分解为 \\(x\\)。（更优的做法） 123456789101112131415161718192021class Solution { public int minOperations(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int n = nums.size(); int idx = 0, sum = 0, ans = 0; for (int i = target; i != 0; ) { int x = i &amp; -i; i -= x; while (idx &lt; n &amp;&amp; nums.get(idx) &lt;= x) { sum += nums.get(idx++); } sum -= x; if (sum &lt; 0) { if (idx == n) return -1; ans += Integer.numberOfTrailingZeros(nums.get(idx) / x); sum += nums.get(idx++); } } return ans; }} 在传球游戏中最大化函数值参考大佬的题解。 方法一：倍增 DP 因为 CPU 缓存的原因，数组开成 new int[35][n] 会更快。因为这样转移的时候只从上一行转移，具有空间局部性；而下面的代码是从左边一列转移，不具有空间局部性。 1234567891011121314151617181920212223242526272829class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); int[][] f = new int[n][35]; long[][] w = new long[n][35]; for (int i = 0; i &lt; n; i++) { f[i][0] = receiver.get(i); w[i][0] = i; } for (int j = 1; j &lt; 35; j++) { for (int i = 0; i &lt; n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; w[i][j] = w[i][j - 1] + w[f[i][j - 1]][j - 1]; } } long ans = 0L; for (int i = 0; i &lt; n; i++) { long cur = 0L; int pos = i; for (int j = 0; j &lt; 35; j++) { if ((k &gt;&gt; j &amp; 1) == 0) continue; cur += w[pos][j]; pos = f[pos][j]; } ans = Math.max(ans, cur + pos); } return ans; }} 方法二：内向基环树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[receiver.get(i)]++; reverse[receiver.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[receiver.get(x)] == 0) { q.offer(receiver.get(x)); } } // 计算每个环的前缀和，并记录每个节点在哪个环的哪个位置 int[] cirNum = new int[n]; int[] cirPos = new int[n]; boolean[] vis = new boolean[n]; List&lt;List&lt;Long&gt;&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { List&lt;Long&gt; cir = new ArrayList&lt;&gt;(); cir.add(0L); // 前缀和的冗余节点 // 存储环的节点，并记录每个节点在哪个环的哪个位置 for (int cur = i; !vis[cur]; cur = receiver.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cirPos[cur] = cir.size(); cir.add((long) cur); } // 重复存储环的节点，方便计算从任意节点开始和结束的价值和 for (int t = cir.size() - 1, j = 1; t &gt; 0; t--, j++) { cir.add(cir.get(j)); } // 计算前缀和 for (int j = 1; j &lt; cir.size(); j++) { cir.set(j, cir.get(j) + cir.get(j - 1)); } circles.add(cir); } } // 对环内的每个节点向环外进行 dfs，从而计算出以每个节点作为起点的价值和 long ans = 0L; // 存储环外节点的前缀和 List&lt;Long&gt; outSum = new ArrayList&lt;&gt;(); outSum.add(0L); for (int i = 0; i &lt; n; i++) { // 注意传递 k + 1，表示总节点数量 if (in[i] != 0) ans = Math.max(ans, dfs(i, circles.get(cirNum[i]), cirPos[i], reverse, in, outSum, k + 1)); } return ans; } private long dfs(int x, List&lt;Long&gt; cir, int pos, List&lt;Integer&gt;[] reverse, int[] in, List&lt;Long&gt; outSum, long k) { long res = 0L; int outLen = outSum.size() - 1; if (outLen &lt; k) { int n = cir.size() / 2; // 因为 cir 多存储了 n - 1 个环内节点，以及一个冗余节点，所以 cir.size() / 2 就是环的长度 res = (k - outLen) / n * cir.get(n) + cir.get(pos + (int) ((k - outLen) % n) - 1) - cir.get(pos - 1); } res += outSum.get(outLen) - outSum.get((int) Math.max(0L, outLen - k)); for (int y : reverse[x]) { if (in[y] != 0) continue; outSum.add(outSum.get(outLen) + y); res = Math.max(res, dfs(y, cir, pos, reverse, in, outSum, k)); outSum.remove(outLen + 1); } return res; }}","link":"/2023/08/28/%E7%AC%AC%20360%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Homework #1 - SQL","text":"作业准备项目地址：Homework #1 - SQL。 准备工作：阅读 Chapters 1-2 27 3-5，学习 Lecture #01 #02，以及阅读课堂笔记。 Q1 [0 points] (q1_sample):Ctrl + C，Ctrl +V。 Q2 [5 points] (q2_not_the_same_title):查询只涉及 titles 表，比较简单。 1234567891011121314SELECT premiered, primary_title || ' (' || original_title || ')'FROM titlesWHERE primary_title != original_title AND type = 'movie' AND genres LIKE '%Action%'ORDER BY premiered DESC, primary_titleLIMIT 10; Q3 [5 points] (q3_longest_running_tv):题目描述很不清晰啊，类型都不知道具体是什么。 12345678910111213SELECT primary_title, IIF(ended IS NULL, 2023, ended) - premiered AS runtimeFROM titlesWHERE primary_title IS NOT NULL AND type = 'tvSeries'ORDER BY runtime DESC, primary_titleLIMIT 20; Q4 [10 points] (q4_directors_in_each_decade):唯一要注意的就是使用 DISTINCT。 12345678910111213SELECT CAST(born / 10 * 10 AS TEXT) || 's' AS decade, COUNT(DISTINCT(people.person_id)) AS num_directorsFROM people INNER JOIN crew USING(person_id)WHERE category = 'director' AND born &gt;= 1900GROUP BY decadeORDER BY decade; Q5 [10 points] (q5_german_type_ratings):德语的缩写是 de。 12345678910111213141516SELECT t.type, ROUND(AVG(r.rating), 2) AS avg_rating, MIN(r.rating), MAX(r.rating)FROM akas as a INNER JOIN ratings as r USING(title_id) INNER JOIN titles as t USING(title_id)WHERE a.language = 'de' AND a.types IN ('imdbDisplay', 'original')GROUP BY t.typeORDER BY avg_rating; Q6 [10 points] (q6_who_played_a_batman):坑点就是模糊查询时 Batman 两边要加上双引号，即 &quot;Batman&quot;。以及在连接 people 和 crew 表时，顺序很重要，如果使用 crew INNRE JOIN people USING(person_id) 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。 12345678910111213crew INNER JOIN people USING(person_id)QUERY PLAN|--SCAN crew USING INDEX ix_crew_person_id|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCTpeople INNER JOIN crew USING(person_id)QUERY PLAN|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCT 12345678910111213141516171819202122232425WITH t AS ( SELECT DISTINCT(person_id), name FROM people INNER JOIN crew USING(person_id) WHERE category = 'actor' AND characters LIKE '%&quot;Batman&quot;%')SELECT name, ROUND(AVG(rating), 2) AS avg_ratingFROM t INNER JOIN crew USING(person_id) INNER JOIN ratings USING(title_id)GROUP BY person_idORDER BY avg_rating DESCLIMIT 10; Q7 [15 points] (q7_born_with_prestige):SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。 123456789SELECT COUNT(DISTINCT(person_id))FROM titles INNER JOIN people ON titles.premiered = people.born INNER JOIN crew USING(person_id)WHERE primary_title = 'The Prestige' AND category IN ('actor', 'actress'); 12345QUERY PLAN|--USE TEMP B-TREE FOR count(DISTINCT)|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?) Q8 [15 points] (q8_directing_rose.sql):比官解快一秒。注意使用 Rose% 而不是 Rose %。 12345678910111213141516171819SELECT DISTINCT(name)FROM crew INNER JOIN people USING(person_id)WHERE category = 'director' AND title_id IN ( SELECT title_id FROM crew INNER JOIN people USING(person_id) WHERE category = 'actress' AND name LIKE 'Rose%' )ORDER BY name; Q9 [15 points] (q9_ode_to_the_dead):这就是窗口函数么，学习了。 123456789101112131415161718192021222324252627282930313233343536373839WITH t AS ( SELECT category, name, died, primary_title, runtime_minutes, DENSE_RANK() OVER( PARTITION BY category ORDER BY died, name ) AS rank_died_name, DENSE_RANK() OVER( PARTITION BY category, person_id ORDER BY runtime_minutes DESC, title_id ) AS rank_runtime_title FROM crew INNER JOIN people USING(person_id) INNER JOIN titles USING(title_id) WHERE died IS NOT NULL AND runtime_minutes IS NOT NULL)SELECT category, name, died, primary_title, runtime_minutes, rank_died_nameFROM tWHERE rank_died_name &lt;= 5 AND rank_runtime_title = 1ORDER BY category, rank_died_name; Q10 [15 points] (q10_all_played_by_leo):不会。。json_each 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。 123456789101112131415161718192021222324252627WITH t1(characters) AS ( SELECT characters FROM people INNER JOIN crew USING(person_id) WHERE name = 'Leonardo DiCaprio' AND born = 1974),t2(value) AS ( SELECT DISTINCT(value) FROM t1, json_each(t1.characters) WHERE value != '' AND value NOT LIKE '%SELF%' ORDER BY value)SELECT GROUP_CONCAT(value)FROM t2; 作业小结最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）","link":"/2023/08/29/Homework%201%20-%20SQL/"},{"title":"Pinely Round 2 (Div. 1 + Div. 2)","text":"Channel如果同时在线人数到达 \\(n\\)，就表示所有人都阅读过；否则，如果总上线人数大于等于 \\(n\\)，则有可能所有人阅读过；否则，不可能所有人阅读过。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), a = io.nextInt(), q = io.nextInt(); String s = io.next(); int cur = a, tot = a; for (int i = 0; i &lt; q &amp;&amp; cur &lt; n; i++) { if (s.charAt(i) == '+') { cur++; tot++; } else { cur--; } } if (cur == n) { io.println(&quot;YES&quot;); } else if (tot &gt;= n) { io.println(&quot;MAYBE&quot;); } else { io.println(&quot;NO&quot;); }} Split Sort对于每个 \\(p_{i}=k+1\\) 和 \\(p_{j}=k\\) 并且 \\(i&lt;j\\)，那么就一定要选一次 \\(x=k+1\\)。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt() - 1; } int[] map = new int[n]; for (int i = 0; i &lt; n; i++) { map[p[i]] = i; } int ans = 0; for (int i = 1; i &lt; n; i++) { if (map[i] &lt; map[i - 1]) { ans++; } } io.println(ans);} MEX Repetition每执行一次操作，就会去除最后一个数，并将 \\(MEX\\) 添加到序列头部。所以可以通过在数组末尾加上原始数组的 \\(MEX\\)，将操作看成是向左移动循环数组的起始索引。求原始数组的 \\(MEX\\) 可以使用求和公式。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); long sum = 0L; int[] a = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } a[n] = (int) ((long) (1 + n) * n / 2 - sum); k = k % (n + 1); for (int i = 0; i &lt; n; i++) { io.print(a[(-k + n + 1 + i) % (n + 1)] + &quot; &quot;); } io.println();} Two-Colored Dominoes横放的牌只会对列有影响，竖放的牌只会对行有影响，所以分别处理。按行遍历竖放的牌，每当遇到 \\(U\\) 就染上和上次相反的颜色，如果该行只包含奇数个 \\(U\\)，就返回 \\(-1\\)。横放的牌同理。 123456789101112131415161718192021222324252627282930313233343536373839public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } final char[] aux = {'B', 'W'}; for (int i = 0; i &lt; n - 1; i++) { int xor = 0; for (int j = 0; j &lt; m; j++) { if (s[i][j] == 'U') { s[i][j] = aux[xor]; s[i + 1][j] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int j = 0; j &lt; m - 1; j++) { int xor = 0; for (int i = 0; i &lt; n; i++) { if (s[i][j] == 'L') { s[i][j] = aux[xor]; s[i][j + 1] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int i = 0; i &lt; n; i++) { io.println(new String(s[i])); }} Speedrun其实思路是知道的，就是不知道怎么写。这个解法看着有点懵，可能其他解法会更好理解一点。注意题目给定 \\(a_{i}&lt;b_{i}\\)。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); int[] h = new int[n]; for (int i = 0; i &lt; n; i++) { h[i] = io.nextInt(); } List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, idx -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1; g[a].add(b); } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从 h[i] 开始） long[] dp = new long[n]; for (int i = n - 1; i &gt;= 0; i--) { for (int j : g[i]) { dp[i] = Math.max(dp[i], dp[j] + (h[j] - h[i] + k) % k); } } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从零开始） long max = 0L; for (int i = 0; i &lt; n; i++) { dp[i] += h[i]; max = Math.max(max, dp[i]); } // 按照 h[i] 的大小，从小到大枚举起点 Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; h[i] - h[j]); long ans = Long.MAX_VALUE; for (int i : aux) { ans = Math.min(ans, max - h[i]); // 如果起点大于 h[i]，那么任务 i 的完成时间需要加 k，从而导致 dp[i] + k // 其实只要枚举入度为 0 的任务就行，但是即使任务 i 不是入度为 0 任务也没有关系，因为对答案没有影响 max = Math.max(max, dp[i] + k); } io.println(ans);}","link":"/2023/08/31/Pinely%20Round%202%20(Div.%201%20+%20Div.%202)/"},{"title":"Educational Codeforces Round 154 (Rated for Div. 2)","text":"Prime Deletion从 \\(1\\) 到 \\(9\\) 的序列中删除一些数（至少保留两位），使得结果为质数。可以发现 \\(13\\) 和 \\(31\\) 都是质数，所以判断 \\(1\\) 和 \\(3\\) 的先后顺序，然后输出即可。 12345678910111213public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; for (int i = 0; i &lt; n; i++) { if (s[i] == '1') { io.println(13); return; } else if(s[i] == '3') { io.println(31); return; } }} Two Binary Strings比赛时我是从左往右遍历记录不相等的数量，如果有不相等的，那么就需要一个 \\(0\\)，否则遇到 \\(1\\) 就输出 YES。和正解的思路是一样的，就是麻烦一点。正解是有相同的 \\(01\\) 出现时就输出 YES。 123456789101112public static void solve() { char[] a = io.next().toCharArray(); char[] b = io.next().toCharArray(); int n = a.length; for (int i = 0; i &lt; n - 1; i++) { if (a[i] == b[i] &amp;&amp; a[i] == '0' &amp;&amp; a[i + 1] == b[i + 1] &amp;&amp; a[i + 1] == '1') { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Queries for the Array比较简单的写法就是用一个标记数组做记录，递增会向左传递，递减会向右传递，然后判断是否冲突即可。更进一步观察，可以发现只需要记录最大的递增位置，和最小的递减位置。 1234567891011121314151617181920212223242526272829public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = true; int pos = -1, neg = n, cur = -1; for (char c : s) { if (c == '+') { cur++; } else if (c == '-') { if (cur-- == neg) { neg = n; } pos = Math.min(pos, cur); } else if (c == '0') { if (cur == pos || cur &lt;= 0) { ok = false; break; } neg = Math.min(neg, cur); } else { if (neg &lt;= cur) { ok = false; break; } pos = cur; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Sorting By Multiplication没想到啊。枚举负数前缀的长度：在负数前缀中，如果 \\(a[i]&lt;=a[i+1]\\)，就需要操作一次；在正数后缀中，如果 \\(a[i]&gt;=a[i+1]\\) 就需要操作一次。（下面的代码很妙啊，不需要加额外的判断语句。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int cnt = 0; for (int i = 0; i &lt; n - 1; i++) { if (a[i] &gt;= a[i + 1]) { cnt++; } } int ans = cnt; for (int i = 1; i &lt; n; i++) { if (a[i - 1] &gt;= a[i]) cnt--; ans = Math.min(ans, cnt + 1); if (a[i - 1] &lt;= a[i]) cnt++; } io.println(ans);}","link":"/2023/09/04/Educational%20Codeforces%20Round%20154%20(Rated%20for%20Div.%202)/"},{"title":"AtCoder Beginner Contest 318","text":"Full Moon模拟。 1234public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); io.println(n &lt; m ? 0 : (n - m) / p + 1);} Overlapping sheets比赛时没什么思路，想到扫描线，就用扫描线 + 区间合并来做了。结果一看题解，暴力标记每个点，没想到。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; int[][] g = new int[100][100]; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(), b = io.nextInt(); int c = io.nextInt(), d = io.nextInt(); for (int x = a; x &lt; b; x++) { for (int y = c; y &lt; d; y++) { if (g[x][y]++ == 0) ans++; } } } io.println(ans);} Blue Spring看到大佬的解法后，感觉我模拟的方式好蠢啊。当时我是枚举是否要买 \\(d\\) 张票，有点麻烦，原来枚举买当日的票更简单。 1234567891011121314public static void solve() { int n = io.nextInt(), d = io.nextInt(), p = io.nextInt(); int[] f = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { f[i] = io.nextInt(); } Arrays.sort(f); long ans = Long.MAX_VALUE, sum = 0L; for (int i = 0; i &lt;= n; i++) { sum += f[i]; ans = Math.min(ans, sum + (long) (n - i + d - 1) / d * p); } io.println(ans);} General Weighted Max Matching动态规划有点不太会，赛时瞎搞 AC 的。记忆化搜索会很好写，然后 DP 的话，我是用三层循环解决的，下面的解法优化掉一层循环。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[][] d = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { d[i][j] = io.nextInt(); } } long[] dp = new long[1 &lt;&lt; n]; for (int k = 2; k &lt; 1 &lt;&lt; n; k++) { int i = Integer.numberOfTrailingZeros(k &amp; -k); dp[k] = dp[k ^ (1 &lt;&lt; i)]; for (int j = i + 1; j &lt; n; j++) { if ((k &gt;&gt; j &amp; 1) == 1) { dp[k] = Math.max(dp[k], dp[k ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j)] + d[i][j]); } } } io.println(dp[(1 &lt;&lt; n) - 1]);} Sandwiches比较显然的做法是把相同的数分为一组，然后组内枚举中间的数。对于每个中间的数，让答案加上 \\(L\\times R\\)，其中 \\(L\\) 和 \\(R\\) 分别是左右两边相等的数的个数，枚举时可以一次性枚举间隔内所有数。 第二个解法是参考大佬的代码得到的，相当于枚举右端点吧。对于每个右端点，它的贡献可以根据下面代码中的公式得出，感觉比较巧妙。 12345678910111213public static void solve() { int n = io.nextInt(); int[] cnt = new int[n]; long[] sum = new long[n]; long ans = 0L; for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; ans += (long) i * cnt[a] - sum[a] - (long) (1 + cnt[a]) * cnt[a] / 2; cnt[a]++; sum[a] += i; } io.println(ans);} Octopus有点抽象，不是很懂。大概是枚举了 \\(N^{2}\\) 个极限位置，然后分别对每个位置判断可行性。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int N = io.nextInt(); long[] X = new long[N]; long[] L = new long[N]; for (int i = 0; i &lt; N; i++) { X[i] = io.nextLong(); } for (int i = 0; i &lt; N; i++) { L[i] = io.nextLong(); } List&lt;Long&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { pos.add(X[i] - L[j]); pos.add(X[i] + L[j] + 1); } } Collections.sort(pos); long ans = 0L; for (int i = 0; i &lt; pos.size() - 1; i++) { long[] dis = new long[N]; for (int j = 0; j &lt; N; j++) { dis[j] = Math.abs(pos.get(i) - X[j]); } Arrays.sort(dis); boolean ok = true; for (int j = 0; j &lt; N; j++) { if (dis[j] &gt; L[j]) { ok = false; break; } } if (ok) { ans += pos.get(i + 1) - pos.get(i); } } io.println(ans);}","link":"/2023/09/04/AtCoder%20Beginner%20Contest%20318/"},{"title":"第 112 场力扣夜喵双周赛","text":"判断通过操作能否让字符串相等 I同下。 判断通过操作能否让字符串相等 II模拟。也可以手动比较，就是适用性不好。（PS：想出一个写法，结果被自己 Hack 掉了~） 1234567891011class Solution { public boolean checkStrings(String s1, String s2) { int n = s1.length(); int[][] c1 = new int[2][26], c2 = new int[2][26]; for (int i = 0; i &lt; n; i++) { c1[i &amp; 1][s1.charAt(i) - 'a']++; c2[i &amp; 1][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(c1, c2); }} 几乎唯一子数组的最大和滑动窗口。 12345678910111213141516171819class Solution { public long maxSum(List&lt;Integer&gt; nums, int m, int k) { int n = nums.size(); long sum = 0L, ans = 0L; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge(nums.get(i), 1, Integer::sum); sum += nums.get(i); if (i &gt;= k - 1) { if (map.size() &gt;= m) ans = Math.max(ans, sum); if (map.merge(nums.get(i - k + 1), -1, Integer::sum) == 0) { map.remove(nums.get(i - k + 1)); } sum -= nums.get(i - k + 1); } } return ans; }} 统计一个字符串的 k 子序列美丽值最大的数目因为和选择的顺序没有关系，所以贪心的选择出现次数最大的字母就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { private static final long MOD = (long) 1e9 + 7; public int countKSubsequencesWithMaxBeauty(String s, int k) { char[] ss = s.toCharArray(); int[] cnt = new int[26]; for (char c : ss) { cnt[c - 'a']++; } TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((a, b) -&gt; b - a); for (int i = 0; i &lt; 26; i++) { map.merge(cnt[i], 1, Integer::sum); } long ans = 1L; for (var e : map.entrySet()) { int key = e.getKey(), val = e.getValue(); if (val &gt;= k) { return (int) (ans * comb(val, k) % MOD * pow(key, k) % MOD); } k -= val; ans = (ans * pow(key, val)) % MOD; } return 0; } private long pow(long x, int n) { long res = 1L; while (n != 0) { if ((n &amp; 1) == 1) res = (res * x) % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; } private long comb(long n, int k) { long res = n; for (int i = 2; i &lt;= k; i++) { res = res * --n / i; } return res % MOD; }}","link":"/2023/09/04/%E7%AC%AC%20112%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 361 场力扣周赛","text":"统计对称整数的数目模拟。 12345678910111213141516171819202122class Solution { public int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i &lt;= high; i++) { int x = i, n = 0; int[] aux = new int[10]; for (; x != 0; x /= 10) { aux[n++] = x % 10; } if (n % 2 == 0) { int sum = 0; for (int j = 0; j &lt; n / 2; j++) { sum += aux[j] - aux[j + n / 2]; } if (sum == 0) { ans++; } } } return ans; }} 生成特殊数字的最少操作比较简洁的暴力写法，当然从个位开始找 \\(25,75,50,00,0\\) 更快。 1234567891011121314151617class Solution { public int minimumOperations(String num) { int n = num.length(), ans = n; for (int i = 0; i &lt; n; i++) { if (num.charAt(i) == '0') { ans = Math.min(ans, n - 1); } for (int j = i + 1; j &lt; n; j++) { int x = (num.charAt(i) - '0') * 10 + num.charAt(j) - '0'; if (x % 25 == 0) { ans = Math.min(ans, n - i - 2); } } } return ans; }} 统计趣味子数组的数目最开始的思路是，找到所有满足 \\(nums[i]\\bmod modulo=k\\) 的下标放入新的列表，然后在新列表中枚举左端点 \\(i\\)，此时满足条件的右端点就是 \\(i+k-1+j\\times modulo\\)。暴力解决的时间复杂度 \\(O(n^{2})\\)，所以可以倒序枚举左端点，顺便记录间隔为 \\(modulo\\) 的后缀和。但是，这样解决还需要特判 \\(k=0\\) 的情况，总之很麻烦。 更好的做法是利用同余的性质。将所有 \\(nums[i]\\bmod modulo=k\\) 的数字看作 \\(1\\)，其他数字看作 \\(0\\)，这样我们要求的就是满足 \\((sum[r+1]-sum[l])\\bmod modulo=k\\) 的所有子数组的数目。我们可以枚举右端点，找到满足 \\((sum[r+1]-k)\\equiv sum[l]\\pmod{modulo}\\) 的左端点的个数，使用前缀和 + 哈希表即可。 12345678910111213141516class Solution { public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) { long ans = 0L; int n = nums.size(), sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int x : nums) { if (x % modulo == k) { sum = (sum + 1) % modulo; } ans += map.getOrDefault((sum - k + modulo) % modulo, 0); map.merge(sum, 1, Integer::sum); } return ans; }} 边权重均等查询树上倍增求最近公共祖先，同时维护边权的计数。详细见灵神题解。（发现汪佬的写法更简单，在 DFS 的同时进行倍增，以及通过拷贝数组来维护边权的计数信息。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution { private static final int M = 14; public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2] - 1; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] depth = new int[n]; int[][] cnt = new int[n][26]; int[][] parent = new int[M][n]; dfs(0, -1, g, depth, parent, cnt); // 查询 int k = queries.length; int[] ans = new int[k]; while (k-- != 0) { int x = queries[k][0], y = queries[k][1]; int z = lca(x, y, depth, parent), max = 0; for (int i = 0; i &lt; 26; i++) { max = Math.max(max, cnt[x][i] + cnt[y][i] - 2 * cnt[z][i]); } ans[k] = depth[x] + depth[y] - 2 * depth[z] - max; } return ans; } // DFS 的同时进行倍增，以及维护边权的计数 private void dfs(int x, int fa, List&lt;int[]&gt;[] g, int[] depth, int[][] parent, int[][] cnt) { for (int i = 1; 1 &lt;&lt; i &lt;= depth[x]; i++) { parent[i][x] = parent[i - 1][parent[i - 1][x]]; } for (int[] t : g[x]) { int y = t[0], w = t[1]; if (y != fa) { parent[0][y] = x; System.arraycopy(cnt[x], 0, cnt[y], 0, 26); cnt[y][w]++; depth[y] = depth[x] + 1; dfs(y, x, g, depth, parent, cnt); } } } // 求最近公共祖先 private int lca(int x, int y, int[] depth, int[][] parent) { if (depth[x] &gt; depth[y]) { int t = x; x = y; y = t; } // 先向上跳到相同深度 int step = depth[y] - depth[x]; for (int i = 0; i &lt; 32; i++) { if ((step &gt;&gt; i &amp; 1) != 0) { y = parent[i][y]; } } // 尽量向上跳 if (x != y) { for (int i = M - 1; i &gt;= 0; i--) { int px = parent[i][x], py = parent[i][y]; if (px != py) { x = px; y = py; } } x = parent[0][x]; } return x; }}","link":"/2023/09/04/%E7%AC%AC%20361%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 362 场力扣周赛","text":"与车相交的点差点又想区间合并做，看下数据范围，直接暴力，更好的做法是差分数组。 123456789101112131415class Solution { public int numberOfPoints(List&lt;List&lt;Integer&gt;&gt; nums) { int[] d = new int[102]; for (var num : nums) { d[num.get(0)]++; d[num.get(1) + 1]--; } int ans = 0; for (int i = 1; i &lt;= 100; i++) { d[i] += d[i - 1]; if (d[i] &gt; 0) ans++; } return ans; }} 判断能否在给定时间到达单元格题目说恰好第 \\(t\\) 秒到达，我还以为之前都不能到达，结果可以。那么特殊情况就是起点和终点相同，并且 \\(t=1\\)。 1234567class Solution { public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx &amp;&amp; sy == fy &amp;&amp; t == 1) return false; int a = Math.abs(sx - fx), b = Math.abs(sy - fy); return Math.max(a, b) &lt;= t; }} 将石头分散到网格图的最少移动次数方法一：回溯 记录所有等于零和大于一的位置，然后 DFS 搜索每个零从哪个位置获取一。 12345678910111213141516171819202122232425262728293031class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); else if (grid[i][j] &gt; 1) b.add(new int[]{i, j}); } } dfs(0, grid, a, b, 0); return ans; } private void dfs(int i, int[][] grid, List&lt;int[]&gt; a, List&lt;int[]&gt; b, int cnt) { if (i == a.size()) { ans = Math.min(ans, cnt); return; } int[] p = a.get(i); for (int j = 0; j &lt; b.size(); j++) { int[] q = b.get(j); if (grid[q[0]][q[1]] &gt; 1) { grid[q[0]][q[1]]--; dfs(i + 1, grid, a, b, cnt + Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1])); grid[q[0]][q[1]]++; } } }} 方法二：状压 DP 不是很懂，具体解释可以看大佬的题解。 123456789101112131415161718192021222324252627282930class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); for (int k = 2; k &lt;= grid[i][j]; k++) b.add(new int[]{i, j}); } } int n = a.size(); int[] f = new int[1 &lt;&lt; n]; for (int i = 1; i &lt; 1 &lt;&lt; n; i++) { f[i] = Integer.MAX_VALUE; int m = Integer.bitCount(i); for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j &amp; 1) == 1) { f[i] = Math.min(f[i], f[i ^ (1 &lt;&lt; j)] + distance(a.get(m - 1), b.get(j))); } } } return f[(1 &lt;&lt; n) - 1]; } private int distance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); }} 字符串转换KMP + 矩阵快速幂，详细见灵神题解，学习 KMP 看代码随想录，还有各种其他解法可以看题解区（很不错！）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { private static final int MOD = (int) 1e9 + 7; public int numberOfWays(String s, String t, long k) { int n = s.length(); char[] text = (s + s.substring(0, n - 1)).toCharArray(); char[] pattern = t.toCharArray(); int c = kmp(text, pattern); // f[0][0] = s.equals(t) ? 1 : 0; // f[0][1] = s.equals(t) ? 0 : 1; // f[i][0] = f[i - 1][0] * (c - 1) + f[i - 1][1] * c; // f[i][1] = f[i - 1][0] * (n - c) + f[i - 1][1] * (n - c - 1); long[][] m = {{c - 1, c}, {n - c, n - c - 1}}; m = pow(m, k); return s.equals(t) ? (int) m[0][0] : (int) m[0][1]; } private int kmp(char[] text, char[] pattern) { int m = text.length, n = pattern.length; int[] next = new int[n]; for (int i = 1, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) { j = next[j - 1]; } if (pattern[i] == pattern[j]) j++; next[i] = j; } int cnt = 0; for (int i = 0, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) { j = next[j - 1]; } if (text[i] == pattern[j]) j++; if (j == n) { cnt++; j = next[j - 1]; } } return cnt; } private long[][] pow(long[][] a, long n) { long[][] res = {{1, 0}, {0, 1}}; while (n != 0) { if ((n &amp; 1) == 1) res = mul(res, a); a = mul(a, a); n &gt;&gt;= 1; } return res; } private long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % MOD; } } return c; }}","link":"/2023/09/11/%E7%AC%AC%20362%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 896 (Div. 2)","text":"Make It Zero挺简单的一道题，偶数长度的数组操作两次就可以，如果是奇数长度，则额外操作两次。写的时候，把 \\(n\\) 错写成 \\(n-1\\)，找 BUG 花了一倍的时间。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } if (n % 2 == 0) { io.println(2); io.println(1 + &quot; &quot; + n); io.println(1 + &quot; &quot; + n); return; } io.println(4); io.println(1 + &quot; &quot; + (n - 1)); io.println(1 + &quot; &quot; + (n - 1)); io.println((n - 1) + &quot; &quot; + n); io.println((n - 1) + &quot; &quot; + n);} 2D Traveling\\(a\\) 和 \\(b\\) 的最短距离有两种情况，一个是 \\(a\\) 和 \\(b\\) 的曼哈顿距离，另一个是 \\(a\\) 和 \\(b\\) 经过 \\(k\\) 的曼哈顿距离，该情况只要求 \\(k\\) 个点中距离 \\(a\\) 和距离 \\(b\\) 最近的距离就行。比赛时遇到个坑点，两个 Long.MAX_VALUE 相加会溢出，所以初始时除以二。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(), a = io.nextInt(), b = io.nextInt(); long[] x = new long[n], y = new long[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } long ak = Long.MAX_VALUE / 2, bk = Long.MAX_VALUE / 2; for (int i = 0; i &lt; k; i++) { ak = Math.min(ak, Math.abs(x[i] - x[a - 1]) + Math.abs(y[i] - y[a - 1])); bk = Math.min(bk, Math.abs(x[i] - x[b - 1]) + Math.abs(y[i] - y[b - 1])); } long ab = Math.abs(x[b - 1] - x[a - 1]) + Math.abs(y[b - 1] - y[a - 1]); io.println(Math.min(ab, ak + bk));} Fill in the Matrix比赛时代码很乱，赛后总是可以优化成比较简单的形式。分类讨论，\\(n\\) 和 \\(m\\) 的大小关系，可以直接得出最大美丽值，需要注意特判 \\(m=1\\) 的情况。然后就是构造，当 \\(n\\leq m-1\\) 时，让一个从 \\(0\\) 开始的数组循环左移来构造行，这样可以保证得到最大美丽值；当 \\(n&gt;m-1\\) 时，前 \\(m-1\\) 行与之前一样构造，之后多余的行只需要和最后一行相同即可（保证不会影响美丽值）。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), m = io.nextInt(); if (m == 1) { io.println(0); } else if (n &lt;= m - 1) { io.println(n + 1); } else { io.println(m); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &lt; Math.min(n, m - 1)) { io.print((j + i) % m + &quot; &quot;); } else { io.print(j + &quot; &quot;); } } io.println(); }} Candy Party (Easy Version)找 BUG 花了半个小时，将判断 hi 是否是二的幂写成 hi % 2 != 0，修改为 Long.bitCount(hi) != 1 后通过，也可以写成 (hi &amp; hi - 1) != 0。因为每个人都需要发送和接收糖果，计算每个人和平均糖果数的差值 \\(x\\)，如果 \\(x\\) 的二进制位不是由连续的 \\(1\\) 组成，那么就无解，否则总是有唯一的 \\(lo\\) 和 \\(hi\\)（都是二的幂），使得 \\(hi-lo=|x|\\)。这样可以计算出每个人发送和接收多少糖果，如果最后相互抵消，则存在满足题目要求的交换方案。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); long lo = x &amp; -x, hi = x + lo; if (Long.bitCount(hi) != 1) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 0; i &lt; 32; i++) { if (cnt[i] != 0) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Candy Party (Hard Version)考虑什么人可以不发送或者不接收糖果，必定是持有糖果数与平均糖果数的差值为二的幂的人，它们比原来多出一种选择，就是只执行一次发送或接收。具体操作见代码，有点说不清。最后大概是从高位到低位遍历，如果当前位不满足条件，就将低一位的差值与平均糖果数为二的幂的数分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; int[] in = new int[32], out = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); if ((x &amp; x - 1) == 0) { int r = Long.numberOfTrailingZeros(x); if (a[i] &lt; avg) in[r]++; else out[r]++; continue; } long lo = x &amp; -x, hi = x + lo; if ((hi &amp; hi - 1) != 0) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 31; i &gt;= 0; i--) { cnt[i] += out[i] - in[i]; if (i == 0) break; in[i - 1] -= cnt[i]; out[i - 1] += cnt[i]; if (in[i - 1] &lt; 0 || out[i - 1] &lt; 0) { io.println(&quot;NO&quot;); return; } } io.println(cnt[0] == 0 ? &quot;YES&quot; : &quot;NO&quot;);}","link":"/2023/09/11/Codeforces%20Round%20896%20(Div.%202)/"},{"title":"Project #1 - Buffer Pool","text":"项目准备项目地址：Project #1 - Buffer Pool 准备工作：阅读 Chapter 12.1-12.4 13.2-13.3 24.2，学习 Lecture #03 #04，以及阅读课堂笔记。 项目结构buffer_pool_manager pages_ 数组相当于缓冲池，frame_id 是该数组的下标，也就唯一标识一个 Page，即标识一个缓冲页面。一个 Page 可以存储不同的物理页面，Page 的数据成员 page_id_ 唯一标识一个物理页面。因为不管是 FetchPage，还是 DeletePage 等函数，我们都是针对实际的物理页面做操作，所以 buffer_pool_manager 中的函数的形参都是提供 page_id。 lru_k_replacer 该类提供缓冲页面的淘汰策略，即淘汰某个 fram_id 对应的缓冲页面。一个缓冲页面会有一个对应的 LRUKNode，它负责记录该缓冲页面的访问历史。 page_guard 主要有三个类：BasicPageGuard，ReadPageGuard 和 WritePageGuard。BasicPageGuard 的作用是保证缓冲页面在使用完后会进行 UnpinPage 操作。而 ReadPageGuard 和 WritePageGuard，它们和 BasicPageGuard 是组合关系，它们的作用在 BasicPageGuard 的基础上保证页面在使用完后会解除读写锁。 Task #1 - LRU-K Replacement Policy实现① 一开始以为 current_timestamp_ 自动就是当前时间戳，调试时发现一直是 \\(0\\)，我真笨。可以直接从 \\(0\\) 开始手动模拟时间戳，调用 RecordAccess 时，让当前时间戳加 \\(1\\) 即可。 ② 在 Evict 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 frame，结果淘汰的是第一次访问时间最早的 frame。 ③ 在 ListNode 中使 history_ 的长度不超过 k_，如果超过就调用 pop_front()，这样每次获取之前第 k_ 个访问记录只需要调用 front() 函数。 ④ 在 RecordAccess 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 BufferPoolManager 构造函数的实现如下： 12345678// we allocate a consecutive memory space for the buffer poolpages_ = new Page[pool_size_];replacer_ = std::make_unique&lt;LRUKReplacer&gt;(pool_size, replacer_k);// Initially, every page is in the free list.for (size_t i = 0; i &lt; pool_size_; ++i) { free_list_.emplace_back(static_cast&lt;int&gt;(i));} 上述代码说明 frame_id 是小于 pool_size 的，所以大于等于 pool_size 的 fram_id 都应该抛出异常。（或许小于零的也应该抛出异常） 补充① 测试时将 DISABLED_SampleTest 改为 SampleTest。 ② 忘记 C++ 的 = 是拷贝，传引用加上 &amp;： 1auto node = node_store_.at(frame_id); // 错误：拷贝 ③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。 Task #2 - Buffer Pool Manager实现① NewPage 和 FetchPage 有很多逻辑相同的部分，可以加个辅助函数来获取 frame_id。 ② 注意，在 FetchPage 时，如果页面在内存中并且 pin_count_ = 0，则需要将其设置为不可淘汰的。 ③ 在 UnpinPage 中，更新 is_dirty 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。 ④ 在 FlushPage 中，注释表示 REGARDLESS of the dirty flag，应该说的是函数调用者，我们在实现时可以根据 is_dirty 来判断是否实际刷盘。 补充① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。 ② 实现 FetchPage 时，有个情况我忘记调用 RecordAccess，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。 Task #3 - Read/Write Page Guards实现① 使用移动构造和移动赋值后，需要清除 that 的元数据。 ② 移动赋值的调用者，也就是 this，如果其 page_ != nullptr，那么需要先将其 Drop，再进行赋值操作。 ③ 实现读写页面守卫的移动构造函数，可以直接赋值 std::move(that.guard_)，相当于调用之前实现的 BasicPageGuard 的移动赋值运算符。 ④ 实现读写页面守卫的 Drop 时，需要注意在调用 guard_.Drop() 之后再解锁页面，所以在 Drop 之前需要保存一下指向页面的指针。 ⑤ 在实现 BufferPoolManager 中的 FetchPageRead 和 FetchPageWrite 时，为页面加读写锁。 ⑥ 和 PageGuard 有关的 FetchPage 函数会返回一个 PageGuard 对象，但是如果所有缓存页已经被 pin，那么该返回什么。一开始我是直接拿 nullptr 构造 PageGuard，但是发现不对，因为 PageGuard 对象并没有检查 page_ == nullptr 的函数，所以页面必须被 Fetch 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管） Leaderboard Task (Optional)准备性能分析 看到CMU 15-445 2023 P1 优化攻略中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 perf 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。 Brendan Gregg’s Homepage How to use flamegraphs for performance profiling profiling 与性能优化总结 speedscope LRU-K（对优化似乎没有帮助） 关于 LRU-K 的论文：The LRU-K Page Replacement Algorithm For Database Disk Buffering。 LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析） 解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂） LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。 LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\\(K\\geq 2\\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。 实现更新：以下内容存在一些错误，将会在下一节纠正。 ① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。 ② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 frame_id，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我） ③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 bpm-bench 测试），结果发现是我理解有问题。尝试使用读写锁在 BufferPoolManager 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 Unknown 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 FetchPage 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。 ④ 参考CMU 15-445 2023 P1 优化攻略，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 ResetMemory 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。 ⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 BufferPoolManager 之前析构 DiskManager，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。 ⑥ 本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 LRUKNode 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 Evict 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性） Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 61 ALEX 111924 104867 261 484 5123 32 ALEX 102401 96293 4886 5221 57123 2 ALEX 120664 123402 182590 248050 2663116 12 ALEX 143562 133514 3813 8132 85169 重做实现纠错 在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 page_table_），但是，如果在刷盘过程中，有另一个线程读取该页面，它在 page_table_ 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误，错误在 disk_manager_memory.h 中被检测： 1234if (page_id &gt;= static_cast&lt;int&gt;(data_.size()) || page_id &lt; 0) { LOG_WARN(&quot;page not exist&quot;); return;} 所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 page_id 和 frame_id，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 page_table_ 的锁，以确保在其他线程 FetchPage 时，表中已有该 page_id）。这时如果有其他线程 Fetch 该 page_id，不会直接从磁盘读，而是读这个表拿到之前的 frame_id，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 FetchPage 该 page_id 时，会发生已淘汰又被 pin 的情况，还会发生其他很复杂的情况） 如何优化 既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 README（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）： ① 缓存页面的访问规则 读写页面时必须 pin 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 pin） 在读页面时，可以释放页面的读锁，因为已经拿到页面的 pin。 在写页面时，必须拿到 pin 和写锁，并且需要检查 pincount_ == 1，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 unpin，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 pin，但是没有关系，因为当前线程拿到写锁，其他线程 pin 之后还需要拿锁才能读写页面。 我们的项目和上面的描述不一样，但是无伤大雅，基本上 PageGuard 和 FetchPage 等函数已经提供了这些功能。 ② 缓冲池管理器的内部锁定 访问 page_table_ 前需要拿到 page_table 的读写锁（文中称作 BufMappingLock）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 pin。在修改 page_table_，或者修改缓存页面头部字段（应该是指 Page 的除 data_ 以外的成员变量，在本项目中就是 page_id_、pin_count_ 和 is_dirty_），或者从磁盘读物理页面到缓存页面时，需要拿到 page_table_ 的写锁。 可以将 BufMappingLock 拆分为 NUM_BUFFER_PARTITIONS 个锁，每个锁负责映射的一部分。每个 page_id_ 属于哪个分区，由 page_id_ 的哈希值的低比特位决定（其实就是有多个 page_table_，每个 page_id 会根据哈希函数来确定存放在哪个 page_table_ 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。 为空闲列表和页面替换提供独占的自旋锁 buffer_strategy_lock ，当拿到该锁时，不应该去获取任何其他锁。 每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 BufMappingLock 锁）。 BM_IO_IN_PROGRESS 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 BufMappingLock 锁吧）。 缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。 ③ 后台线程刷盘 按照淘汰顺序扫描页面，选择 is_dirty_ == true &amp;&amp; pin_count_ == 0 的页面，然后 pin 该页面并刷盘，最后回收到空闲列表。 还有一些优化方式，没看懂就不翻译了。 总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。 尝试实现 重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。 ① FetchPage 在判断 page_id 是否在 page_table_ 时，需要使用 page_table_ 的独占锁。并且如果页面不在 page_table_ 中，则在函数返回 nullptr 或修改 page_table_ 之前不能释放该锁，以防止多次 FetchPage 同一个 page_id 时，多次从 free_list_ 中获取页面或者多次淘汰页面。 ② 因为在 FetchPage 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 pin 的，所以之后设置 pin_count_ 时，不能直接设置为 1，而是进行 ++ 操作。 第一次重构没有拆分 BufMappingLock，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 unique_lock 作为参数，并且 atomic_flag 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。不搞了，像个小丑，没意思。 Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 26 ALEX 92024 80293 5082 5287 57971 调试① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。 ② 优化时容易出问题的点就是 NewPage 和 FetchPage，以及 UnpinPage。像是 FlushPage、FlushAllPage 以及 DeletePage 都可以暂时不管（可以直接 return），这样比较方便调试。 补充① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。 ② 遇到 Reference to non-static member function must be called 问题，解决方案在此。 ③ MySQL Buffer Pool 的实现 15.5.1 Buffer Pool。 ④ Linus Torvalds 发表的一篇评论：do not use spinlocks in user space, unless you actually know what you’re doing。 ⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。 ⑥ 发现一个感觉不错的博客：MC++。 测试结果测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。 优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。 每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行： 123456789#!/bin/bashmake lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)./test/lru_k_replacer_test./test/buffer_pool_manager_test./test/page_guard_testmake formatmake check-lintmake check-clang-tidy-p1make submit-p1 项目小结① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。 ② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，bpm 优化也就是简单减少锁的粒度，lru 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。 ③ 我好菜啊！！！前三个任务花了两天，优化花了好几天。 更新：发现 Lecture #06 就是讲 BufferPool 优化的（课堂笔记），不知道能不能在这用上，等做完所有 Project 再来试试。","link":"/2023/09/12/Project%201%20-%20Buffer%20Pool/"},{"title":"Codeforces Round 897 (Div. 2)","text":"green_gold_dog, array and permutation让最小值减去最大值，就一定可以得到 \\(n\\) 个不同的差值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; a[i] - a[j]); int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { int t = aux[i]; ans[t] = n - i; } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} XOR Palindromes算是简单的分类讨论，比赛时写的稀烂。 123456789101112131415161718public static void solve() { int n = io.nextInt(), cnt = 0; char[] s = io.next().toCharArray(); for (int i = 0; i &lt; n / 2; i++) { if (s[i] != s[n - i - 1]) { cnt++; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt;= n; i++) { if (i &lt; cnt || i &gt; n - cnt || (i - cnt) % 2 == 1 &amp;&amp; n % 2 == 0) { sb.append('0'); } else { sb.append('1'); } } io.println(sb);} Salyg1n and the MEX Game比赛调试一小时，疯狂超时，结果是限制太强的原因。（浪费时间。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); } Arrays.sort(s); int x = n; for (int i = 0; i &lt; n ; i++) { if (s[i] != i) { x = i; break; } } while (x != -1) { io.println(x); io.flush(); x = io.nextInt(); }} Cyclic Operations做了一个多小时 AC，有点像之前做的内向基环树，该题每个点都有个出边，所以至少有一个环。首先要特判 \\(k=1\\) 的情况，该情况每个位置都必须自成一个环，即 \\(a_{i}=i\\)；其他情况所有环的长度都必须为 \\(k\\)，这样可以保证答案存在。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[b[i]]++; } Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } while (!q.isEmpty()) { int x = q.poll(); if (--in[b[x]] == 0) { q.offer(b[x]); } } int cnt = 0; boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { if (in[i] == 0 || vis[i]) continue; int len = 0; for ( ; !vis[i]; i = b[i]) { vis[i] = true; len++; } if (len != k) { io.println(&quot;NO&quot;); return; } cnt++; } if (k == 1 &amp;&amp; cnt != n) { io.println(&quot;NO&quot;); } else { io.println(&quot;YES&quot;); }} Salyg1n and Array (simple version)注意，\\(n\\) 和 \\(k\\) 都是偶数！手推的话可能可以做出来吧。 12345678910111213141516public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } for (; i &lt;= n; i++) { io.println(&quot;? &quot; + (i - k + 1)); io.flush(); ans ^= io.nextInt(); } io.println(&quot;! &quot; + ans); io.flush();} Salyg1n and Array (hard version)技巧性有点强，真想不到。就是如果多出一部分，可以通过两次异或算出来。 123456789101112131415161718public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } int t = n - i + 1; io.println(&quot;? &quot; + (n - k + 1 - t / 2)); io.flush(); ans ^= io.nextInt(); io.println(&quot;? &quot; + (n - k + 1)); io.flush(); ans ^= io.nextInt(); io.println(&quot;! &quot; + ans); io.flush();}","link":"/2023/09/17/Codeforces%20Round%20897%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 320","text":"Leyland Number模拟。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(); int x = 1; for (int i = 0; i &lt; b; i++) { x *= a; } int y = 1; for (int i = 0; i &lt; a; i++) { y *= b; } io.println(x + y);} Longest Palindrome模拟。 123456789101112131415public static void solve() { String s = io.next(); int n = s.length(); int ans = 1; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { String a = s.substring(i, j + 1); String b = new StringBuilder(a).reverse().toString(); if (a.equals(b)) { ans = Math.max(ans, j - i + 1); } } } io.println(ans);} Slot Strategy 2 (Easy)暴力枚举每个转盘的时间。 1234567891011121314151617181920212223public static void solve() { int n = 3, m = io.nextInt(); int ans = Integer.MAX_VALUE; String[] s = new String[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.next(); } for (int i = 0; i &lt; n * m; i++) { char a = s[0].charAt(i % m); for (int j = 0; j &lt; n * m; j++) { if (i == j) continue; char b = s[1].charAt(j % m); for (int k = 0; k &lt; n * m; k++) { if (i == k || j == k) continue; char c = s[2].charAt(k % m); if (a == b &amp;&amp; b == c) { ans = Math.min(ans, Math.max(i, Math.max(j, k))); } } } } io.println(ans == Integer.MAX_VALUE ? -1 : ans);} Relative PositionDFS 模拟，需要注意给的不是一棵树，所以在 DFS 时要使用访问数组，而不能用父结点。 1234567891011121314151617181920212223242526272829303132333435public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1, x = io.nextInt(), y = io.nextInt(); g[a].add(new int[]{b, x, y}); g[b].add(new int[]{a, -x, -y}); } long[] X = new long[n]; long[] Y = new long[n]; Arrays.fill(X, Long.MAX_VALUE); Arrays.fill(Y, Long.MAX_VALUE); boolean[] vis = new boolean[n]; dfs(0, vis, g, 0, 0, X, Y); for (int i = 0; i &lt; n; i++) { if (X[i] != Long.MAX_VALUE &amp;&amp; Y[i] != Long.MAX_VALUE) { io.println(X[i] + &quot; &quot; + Y[i]); } else { io.println(&quot;undecidable&quot;); } }}private static void dfs(int i, boolean[] vis, List&lt;int[]&gt;[] g, long x, long y, long[] X, long[] Y) { X[i] = x; Y[i] = y; vis[i] = true; for (int[] t : g[i]) { int j = t[0]; if (vis[j]) continue; long nx = t[1] + x, ny = t[2] + y; dfs(j, vis, g, nx, ny, X, Y); }} Somen Nagashi还是模拟，可以一边输入一边处理，减少代码量。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); long[] ans = new long[n], re = new long[n]; PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;((a, b) -&gt; Long.compare(re[a], re[b])); for (int i = 0; i &lt; n; i++) { q.offer(i); } while (m-- != 0) { int t = io.nextInt(), w = io.nextInt(), s = io.nextInt(); while (!p.isEmpty() &amp;&amp; re[p.peek()] &lt;= t) q.offer(p.poll()); if (q.isEmpty()) continue; int x = q.peek(); ans[x] += w; re[x] = t + s; p.offer(q.poll()); } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }}","link":"/2023/09/17/AtCoder%20Beginner%20Contest%20320/"},{"title":"第 113 场力扣夜喵双周赛","text":"使数组成为递增数组的最少右移次数直接从最小值开始判断数组是否递增，或者可以找到第一个递减的位置，然后再判断数组是否递增（因为如果数组满足条件，则其最多只有一个递减段）。 12345678910111213141516class Solution { public int minimumRightShifts(List&lt;Integer&gt; nums) { int n = nums.size(), idx = -1, min = 101; for (int i = 0; i &lt; n; i++) { if (nums.get(i) &lt; min) { min = nums.get(i); idx = i; } } for (int i = 0; i &lt; n - 1; i++) { int x = (idx + i) % n, y = (x + 1) % n; if (nums.get(x) &gt; nums.get(y)) return -1; } return (n - idx) % n; }} 删除数对后的最小数组长度贪心，比赛时我是用双指针做的，前半部分和后半部分进行匹配（当时边界想了很久，真笨！）。其他做法，参考题解：【小羊肖恩】数学 + 贪心：解决较长数组脑筋急转弯问题的关键。（因为 HashMap 很慢，所以用双指针会更快。） 方法一：贪心 1234567891011class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), i = 0; for (int j = (n + 1) / 2; j &lt; n; j++) { if (nums.get(i) &lt; nums.get(j)) { i++; } } return n - i * 2; }} 方法二：贪心 + 数学 12345678910class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), max = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { max = Math.max(max, map.merge(x, 1, Integer::sum)); } return 2 * max &lt;= n ? n % 2 : n - (n - max) * 2; }} 统计距离为 k 的点对枚举 \\(x_{1}\\oplus x_{2}\\) 的值为 \\(p\\)，可以得到 \\(y_{1}\\oplus y_{2}\\) 的值为 \\(k-p\\)。可以使用 HashMap 对前缀中的值计数来求解，需要注意循环的顺序，如果调换顺序会使代码变复杂，会花费更多的时间计算答案。 1234567891011121314class Solution { public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates, int k) { int ans = 0; Map&lt;List&lt;Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;(); for (var c : coordinates) { int x = c.get(0), y = c.get(1); for (int i = 0; i &lt;= k; i++) { ans += map.getOrDefault(List.of(x ^ i, y ^ (k - i)), 0); } map.merge(c, 1, Integer::sum); } return ans; }} 可以到达每一个节点的最少边反转次数换根 DP，关键是要想到建立反向边，并为边添加相应的边权。 12345678910111213141516171819202122232425262728293031323334class Solution { public int[] minEdgeReversals(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(new int[]{v, 0}); g[v].add(new int[]{u, 1}); } int[] ans = new int[n]; ans[0] = dfs(0, -1, g); dfs2(0, -1, g, ans); return ans; } private int dfs(int x, int fa, List&lt;int[]&gt;[] g) { int res = 0; for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; res += dfs(y, x, g) + w; } return res; } private void dfs2(int x, int fa, List&lt;int[]&gt;[] g, int[] ans) { for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; ans[y] = ans[x] + (w == 0 ? 1 : -1); dfs2(y, x, g, ans); } }}","link":"/2023/09/17/%E7%AC%AC%20113%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 363 场力扣周赛","text":"计算 K 置位下标对应元素的和模拟。 1234567891011class Solution { public int sumIndicesWithKSetBits(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i++) { if (Integer.bitCount(i) == k) { ans += nums.get(i); } } return ans; }} 让所有学生保持开心的分组方法数比赛时又写复杂了，当时是想到所有相同的数都必须同时选，所以加了一层循环来跳过相同的数。但是相同的数天然的不满足判断条件，所以不需要这样写。这题唯一需要注意的就是特判全都不选的情况，以及全都选的情况必定满足，可以直接加到答案里（以减少判断代码）。 12345678910111213class Solution { public int countWays(List&lt;Integer&gt; nums) { Collections.sort(nums); int n = nums.size(), ans = 1; if (nums.get(0) &gt; 0) ans++; for (int i = 0; i &lt; n - 1; i++) { if (i + 1 &gt; nums.get(i) &amp;&amp; i + 1 &lt; nums.get(i + 1)) { ans++; } } return ans; }} 最大合金数比赛时又又写复杂了，当时是把所有的库存都清除了再二分的，其实可以直接二分！！ 12345678910111213141516171819class Solution { public int maxNumberOfAlloys(int n, int k, int budget, List&lt;List&lt;Integer&gt;&gt; composition, List&lt;Integer&gt; stock, List&lt;Integer&gt; cost) { int ans = 0; for (var cur : composition) { int lo = 0, hi = (int) 2e8; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; long cnt = 0L; for (int i = 0; i &lt; n; i++) { cnt += Math.max((long) cur.get(i) * mid - stock.get(i), 0L) * cost.get(i); } if (cnt &lt;= budget) lo = mid + 1; else hi = mid - 1; } ans = Math.max(ans, hi); } return ans; }} 完全子集的最大元素和注意题目的描述是每对元素的乘积都是完全平方数。朴素的想法就是对下标进行质因数分解，将所有出现次数为奇数质因数相乘，其结果作为桶的下标，把所有同类的数放在同一个桶里面，然后对每个桶求和取最大值，这样的时间复杂度是 \\(O(n\\sqrt{n})\\)。但是有 \\(O(n)\\) 的解法，如下所示。 1234567891011121314class Solution { public long maximumSum(List&lt;Integer&gt; nums) { long ans = 0L; int n = nums.size(); for (int i = 1; i &lt;= n; i++) { long sum = 0L; for (int j = 1; i * j * j &lt;= n; j++) { sum += nums.get(i * j * j - 1); } ans = Math.max(ans, sum); } return ans; }}","link":"/2023/09/17/%E7%AC%AC%20363%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 321","text":"321-like Checker模拟。 1234567891011public static void solve() { int n = io.nextInt(); String s = String.valueOf(n); for (int i = 0; i &lt; s.length() - 1; i++) { if (s.charAt(i) &lt;= s.charAt(i + 1)) { io.println(&quot;No&quot;); return; } } io.println(&quot;Yes&quot;);} Cutoff比赛时是暴力做的，赛后这个 \\(O(1)\\) 还想了半天。不多解释，代码还是比较好理解的。 12345678910111213141516public static void solve() { int n = io.nextInt(), x = io.nextInt(); int min = 101, max = -1, sum = 0; for (int i = 0; i &lt; n - 1; i++) { int t = io.nextInt(); sum += t; min = Math.min(min, t); max = Math.max(max, t); } int t = x - (sum - min - max); if (t &gt; max) { io.println(-1); } else { io.println(t &lt;= min ? 0 : t); }} 321-like Searcher原来是使用十个二进制位来表示对应数字是否存在，通过暴力枚举算出所有可能的数，最后排序获取对应的位置即可，真的没想到。 123456789101112131415public static void solve() { int k = io.nextInt(); List&lt;Long&gt; ans = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; 1 &lt;&lt; 10; i++) { long x = 0L; for (int j = 9; j &gt;= 0; j--) { if ((i &gt;&gt; j &amp; 1) == 1) { x = x * 10 + j; } } ans.add(x); } Collections.sort(ans); io.println(ans.get(k - 1));} Set Menu二分，状态真差，把加法和乘法混淆了。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); long[] sum = new long[m + 1]; for (int i = 0; i &lt; m; i++) { sum[i + 1] = sum[i] + b[i]; } long ans = 0L; for (int i = 0; i &lt; n; i++) { int x = p - a[i]; int lo = 0, hi = m - 1; while (lo &lt;= hi) { int mid= lo + (hi - lo) / 2; if (b[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } ans += ((long) lo * a[i] + sum[lo]) + (long) (m - lo) * p; } io.println(ans);}","link":"/2023/09/27/AtCoder%20Beginner%20Contest%20321/"},{"title":"第 364 场力扣周赛","text":"最大二进制奇数模拟。 12345678910111213141516class Solution {public: string maximumOddBinaryNumber(string s) { int n = s.size(), cnt = 0; for (char c : s) { if (c == '1') cnt++; } string ans; for (int i = 0; i &lt; n - 1; i++) { if (i &lt; cnt - 1) ans.push_back('1'); else ans.push_back('0'); } ans.push_back('1'); return ans; }}; 美丽塔 I同下。 美丽塔 II枚举以每个位置作为山顶，可以得到的最大高度和。通过使用单调栈 + 前后缀分解，可以 \\(O(n)\\) 的时间算出答案。 1234567891011121314151617181920212223242526class Solution {public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { int n = maxHeights.size(); vector&lt;long long&gt; left(n + 1), right(n + 1); stack&lt;int&gt; stk; stk.push(-1); for (int i = 0; i &lt; n; i++) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); left[i + 1] = left[stk.top() + 1] + 1LL * maxHeights[i] * (i - stk.top()); stk.push(i); } stk = stack&lt;int&gt;(); stk.push(n); for (int i = n - 1; i &gt;= 0; i--) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); right[i] = right[stk.top()] + 1LL * maxHeights[i] * (stk.top() - i); stk.push(i); } long long ans = 0; for (int i = 0; i &lt; n; i++) { ans = max(ans, left[i] + right[i]); } return ans; }}; 统计树中的合法路径数目树型 DP，对于每个节点，计算以该节点为根的子树中，经过该节点的有效路径数，我们只需要维护子树中不包含质数的路径数和只包含一个质数的路径数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { private static final int N = (int) 1e5; private static final boolean[] np = new boolean[N + 1]; static { np[0] = np[1] = true; for (int i = 2; i &lt;= N / i; i++) { if (!np[i]) { for (int j = i; j &lt;= N / i; j++) { np[j * i] = true; } } } } long ans = 0L; public long countPaths(int n, int[][] edges) { List&lt;Integer&gt;[] g = new List[n + 1]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { g[e[0]].add(e[1]); g[e[1]].add(e[0]); } dfs(1, 0, g); return ans; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g) { int zero = 0, one = 0; if (np[x]) zero = 1; else one = 1; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g); ans += (long) zero * t[1] + (long) one * t[0]; if (np[x]) { zero += t[0]; one += t[1]; } else { one += t[0]; } } return new int[]{zero, one}; }}","link":"/2023/09/27/%E7%AC%AC%20364%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 899 (Div. 2)","text":"Increasing Sequence模拟，注意最后答案要减一。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int b = 1; for (int i = 0; i &lt; n; i++) { if (b == a[i]) b += 2; else b += 1; } io.println(b - 1);} Sets and Union比赛时写复杂了，就是枚举不选哪个数，使用位运算会很简单。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); long xor = 0L; long[] s = new long[n]; for (int i = 0; i &lt; n; i++) { int k = io.nextInt(); for (int j = 0; j &lt; k; j++) { s[i] |= 1L &lt;&lt; io.nextInt(); } xor |= s[i]; } int ans = 0; for (int i = 1; i &lt;= 50; i++) { if ((xor &gt;&gt; i &amp; 1) != 1) continue; long res = 0L; for (int j = 0; j &lt; n; j++) { if ((s[j] &gt;&gt; i &amp; 1) != 1) { res |= s[j]; } } ans = Math.max(ans, Long.bitCount(res)); } io.println(ans);} Card Game思维题，没想出来。不管前两张牌如何操作，都必定可以拿到之后的所有正数牌，然后对前两张牌分类讨论即可。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } long ans = 0L; for (int i = 2; i &lt; n; i++) { ans += Math.max(0, a[i]); } ans += Math.max(0, a[0] + Math.max(0, n &gt; 1 ? a[1] : 0)); io.println(ans);} Tree XOR很典的换根 DP，因为第三题花费太长时间，导致差几分钟 AC。只要相邻的两个节点值不相同，它们就需要做一次操作。先以一个节点为根做 DFS，并记录所有节点的子树大小，和以该节点为根的成本。然后再做一次 DFS，换根计算代价的差值。（比赛时犯蠢，在换根的过程中打印答案，但是遍历不能保证从 \\(1\\) 到 \\(n\\) 的顺序，所以是错的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static long[] ans;private static int[] value, sz;private static List&lt;Integer&gt;[] g;public static void solve() { int n = io.nextInt(); value = new int[n]; for (int i = 0; i &lt; n; i++) { value[i] = io.nextInt(); } g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1; g[u].add(v); g[v].add(u); } sz = new int[n]; ans = new long[n]; dfs1(0, -1); dfs2(0, -1); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs1(int x, int fa) { sz[x] = 1; for (int y : g[x]) { if (y == fa) continue; dfs1(y, x); sz[x] += sz[y]; ans[0] += (long) sz[y] * (value[x] ^ value[y]); }}private static void dfs2(int x, int fa) { for (int y : g[x]) { if (y == fa) continue; ans[y] = ans[x] + (long) (sz[0] - sz[y] - sz[y]) * (value[x] ^ value[y]); dfs2(y, x); }}","link":"/2023/09/27/Codeforces%20Round%20899%20(Div.%202)/"},{"title":"Educational Codeforces Round 155 (Rated for Div. 2)","text":"Rigged!模拟。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] s = new int[n]; int[] e = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); e[i] = io.nextInt(); } for (int i = 1; i &lt; n; i++) { if (s[i] &gt;= s[0] &amp;&amp; e[i] &gt;= e[0]) { io.println(-1); return; } } io.println(s[0]);} Chips on the Board有两种情况，每行都放一个或者每列都放一个，然后模拟即可。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] b = new int[n]; long suma = 0L; int mina = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); suma += a[i]; mina = Math.min(mina, a[i]); } long sumb = 0L; int minb = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); sumb += b[i]; minb = Math.min(minb, b[i]); } io.println(Math.min(suma + (long) minb * n, sumb + (long) mina * n));} Make it Alternating所有连续重复数的个数就是最少操作次数，然后就是简单的应用组合数学。 1234567891011121314151617181920private static final int MOD = 998244353;public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; long cnt = n, sum = 1L; for (int i = 0; i &lt; n; ) { int j = i + 1; while (j &lt; n &amp;&amp; s[j] == s[j - 1]) { j++; } sum = sum * (j - i) % MOD; cnt--; i = j; } for (long i = 1; i &lt;= cnt; i++) { sum = sum * i % MOD; } io.println(cnt + &quot; &quot; + sum);} Sum of XOR Functions固定右端点，然后分别考虑每一位，计算答案，公式如下： $$ \\sum_{r=1}^{n}\\sum_{l=1}^{r}f(l,r)\\cdot (r-l+1) =\\sum_{r=1}^{n}\\sum_{i=0}^{31}\\sum_{l=1}^{r}(f_{i}(1,r)\\oplus f_{i}(1,l-1))\\cdot (r-(l-1)) $$ 可以发现对于每一位，\\(f_{i}(1,r)\\oplus f_{i}(1,l-1)\\) 的值不是 \\(1\\) 就是 \\(0\\)，只有当值为 \\(1\\) 时才会对答案有贡献。如果 \\(f_{i}(1,r)=1\\)，那么右端点 \\(r\\) 的第 \\(i\\) 位对答案的贡献为 \\((cnt[i][0]\\cdot r-sum[i][0])\\cdot 2^{i}\\)（其中 \\(cnt[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的个数，\\(sum[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的区间长度之和），另一种情况同理。 12345678910111213141516171819202122private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] s = new int[n + 1]; for (int i = 0; i &lt; n; i++) { s[i + 1] = s[i] ^ io.nextInt(); } long ans = 0L; long[][] cnt = new long[32][2]; long[][] sum = new long[32][2]; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt; 32; j++) { int x = s[i] &gt;&gt; j &amp; 1; ans = (ans + (cnt[j][x ^ 1] * i - sum[j][x ^ 1]) % MOD * (1 &lt;&lt; j)) % MOD; cnt[j][x]++; sum[j][x] += i; } } io.println(ans);}","link":"/2023/09/27/Educational%20Codeforces%20Round%20155%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 900 (Div. 3)","text":"How Much Does Daytona Cost?所有长度为 \\(1\\) 的子数组，包含的元素必定是众数，所以只需判断 \\(k\\) 是否存在于数组中。 12345678910public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean ok = false; for (int i = 0; i &lt; n; i++) { if (k == io.nextInt()) { ok = true; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Aleksa and Stack两个奇数相加得到偶数，两个奇数相乘得到奇数，奇数不会被偶数整除，所以构造一个全是奇数的序列即可。 1234567public static void solve() { int n = io.nextInt(); for (int i = 0; i &lt; n; i++) { io.print(i * 2 + 1 + &quot; &quot;); } io.println();} Vasilije in Cacak只要 \\(x\\) 在最小值和最大值之间，就总是可以被表示出来。 12345678public static void solve() { int n = io.nextInt(), k = io.nextInt(); long x = io.nextLong(); long a = (long) (1 + k) * k / 2; long b = (long) (n - k + 1 + n) * k / 2; if (x &gt;= a &amp;&amp; x &lt;= b) io.println(&quot;YES&quot;); else io.println(&quot;NO&quot;);} Reverse Madness数组被 \\(l\\) 和 \\(r\\) 分段，每一段都是相互独立的，可以单独考虑段内的反转情况。可以发现段内反转总是中心对称的，每个元素是否反转，取决于该元素位置被反转次数的奇偶性，可以用两边向中间求累加和的方式统计，也可以用差分数组。（比赛时我没有统计奇偶性，而是抵消相邻的反转的相同部分） 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[] l = new int[k]; for (int i = 0; i &lt; k; i++) { l[i] = io.nextInt() - 1; } int[] r = new int[k]; for (int i = 0; i &lt; k; i++) { r[i] = io.nextInt() - 1; } int q = io.nextInt(); int[] cnt = new int[n]; for (int i = 0; i &lt; q; i++) { cnt[io.nextInt() - 1]++; } for (int i = 0; i &lt; k; i++) { int sum = 0; for (int a = l[i]; a &lt;= (l[i] + r[i]) / 2; a++) { int b = r[i] + l[i] - a; sum += cnt[a] + cnt[b]; if (sum % 2 == 1) { char c = s[a]; s[a] = s[b]; s[b] = c; } } } io.println(new String(s));} Iva &amp; Pav比较简单的做法是，计算每个比特位的前缀和，然后对每个查询二分答案的位置，将二分位置的值和 \\(k\\) 比较来判断二分的走向。比赛时我是用下面的方法做的，就是没想到二分，其实也可以不用二分，但是没看明白为什么，代码在此。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } // next[i][j] 表示 a[i] 的第 j 位等于 0 的下一个位置 int[][] next = new int[n + 1][32]; Arrays.fill(next[n], n); for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; 32; j++) { next[i][j] = next[i + 1][j]; if ((a[i] &gt;&gt; j &amp; 1) == 0) { next[i][j] = i; } } } int q = io.nextInt(); while (q-- != 0) { int l = io.nextInt() - 1, k = io.nextInt(); if (a[l] &lt; k) { io.print(&quot;-1 &quot;); continue; } int lo = l, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; int cur = 0; for (int i = 0; i &lt; 32; i++) { if (next[mid][i] &gt; mid &amp;&amp; next[mid][i] == next[l][i]) { cur |= 1 &lt;&lt; i; } } if (cur &gt;= k) lo = mid + 1; else hi = mid - 1; } io.print(hi + 1 + &quot; &quot;); } io.println();}","link":"/2023/09/27/Codeforces%20Round%20900%20(Div.%203)/"},{"title":"CodeTON Round 6 (Div. 1 + Div. 2, Rated, Prizes!)","text":"MEXanized Array分类讨论，一开始以为不能有重复，花了很多时间。（菜） 12345public static void solve() { int n = io.nextInt(), k = io.nextInt(), x = io.nextInt(); if (n &lt; k || x &lt; k - 1) io.println(-1); else io.println((k - 1) * k / 2 + (n - k) * (x == k ? k - 1 : x));} Friendly Arrays又看错题了，其实是道很简单的题。 123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); int a = 0; for (int i = 0; i &lt; n; i++) { a ^= io.nextInt(); } int b = 0; for (int i = 0; i &lt; m; i++) { b |= io.nextInt(); } int min = a, max = a; if (n % 2 == 0) { min = a ^ (a &amp; b); } else { max = a | b; } io.println(min + &quot; &quot; + max);} Colorful Table一个数可以向外扩展到大于等于它的的数的位置，我们可以按 \\(k\\) 的大小记录左右端点，然后按照从大到小遍历，来扩展边界，最后计算答案。注意，排除不在数组中的数。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean[] mark = new boolean[k]; int[] l = new int[k], r = new int[k]; Arrays.fill(l, n); Arrays.fill(r, -1); for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; mark[a] = true; l[a] = Math.min(l[a], i); r[a] = i; } for (int i = k - 2; i &gt;= 0; i--) { l[i] = Math.min(l[i], l[i + 1]); r[i] = Math.max(r[i], r[i + 1]); } for (int i = 0; i &lt; k; i++) { if (!mark[i]) io.print(0 + &quot; &quot;); else io.print(2 * (r[i] - l[i] + 1) + &quot; &quot;); } io.println();} Prefix Purchase又又犯蠢了，题目都没读明白。如果右边有更小的数，那么肯定选更小的数是更优的，可以从右向左遍历，将右边的最小值传递到当前位置。然后就是依次处理每个位置，细节见代码。 1234567891011121314151617181920void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; c(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c[i]; } int k; cin &gt;&gt; k; for (int i = n - 2; i &gt;= 0; i--) { c[i] = min(c[i], c[i + 1]); } int m = k; for (int i = 0; i &lt; n; i++) { int x = i == 0 ? c[i] : c[i] - c[i - 1]; if (x != 0) m = min(m, k / x); k -= x * m; cout &lt;&lt; m &lt;&lt; &quot; \\n&quot;[i == n - 1]; }}","link":"/2023/09/27/CodeTON%20Round%206%20(Div.%201%20+%20Div.%202,%20Rated,%20Prizes!)/"},{"title":"Project #2 - B+Tree","text":"项目准备项目地址：Project #2 - B+Tree 准备工作：阅读 Chapter 14.5 24.5 14.1-14.4 18.10.2，学习 Lecture #07 #08 #09，以及阅读课堂笔记。 Task #1 - B+Tree Pages实现① 第一个比较迷惑的点就是 max_size_ 的含义，对官方提供的B+Tree进行插入操作，发现叶子节点的 size_ 不会到达 max_size_。难道叶子节点实际只能包含 max_size_ - 1 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 max_size_ 时，进行分裂，内部节点在插入前大小达到 max_size_ 时进行分裂。所以对于内部节点，max_size_ 表示它能包含的指针数量；对于叶子节点，max_size_ 表示它能包含的键值对数量。 ② GetMinSize 的实现，同样参考官方示例，对于非叶子节点，返回 (max_size_ + 1) / 2；对于叶子节点，返回 max_size_ / 2。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。 补充① 如何理解 MappingType array_[0]，注释表示它是 Flexible array member for page data，参见维基百科Flexible array member。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。 ② 在内部节点和叶子节点中，array_ 的唯一区别就是在搜索内部节点时不能使用 array[0]_.first，因为它并不能准确表示 array_[0].second 中 key 的范围（向 array_[0].second 中插入一个更小的 key，它就失效了）。 Task #2a - B+Tree Insertion and Search for Single Values实现① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \\(O(n)\\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。 ② 可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Search 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 -index - 1（方便之后插入，类似 Java 中的 BinarySearch）。具体的实现逻辑： 内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 index - 1。 叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 -index - 1，否则返回 index。 ③ 特别注意 PageGuard 的使用，只有当操作完页面之后，才对其进行 Drop 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 Drop，这样可以尽早释放页面的锁以及 Unpin 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 Drop 上个页面（使用 Context）。注意拿锁和 Drop 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。 ④ 获取页面需要进行类型转换，如果只读不写就使用 page_guard.h 中提供的 As 函数，只有需要写页面时才使用 AsMut 函数，因为该函数会将页面置为脏页。先将其转换为 BPlusTreePage，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 BPlusTree 类中已经为我们提供了别名： 12using InternalPage = BPlusTreeInternalPage&lt;KeyType, page_id_t, KeyComparator&gt;;using LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;; 一开始我没有注意，在对内部节点转换时，误将其 page_id_t 转为 ValueType，导致完全误解了整个项目的结构。 ⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Split 函数，来实现分裂。 叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（BufferPoolManager，Context），我将分裂函数的参数设计为 BPlusTreeInternalPage &amp;new_page，它会返回将插入到上层的 key，即新节点的第一个 key。 内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 array_[GetMinSize() - 1] 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 array_[0].first，因为分裂的时候复制了）。 ⑥ 同理，在内部页面和叶子页面类中可以添加 Insert 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 page_id 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为 const std::optional&lt;KeyType&gt; &amp;opt 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 Search 的实现，当 index ≥ 0 时返回 false，否则继续插入。 调试调试时可以先使用可视化网站查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（解决方案）： 123#!/bin/bashmake b_plus_tree_printer -j$(nproc){ echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; } | ./bin/b_plus_tree_printer 在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN - Drawing an empty tree 错误，原因是我们没有实现 b_plus_tree.cpp 中的 IsEmpty 函数。 补充① 如何使用 upper_bound 和 lower_bound（Java 选手表示踩了很多坑），可以看看 cppreference 的示例代码，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。 ② 测试时忽略 iterators 的测试。 ③ GetValue 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 BufferPoolManager 的实现）。 Task #2b - B+Tree Deletions实现① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 page_id。 ② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。 ③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 next_page_id_。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 DeletePage 操作，在 DeletePage 之前需要 Drop/Unpin 页面。有个疑问，DeletePage 之前 Drop 之后，如果有线程 Fetch，那么删除页面的操作就会失败。） 调试实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 pop_back() 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。 Task #3 - An Iterator for Leaf Scans基本上没有难度，遇到唯一的错误就是把 GetSize 打成了 GetMaxSize（因为用的自动补全）。 Task #4 - Concurrent Index① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 MixTest2，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 2 3，将 total_keys 修改为 1000，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。 ② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN - page not exist，发现是 BufferPoolManager 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 FetchPageBasic/Read/Write 返回 nullptr 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（但是重构了个寂寞，效率没变，难受啊） ③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 Fetch 和 Drop 的顺序就 OK。 (Optional) Leaderboard Task① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。 ② 优化暂时搁置。 Rank Submission Name read_qps write_qps total_qps 36 ALEX 200376 603 200980 测试结果Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。 Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。 12345678910#!/bin/bashmake b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)./test/b_plus_tree_insert_test./test/b_plus_tree_sequential_scale_test./test/b_plus_tree_delete_test./test/b_plus_tree_concurrent_testmake formatmake check-lintmake check-clang-tidy-p2make submit-p2 项目小结开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 MaxSize 和 MinSize，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 key。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧）","link":"/2023/09/29/Project%202%20-%20B+Tree/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"CMU 15-445","slug":"课程/CMU-15-445","link":"/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}