{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\%i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\%x=0\\)，因而也满足 \\(n\\%x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\%x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"},{"name":"竞赛","slug":"竞赛","link":"/tags/%E7%AB%9E%E8%B5%9B/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}