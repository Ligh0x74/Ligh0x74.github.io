{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"C++ Primer 第 1-7 章","text":"变量变量定义何为对象 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。一些人仅在与类有关的场景下才使用对象这个词。另一些人则把命名的对象和未命名的对象区分开来，他们把命名了的对象叫做变量。还有一些人把对象和值区分开来，其中对象指能被程序修改的数据，而值指只读的数据。 列表初始化 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。 默认初始化 定义于函数体外的内置类型的对象被初始化为 0，定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定。 值初始化 相当于 Java 的默认初始化。 变量声明为了支持分离式编译（separate complication），C++ 语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显示地初始化变量。 标识符C++ 标识符（identifier）由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。 作用域如果在内层作用域声明名字，它将隐藏外层作用域中声明的同名实体。（Java 不支持） 作用域操作符的使用：① 命名空间作用域（namespace::name）；② 全局作用域（::name）；③ 类作用域（class::name）。 基本类型算数类型 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8 位 wchar_t 宽字符 16 位 char16_t Unicode 字符 16 位 char32_t Unicode 字符 32 位 short 短整型 16 位 int 整型 16 位 long 长整型 32 位 long long 长整型 64 位 float 单精度浮点数 6 位有效数字 double 双精度浮点数 10 位有效数字 long double 扩展精度浮点数 10 位有效数字 带符号类型和无符号类型 int、short、long 和 long long 都是带符号类型，在类型名前添加 unsigned 就可以得到无符号类型。特别的，类型 unsigned int 可以缩写为 unsigned，类型 char 的符号由编译器决定。 字面值常量整型和浮点型字面值 整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。 十进制字面值的类型是能容纳其数值的 int、long 和 long long 中的尺寸最小者。 八进制和十六进制字面值的类型是能容纳其数值的 int、unsigned int、long、unsigned long、long long 和 unsigned long long 中的尺寸最小者。 浮点型字面值默认是 double 类型。 字符和字符串字面值 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符（’\\0’），因此字符串字面值的长度要比它的内容多 1。 复合类型一条声明语句由一个基本类型（base type）和紧随其后的一个声明符（declarator）列表组成。 引用引用并非对象，而是某个已存在对象的别名。（左值引用） 引用必须初始化 引用的初始值必须是对象 引用的类型需要和绑定的对象的类型匹配 指针 指针的类型需要和指向的对象的类型匹配 使用123int i = 1024;int &amp;r = i; // 引用int *p = &amp;i; // 指针 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。 const 关键字const 对象一旦创建其值就不能改变，所以 const 对象必须初始化。 对常量的引用（reference to const） 不能通过 const 引用修改绑定的对象，但是可以通过其他方式修改 const 引用可以绑定常量和非常量对象，甚至可以绑定到常量表达式，但是非常量引用不能绑定常量对象 指向常量的指针（pointer to const） 不能通过指向常量的指针修改指向的对象，但是可以通过其他方式修改 指向常量的指针可以指向常量和非常量对象，但是普通指针不能指向常量对象 常量指针（const pointer） 不能修改常量指针的指向，但是可以修改常量指针指向的对象 使用1234int i = 1024;const int &amp;r = i; // 对常量的引用const int *p1 = &amp;i; // 指向常量的指针int *const p2 = &amp;i; // 常量指针 顶层 const 和 底层 const用名词顶层 const 表示任意的对象是常量，而用名词底层 const 表示不能通过指针或引用修改指向或绑定的对象。 需要注意，指向常量的指针或绑定常量的引用，只是限定不能通过该指针或引用修改对象，而不保证对象一定是常量。 12345int i = 42;const int &amp;r = i; // 底层 constconst int j = 1024; // 顶层 constint *const p1 = &amp;i; // 顶层 constconst int *p2 = &amp;i; // 底层 const constexpr 和常量表达式常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。 可以将变量声明为 constexpr 类型以便由编译器验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。 处理类型类型别名12typedef double d;using ll = long long; 指针、常量和类型别名如果某个类型别名只带的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。 123typedef char *pstring;const pstring cstr = 0; // cstr 是指向 char 的常量指针const pstring *ps; // ps 指向的对象是指向 char 的常量指针 auto 类型说明符auto 让编译器通过初始值来推算变量的类型。 12auto i = 0, *p = &amp;i; // 正确auto sz = 0, pi = 3.14; // 错误：sz 和 pi 的基本类型不一致 复合类型、常量和 auto编译器推断出来的 auto 类型有时候和初始值的类型并不完全一样。（将会忽略顶层 const 和引用） 12345678int i = 42, &amp;r = i;const int j = 1024;auto a = j; // intauto b = r; // intconst auto c = j; // const intauto &amp;d = j; // const int &amp;auto e = &amp;i; // int *auto f = &amp;j; // const int * decltype 类型指示符decltype 让编译器通过表达式推断变量的类型，但是不会实际计算表达式的值。（推断出的类型是准确的） 1234const int i = 42, &amp;r = i;decltype(i) a = 0; // const intdecltype(r) b = i; // const int &amp;decltype((i)) c = i; // const int &amp; 头文件和预处理器为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件名字应与类的名字一样。头文件通常包含那些只能被定义一次的实体，如类、const 和 constexpr 变量等。头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。 预处理器会将 #include 标记替换为指定的头文件，因此如果重复包含头文件则可能会导致名字冲突。我们可以使用头文件保护符来防止重复包含： 12345678910#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string&gt;struct Sales_data { std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;};#endif 字符串、向量和数组命名空间的 using 声明通过 using 声明，可以在使用某个命名空间中的名字时无需添加命名空间前缀。注意，每个名字都需要独立的 using 声明，并且头文件不应该包含 using 声明，因为头文件的内容会拷贝到所有引用它的文件中去，由此可能会产生名字冲突。 12// using namespace::name; 标椎库类型 string标准库类型 string 表示可变长的字符序列，使用 string 类型必须包含 string 头文件。 触发 getline 函数返回的那个换行符实际上被丢弃了，得到的 string 对象中并不包含该换行符。 当把 string 对象和字符字面值以及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是 string。因为该加法实际上是 string 类重载的加法，两个字面值是不能相加的。 注意，字符串字面值和 string 是不同的类型。 标准库类型 vector标准库类型 vector 表示对象的集合，使用 vector 类型必须包含 vector 头文件。 vector 是一个类模板，模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据目标创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。 迭代器begin 成员返回指向第一个元素的迭代器，end 成员返回指向尾后元素的迭代器。 使用 iterator 和 const_iterator 来表示迭代器的类型，iterator 对象可读可写，const_iterator 对象可读不可写（类似常量指针）。begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量，返回 const_iterator；如果对象不是常量，返回 iterator。或者，我们可以使用 cbegin 和 cend 成员指定返回 const_iterator 类型。 数组数组中元素的个数也属于数组类型的一部分，编译时应该是已知的。 当使用字符串字面值初始化字符数组时，会将空字符也拷贝到字符数组中。 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。 123456char a[] = &quot;C++&quot;; // {'C', '+', '+', '\\0'}char *b[4]; // b 是含有 4 个 int * 的数组char &amp;c[4] = a; // 错误：不存在引用的数组char (*d)[4] = &amp;a; // d 指向含有 4 个 int 的数组char (&amp;e)[4] = a; // e 引用含有 4 个 int 的数组 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 在使用数组下标的时候，通常将其定义为 size_t 类型。size_t 是一种机器相关的无符号类型，它被设计的足够大以便能够表示内存中任意对象的大小。在 cstddef 头文件中定义了 size_t 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 语言版本。 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。使用 auto 推断数组得到指针类型，使用 decltype 推断数组得到数组类型。 可以使用标椎库中的 begin 和 end 函数得到指向数组首元素的指针和指向数组尾后元素的指针，使用方法是将数组作为参数传递给函数。 多维数组要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。因为如果不是引用类型，则编译器将其推断为指针类型，那么内层循环就相当于使用范围 for 遍历指针类型，显然不合法。 表达式优先级规定了运算对象的组合方式，但是没有说明运算对象按照说明顺序求值。对于那些没有指定执行顺序的运算符说来，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。 进行比较运算时除非比较对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象。 sizeof 运算符返回一个表达式或一个类型名字所占的字节数。 命名的强制类型转换：static_cast、const_cast、reinterpret_cast 和 dynamic_cast。 运算符优先级：https://en.cppreference.com/w/cpp/language/operator_precedence。 函数函数基础可以将局部变量定义成 static 类型，称为局部静态对象。如果局部静态对象没有显示的初始化，它将执行值初始化。 分离式编译分别编译每个源文件为对象文件，然后将所有对象文件链接在一起形成可执行文件。如果我们修改了其中一个源文件，那么只需重新编译那个改动的文件。 参数传递传值会进行对象的拷贝，传引用实际上是为对象取别名。 返回类型和 return 语句不要返回局部对象的指针或引用，因为函数返回后它占用的空间将被释放。 12auto fun(int i) -&gt; int (*)[10]; // 尾置返回类型 函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。因为顶层 const 不影响传入函数的对象，所以不能同时定义形参的区别只是有无顶层 const 的函数。 特殊用途语言特性默认实参 如果某个形参有默认值，那么它后面的所有形参都必须有默认值。 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。 内联函数和 constexpr 函数 将函数指定为内联函数（inline），就是请求编译器将函数在每个调用点上内联地展开，但是编译器并不一定执行。 constexpr 函数的返回类型和形参类型必须是字面值类型，而且函数体中有且仅有一条 return 语句。 调试帮助 assert 宏定义在 cassert 头文件中，当它使用的表达式为假时，输出信息并终止程序的执行。如果定义了 NDEBUG 宏，则 assert 不会执行。 函数指针函数指针指向的是函数而非对象，函数的类型由返回值和形参类型决定，而与函数名无关。 1234567int add(int a, int b);int (*pf)(int, int) = nullptr;pf = add; // 正确pf = &amp;add; // 正确int c = pf(1, 2); // 正确c = (*pf)(1, 2); // 正确 与数组类似，使用函数作为形参实际上使用的是函数指针，两种声明方式都可以。但是如果使用函数作为返回类型，则必须指定为函数指针，而不能是函数。 类类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义。 如果不主动定义拷贝、赋值和析构操作，则编译器会生成它们，默认对对象的每个成员执行相关操作。 this 指针成员函数通过一个名为 this 的隐式参数访问调用它的那个对象，this 指针默认是常量指针。可以通过将 const 关键字放在成员函数的参数列表之后表示 this 是一个指向常量的常量指针，这样的函数被称为常量成员函数。常量对象只能调用常量成员函数。 构造函数在自定义构造函数后，如果还需要默认的构造函数，可以在参数列表后面加上 = default 来要求编译器生成。注意，使用默认构造函数初始化对象时不需要加上圆括号，如果加上圆括号则表示声明一个函数。 如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。本质上就是要注意区别：构造函数初始值列表执行初始化操作，构造函数内部执行的是赋值操作。（Java 可以在构造函数内初始化常量） 成员的初始化顺序与它们在类定义中出现的顺序一致，与构造函数初始值列表中的顺序没有关系，所以如果在初始值列表中用某个成员初始化其他成员要特别注意顺序问题。 委托构造函数：可以通过成员初始值列表调用其他构造函数。（类似 Java 中的 this 调用其他构造函数） 能通过一个实参调用的构造函数，它的参数类型的对象可以隐式转换为类类型，可以在类内部将构造函数声明为 explicit 来抑制隐式转换。（注意对单实参调用的构造函数才有效，并且只能在类内部使用） 静态成员 static 关键字只能出现在类内部 static 成员函数不能声明为 const 函数 static 数据成员只能在类内部声明，在类外部定义和初始化（静态常量数据成员除外） 访问控制class 的成员默认是 private 的，struct 的成员默认是 public 的。 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想将一个函数作为友元，只需要在类的内部添加以 friend 关键字开头的函数声明语句。一般来说，最好在类定义开始或结束前的位置集中声明友元。 类内部的友元声明仅仅指定了访问的权限，如果我们希望类的用户能够调用某个友元函数，还需要额外对函数进行声明。一般将类的定义和友元的声明（类的外部）放在同一个头文件中。 其他特性由类定义的类型别名也存在访问限制，并且和普通成员不同，类型别名的定义需要出现在使用它的代码之前。 定义在类内部的成员函数默认是内联的。定义在类外部的成员函数如果要声明为内联函数，可以在声明或定义的地方添加 inline 关键字，最好只在定义的地方（类外部）添加关键字，这样可以使类更容易理解。 可以使用 mutable 关键字修饰成员变量表示它是可变的，这样即使在 const 成员函数内也可以修改该可变成员的值。 const 函数和非 const 函数可以视作重载函数，因为常量对象不能调用非常量函数。 当成员函数定义在类的外部时，即使在函数名前添加类的作用域，该函数的返回类型总是在类的作用域之外。此时，如果返回类型是类的成员，那么需要在返回类型前也加上类的作用域。 编译器处理类的定义的步骤：① 编译成员的声明；② 直到类全部可见后才编译函数体。","link":"/2023/08/12/C++%20Primer%20%E7%AC%AC%201-7%20%E7%AB%A0/"},{"title":"Lecture #01: Course Introduction and the Relational Model","text":"此处可以查看课程幻灯片和笔记，以下内容为课前阅读 Database System Concepts (7th Edition) 的笔记。 Chapter 1: Introduction数据库的两种使用模式：① 在线事务处理（OLTP），② 数据分析（data analytics）。 使用文件处理系统（file-processing system）存储数据的缺点： 数据冗余，相同数据可能存储在不同文件；数据不一致，修改重复数据时没有全部修改。 访问困难，需要根据需求的变化，修改相应的数据访问程序。 数据隔离，访问存储在不同文件的数据需要编写复杂的程序。 数据的完整性（Integrity）难以保证，当添加一致性约束（consistency constraints）时很难修改程序来执行该约束。 无法保证原子性，当系统发生故障时，不能将数据恢复为一致的状态。 很难进行数据访问权限的约束，因此安全性难以保证。 数据模型（data model）： 定义：用于描述数据、数据关系、数据语义和一致性约束的概念工具的集合。 分类：关系模型（Relational Model）、实体关系模型（Entity-Relationship Model）、半结构化数据模型（Semi-structured Data Model）和基于对象的数据模型（Object-Based Data Model）。 数据抽象（data abstraction）的级别： 物理级别：描述数据的存储方式。 逻辑级别：描述存储什么数据，以及数据之间的关系。 视图级别：描述数据库的一部分。 实例（instance）：在特定时刻存储在数据库中的信息集合。 模式（scheme）：数据库的总体设计，分为物理模式、逻辑模式和视图模式。 数据定义语言（DDL）：指定数据库的模式。 数据操纵语言（DML）：表达数据库的查询和更新。分为 Procedural DMLs 和 Declarative DMLs，其中 Procedural DMLs 不仅要求用户指定需要什么数据，还要求指定如何获取这些数据。 数据库系统的功能组件： 存储管理器： 组成：授权和完整性管理器、事务管理、文件管理和缓存管理。 实现：数据文件，存储数据库；数据字典，存储元数据；索引，提供对数据的快速访问。 查询处理器： 组成：DDL 解释器、DML 编译器和查询执行引擎。 事务管理器： 组成：恢复管理器和并发控制管理器。 数据库系统的体系结构：集中式数据库，并行式数据库和分布式数据库。 Chapter 2: Introduction to the Relational Model在关系模型中，表被称为关系（relation），行被称为元组（tuple），列被称为属性（attribute）。 关系的模式，表示关系的逻辑设计；关系的实例，表示关系在某个时刻的内容。 关系的超键（superkey）是唯一标识关系中元组的属性集合，最小的超键被称为候选键（candidate key），数据库设计者选择一个候选键作为主键（primary key）。 从关系 \\(r_{1}\\) 的属性集合 \\(A\\) 到关系 \\(r_{2}\\) 的主键 \\(B\\) 的外键约束（foreign-key constraint）表明， \\(r_{1}\\) 中每个元组的 \\(A\\) 值必须也是 \\(r_{2}\\) 中某个元组的 \\(B\\) 值。关系 \\(r_{1}\\) 称为引用关系（referencing relation），关系 \\(r_{2}\\) 称为被引用关系（referenced relation）。在外键约束中，被引用的属性集合必须是被引用关系的主键，更一般的引用完整性约束（referential integrity constraint）不作此要求。 查询语言（query language）的分类：命令式（imperative），函数式（functional）和声明式（declarative）。 关系代数（Relational Algebra）：Select（\\(\\sigma\\)）、Project（\\(\\Pi\\)）、Cartesian-Product（\\(\\times\\)）、Join（\\(\\Join\\)）、Union（\\(\\cup\\)）、Intersection（\\(\\cap\\)）、Difference（\\(-\\)）、Assignment（\\(\\leftarrow\\)）、Rename（\\(\\rho\\)）。 Chapter 27: Formal-Relational Query LanguagesTODO","link":"/2023/08/12/Lecture%2001%20Course%20Introduction%20and%20the%20Relational%20Model/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"CMU 15-445","slug":"课程/CMU-15-445","link":"/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"},{"name":"阅读","slug":"阅读","link":"/categories/%E9%98%85%E8%AF%BB/"},{"name":"C++ Primer","slug":"阅读/C-Primer","link":"/categories/%E9%98%85%E8%AF%BB/C-Primer/"},{"name":"Database System Concepts","slug":"阅读/Database-System-Concepts","link":"/categories/%E9%98%85%E8%AF%BB/Database-System-Concepts/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}