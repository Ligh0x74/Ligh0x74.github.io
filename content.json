{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 893 (Div. 2)","text":"Buttons优先选择公共按钮，当且仅当先手的按钮数量大于后手的按钮数量时，先手者胜。 12345public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (a + c % 2 &gt; b) io.println(&quot;First&quot;); else io.println(&quot;Second&quot;);} The Walkway模拟题，特别需要注意头尾的边界处理，加上哨兵真的会方便很多。可以假设位置 \\(1-d\\) 和位置 \\(n+1\\) 有卖家，这样就不用特判，可以直接处理！！！ 123456789101112131415161718192021222324252627public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] s = new int[m + 2]; for (int i = 1; i &lt;= m; i++) { s[i] = io.nextInt(); } s[0] = 1 - d; s[m + 1] = n + 1; int ans = m - 1, delta = Integer.MAX_VALUE, cnt = 0; for (int i = 1; i &lt;= m; i++) { int A = (s[i] - s[i - 1] - 1) / d; int B = (s[i + 1] - s[i] - 1) / d; int C = (s[i + 1] - s[i - 1] - 1) / d; int D = C - A - B; if (D &lt; delta) { delta = D; cnt = 1; } else if (D == delta) { cnt++; } ans += A; } ans += (s[m + 1] - s[m] - 1) / d + delta - 1; io.println(ans + &quot; &quot; + cnt);} Yet Another Permutation Problem构造题，首先需要发现什么公约数不可能出现，很明显不可能得到 \\(d_{i}=\\gcd (a_{i},a_{(i\\bmod n)+1})&gt; \\lfloor \\frac{n}{2}\\rfloor\\)。然后考虑所有小于等于 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 的数是否能被包含，可以发现对于每个 \\(a_{i}=x\\leq \\lfloor \\frac{n}{2}\\rfloor\\) 总有 \\(a_{(i\\bmod n)+1}=2\\cdot x\\leq n\\)，所以我们可以枚举所有奇数乘以二的幂来构造答案。 12345678910111213public static void solve() { int n = io.nextInt(), idx = 0; int[] ans = new int[n]; for (int i = 1; i &lt;= n; i += 2) { for (int j = i; j &lt;= n; j *= 2) { ans[idx++] = j; } } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} Trees and Segments难以描述，看代码吧，调试半天。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[][] prefix = new int[n + 1][k + 1]; int[][] suffix = new int[n + 1][k + 1]; // 枚举可以在 k 次操作内变为全 0 的子数组，并将其长度记录到所属的前后缀中 for (int i = 0; i &lt; n; i++) { int cnt1 = 0; for (int j = i; j &lt; n; j++) { cnt1 += s[j] - '0'; if (cnt1 &gt; k) break; prefix[j + 1][cnt1] = Math.max(prefix[j + 1][cnt1], j - i + 1); suffix[i][cnt1] = Math.max(suffix[i][cnt1], j - i + 1); } } // 在前缀 [0, i] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= k; j++) { prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i][j]); if (j &gt; 0) prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i + 1][j - 1]); } } // 在后缀 [i, n - 1] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= k; j++) { suffix[i][j] = Math.max(suffix[i][j], suffix[i + 1][j]); if (j &gt; 0) suffix[i][j] = Math.max(suffix[i][j], suffix[i][j - 1]); } } // 枚举连续 1 的起点和终点，并记录该连续 1 的长度对应的连续 0 的最长长度（注意包含长度为 0 的情况） int[] max0by1 = new int[n + 1]; Arrays.fill(max0by1, -1); max0by1[0] = suffix[0][k]; for (int i = 0; i &lt; n; i++) { int cnt0 = 0; for (int j = i; j &lt; n; j++) { cnt0 += (s[j] - '0') ^ 1; if (cnt0 &gt; k) break; max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], prefix[i][k - cnt0]); max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], suffix[j + 1][k - cnt0]); } } // 计算答案 int[] ans = new int[n + 1]; for (int a = 1; a &lt;= n; a++) { for (int i = 0; i &lt;= n; i++) { if (max0by1[i] == -1) continue; ans[a] = Math.max(ans[a], i + max0by1[i] * a); } } for (int i = 1; i &lt;= n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}","link":"/2023/08/16/Codeforces%20Round%20893%20(Div.%202)/"},{"title":"第 111 场力扣夜喵双周赛","text":"统计和小于目标的下标对数目使用排序 + 双指针优化。如果 \\(nums[lo]+nums[hi]&lt;target\\)，那么 \\([lo+1,hi]\\) 范围内的数都能与 \\(nums[lo]\\) 组成对，\\(lo\\) 加一；反之，\\([lo,hi-1]\\) 范围内的数都不能与 \\(nums[hi]\\) 组成对，\\(hi\\) 减一。 Java 123456789101112131415class Solution { public int countPairs(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int lo = 0, hi = nums.size() - 1, ans = 0; while (lo &lt; hi) { if (nums.get(lo) + nums.get(hi) &lt; target) { ans += hi - lo; lo++; } else { hi--; } } return ans; }} C++ 12345678910111213141516class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans = 0; for (int i = 0, j = n - 1; i &lt; j; ) { if (nums[i] + nums[j] &lt; target) { ans += j - i; i++; } else { j--; } } return ans; }}; 循环增长使字符串子序列等于另一个字符串贪心取就行。 Java 1234567891011class Solution { public boolean canMakeSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1.charAt(i) == str2.charAt(j) || (str1.charAt(i) + 1 - 'a') % 26 == str2.charAt(j) - 'a') { j++; } } return j == n; }} C++ 123456789101112class Solution {public: bool canMakeSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1[i] == str2[j] || (str1[i] + 1 - 'a') % 26 == str2[j] - 'a') { j++; } } return j == n; }}; 将三个组排序要将 \\(nums\\) 变为美丽数组，就要将 \\(nums\\) 变为非递减的形式，所以问题就变为求最长非递减子序列。 Java 动态规划： 12345678910111213141516class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), ans = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (nums.get(i) &gt;= nums.get(j)) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } return n - ans; }} 贪心 + 二分： 1234567891011121314151617class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), maxLen = 0; int[] aux = new int[n]; for (int x : nums) { int lo = 0, hi = maxLen - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (aux[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } aux[lo] = x; if (lo == maxLen) maxLen++; } return n - maxLen; }} 状态机 DP： 有点妙啊，\\(dp[i][j]\\) 表示将子数组 \\([0,i]\\) 变为以 \\([1,j]\\) 为结尾的美丽数组所需的最小修改次数，然后可以空间优化。 1234567891011class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int[] dp = {Integer.MAX_VALUE, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = Math.min(dp[i - 1], dp[i] + (x == i ? 0 : 1)); } } return dp[3]; }} C++ 123456789101112class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { int dp[4] = {INT_MAX, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = min(dp[i - 1], dp[i] + (x != i)); } } return dp[3]; }}; 范围中美丽整数的数目经典数位 DP 没什么好说的，主要是记忆化取模，边乘边取模。 Java 1234567891011121314151617181920212223242526class Solution { public int numberOfBeautifulIntegers(int low, int high, int k) { return f(0, 10, 0, true, false, high + &quot;&quot;, k, new Integer[10][20][k]) - f(0, 10, 0, true, false, low - 1 + &quot;&quot;, k, new Integer[10][20][k]); } private int f(int i, int diff, int mod, boolean isLimit, boolean isNum, String s, int k, Integer[][][] dp) { if (i == s.length()) { return isNum &amp;&amp; diff == 10 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff][mod] != null) { return dp[i][diff][mod]; } int res = 0; if (!isNum) res += f(i + 1, diff, mod, false, false, s, k, dp); int lo = isNum ? 0 : 1, hi = isLimit ? s.charAt(i) - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += f(i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true, s, k, dp); } if (!isLimit &amp;&amp; isNum) { dp[i][diff][mod] = res; } return res; }} C++ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int numberOfBeautifulIntegers(int low, int high, int k) { string s; const int BASE = 10; int dp[10][20][k]; auto f = [&amp;](auto self, int i, int diff, int mod, bool isLimit, bool isNum) { if (i == s.size()) { return isNum &amp;&amp; diff == 0 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff + BASE][mod] != -1) { return dp[i][diff + BASE][mod]; } int res = 0; if (!isNum) res += self(self, i + 1, diff, mod, false, false); int lo = isNum ? 0 : 1, hi = isLimit ? s[i] - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += self(self, i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true); } if (!isLimit &amp;&amp; isNum) dp[i][diff + BASE][mod] = res; return res; }; auto calc = [&amp;](int x) { s = to_string(x); memset(dp, -1, sizeof(dp)); return f(f, 0, 0, 0, true, false); }; return calc(high) - calc(low - 1); }};","link":"/2023/08/21/%E7%AC%AC%20111%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 359 场力扣周赛","text":"判别首字母缩略词Java 123456789101112class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { int n = words.size(), m = s.length(); if (n != m) return false; for (int i = 0; i &lt; n; i++) { if (words.get(i).charAt(0) != s.charAt(i)) { return false; } } return true; }} C++ 12345678910111213class Solution {public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) { int m = words.size(), n = s.size(); if (m != n) return false; for (int i = 0; i &lt; n; i++) { if (words[i][0] != s[i]) { return false; } } return true; }}; k-avoiding 数组的最小总和贪心。 Java 123456class Solution { public int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }} C++ 1234567class Solution {public: int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }}; 销售利润最大化不从动态规划的角度思考，我首先用的是对左端点排序。如果用动态规划，那么根据转移方程就会对右端点排序，处理方式也比对左端点排序简单一些。还可以不排序做，使用桶存储相同 \\(end\\) 的 \\(offer\\)，分别处理每个桶。 Java 1234567891011121314class Solution { public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) { Collections.sort(offers, (a, b) -&gt; a.get(1) - b.get(1)); offers.add(List.of(n - 1, n - 1, 0)); int m = offers.size(), i = 0; int[] leftMax = new int[n + 1]; for (var offer : offers) { int s = offer.get(0), e = offer.get(1), g = offer.get(2); for (; i &lt;= e; i++) leftMax[i + 1] = leftMax[i]; leftMax[e + 1] = Math.max(leftMax[e + 1], leftMax[s] + g); } return leftMax[n]; }} C++ 1234567891011121314151617class Solution {public: int maximizeTheProfit(int n, vector&lt;vector&lt;int&gt;&gt;&amp; offers) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; groups(n); for (auto &amp;offer : offers) { groups[offer[1]].emplace_back(offer[0], offer[2]); } vector&lt;int&gt; f(n + 1); for (int end = 0; end &lt; n; end++) { f[end + 1] = f[end]; for (auto &amp;[start, gold] : groups[end]) { f[end + 1] = max(f[end + 1], f[start] + gold); } } return f[n]; }}; 找出最长等值子数组Java 滑动窗口： 12345678910111213141516171819class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int lo = 0, hi = 0, ans = 0; while (hi &lt; n) { map.merge(nums.get(hi++), 1, Integer::sum); if (hi - lo - map.get(nums.get(lo)) &gt; k) { map.merge(nums.get(lo++), -1, Integer::sum); } ans = Math.max(ans, map.get(nums.get(lo))); } while (lo + 1 &lt; n) { map.merge(nums.get(lo++), -1, Integer::sum); ans = Math.max(ans, map.get(nums.get(lo))); } return ans; }} 滑动窗口（优化）： 优化一：观察到 \\(1\\leq nums[i]\\leq nums.lenth\\)，所以可以用数组模拟哈希表。 优化二：滑动窗口直接枚举右端点，这样可以枚举到所有情况。但是如何保证删除的元素数量小于等于 \\(k\\) 呢？当左端点的值 \\(nums[i]\\) 不能构成等值数组，则将左端点右移。为什么这样可以保证？当 \\(nums[i]\\neq nums[j]\\) 时，移动左端点不影响答案；当 \\(nums[i]=nums[j]\\) 时，移动左端点可以保证删除的元素数量小于等于 \\(k\\)。 1234567891011121314class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; int[] map = new int[n + 1]; for (int i = 0, j = 0; j &lt; n; j++) { map[nums.get(j)]++; if (j - i + 1 - map[nums.get(i)] &gt; k) { map[nums.get(i++)]--; } ans = Math.max(ans, map[nums.get(j)]); } return ans; }} C++ 分组 + 双指针： 123456789101112131415161718192021class Solution {public: int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); for (int i = 0; i &lt; n; i++) { pos[nums[i]].push_back(i); } for (auto &amp;ps : pos) { int left = 0; for (int right = 0; right &lt; ps.size(); right++) { while (ps[right] - ps[left] - right + left &gt; k) { left++; } ans = max(ans, right - left + 1); } } return ans; }};","link":"/2023/08/21/%E7%AC%AC%20359%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 315","text":"tcdr模拟。 Java 123456789public static void solve() { String s = io.next(); var sb = new StringBuilder(); Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); for (char c : s.toCharArray()) { if (!set.contains(c)) sb.append(c); } io.println(sb.toString());} C++ 12345678void solve() { string s; cin &gt;&gt; s; s.erase(remove_if(s.begin(), s.end(), [&amp;](char c) { return set{'a', 'e', 'i', 'o', 'u'}.count(c); }), s.end()); cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;} The Middle Day模拟。 Java 1234567891011121314151617public static void solve() { int m = io.nextInt(); int[] d = new int[m]; int tot = 0; for (int i = 0; i &lt; m; i++) { d[i] = io.nextInt(); tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { io.println(i + 1 + &quot; &quot; + mid); return; } mid -= d[i]; }} C++ 123456789101112131415161718void solve() { int m; cin &gt;&gt; m; int tot = 0; vector&lt;int&gt; d(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; d[i]; tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot;\\n&quot;; return; } mid -= d[i]; }} Flavors模拟。 Java 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] buckets = new List[n + 1]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int f = io.nextInt(), s = io.nextInt(); buckets[f].add(s); } int ans = 0, max1 = 0, max2 = 0; for (var bucket : buckets) { if (bucket.isEmpty()) continue; Collections.sort(bucket, (a, b) -&gt; b - a); int a = bucket.get(0); if (a &gt; max1) { max2 = max1; max1 = a; } else if (a &gt; max2) { max2 = a; } if (bucket.size() &lt; 2) continue; int b = bucket.get(1); ans = Math.max(ans, a + b / 2); } ans = Math.max(ans, max1 + max2); io.println(ans);} C++ 12345678910111213141516171819202122232425void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; buckets(n + 1); for (int i = 0; i &lt; n; i++) { int f, s; cin &gt;&gt; f &gt;&gt; s; buckets[f].push_back(s); } int ans = 0, max1 = 0, max2 = 0; for (auto &amp;bucket : buckets) { if (bucket.empty()) continue; nth_element(bucket.begin(), bucket.begin() + 1, bucket.end(), greater()); if (bucket[0] &gt; max1) { max2 = max1; max1 = bucket[0]; } else if (bucket[0] &gt; max2) { max2 = bucket[0]; } if (bucket.size() &lt; 2) continue; ans = max(ans, bucket[0] + bucket[1] / 2); } ans = max(ans, max1 + max2); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} Magical Cookies算是暴力吧。首先最多执行 \\(m+n\\) 次操作，然后每次操作将所有行和列遍历，判断是否可以标记。如果不优化，那么遍历的复杂度是 \\(O(mn)\\)，总时间复杂度就是 \\(O(mn(m+n))\\)，会超时。可以维护剩余的行数 \\(r\\) 和剩余的列数 \\(c\\)，那么如果某行的某颜色的数量等于列数，那么就说明可以标记该行，列同理。这样我们就可以只维护行列中的每个颜色有多少饼干，而不需要维护位置关系，从而将遍历的时间复杂度降为 \\(O(26(m+n))\\)。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] arr = new String[m]; for (int i = 0; i &lt; m; i++) { arr[i] = io.next(); } int[][] row = new int[m][26]; int[][] col = new int[n][26]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { row[i][arr[i].charAt(j) - 'a']++; col[j][arr[i].charAt(j) - 'a']++; } } int r = m, c = n; boolean[] vr = new boolean[m]; boolean[] vc = new boolean[n]; for (int k = 0; k &lt; m + n; k++) { List&lt;int[]&gt; mr = new ArrayList&lt;&gt;(); List&lt;int[]&gt; mc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { if (vr[i]) continue; for (int j = 0; j &lt; 26; j++) { if (row[i][j] == c &amp;&amp; c &gt;= 2) { mr.add(new int[]{i, j}); } } } for (int i = 0; i &lt; n; i++) { if (vc[i]) continue; for (int j = 0; j &lt; 26; j++) { if (col[i][j] == r &amp;&amp; r &gt;= 2) { mc.add(new int[]{i, j}); } } } for (int[] p : mr) { r--; vr[p[0]] = true; for (int i = 0; i &lt; n; i++) { col[i][p[1]]--; } } for (int[] p : mc) { c--; vc[p[0]] = true; for (int i = 0; i &lt; m; i++) { row[i][p[1]]--; } } } io.println(r * c);} Prerequisites首先找到第 \\(1\\) 本书的所有前置书，然后对所有书进行拓扑排序，将之前找到的前置书按拓扑排序的倒序打印即可。或者直接 DFS。。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(); int[] indegree = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); for (int j = 0; j &lt; c; j++) { int q = io.nextInt() - 1; g[i].add(q); indegree[q]++; } } boolean[] mark = new boolean[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty()) { int x = q.poll(); for (int y : g[x]) { if (mark[y]) continue; mark[y] = true; q.offer(y); } } for (int i = 0; i &lt; n; i++) { if (indegree[i] == 0) { q.offer(i); } } Deque&lt;Integer&gt; ans = new ArrayDeque&lt;&gt;(); while (!q.isEmpty()) { int x = q.poll(); if (mark[x]) ans.push(x); for (int y : g[x]) { if (--indegree[y] == 0) { q.offer(y); } } } while (!ans.isEmpty()) io.print(ans.pop() + 1 + &quot; &quot;); io.println();} C++ 123456789101112131415161718192021222324252627282930313233void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; j++) { int q; cin &gt;&gt; q; q--; adj[i].push_back(q); } } vector&lt;bool&gt; mark(n); auto dfs = [&amp;](auto self, int x) { if (mark[x]) { return; } for (auto y : adj[x]) { self(self, y); } mark[x] = true; if (x != 0) { std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; } }; dfs(dfs, 0); cout &lt;&lt; &quot;\\n&quot;;} Shortcuts动态规划，调试好久。。如果所有点都选，那么答案最多为 \\(10^{9}\\)，所以可以确定不选的点不会超过 \\(30\\)。然后定义状态 \\(dp[i][j]\\) 表示到达第 \\(i\\) 个点并且总共跳过 \\(j\\) 个点的最短距离。如何想到定义该状态呢，因为答案和具体选哪几个点无关，只和最短距离以及跳过多少个点有关，大概是这样吧。 Java 1234567891011121314151617181920212223242526272829public static void solve() { int c = 30; int n = io.nextInt(); int[] x = new int[n]; int[] y = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } double[][] dp = new double[n][c]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][0] = 0; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; c; j++) { for (int k = i + 1; k &lt; n &amp;&amp; k - i - 1 + j &lt; c; k++) { int nj = j + k - i - 1; dp[k][nj] = Math.min(dp[k][nj], dp[i][j] + Math.sqrt((x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]))); } } } double ans = Integer.MAX_VALUE; for (int i = 0; i &lt; c; i++) { ans = Math.min(ans, dp[n - 1][i] + (i == 0 ? 0 : 1 &lt;&lt; (i - 1))); } io.println(ans);}","link":"/2023/08/21/AtCoder%20Beginner%20Contest%20315/"},{"title":"Educational Codeforces Round 153 (Rated for Div. 2)","text":"Not a Substring构造题。如果 \\(s\\) 中存在连续相同的括号，则可以构造交替出现的括号；如果 \\(s\\) 是交替出现的括号，那么就构造连续的括号，此时包含的唯一交替的括号就是 \\(()\\)，特判一下即可。 123456789101112131415161718public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = false; for (int i = 1; i &lt; n; i++) { if (s[i] == s[i - 1]) { ok = true; break; } } if (new String(s).equals(&quot;()&quot;)) { io.println(&quot;NO&quot;); return; } io.println(&quot;YES&quot;); if (ok) io.println(&quot;()&quot;.repeat(n)); else io.println(&quot;(&quot;.repeat(n) + &quot;)&quot;.repeat(n));} Fancy Coins数学题。假设最终使用 \\(x\\) 枚价值为 \\(1\\) 的硬币，\\(y\\) 枚价值为 \\(k\\) 的硬币。如果 \\(x\\) 大于等于 \\(k\\)，我们总是将其合成为价值为 \\(k\\) 的硬币，所以可以保证 \\(x\\) 小于 \\(k\\)。显然 \\(x=m\\bmod k\\)，\\(y=\\frac{m}{k}\\)。那么需要补充多少花色硬币呢？易知，需要补充 \\(\\max(0,x-a_{1})\\) 个价值为 \\(1\\) 的花色硬币，和 \\(\\max (0,y-a_{k}-\\max (0,\\frac{a_{1}-x}{k}))\\) 个价值为 \\(k\\) 的花色硬币。 12345public static void solve() { int m = io.nextInt(), k = io.nextInt(), a1 = io.nextInt(), ak = io.nextInt(); int ans = Math.max(0, m % k - a1) + Math.max(0, m / k - ak - Math.max(0, a1 - m % k) / k); io.println(ans);} Game on Permutation一开始的想法是，如果某个元素左边恰好只有一个小于它的元素，那么该位置就是胜位。然而暴力找每个位置左边比它小的元素个数的时间复杂度是 \\(O(n^{2})\\)，赛时就不知道怎么优化。其实我们可以知道，给定一个序列，胜位是固定不变的。所以可以考虑维护左边的最小元素（表示下一步是否可以下棋）和最小的胜位（如果大于最小胜位，则当前位必输），然后就可以很方便的模拟出答案。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] p = new int[n]; int ans = 0, min = n + 1, minWin = n + 1; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); if (min &lt; p[i] &amp;&amp; p[i] &lt;= minWin) { ans++; minWin = Math.min(minWin, p[i]); } min = Math.min(min, p[i]); } io.println(ans);} Balanced String不会不会。。o(╥﹏╥)o","link":"/2023/08/21/Educational%20Codeforces%20Round%20153%20(Rated%20for%20Div.%202)/"},{"title":"Project #0 - C++ Primer","text":"项目准备项目地址：Project #0 - C++ Primer。 准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。 Task #1 - Copy-On-Write Trie实现Get 函数 没有什么特别需要注意的，实现比较简单。 实现逻辑： 如果 root_ == nullptr 为真，则返回 nullptr。 沿着 Trie 树遍历，如果节点不存在，则返回 nullptr。 如果目标节点不是 TrieNodeWithValue 类型，则返回 nullptr。 否则，返回目标节点的值。 Put 函数 一开始比较疑惑的点是，智能指针存储的都是 const 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？ 其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 const 指针就能做到。 本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 key.empty() 和 root_ == nullptr。 实现逻辑： 如果 key.empty() 为真： 如果 root_ == nullptr 为真，则使用 value​ 构造 Trie 树并返回。 否则，使用 root_-&gt;children_ 和 value 构造 Trie 树并返回。 根据 root_ == nullptr 条件初始化新 Trie 树的 root。 沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）： 如果克隆完所有字符，则返回新 Trie 树。 否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。 Remove 函数 需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意： ① 节点不包含值需要转换为 TrieNode 类型，也就是说拷贝的时候需要调用 TrieNode::Clone()。 ② 如果节点满足 children_.empty() &amp;&amp; !is_value_node_ 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 erase 父节点中 map 的 key。 实现逻辑： 如果 root_ == nullptr 为真，则返回 *this。 如果 key.empty() 为真，则调用 root_-&gt;TrieNode::Clone() 克隆，并返回新 Trie 树。 沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 *this。 将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。 否则，依次克隆栈中的元素，然后返回新 Trie 树。 补充C++ 因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。 ① 使用 at 访问 const map 对象，因为 [] 运算符可能会自动添加键值。 123const map&lt;int,int&gt; m;cout &lt;&lt; m[1024]; // 错误，No viable overloaded operator[] for type 'const map&lt;int, int&gt;'cout &lt;&lt; m.at(1024); // 正确 ② = 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。 12345map&lt;int,int&gt; m;m[1024] = 1024;auto n = m;n[1024] = 2048;cout &lt;&lt; m[1024]; // 输出：1024 ③ 在 Java 中只要是对象就可以和 null 比较，而 C++ 中只有指针可以和 nullptr 比较。 GDB ① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击此处产生该问题的原因，以及相应的解决方案告诉我下载 libstdc++6-dbgsym，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。 ② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以在此查看该课程提供的 GDB 教程。以及可以阅读：GDB Tutorial: Finding Segmentation Faults。 ③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。 CMake 项目推荐使用 clang-14 作为编译器，解决方案在此。 Task #2 - Concurrent Key-Value Store实现因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 std::mutex 即可。读操作在获取 root_ 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 write_lock_ 上锁。Put 时记得使用 std::move()，因为值可能是不可复制的。 补充① 关于线程和锁的知识，推荐阅读 CS110 Lecture 10: Threads and Mutexes。 ② C++ 有个复制省略（Copy elision）的优化。 ③ 关于 C++ 模板的 FAQ、template 关键字的讨论 和 Dependent names 的定义。（好复杂啊）之所以查这些内容，是因为 CLion 给我生成了不同的表达式： 123auto value = root.template Get&lt;T&gt;(key);root = root.template Put(key, std::move(value));root = root.Remove(key); 以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 &lt;&gt; 来指定类型。然后何时使用 template 没怎么弄明白。 Task #3 - Debugging实现挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 Put 时打断点调试的，应该差不多吧。 补充无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：/usr/bin/ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案在此。 Task #4 - SQL String Functions实现文件的路径：./src/include/execution/expressions 和 ./src/planner/plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 std::tolower 或许有一些注意事项。注册函数时，需要保证参数是有效的，即参数只有一个并且是 VARCHAR 类型。 测试结果就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord 讨论。 修改之后通过！ 项目小结任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 key 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。","link":"/2023/08/26/Project%200%20-%20C++%20Primer/"},{"title":"Codeforces Round 894 (Div. 3)","text":"Gift Carpet从左到右每列贪心取即可。 12345678910111213141516171819202122public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] g = new String[m]; for (int i = 0; i &lt; m; i++) { g[i] = io.next(); } int idx = 0; String s = &quot;vika&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (g[j].charAt(i) == s.charAt(idx)) { idx++; break; } } if (idx == s.length()) { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Sequence Game构造题。当 \\(b_{i-1}&gt;b_{i}\\) 时，在两个数中间添加一个 \\(1\\) 即可。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(b[0]); for (int i = 1; i &lt; n; i++) { if (b[i] &lt; b[i - 1]) ans.add(1); ans.add(b[i]); } io.println(ans.size()); for (int x : ans) io.print(x + &quot; &quot;); io.println();} Flower City Fence阅读理解。题目中的“对角线对称”这个概念根本不用管，就是不断对区间做加法，然后判断是否和原数组相等，可以使用差分 + 前缀和解决。看完题解，发现其实也可以 \\(O(1)\\) 空间解决，因为数组是非递增的，按顺序遍历就行，具体见代码。 123456789101112131415public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } for (int i = 0, j = n; i &lt; n; i++) { for (; j &gt; 0 &amp;&amp; a[j - 1] &lt;= i; j--) ; if (a[i] != j) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Ice Cream Balls题目描述很有问题，其实就是问从一个长度为 \\(m\\) 的序列中选两个值组成集合，使得不同集合的数目恰好为 \\(n\\) 的 \\(m\\) 是多少。可以先二分求 \\(x\\)，使得 \\(C_{x}^{2}\\leq n\\) 且 \\(C_{x+1}^{2}&gt;n\\)。然后答案就是 \\(x+(n-C_{x}^{2})\\)，表示 \\([1,n-C_{x}^{2}]\\) 范围内的每个数各取两个，以及 \\([n-C_{x}^{2}+1,x]\\) 范围内的每个数各取一个。PS：读题很容易漏掉恰好两个字。 12345678910public static void solve() { long n = io.nextLong(); long lo = 2, hi = (long) 1e9 * 2; while (lo &lt;= hi) { long mid = lo + (hi - lo) / 2; if (mid * (mid - 1) / 2 &lt;= n) lo = mid + 1; else hi = mid - 1; } io.println(hi + (n - hi * (hi - 1) / 2));} Kolya and Movie Theatre做这道题时漏掉“开业前一天去过电影院”这个条件，导致想了半天。答案要求最多看 \\(m\\) 部电影的最大娱乐价值，首先我们可以观察到娱乐值的下降幅度只与最后一次去电影院的日期 \\(x\\) 有关，即下降幅度为 \\(x\\cdot d\\)。所以我们可以从前往后枚举 \\(x\\)，并且维护最大长度为 \\(m\\) 的优先队列，来保证最多看 \\(m\\) 部电影。需要注意电影的娱乐值可能是负数，而我们只需要在优先队列中存储正数即可。 123456789101112131415public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = io.nextInt(); PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); long sum = 0L, ans = 0L; for (int i = 0; i &lt; n; i++) { if (a[i] &lt;= 0) continue; q.offer(a[i]); sum += a[i]; if (q.size() &gt; m) sum -= q.poll(); ans = Math.max(ans, sum - (long) d * (i + 1)); } io.println(ans);} Magic Will Save the World初见时想到的是二分时间 + 动态规划，赛后优化发现可以直接动态规划做。我是用背包做的，\\(dp[i][j]\\) 表示前 \\(i\\) 个怪物使用 \\(j\\) 点法术值能够击败的怪物总强度最大是多少，然后枚举水法术值计算答案。但是其实可以不用这样，我们只需要知道怪物的子集的所有可能强度是多少，然后枚举所有能够到达的强度即可。（C++ 位图很方便） 12345678910111213141516171819202122public static void solve() { int w = io.nextInt(), f = io.nextInt(), n = io.nextInt(); int sum = 0; int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); sum += s[i]; } boolean[] dp = new boolean[sum + 1]; dp[0] = true; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= s[i]; j--) { dp[j] = dp[j] || dp[j - s[i]]; } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt;= sum; i++) { if (!dp[i]) continue; ans = Math.min(ans, Math.max((i + w - 1) / w, (sum - i + f - 1) / f)); } io.println(ans);} The Great Equalizer很容易就可以得出结论，设备的输出值是数组的最大值 + 排序后相邻元素的最大差值，但是不知道怎么维护。使用 C++ 的 multiset 很容易写，详细见大佬的代码。","link":"/2023/08/26/Codeforces%20Round%20894%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 317","text":"Potions二分。 12345678910111213141516public static void solve() { int n = io.nextInt(), h = io.nextInt(), x = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); } x = x - h; int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (p[mid] &lt; x) lo = mid + 1; else hi = mid - 1; } io.println(lo + 1);} MissingNo.求和公式。 12345678910111213public static void solve() { int n = io.nextInt(); int sum = 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); sum += a; min = Math.min(min, a); max = Math.max(max, a); } io.println((min + max) * (max - min + 1) / 2 - sum);} Remembering the Days暴力 DFS。 12345678910111213141516171819202122232425262728293031private static int ans = Integer.MIN_VALUE;public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, w = io.nextInt(); g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { dfs(i, 0, g, vis); } io.println(ans);}private static void dfs(int x, int dis, List&lt;int[]&gt;[] g, boolean[] vis) { vis[x] = true; ans = Math.max(ans, dis); for (int[] t : g[x]) { int y = t[0], w = t[1]; if (!vis[y]) { dfs(y, dis + w, g, vis); } } vis[x] = false;} President01 背包，比赛时转移方程弄错了一个细节，本来以为和答案是等价的，赛后改下就过了。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); int sum = 0; int[] x = new int[n]; int[] y = new int[n]; int[] z = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); z[i] = io.nextInt(); sum += z[i]; } long[] dp = new long[sum + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= z[i]; j--) { if (dp[j - z[i]] == Long.MAX_VALUE) continue; dp[j] = Math.min(dp[j], dp[j - z[i]] + Math.max(0, (y[i] - x[i] + 1) / 2)); } } long ans = Long.MAX_VALUE; for (int i = (sum + 1) / 2; i &lt;= sum; i++) { ans = Math.min(ans, dp[i]); } io.println(ans);} Avoid Eye Contact模拟题，比赛时想复杂了，直接模拟就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void solve() { int h = io.nextInt(), w = io.nextInt(); String[] a = new String[h]; for (int i = 0; i &lt; h; i++) { a[i] = io.next(); } int s = -1, g = -1; boolean[][] mark = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { char c = a[i].charAt(j); if (c == 'S') { s = i * w + j; } else if (c == 'G') { g = i * w + j; } else if (c == '#') { mark[i][j] = true; } else if (c == '^') { mark[i][j] = true; for (int k = i - 1; k &gt;= 0 &amp;&amp; a[k].charAt(j) == '.'; k--) { mark[k][j] = true; } } else if (c == 'v') { mark[i][j] = true; for (int k = i + 1; k &lt; h &amp;&amp; a[k].charAt(j) == '.'; k++) { mark[k][j] = true; } } else if (c == '&lt;') { mark[i][j] = true; for (int k = j - 1; k &gt;= 0 &amp;&amp; a[i].charAt(k) == '.'; k--) { mark[i][k] = true; } } else if (c == '&gt;') { mark[i][j] = true; for (int k = j + 1; k &lt; w &amp;&amp; a[i].charAt(k) == '.'; k++) { mark[i][k] = true; } } } } int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; int[] dis = new int[h * w]; Arrays.fill(dis, -1); dis[s] = 0; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(s); while (!q.isEmpty()) { int z = q.poll(); int x = z / w, y = z % w; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= h || ny &lt; 0 || ny &gt;= w || mark[nx][ny]) continue; int nz = nx * w + ny; if (dis[nz] != -1) continue; dis[nz] = dis[z] + 1; q.offer(nz); } } io.println(dis[g]);}","link":"/2023/08/28/AtCoder%20Beginner%20Contest%20317/"},{"title":"Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2)","text":"Increasing and Decreasing比赛时漏看第三个条件，搞半天。而且似乎倒着减会比较容易做（差不多）。 123456789101112131415public static void solve() { int x = io.nextInt(), y = io.nextInt(), n = io.nextInt(); int z = (1 + n - 1) * (n - 1) / 2; if (z &gt; y - x) { io.println(-1); return; } io.print(x + &quot; &quot;); int d = x + y - x - z; for (int i = n - 1; i &gt;= 1; i--) { d += i; io.print(d + &quot; &quot;); } io.println();} Swap and Reverse找规律。第一个操作表明奇数下标相互连通，偶数下标相互连通。第二个操作，如果 \\(k\\) 是奇数，则连通性不会改变，分别对奇偶字母排序，然后构造即可；如果 \\(k\\) 是偶数，则奇数下标和偶数下标相互连通，对所有字母排序即可。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); if (k % 2 == 0) { Arrays.sort(s); io.println(new String(s)); } else { PriorityQueue&lt;Character&gt; list1 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; list2 = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) list1.add(s[i]); else list2.add(s[i]); } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) sb.append(list1.poll()); else sb.append(list2.poll()); } io.println(sb.toString()); }} Divisor Chain比赛时瞎猜 AC 的，当时是想从 \\(1\\) 开始构造到 \\(x\\)，过程比答案复杂。正解是从 \\(x\\) 一直减去最低有效位的一（必定是除数），直到 \\(x\\) 等于 \\(2\\) 的幂（只剩一个一），然后让 \\(x\\) 一直减去 \\(\\frac{x}{2}\\) 即可。 123456789101112131415161718public static void solve() { int x = io.nextInt(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(x); while ((x &amp; (x - 1)) != 0) { x &amp;= (x - 1); ans.add(x); } while (x != 1) { x /= 2; ans.add(x); } io.println(ans.size()); for (int y : ans) { io.print(y + &quot; &quot;); } io.println();} Matrix Cascade使用差分数组维护从上到下的翻转次数，需要注意的是正负需要分开存，正数每层左移一位，负数每层右移一位。PS：这题 \\(p\\) 和 \\(q\\) 总是写错，Debug 很久。以及大佬的代码看不懂。 1234567891011121314151617181920212223242526272829303132public static void solve() { int n = io.nextInt(); char[][] a = new char[n][]; for (int i = 0; i &lt; n; i++) { a[i] = io.next().toCharArray(); } int ans = 0; int[] p = new int[n + 1]; int[] q = new int[n + 1]; int[] sum = new int[n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (a[i][j] - '0' != sum[j + 1] % 2) { ans++; p[j] ^= 1; q[j + 1] ^= 1; } } p[0] ^= p[1]; for (int j = 1; j &lt; n; j++) { p[j] = p[j + 1]; } q[n] ^= q[n - 1]; for (int j = n - 1; j &gt; 0; j--) { q[j] = q[j - 1]; } for (int j = 0; j &lt; n; j++) { sum[j + 1] = sum[j] ^ p[j] ^ q[j]; } } io.println(ans);} Guess Game有点难以描述，超出能力范围了。这是一个比较好理解的做法，分别考虑每一位。从最低位开始，如果前缀相同，那么就计算当前位 \\(0\\) 和 \\(1\\) 的个数，只有爱丽丝拿 \\(1\\)，鲍勃拿 \\(1\\) 或 \\(0\\) 的情况，当前位才会多走一轮。初始时，设置答案为 \\(n \\times n\\)，因为每个组合至少会走一轮。最后需要使用快速幂求 \\(n\\) 的逆元。 1234567891011121314151617181920212223242526272829303132333435363738private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); long ans = (long) n * n; for (int t = 0; t &lt; 30; t++) { for (int l = 0, r = 0; l &lt; n; l = r) { int[] cnt = new int[2]; while (r &lt; n &amp;&amp; a[l] / 2 == a[r] / 2) { cnt[a[r] % 2]++; r++; } ans += (long) cnt[1] * (cnt[1] + cnt[0]); } for (int i = 0; i &lt; n; i++) { a[i] /= 2; } } ans = ans % MOD * pow(n, MOD - 2) % MOD * pow(n, MOD - 2) % MOD; io.println(ans);}private static int pow(int a, int n) { long res = 1, x = a; while (n != 0) { if (n % 2 == 1) { res = (res * x) % MOD; } x = (x * x) % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/08/28/Harbour.Space%20Scholarship%20Contest%202023-2024%20(Div.%201%20+%20Div.%202)/"},{"title":"第 360 场力扣周赛","text":"距离原点最远的点核心：要距离原点最远，那么可选的位置肯定是向同一个方向移动。 123456789101112class Solution { public int furthestDistanceFromOrigin(String moves) { int n = moves.length(), dis = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { char c = moves.charAt(i); if (c == 'L') dis--; else if (c == 'R') dis++; else cnt++; } return Math.max(cnt - dis, cnt + dis); }} 找出美丽数组的最小和和上周一样的题目。 123456class Solution { public long minimumPossibleSum(int n, int target) { long m = Math.min(target / 2, n); return (m * (m + 1) + (target * 2 + n - m - 1) * (n - m)) / 2; }} 使子序列的和等于目标的最少操作次数比赛时思路满天飞，各种乱写。其实最后的思路是对的，但是基于之前的代码改写，导致有很多 Bug。赛后 15 分钟 AC。从低位到高位枚举 \\(target\\) 中的 \\(1\\)，假设当前 \\(1\\) 对应的值为 \\(x\\)，那么 \\(nums\\) 中所有小于等于 \\(x\\) 的值都可以用来填补 \\(x\\)，如果不够那么肯定需要将下一个大于 \\(x\\) 的值分解为 \\(x\\)。（更优的做法） 123456789101112131415161718192021class Solution { public int minOperations(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int n = nums.size(); int idx = 0, sum = 0, ans = 0; for (int i = target; i != 0; ) { int x = i &amp; -i; i -= x; while (idx &lt; n &amp;&amp; nums.get(idx) &lt;= x) { sum += nums.get(idx++); } sum -= x; if (sum &lt; 0) { if (idx == n) return -1; ans += Integer.numberOfTrailingZeros(nums.get(idx) / x); sum += nums.get(idx++); } } return ans; }} 在传球游戏中最大化函数值参考大佬的题解。 方法一：倍增 DP 因为 CPU 缓存的原因，数组开成 new int[35][n] 会更快。因为这样转移的时候只从上一行转移，具有空间局部性；而下面的代码是从左边一列转移，不具有空间局部性。 1234567891011121314151617181920212223242526272829class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); int[][] f = new int[n][35]; long[][] w = new long[n][35]; for (int i = 0; i &lt; n; i++) { f[i][0] = receiver.get(i); w[i][0] = i; } for (int j = 1; j &lt; 35; j++) { for (int i = 0; i &lt; n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; w[i][j] = w[i][j - 1] + w[f[i][j - 1]][j - 1]; } } long ans = 0L; for (int i = 0; i &lt; n; i++) { long cur = 0L; int pos = i; for (int j = 0; j &lt; 35; j++) { if ((k &gt;&gt; j &amp; 1) == 0) continue; cur += w[pos][j]; pos = f[pos][j]; } ans = Math.max(ans, cur + pos); } return ans; }} 方法二：内向基环树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[receiver.get(i)]++; reverse[receiver.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[receiver.get(x)] == 0) { q.offer(receiver.get(x)); } } // 计算每个环的前缀和，并记录每个节点在哪个环的哪个位置 int[] cirNum = new int[n]; int[] cirPos = new int[n]; boolean[] vis = new boolean[n]; List&lt;List&lt;Long&gt;&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { List&lt;Long&gt; cir = new ArrayList&lt;&gt;(); cir.add(0L); // 前缀和的冗余节点 // 存储环的节点，并记录每个节点在哪个环的哪个位置 for (int cur = i; !vis[cur]; cur = receiver.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cirPos[cur] = cir.size(); cir.add((long) cur); } // 重复存储环的节点，方便计算从任意节点开始和结束的价值和 for (int t = cir.size() - 1, j = 1; t &gt; 0; t--, j++) { cir.add(cir.get(j)); } // 计算前缀和 for (int j = 1; j &lt; cir.size(); j++) { cir.set(j, cir.get(j) + cir.get(j - 1)); } circles.add(cir); } } // 对环内的每个节点向环外进行 dfs，从而计算出以每个节点作为起点的价值和 long ans = 0L; // 存储环外节点的前缀和 List&lt;Long&gt; outSum = new ArrayList&lt;&gt;(); outSum.add(0L); for (int i = 0; i &lt; n; i++) { // 注意传递 k + 1，表示总节点数量 if (in[i] != 0) ans = Math.max(ans, dfs(i, circles.get(cirNum[i]), cirPos[i], reverse, in, outSum, k + 1)); } return ans; } private long dfs(int x, List&lt;Long&gt; cir, int pos, List&lt;Integer&gt;[] reverse, int[] in, List&lt;Long&gt; outSum, long k) { long res = 0L; int outLen = outSum.size() - 1; if (outLen &lt; k) { int n = cir.size() / 2; // 因为 cir 多存储了 n - 1 个环内节点，以及一个冗余节点，所以 cir.size() / 2 就是环的长度 res = (k - outLen) / n * cir.get(n) + cir.get(pos + (int) ((k - outLen) % n) - 1) - cir.get(pos - 1); } res += outSum.get(outLen) - outSum.get((int) Math.max(0L, outLen - k)); for (int y : reverse[x]) { if (in[y] != 0) continue; outSum.add(outSum.get(outLen) + y); res = Math.max(res, dfs(y, cir, pos, reverse, in, outSum, k)); outSum.remove(outLen + 1); } return res; }}","link":"/2023/08/28/%E7%AC%AC%20360%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Homework #1 - SQL","text":"作业准备项目地址：Homework #1 - SQL。 准备工作：阅读 Chapters 1-2 27 3-5，学习 Lecture #01 #02，以及阅读课堂笔记。 Q1 [0 points] (q1_sample):Ctrl + C，Ctrl +V。 Q2 [5 points] (q2_not_the_same_title):查询只涉及 titles 表，比较简单。 1234567891011121314SELECT premiered, primary_title || ' (' || original_title || ')'FROM titlesWHERE primary_title != original_title AND type = 'movie' AND genres LIKE '%Action%'ORDER BY premiered DESC, primary_titleLIMIT 10; Q3 [5 points] (q3_longest_running_tv):题目描述很不清晰啊，类型都不知道具体是什么。 12345678910111213SELECT primary_title, IIF(ended IS NULL, 2023, ended) - premiered AS runtimeFROM titlesWHERE primary_title IS NOT NULL AND type = 'tvSeries'ORDER BY runtime DESC, primary_titleLIMIT 20; Q4 [10 points] (q4_directors_in_each_decade):唯一要注意的就是使用 DISTINCT。 12345678910111213SELECT CAST(born / 10 * 10 AS TEXT) || 's' AS decade, COUNT(DISTINCT(people.person_id)) AS num_directorsFROM people INNER JOIN crew USING(person_id)WHERE category = 'director' AND born &gt;= 1900GROUP BY decadeORDER BY decade; Q5 [10 points] (q5_german_type_ratings):德语的缩写是 de。 12345678910111213141516SELECT t.type, ROUND(AVG(r.rating), 2) AS avg_rating, MIN(r.rating), MAX(r.rating)FROM akas as a INNER JOIN ratings as r USING(title_id) INNER JOIN titles as t USING(title_id)WHERE a.language = 'de' AND a.types IN ('imdbDisplay', 'original')GROUP BY t.typeORDER BY avg_rating; Q6 [10 points] (q6_who_played_a_batman):坑点就是模糊查询时 Batman 两边要加上双引号，即 &quot;Batman&quot;。以及在连接 people 和 crew 表时，顺序很重要，如果使用 crew INNRE JOIN people USING(person_id) 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。 12345678910111213crew INNER JOIN people USING(person_id)QUERY PLAN|--SCAN crew USING INDEX ix_crew_person_id|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCTpeople INNER JOIN crew USING(person_id)QUERY PLAN|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCT 12345678910111213141516171819202122232425WITH t AS ( SELECT DISTINCT(person_id), name FROM people INNER JOIN crew USING(person_id) WHERE category = 'actor' AND characters LIKE '%&quot;Batman&quot;%')SELECT name, ROUND(AVG(rating), 2) AS avg_ratingFROM t INNER JOIN crew USING(person_id) INNER JOIN ratings USING(title_id)GROUP BY person_idORDER BY avg_rating DESCLIMIT 10; Q7 [15 points] (q7_born_with_prestige):SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。 123456789SELECT COUNT(DISTINCT(person_id))FROM titles INNER JOIN people ON titles.premiered = people.born INNER JOIN crew USING(person_id)WHERE primary_title = 'The Prestige' AND category IN ('actor', 'actress'); 12345QUERY PLAN|--USE TEMP B-TREE FOR count(DISTINCT)|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?) Q8 [15 points] (q8_directing_rose.sql):比官解快一秒。注意使用 Rose% 而不是 Rose %。 12345678910111213141516171819SELECT DISTINCT(name)FROM crew INNER JOIN people USING(person_id)WHERE category = 'director' AND title_id IN ( SELECT title_id FROM crew INNER JOIN people USING(person_id) WHERE category = 'actress' AND name LIKE 'Rose%' )ORDER BY name; Q9 [15 points] (q9_ode_to_the_dead):这就是窗口函数么，学习了。 123456789101112131415161718192021222324252627282930313233343536373839WITH t AS ( SELECT category, name, died, primary_title, runtime_minutes, DENSE_RANK() OVER( PARTITION BY category ORDER BY died, name ) AS rank_died_name, DENSE_RANK() OVER( PARTITION BY category, person_id ORDER BY runtime_minutes DESC, title_id ) AS rank_runtime_title FROM crew INNER JOIN people USING(person_id) INNER JOIN titles USING(title_id) WHERE died IS NOT NULL AND runtime_minutes IS NOT NULL)SELECT category, name, died, primary_title, runtime_minutes, rank_died_nameFROM tWHERE rank_died_name &lt;= 5 AND rank_runtime_title = 1ORDER BY category, rank_died_name; Q10 [15 points] (q10_all_played_by_leo):不会。。json_each 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。 123456789101112131415161718192021222324252627WITH t1(characters) AS ( SELECT characters FROM people INNER JOIN crew USING(person_id) WHERE name = 'Leonardo DiCaprio' AND born = 1974),t2(value) AS ( SELECT DISTINCT(value) FROM t1, json_each(t1.characters) WHERE value != '' AND value NOT LIKE '%SELF%' ORDER BY value)SELECT GROUP_CONCAT(value)FROM t2; 作业小结最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）","link":"/2023/08/29/Homework%201%20-%20SQL/"},{"title":"Pinely Round 2 (Div. 1 + Div. 2)","text":"Channel如果同时在线人数到达 \\(n\\)，就表示所有人都阅读过；否则，如果总上线人数大于等于 \\(n\\)，则有可能所有人阅读过；否则，不可能所有人阅读过。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), a = io.nextInt(), q = io.nextInt(); String s = io.next(); int cur = a, tot = a; for (int i = 0; i &lt; q &amp;&amp; cur &lt; n; i++) { if (s.charAt(i) == '+') { cur++; tot++; } else { cur--; } } if (cur == n) { io.println(&quot;YES&quot;); } else if (tot &gt;= n) { io.println(&quot;MAYBE&quot;); } else { io.println(&quot;NO&quot;); }} Split Sort对于每个 \\(p_{i}=k+1\\) 和 \\(p_{j}=k\\) 并且 \\(i&lt;j\\)，那么就一定要选一次 \\(x=k+1\\)。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt() - 1; } int[] map = new int[n]; for (int i = 0; i &lt; n; i++) { map[p[i]] = i; } int ans = 0; for (int i = 1; i &lt; n; i++) { if (map[i] &lt; map[i - 1]) { ans++; } } io.println(ans);} MEX Repetition每执行一次操作，就会去除最后一个数，并将 \\(MEX\\) 添加到序列头部。所以可以通过在数组末尾加上原始数组的 \\(MEX\\)，将操作看成是向左移动循环数组的起始索引。求原始数组的 \\(MEX\\) 可以使用求和公式。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); long sum = 0L; int[] a = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } a[n] = (int) ((long) (1 + n) * n / 2 - sum); k = k % (n + 1); for (int i = 0; i &lt; n; i++) { io.print(a[(-k + n + 1 + i) % (n + 1)] + &quot; &quot;); } io.println();} Two-Colored Dominoes横放的牌只会对列有影响，竖放的牌只会对行有影响，所以分别处理。按行遍历竖放的牌，每当遇到 \\(U\\) 就染上和上次相反的颜色，如果该行只包含奇数个 \\(U\\)，就返回 \\(-1\\)。横放的牌同理。 123456789101112131415161718192021222324252627282930313233343536373839public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } final char[] aux = {'B', 'W'}; for (int i = 0; i &lt; n - 1; i++) { int xor = 0; for (int j = 0; j &lt; m; j++) { if (s[i][j] == 'U') { s[i][j] = aux[xor]; s[i + 1][j] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int j = 0; j &lt; m - 1; j++) { int xor = 0; for (int i = 0; i &lt; n; i++) { if (s[i][j] == 'L') { s[i][j] = aux[xor]; s[i][j + 1] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int i = 0; i &lt; n; i++) { io.println(new String(s[i])); }} Speedrun其实思路是知道的，就是不知道怎么写。这个解法看着有点懵，可能其他解法会更好理解一点。注意题目给定 \\(a_{i}&lt;b_{i}\\)。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); int[] h = new int[n]; for (int i = 0; i &lt; n; i++) { h[i] = io.nextInt(); } List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, idx -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1; g[a].add(b); } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从 h[i] 开始） long[] dp = new long[n]; for (int i = n - 1; i &gt;= 0; i--) { for (int j : g[i]) { dp[i] = Math.max(dp[i], dp[j] + (h[j] - h[i] + k) % k); } } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从零开始） long max = 0L; for (int i = 0; i &lt; n; i++) { dp[i] += h[i]; max = Math.max(max, dp[i]); } // 按照 h[i] 的大小，从小到大枚举起点 Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; h[i] - h[j]); long ans = Long.MAX_VALUE; for (int i : aux) { ans = Math.min(ans, max - h[i]); // 如果起点大于 h[i]，那么任务 i 的完成时间需要加 k，从而导致 dp[i] + k // 其实只要枚举入度为 0 的任务就行，但是即使任务 i 不是入度为 0 任务也没有关系，因为对答案没有影响 max = Math.max(max, dp[i] + k); } io.println(ans);}","link":"/2023/08/31/Pinely%20Round%202%20(Div.%201%20+%20Div.%202)/"},{"title":"Educational Codeforces Round 154 (Rated for Div. 2)","text":"Prime Deletion从 \\(1\\) 到 \\(9\\) 的序列中删除一些数（至少保留两位），使得结果为质数。可以发现 \\(13\\) 和 \\(31\\) 都是质数，所以判断 \\(1\\) 和 \\(3\\) 的先后顺序，然后输出即可。 12345678910111213public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; for (int i = 0; i &lt; n; i++) { if (s[i] == '1') { io.println(13); return; } else if(s[i] == '3') { io.println(31); return; } }} Two Binary Strings比赛时我是从左往右遍历记录不相等的数量，如果有不相等的，那么就需要一个 \\(0\\)，否则遇到 \\(1\\) 就输出 YES。和正解的思路是一样的，就是麻烦一点。正解是有相同的 \\(01\\) 出现时就输出 YES。 123456789101112public static void solve() { char[] a = io.next().toCharArray(); char[] b = io.next().toCharArray(); int n = a.length; for (int i = 0; i &lt; n - 1; i++) { if (a[i] == b[i] &amp;&amp; a[i] == '0' &amp;&amp; a[i + 1] == b[i + 1] &amp;&amp; a[i + 1] == '1') { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Queries for the Array比较简单的写法就是用一个标记数组做记录，递增会向左传递，递减会向右传递，然后判断是否冲突即可。更进一步观察，可以发现只需要记录最大的递增位置，和最小的递减位置。 1234567891011121314151617181920212223242526272829public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = true; int pos = -1, neg = n, cur = -1; for (char c : s) { if (c == '+') { cur++; } else if (c == '-') { if (cur-- == neg) { neg = n; } pos = Math.min(pos, cur); } else if (c == '0') { if (cur == pos || cur &lt;= 0) { ok = false; break; } neg = Math.min(neg, cur); } else { if (neg &lt;= cur) { ok = false; break; } pos = cur; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Sorting By Multiplication没想到啊。枚举负数前缀的长度：在负数前缀中，如果 \\(a[i]&lt;=a[i+1]\\)，就需要操作一次；在正数后缀中，如果 \\(a[i]&gt;=a[i+1]\\) 就需要操作一次。（下面的代码很妙啊，不需要加额外的判断语句。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int cnt = 0; for (int i = 0; i &lt; n - 1; i++) { if (a[i] &gt;= a[i + 1]) { cnt++; } } int ans = cnt; for (int i = 1; i &lt; n; i++) { if (a[i - 1] &gt;= a[i]) cnt--; ans = Math.min(ans, cnt + 1); if (a[i - 1] &lt;= a[i]) cnt++; } io.println(ans);}","link":"/2023/09/04/Educational%20Codeforces%20Round%20154%20(Rated%20for%20Div.%202)/"},{"title":"AtCoder Beginner Contest 318","text":"Full Moon模拟。 1234public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); io.println(n &lt; m ? 0 : (n - m) / p + 1);} Overlapping sheets比赛时没什么思路，想到扫描线，就用扫描线 + 区间合并来做了。结果一看题解，暴力标记每个点，没想到。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; int[][] g = new int[100][100]; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(), b = io.nextInt(); int c = io.nextInt(), d = io.nextInt(); for (int x = a; x &lt; b; x++) { for (int y = c; y &lt; d; y++) { if (g[x][y]++ == 0) ans++; } } } io.println(ans);} Blue Spring看到大佬的解法后，感觉我模拟的方式好蠢啊。当时我是枚举是否要买 \\(d\\) 张票，有点麻烦，原来枚举买当日的票更简单。 1234567891011121314public static void solve() { int n = io.nextInt(), d = io.nextInt(), p = io.nextInt(); int[] f = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { f[i] = io.nextInt(); } Arrays.sort(f); long ans = Long.MAX_VALUE, sum = 0L; for (int i = 0; i &lt;= n; i++) { sum += f[i]; ans = Math.min(ans, sum + (long) (n - i + d - 1) / d * p); } io.println(ans);} General Weighted Max Matching动态规划有点不太会，赛时瞎搞 AC 的。记忆化搜索会很好写，然后 DP 的话，我是用三层循环解决的，下面的解法优化掉一层循环。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[][] d = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { d[i][j] = io.nextInt(); } } long[] dp = new long[1 &lt;&lt; n]; for (int k = 2; k &lt; 1 &lt;&lt; n; k++) { int i = Integer.numberOfTrailingZeros(k &amp; -k); dp[k] = dp[k ^ (1 &lt;&lt; i)]; for (int j = i + 1; j &lt; n; j++) { if ((k &gt;&gt; j &amp; 1) == 1) { dp[k] = Math.max(dp[k], dp[k ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j)] + d[i][j]); } } } io.println(dp[(1 &lt;&lt; n) - 1]);} Sandwiches比较显然的做法是把相同的数分为一组，然后组内枚举中间的数。对于每个中间的数，让答案加上 \\(L\\times R\\)，其中 \\(L\\) 和 \\(R\\) 分别是左右两边相等的数的个数，枚举时可以一次性枚举间隔内所有数。 第二个解法是参考大佬的代码得到的，相当于枚举右端点吧。对于每个右端点，它的贡献可以根据下面代码中的公式得出，感觉比较巧妙。 12345678910111213public static void solve() { int n = io.nextInt(); int[] cnt = new int[n]; long[] sum = new long[n]; long ans = 0L; for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; ans += (long) i * cnt[a] - sum[a] - (long) (1 + cnt[a]) * cnt[a] / 2; cnt[a]++; sum[a] += i; } io.println(ans);} Octopus有点抽象，不是很懂。大概是枚举了 \\(N^{2}\\) 个极限位置，然后分别对每个位置判断可行性。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int N = io.nextInt(); long[] X = new long[N]; long[] L = new long[N]; for (int i = 0; i &lt; N; i++) { X[i] = io.nextLong(); } for (int i = 0; i &lt; N; i++) { L[i] = io.nextLong(); } List&lt;Long&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { pos.add(X[i] - L[j]); pos.add(X[i] + L[j] + 1); } } Collections.sort(pos); long ans = 0L; for (int i = 0; i &lt; pos.size() - 1; i++) { long[] dis = new long[N]; for (int j = 0; j &lt; N; j++) { dis[j] = Math.abs(pos.get(i) - X[j]); } Arrays.sort(dis); boolean ok = true; for (int j = 0; j &lt; N; j++) { if (dis[j] &gt; L[j]) { ok = false; break; } } if (ok) { ans += pos.get(i + 1) - pos.get(i); } } io.println(ans);}","link":"/2023/09/04/AtCoder%20Beginner%20Contest%20318/"},{"title":"第 112 场力扣夜喵双周赛","text":"判断通过操作能否让字符串相等 I同下。 判断通过操作能否让字符串相等 II模拟。也可以手动比较，就是适用性不好。（PS：想出一个写法，结果被自己 Hack 掉了~） 1234567891011class Solution { public boolean checkStrings(String s1, String s2) { int n = s1.length(); int[][] c1 = new int[2][26], c2 = new int[2][26]; for (int i = 0; i &lt; n; i++) { c1[i &amp; 1][s1.charAt(i) - 'a']++; c2[i &amp; 1][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(c1, c2); }} 几乎唯一子数组的最大和滑动窗口。 12345678910111213141516171819class Solution { public long maxSum(List&lt;Integer&gt; nums, int m, int k) { int n = nums.size(); long sum = 0L, ans = 0L; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge(nums.get(i), 1, Integer::sum); sum += nums.get(i); if (i &gt;= k - 1) { if (map.size() &gt;= m) ans = Math.max(ans, sum); if (map.merge(nums.get(i - k + 1), -1, Integer::sum) == 0) { map.remove(nums.get(i - k + 1)); } sum -= nums.get(i - k + 1); } } return ans; }} 统计一个字符串的 k 子序列美丽值最大的数目因为和选择的顺序没有关系，所以贪心的选择出现次数最大的字母就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { private static final long MOD = (long) 1e9 + 7; public int countKSubsequencesWithMaxBeauty(String s, int k) { char[] ss = s.toCharArray(); int[] cnt = new int[26]; for (char c : ss) { cnt[c - 'a']++; } TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((a, b) -&gt; b - a); for (int i = 0; i &lt; 26; i++) { map.merge(cnt[i], 1, Integer::sum); } long ans = 1L; for (var e : map.entrySet()) { int key = e.getKey(), val = e.getValue(); if (val &gt;= k) { return (int) (ans * comb(val, k) % MOD * pow(key, k) % MOD); } k -= val; ans = (ans * pow(key, val)) % MOD; } return 0; } private long pow(long x, int n) { long res = 1L; while (n != 0) { if ((n &amp; 1) == 1) res = (res * x) % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; } private long comb(long n, int k) { long res = n; for (int i = 2; i &lt;= k; i++) { res = res * --n / i; } return res % MOD; }}","link":"/2023/09/04/%E7%AC%AC%20112%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 361 场力扣周赛","text":"统计对称整数的数目模拟。 12345678910111213141516171819202122class Solution { public int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i &lt;= high; i++) { int x = i, n = 0; int[] aux = new int[10]; for (; x != 0; x /= 10) { aux[n++] = x % 10; } if (n % 2 == 0) { int sum = 0; for (int j = 0; j &lt; n / 2; j++) { sum += aux[j] - aux[j + n / 2]; } if (sum == 0) { ans++; } } } return ans; }} 生成特殊数字的最少操作比较简洁的暴力写法，当然从个位开始找 \\(25,75,50,00,0\\) 更快。 1234567891011121314151617class Solution { public int minimumOperations(String num) { int n = num.length(), ans = n; for (int i = 0; i &lt; n; i++) { if (num.charAt(i) == '0') { ans = Math.min(ans, n - 1); } for (int j = i + 1; j &lt; n; j++) { int x = (num.charAt(i) - '0') * 10 + num.charAt(j) - '0'; if (x % 25 == 0) { ans = Math.min(ans, n - i - 2); } } } return ans; }} 统计趣味子数组的数目最开始的思路是，找到所有满足 \\(nums[i]\\bmod modulo=k\\) 的下标放入新的列表，然后在新列表中枚举左端点 \\(i\\)，此时满足条件的右端点就是 \\(i+k-1+j\\times modulo\\)。暴力解决的时间复杂度 \\(O(n^{2})\\)，所以可以倒序枚举左端点，顺便记录间隔为 \\(modulo\\) 的后缀和。但是，这样解决还需要特判 \\(k=0\\) 的情况，总之很麻烦。 更好的做法是利用同余的性质。将所有 \\(nums[i]\\bmod modulo=k\\) 的数字看作 \\(1\\)，其他数字看作 \\(0\\)，这样我们要求的就是满足 \\((sum[r+1]-sum[l])\\bmod modulo=k\\) 的所有子数组的数目。我们可以枚举右端点，找到满足 \\((sum[r+1]-k)\\equiv sum[l]\\pmod{modulo}\\) 的左端点的个数，使用前缀和 + 哈希表即可。 12345678910111213141516class Solution { public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) { long ans = 0L; int n = nums.size(), sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int x : nums) { if (x % modulo == k) { sum = (sum + 1) % modulo; } ans += map.getOrDefault((sum - k + modulo) % modulo, 0); map.merge(sum, 1, Integer::sum); } return ans; }} 边权重均等查询树上倍增求最近公共祖先，同时维护边权的计数。详细见灵神题解。（发现汪佬的写法更简单，在 DFS 的同时进行倍增，以及通过拷贝数组来维护边权的计数信息。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution { private static final int M = 14; public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2] - 1; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] depth = new int[n]; int[][] cnt = new int[n][26]; int[][] parent = new int[M][n]; dfs(0, -1, g, depth, parent, cnt); // 查询 int k = queries.length; int[] ans = new int[k]; while (k-- != 0) { int x = queries[k][0], y = queries[k][1]; int z = lca(x, y, depth, parent), max = 0; for (int i = 0; i &lt; 26; i++) { max = Math.max(max, cnt[x][i] + cnt[y][i] - 2 * cnt[z][i]); } ans[k] = depth[x] + depth[y] - 2 * depth[z] - max; } return ans; } // DFS 的同时进行倍增，以及维护边权的计数 private void dfs(int x, int fa, List&lt;int[]&gt;[] g, int[] depth, int[][] parent, int[][] cnt) { for (int i = 1; 1 &lt;&lt; i &lt;= depth[x]; i++) { parent[i][x] = parent[i - 1][parent[i - 1][x]]; } for (int[] t : g[x]) { int y = t[0], w = t[1]; if (y != fa) { parent[0][y] = x; System.arraycopy(cnt[x], 0, cnt[y], 0, 26); cnt[y][w]++; depth[y] = depth[x] + 1; dfs(y, x, g, depth, parent, cnt); } } } // 求最近公共祖先 private int lca(int x, int y, int[] depth, int[][] parent) { if (depth[x] &gt; depth[y]) { int t = x; x = y; y = t; } // 先向上跳到相同深度 int step = depth[y] - depth[x]; for (int i = 0; i &lt; 32; i++) { if ((step &gt;&gt; i &amp; 1) != 0) { y = parent[i][y]; } } // 尽量向上跳 if (x != y) { for (int i = M - 1; i &gt;= 0; i--) { int px = parent[i][x], py = parent[i][y]; if (px != py) { x = px; y = py; } } x = parent[0][x]; } return x; }}","link":"/2023/09/04/%E7%AC%AC%20361%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 362 场力扣周赛","text":"与车相交的点差点又想区间合并做，看下数据范围，直接暴力，更好的做法是差分数组。 123456789101112131415class Solution { public int numberOfPoints(List&lt;List&lt;Integer&gt;&gt; nums) { int[] d = new int[102]; for (var num : nums) { d[num.get(0)]++; d[num.get(1) + 1]--; } int ans = 0; for (int i = 1; i &lt;= 100; i++) { d[i] += d[i - 1]; if (d[i] &gt; 0) ans++; } return ans; }} 判断能否在给定时间到达单元格题目说恰好第 \\(t\\) 秒到达，我还以为之前都不能到达，结果可以。那么特殊情况就是起点和终点相同，并且 \\(t=1\\)。 1234567class Solution { public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx &amp;&amp; sy == fy &amp;&amp; t == 1) return false; int a = Math.abs(sx - fx), b = Math.abs(sy - fy); return Math.max(a, b) &lt;= t; }} 将石头分散到网格图的最少移动次数方法一：回溯 记录所有等于零和大于一的位置，然后 DFS 搜索每个零从哪个位置获取一。 12345678910111213141516171819202122232425262728293031class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); else if (grid[i][j] &gt; 1) b.add(new int[]{i, j}); } } dfs(0, grid, a, b, 0); return ans; } private void dfs(int i, int[][] grid, List&lt;int[]&gt; a, List&lt;int[]&gt; b, int cnt) { if (i == a.size()) { ans = Math.min(ans, cnt); return; } int[] p = a.get(i); for (int j = 0; j &lt; b.size(); j++) { int[] q = b.get(j); if (grid[q[0]][q[1]] &gt; 1) { grid[q[0]][q[1]]--; dfs(i + 1, grid, a, b, cnt + Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1])); grid[q[0]][q[1]]++; } } }} 方法二：状压 DP 不是很懂，具体解释可以看大佬的题解。 123456789101112131415161718192021222324252627282930class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); for (int k = 2; k &lt;= grid[i][j]; k++) b.add(new int[]{i, j}); } } int n = a.size(); int[] f = new int[1 &lt;&lt; n]; for (int i = 1; i &lt; 1 &lt;&lt; n; i++) { f[i] = Integer.MAX_VALUE; int m = Integer.bitCount(i); for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j &amp; 1) == 1) { f[i] = Math.min(f[i], f[i ^ (1 &lt;&lt; j)] + distance(a.get(m - 1), b.get(j))); } } } return f[(1 &lt;&lt; n) - 1]; } private int distance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); }} 字符串转换KMP + 矩阵快速幂，详细见灵神题解，学习 KMP 看代码随想录，还有各种其他解法可以看题解区（很不错！）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { private static final int MOD = (int) 1e9 + 7; public int numberOfWays(String s, String t, long k) { int n = s.length(); char[] text = (s + s.substring(0, n - 1)).toCharArray(); char[] pattern = t.toCharArray(); int c = kmp(text, pattern); // f[0][0] = s.equals(t) ? 1 : 0; // f[0][1] = s.equals(t) ? 0 : 1; // f[i][0] = f[i - 1][0] * (c - 1) + f[i - 1][1] * c; // f[i][1] = f[i - 1][0] * (n - c) + f[i - 1][1] * (n - c - 1); long[][] m = {{c - 1, c}, {n - c, n - c - 1}}; m = pow(m, k); return s.equals(t) ? (int) m[0][0] : (int) m[0][1]; } private int kmp(char[] text, char[] pattern) { int m = text.length, n = pattern.length; int[] next = new int[n]; for (int i = 1, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) { j = next[j - 1]; } if (pattern[i] == pattern[j]) j++; next[i] = j; } int cnt = 0; for (int i = 0, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) { j = next[j - 1]; } if (text[i] == pattern[j]) j++; if (j == n) { cnt++; j = next[j - 1]; } } return cnt; } private long[][] pow(long[][] a, long n) { long[][] res = {{1, 0}, {0, 1}}; while (n != 0) { if ((n &amp; 1) == 1) res = mul(res, a); a = mul(a, a); n &gt;&gt;= 1; } return res; } private long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % MOD; } } return c; }}","link":"/2023/09/11/%E7%AC%AC%20362%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 896 (Div. 2)","text":"Make It Zero挺简单的一道题，偶数长度的数组操作两次就可以，如果是奇数长度，则额外操作两次。写的时候，把 \\(n\\) 错写成 \\(n-1\\)，找 BUG 花了一倍的时间。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } if (n % 2 == 0) { io.println(2); io.println(1 + &quot; &quot; + n); io.println(1 + &quot; &quot; + n); return; } io.println(4); io.println(1 + &quot; &quot; + (n - 1)); io.println(1 + &quot; &quot; + (n - 1)); io.println((n - 1) + &quot; &quot; + n); io.println((n - 1) + &quot; &quot; + n);} 2D Traveling\\(a\\) 和 \\(b\\) 的最短距离有两种情况，一个是 \\(a\\) 和 \\(b\\) 的曼哈顿距离，另一个是 \\(a\\) 和 \\(b\\) 经过 \\(k\\) 的曼哈顿距离，该情况只要求 \\(k\\) 个点中距离 \\(a\\) 和距离 \\(b\\) 最近的距离就行。比赛时遇到个坑点，两个 Long.MAX_VALUE 相加会溢出，所以初始时除以二。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(), a = io.nextInt(), b = io.nextInt(); long[] x = new long[n], y = new long[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } long ak = Long.MAX_VALUE / 2, bk = Long.MAX_VALUE / 2; for (int i = 0; i &lt; k; i++) { ak = Math.min(ak, Math.abs(x[i] - x[a - 1]) + Math.abs(y[i] - y[a - 1])); bk = Math.min(bk, Math.abs(x[i] - x[b - 1]) + Math.abs(y[i] - y[b - 1])); } long ab = Math.abs(x[b - 1] - x[a - 1]) + Math.abs(y[b - 1] - y[a - 1]); io.println(Math.min(ab, ak + bk));} Fill in the Matrix比赛时代码很乱，赛后总是可以优化成比较简单的形式。分类讨论，\\(n\\) 和 \\(m\\) 的大小关系，可以直接得出最大美丽值，需要注意特判 \\(m=1\\) 的情况。然后就是构造，当 \\(n\\leq m-1\\) 时，让一个从 \\(0\\) 开始的数组循环左移来构造行，这样可以保证得到最大美丽值；当 \\(n&gt;m-1\\) 时，前 \\(m-1\\) 行与之前一样构造，之后多余的行只需要和最后一行相同即可（保证不会影响美丽值）。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), m = io.nextInt(); if (m == 1) { io.println(0); } else if (n &lt;= m - 1) { io.println(n + 1); } else { io.println(m); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &lt; Math.min(n, m - 1)) { io.print((j + i) % m + &quot; &quot;); } else { io.print(j + &quot; &quot;); } } io.println(); }} Candy Party (Easy Version)找 BUG 花了半个小时，将判断 hi 是否是二的幂写成 hi % 2 != 0，修改为 Long.bitCount(hi) != 1 后通过，也可以写成 (hi &amp; hi - 1) != 0。因为每个人都需要发送和接收糖果，计算每个人和平均糖果数的差值 \\(x\\)，如果 \\(x\\) 的二进制位不是由连续的 \\(1\\) 组成，那么就无解，否则总是有唯一的 \\(lo\\) 和 \\(hi\\)（都是二的幂），使得 \\(hi-lo=|x|\\)。这样可以计算出每个人发送和接收多少糖果，如果最后相互抵消，则存在满足题目要求的交换方案。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); long lo = x &amp; -x, hi = x + lo; if (Long.bitCount(hi) != 1) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 0; i &lt; 32; i++) { if (cnt[i] != 0) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Candy Party (Hard Version)考虑什么人可以不发送或者不接收糖果，必定是持有糖果数与平均糖果数的差值为二的幂的人，它们比原来多出一种选择，就是只执行一次发送或接收。具体操作见代码，有点说不清。最后大概是从高位到低位遍历，如果当前位不满足条件，就将低一位的差值与平均糖果数为二的幂的数分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; int[] in = new int[32], out = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); if ((x &amp; x - 1) == 0) { int r = Long.numberOfTrailingZeros(x); if (a[i] &lt; avg) in[r]++; else out[r]++; continue; } long lo = x &amp; -x, hi = x + lo; if ((hi &amp; hi - 1) != 0) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 31; i &gt;= 0; i--) { cnt[i] += out[i] - in[i]; if (i == 0) break; in[i - 1] -= cnt[i]; out[i - 1] += cnt[i]; if (in[i - 1] &lt; 0 || out[i - 1] &lt; 0) { io.println(&quot;NO&quot;); return; } } io.println(cnt[0] == 0 ? &quot;YES&quot; : &quot;NO&quot;);}","link":"/2023/09/11/Codeforces%20Round%20896%20(Div.%202)/"},{"title":"Project #1 - Buffer Pool","text":"项目准备项目地址：Project #1 - Buffer Pool 准备工作：阅读 Chapter 12.1-12.4 13.2-13.3 24.2，学习 Lecture #03 #04，以及阅读课堂笔记。 项目结构buffer_pool_manager pages_ 数组相当于缓冲池，frame_id 是该数组的下标，也就唯一标识一个 Page，即标识一个缓冲页面。一个 Page 可以存储不同的物理页面，Page 的数据成员 page_id_ 唯一标识一个物理页面。因为不管是 FetchPage，还是 DeletePage 等函数，我们都是针对实际的物理页面做操作，所以 buffer_pool_manager 中的函数的形参都是提供 page_id。 lru_k_replacer 该类提供缓冲页面的淘汰策略，即淘汰某个 fram_id 对应的缓冲页面。一个缓冲页面会有一个对应的 LRUKNode，它负责记录该缓冲页面的访问历史。 page_guard 主要有三个类：BasicPageGuard，ReadPageGuard 和 WritePageGuard。BasicPageGuard 的作用是保证缓冲页面在使用完后会进行 UnpinPage 操作。而 ReadPageGuard 和 WritePageGuard，它们和 BasicPageGuard 是组合关系，它们的作用在 BasicPageGuard 的基础上保证页面在使用完后会解除读写锁。 Task #1 - LRU-K Replacement Policy实现① 一开始以为 current_timestamp_ 自动就是当前时间戳，调试时发现一直是 \\(0\\)，我真笨。可以直接从 \\(0\\) 开始手动模拟时间戳，调用 RecordAccess 时，让当前时间戳加 \\(1\\) 即可。 ② 在 Evict 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 frame，结果淘汰的是第一次访问时间最早的 frame。 ③ 在 ListNode 中使 history_ 的长度不超过 k_，如果超过就调用 pop_front()，这样每次获取之前第 k_ 个访问记录只需要调用 front() 函数。 ④ 在 RecordAccess 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 BufferPoolManager 构造函数的实现如下： 12345678// we allocate a consecutive memory space for the buffer poolpages_ = new Page[pool_size_];replacer_ = std::make_unique&lt;LRUKReplacer&gt;(pool_size, replacer_k);// Initially, every page is in the free list.for (size_t i = 0; i &lt; pool_size_; ++i) { free_list_.emplace_back(static_cast&lt;int&gt;(i));} 上述代码说明 frame_id 是小于 pool_size 的，所以大于等于 pool_size 的 fram_id 都应该抛出异常。（或许小于零的也应该抛出异常） 补充① 测试时将 DISABLED_SampleTest 改为 SampleTest。 ② 忘记 C++ 的 = 是拷贝，传引用加上 &amp;： 1auto node = node_store_.at(frame_id); // 错误：拷贝 ③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。 Task #2 - Buffer Pool Manager实现① NewPage 和 FetchPage 有很多逻辑相同的部分，可以加个辅助函数来获取 frame_id。 ② 注意，在 FetchPage 时，如果页面在内存中并且 pin_count_ = 0，则需要将其设置为不可淘汰的。 ③ 在 UnpinPage 中，更新 is_dirty 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。 ④ 在 FlushPage 中，注释表示 REGARDLESS of the dirty flag，应该说的是函数调用者，我们在实现时可以根据 is_dirty 来判断是否实际刷盘。 补充① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。 ② 实现 FetchPage 时，有个情况我忘记调用 RecordAccess，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。 Task #3 - Read/Write Page Guards实现① 使用移动构造和移动赋值后，需要清除 that 的元数据。 ② 移动赋值的调用者，也就是 this，如果其 page_ != nullptr，那么需要先将其 Drop，再进行赋值操作。 ③ 实现读写页面守卫的移动构造函数，可以直接赋值 std::move(that.guard_)，相当于调用之前实现的 BasicPageGuard 的移动赋值运算符。 ④ 实现读写页面守卫的 Drop 时，需要注意在调用 guard_.Drop() 之后再解锁页面，所以在 Drop 之前需要保存一下指向页面的指针。 ⑤ 在实现 BufferPoolManager 中的 FetchPageRead 和 FetchPageWrite 时，为页面加读写锁。 Leaderboard Task (Optional)准备性能分析 看到CMU 15-445 2023 P1 优化攻略中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 perf 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。 Brendan Gregg’s Homepage How to use flamegraphs for performance profiling profiling 与性能优化总结 speedscope LRU-K（对优化似乎没有帮助） 关于 LRU-K 的论文：The LRU-K Page Replacement Algorithm For Database Disk Buffering。 LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析。） 解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂。） LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。 LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（K≥2），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。 实现① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。 ② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 frame_id，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我。） ③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 bpm-bench 测试），结果发现是我理解有问题。尝试使用读写锁在 BufferPoolManager 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 Unknown 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 FetchPage 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。 ④ 参考CMU 15-445 2023 P1 优化攻略，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 ResetMemory 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还不错，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。 ⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 BufferPoolManager 之前析构 DiskManager，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。 ⑥ 本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 LRUKNode 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 Evict 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性。） Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 61 ALEX 111924 104867 261 484 5123 32 ALEX 102401 96293 4886 5221 57123 2 ALEX 120664 123402 182590 248050 2663116 12 ALEX 143562 133514 3813 8132 85169 调试① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。 ② 优化时容易出问题的点就是 NewPage 和 FetchPage，以及 UnpinPage。像是 FlushPage、FlushAllPage 以及 DeletePage 都可以暂时不管（可以直接 return），这样比较方便调试。 补充① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。 ② 遇到 Reference to non-static member function must be called 问题，解决方案在此。 ③ MySQL Buffer Pool 的实现 15.5.1 Buffer Pool。 测试结果测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。 优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。 每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行： 123456789#!/bin/bashmake lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)./test/lru_k_replacer_test./test/buffer_pool_manager_test./test/page_guard_testmake formatmake check-lintmake check-clang-tidy-p1make submit-p1 项目小结① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。 ② 一开始以为优化很需要技巧，写出来的话或许可以吹一吹。虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，bpm 优化也就是简单减少锁的粒度，lru 的优化也完全是针对基准测试做的，没太大意思（虽然一开始没想出来）。不过，死锁还是很难调试的。 ③ 我好菜啊！！！前三个任务花了两天，优化花了好几天。","link":"/2023/09/12/Project%201%20-%20Buffer%20Pool/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"CMU 15-445","slug":"课程/CMU-15-445","link":"/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"}],"pages":[{"title":"About","text":"","link":"/about/index.html"}]}