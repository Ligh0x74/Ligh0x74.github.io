{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/06/01/hello-world/"},{"title":"Java 快速输入输出","text":"输入 Scanner 会使用正则表达式解析输入，而 BufferedReader 直接读取输入，所以 Scanner 更慢。 输出 System.out（类型为 PrintStream）的 autoFlush 属性默认为 True，所以 System.out 更慢。 模板 1234567891011121314151617181920212223242526272829303132333435363738394041class FastIO extends PrintWriter { private BufferedReader br; private StringTokenizer st; public FastIO() { this(System.in, System.out); } public FastIO(InputStream in, OutputStream out) { super(out); br = new BufferedReader(new InputStreamReader(in)); } public FastIO(String input, String output) throws FileNotFoundException { super(output); br = new BufferedReader(new FileReader(input)); } public String next() { try { while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine()); return st.nextToken(); } catch (IOException e) { e.printStackTrace(); } return null; } public int nextInt() { return Integer.parseInt(next()); } public double nextDouble() { return Double.parseDouble(next()); } public long nextLong() { return Long.parseLong(next()); }} 测试 INOUTEST - Enormous Input and Output Test","link":"/2023/07/30/Java%20%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"title":"第 356 场力扣周赛","text":"满足目标工作时长的员工数目方法一：遍历 1234567class Solution { public int numberOfEmployeesWhoMetTarget(int[] hours, int target) { int ans = 0; for (int x : hours) if (x &gt;= target) ans++; return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 统计完全子数组的数目方法一：暴力优化 比赛时本来是想滑窗的，但是当时没想通。而枚举左右端点再遍历的暴力方法，时间复杂度为 \\(O(n^{3})\\) 会超时。结果想半天发现可以使用前缀和的思路，先枚举左端点，然后一边遍历一边枚举右端点。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(), ans = 0; // 至少要有 cnt 个元素 for (int i = 0; i &lt;= n - cnt; i++) { set.clear(); for (int j = i; j &lt; n; j++) { set.add(nums[j]); if (set.size() == cnt) { ans += n - j; break; } } } return ans; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：滑动窗口 枚举右端点，并且让窗口是完全子数组的前提下，使左端点尽可能靠右，此时所有小于等于左端点的位置，都满足条件。 1234567891011121314151617181920class Solution { public int countCompleteSubarrays(int[] nums) { int n = nums.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int x : nums) set.add(x); int cnt = set.size(); int lo = 0, hi = 0, ans = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (hi &lt; n) { map.merge(nums[hi++], 1, Integer::sum); if (map.size() == cnt) { while (map.get(nums[lo]) &gt; 1) { map.merge(nums[lo++], -1, Integer::sum); } ans += lo + 1; } } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 包含三个字符串的最短字符串方法一：枚举 枚举字符串 \\(a,b,c\\) 的全排列，然后从前往后合并，以消除公共字符。需要注意，如果字符串存在包含关系，则不需要进行合并操作。 123456789101112131415161718192021222324252627class Solution { public String minimumString(String a, String b, String c) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(merge(merge(a, b), c)); list.add(merge(merge(a, c), b)); list.add(merge(merge(b, a), c)); list.add(merge(merge(b, c), a)); list.add(merge(merge(c, a), b)); list.add(merge(merge(c, b), a)); list.sort((s1, s2) -&gt; { int m = s1.length(), n = s2.length(); if (m != n) return m - n; return s1.compareTo(s2); }); return list.get(0); } private String merge(String a, String b) { if (a.contains(b)) return a; int m = a.length(), n = b.length(); for (int i = Math.min(m, n); ; i--) { if (a.substring(m - i).equals(b.substring(0, i))) { return a + b.substring(i); } } }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)，其中 \\(n\\) 为字符串 \\(a,b,c\\) 长度的最大值。 空间复杂度：\\(O(n)\\)。 统计范围内的步进数字数目方法一：数位DP 感觉有点像 DFS，枚举当前位的数字，多传递一个参数 isLimit 可以省去很多判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { private static final int MOD = (int) 1e9 + 7; public int countSteppingNumbers(String low, String high) { int m = low.length(), n = high.length(); // dp[i][j] 表示 i 位数的最高位为 j 的步进数字的数目 int[][] dp = new int[n][10]; Arrays.fill(dp[0], 1); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { if (j - 1 &gt;= 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD; if (j + 1 &lt;= 9) dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } // 字符串不方便做减法，所以先减，如果 low 是步进数字则加回来 return (f(dp, high, 0, -1, true) - f(dp, low, 0, -1, true) + valid(low) + MOD) % MOD; } private int f(int[][] dp, String s, int i, int pre, boolean isLimit) { int n = s.length(); // 如果数字不为空，则计数值加一 if (i == n) return pre != -1 ? 1 : 0; if (pre != -1 &amp;&amp; !isLimit) return dp[n - i][pre]; int cur = s.charAt(i) - '0', res = 0; int hi = isLimit ? cur : 9; // 如果选 0 并且数字为空，则表示跳过当前位 for (int j = 0; j &lt;= hi; j++) { if (pre == -1 || Math.abs(j - pre) == 1) { res = (res + f(dp, s, i + 1, (pre == -1 &amp;&amp; j == 0) ? -1 : j, isLimit &amp;&amp; j == hi)) % MOD; } } return res; } private int valid(String s) { int n = s.length(); for (int i = 1; i &lt; n; i++) { if (Math.abs(s.charAt(i) - s.charAt(i - 1)) != 1) { return 0; } } return 1; }} 复杂度分析 时间复杂度：\\(O(nm^{2})\\)，其中 \\(n\\) 为 high 的长度，\\(m = 10\\)。 空间复杂度：\\(O(nm)\\)。","link":"/2023/07/31/%E7%AC%AC%20356%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 312","text":"Chord简单模拟，比赛时打错了一个字母。 12345public static void solve() { String s = io.next(); Set&lt;String&gt; set = Set.of(&quot;ACE&quot;, &quot;BDF&quot;, &quot;CEG&quot;, &quot;DFA&quot;, &quot;EGB&quot;, &quot;FAC&quot;, &quot;GBD&quot;); io.println(set.contains(s) ? &quot;Yes&quot; : &quot;No&quot;);} TaK Code因为左上角和右下角是中心对称的，所以判断右下角时可以使用形如 i + 8 - x 的下标来简化代码。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); String[] arr = new String[n]; for (int i = 0; i &lt; n; i++) arr[i] = io.next(); for (int i = 0; i + 8 &lt; n; i++) { for (int j = 0; j + 8 &lt; m; j++) { boolean ok = true; for (int x = 0; x &lt; 4; x++) { for (int y = 0; y &lt; 4; y++) { if (arr[i + x].charAt(j + y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } if (arr[i + 8 - x].charAt(j + 8 - y) != (x != 3 &amp;&amp; y != 3 ? '#' : '.')) { ok = false; } } } if (ok) io.println((i + 1) + &quot; &quot; + (j + 1)); } }} Invisible Hand其实第一眼看到感觉是可以二分做的，不过比赛时使用的是两个优先队列模拟解决的，边界想了半天，结果最优解很妙啊。我们要求最小的 \\(x\\)，使得可能卖 \\(x\\) 元的卖家数量 \\(f(x)\\) 大于等于可能花 \\(x\\) 元买的买家数量 \\(g(x)\\)。其实我们要求的就是使 \\(f(x)-g(x) &gt;= 0\\) 时的最小 \\(x\\)，而 \\(f(x) - g(x)\\) 是随 \\(x\\) 非严格递增的，当 \\(x = 0\\) 时，\\(f(x)-g(x)=-M\\)，并且答案的取值在 \\(A_{1},\\dots,A_{N},B_{1}+1,\\dots,B_{M}+1\\) 中，所以可以直接排序（或者快速选择），然后输出第 \\(M\\) 个数即为答案。 12345678910public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] arr = new int[n + m]; for (int i = 0; i &lt; n; i++) arr[i] = io.nextInt(); // 当价格大于买家的价格时，买家才会减一 for (int i = 0; i &lt; m; i++) arr[i + n] = io.nextInt() + 1; // 可以使用快速选择替换 Arrays.sort(arr); io.println(arr[m - 1]);} Count Bracket Sequences动态规划，不太会做。首先定义状态 \\(dp[i][j]\\)，表示区间 \\([1,i]\\) 中左括号比右括号多 \\(j\\) 个的方案数（也可以定义为其他形式）。然后写状态转移方程，可以画图看下转移方向，每层会分别向左下和右下转移 \\(n\\) 次，然后就可以写出不用特判边界的转移方程。还可以使用滚动数组优化空间，此处略过。 1234567891011121314151617private static final int MOD = 998244353;public static void solve() { String s = io.next(); int n = s.length(); // dp[i][j] 表示区间 [1, i] 中左括号比右括号多 j 个的方案数 int[][] dp = new int[n + 1][n + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { char c = s.charAt(i - 1); for (int j = 0; j &lt; n; j++) { if (c != ')') dp[i][j + 1] = dp[i - 1][j]; if (c != '(') dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD; } } io.println(dp[n][0]);}","link":"/2023/07/31/AtCoder%20Beginner%20Contest%20312/"},{"title":"Codeforces Round 889 (Div. 2)","text":"Dalton the Teacher如果伤心的学生有 \\(x\\) 个，则答案为 \\(\\lceil \\frac{x}{2}\\rceil\\)。步骤如下：如果至少有两个伤心的学生，则交换他们的椅子；如果只有一个伤心的学生，则让他和任意其他学生交换椅子。 123456789public static void solve() { int n = io.nextInt(), cnt = 0; for (int i = 1; i &lt;= n; i++) { if (i == io.nextInt()) { cnt++; } } io.println((cnt + 1) / 2);} Longest Divisors Interval这道题感觉很妙啊，比赛时看到 \\(n\\) 的范围很大，所以猜了一个结论也没有细想，结果是对的。假设我们已经找到区间 \\([l,r]\\) 对每个满足 \\(l\\leq i\\leq r\\) 的 \\(i\\)，\\(n\\bmod i=0\\)。然后我们可以将区间 \\([l,r]\\) 转化为区间 \\([1,r-l+1]\\)，因为对每个满足 \\(1\\leq x\\leq r-l+1\\) 的 \\(x\\)，在区间 \\([l,r]\\) 中总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)，因而也满足 \\(n\\bmod x=0\\)。 为什么总是可以找到呢？因为一个连续的数列，对 \\(x\\) 取余得到的余数的周期为 \\(x\\)，所以一个长度为 \\(x\\) 的区间内，总是可以找到一个数 \\(y\\)，使得 \\(y\\bmod x=0\\)。 时间复杂度 \\(O(\\log{(\\max n)})\\)，具体不知道怎么算的。 123456789public static void solve() { long n = io.nextLong(); for (int i = 1; ; i++) { if (n % i != 0) { io.println(i - 1); return; } }} Dual (Easy Version), Dual (Hard Version)比赛时想到找最大或最小的数和倍增，但是没弄明白。首先，如果所有数都非负或非正，那么只要做前缀或后缀和就可以得到非递减的数组，最多操作 \\(19\\) 次。此时我们还剩下 \\(31-19=12\\) 次操作机会，我们考虑如何在 \\(12\\) 次操作内把数组中的数都变为非负或非正： 当最大的正数加最小的负数大于等于零时：如果负数的数量小于等于 \\(12\\)，那么我们可以在 \\(12\\) 次操作内把所有负数变为正数；反之，我们可以选择一个负数让它倍增 \\(5\\) 次，它就会变为最小的负数，并且最大的正数加最小的负数一定小于零，然后我们就可以在 \\(7\\) 次操作内把所有正数变为负数（因为此时正数的数量小于 \\(7\\)）。 当最大的正数加最小的负数小于等于零时：同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; int minPos = 0, maxPos = 0, neg = 0, pos = 0; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); if (arr[i] &lt; 0) neg++; if (arr[i] &gt; 0) pos++; if (arr[i] &lt; arr[minPos]) minPos = i; if (arr[i] &gt; arr[maxPos]) maxPos = i; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); if (arr[minPos] + arr[maxPos] &gt;= 0) { if (neg &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{minPos, minPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } } else { if (pos &lt;= 12) { for (int i = 0; i &lt; n; i++) { if (arr[i] &gt; 0) { ans.add(new int[]{i, minPos}); } } for (int i = n - 2; i &gt;= 0; i--) { ans.add(new int[]{i, (i + 1)}); } } else { for (int i = 0; i &lt; 5; i++) { ans.add(new int[]{maxPos, maxPos}); } for (int i = 0; i &lt; n; i++) { if (arr[i] &lt; 0) { ans.add(new int[]{i, maxPos}); } } for (int i = 0; i &lt; n - 1; i++) { ans.add(new int[]{(i + 1), i}); } } } io.println(ans.size()); ans.forEach(k -&gt; io.println((k[0] + 1) + &quot; &quot; + (k[1] + 1)));} Earn or Unlock每种方案都有一个可以到达的最远位置 \\(x\\)，对于该位置我们能够得到的点数是确定的，即为 \\(\\sum_{i=0}^{x}a_{i} - x\\) 点。所以我们只需要枚举每一个最远位置就能够解决问题，如果使用 DFS 时间复杂度是指数级别的，通过使用状压 DP 可以降低时间复杂度。假设当前枚举到位置 \\(i\\)，当前的可达位置是 \\(dp_{i}\\)，那么下一个可达位置就是 \\(dp_{i+1}=dp_{i}|(dp_{i}&lt;&lt;a_{i})\\)，然后如果当前位置可达，我们计算完答案之后需要将当前位置置为 \\(0\\)，因为对于下一个位置来说，当前位置已经解锁。如果使用 C++ 实现可以直接使用 \\(bitset\\)，而使用 Java 实现则需要手动写位图，因为 Java 内置的位图没有移位操作。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[] arr = new int[2 * n + 1]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } // 位图 int m = n * 2 / 64 + 1; long[] dp = new long[m]; long[] dq = new long[m]; dp[0] = 1L; long sum = 0L, ans = 0L; for (int i = 0; i &lt; 2 * n; i++) { sum += arr[i]; // 位图左移 arr[i] 位，并且或上它本身 int p = arr[i] / 64, q = arr[i] % 64; for (int j = 0; j &lt; m; j++) { dq[j] = dp[j]; if (j &gt;= p) { dq[j] |= dp[j - p] &lt;&lt; q; if (j &gt; p &amp;&amp; q &gt; 0) dq[j] |= dp[j - p - 1] &gt;&gt;&gt; (64 - q); } } long[] tmp = dp; dp = dq; dq = tmp; // 判断当前位是否可达 p = i / 64; q = i % 64; if (((dp[p] &gt;&gt; q) &amp; 1) == 1) { dp[p] ^= 1L &lt;&lt; q; ans = Math.max(ans, sum - i); } } io.println(ans);}","link":"/2023/08/02/Codeforces%20Round%20889%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 313","text":"To Be Saikyo简单模拟。 1234567public static void solve() { int n = io.nextInt(), x = io.nextInt(), max = 0; for (int i = 1; i &lt; n; i++) { max = Math.max(max, io.nextInt()); } io.println(Math.max(max - x + 1, 0));} Who is Saikyo?如果 \\(A\\) 比 \\(B\\) 强，则让 \\(B\\) 的入度加一，最后入度为零的程序员就是最强的，如果多于一个那么返回 \\(-1\\) 。 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n + 1]; for (int i = 0; i &lt; m; i++) { int u = io.nextInt(), v = io.nextInt(); in[v]++; } int ans = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) { if (in[i] == 0) { ans = i; cnt++; } } io.println(cnt == 1 ? ans : -1);} Approximate Equalization 2假设我们将数组 \\(A\\) 执行最少操作后得到数组 \\(B\\) ，那么 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 就是最小操作次数，因为必定有 \\(\\sum_{i=1}^{N}A_{i}=\\sum_{i=1}^{N}B_{i}\\) ，所以上述公式一定可以被二整除。题目要求 \\(B\\) 的最大值和最小值的差最多为一，那么 \\(B\\) 一定由 \\(N-r\\) 个 \\(p\\) ，以及 \\(r\\) 个 \\(p+1\\) 组成，其中 \\(p=\\frac{\\sum_{i=1}^{N}B_{i}}{N},r=\\sum_{i=1}^{N}B_{i}\\bmod N\\) 。然后问题就变为如何组织 \\(A_{i}\\) 和 \\(B_{i}\\) 的对应关系，使得 \\(\\frac{\\sum_{i=1}^{N}|A_{i}-B{i}|}{2}\\) 最小。显然对数组 \\(A\\) 进行升序排序，那么数组 \\(B\\) 的 \\(N-r\\) 个 \\(p\\) 对应 \\(A\\) 的前 \\(N-r\\) 个元素，数组 \\(B\\) 的 \\(r\\) 个 \\(p+1\\) 对应 \\(A\\) 的后 \\(r\\) 个元素，这样排列会使得操作次数最小。 PS：比赛时没什么思路，猜了个平均数，然后没有排序通过遍历比较大小来计算操作次数，结果和正解殊途同归了。 12345678910111213141516public static void solve() { int n = io.nextInt(); long sum = 0L; int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); sum += arr[i]; } // 可以替换为快速选择 Arrays.sort(arr); long ans = 0L, p = sum / n, r = sum % n; for (int i = 0; i &lt; n; i++) { ans += Math.abs(arr[i] - (p + (i &gt;= n - r ? 1 : 0))); } io.println(ans / 2);} Odd or Even每次查询的返回值可以看作 \\(A_{x_{1}}\\oplus A_{x_{2}}\\oplus \\cdots \\oplus A_{x_{k}}\\) ，所以我们可以首先对前 \\(k+1\\) 个数进行 \\(k+1\\) 次查询，然后把所有查询结果异或，可以得到前 \\(k+1\\) 个数的异或值（因为在 \\(k+1\\) 次查询中，每个数出现 \\(k\\) 次，并且 \\(k\\) 是奇数），将该异或值分别与之前的查询结果异或，可以得到前 \\(k+1\\) 个数的值。之后的操作类似，就是查询然后异或，得到后面的所有值。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(), k = io.nextInt(), xor = 0; List&lt;Integer&gt; aux; int[] ans = new int[n]; for (int i = 0; i &lt;= k; i++) { aux = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= k; j++) { if (i != j) aux.add(j); } ans[i] = query(aux); xor ^= ans[i]; } for (int i = 0; i &lt;= k; i++) ans[i] ^= xor; xor ^= ans[k] ^ ans[k - 1]; aux = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; k; i++) aux.add(i); for (int i = k + 1; i &lt; n; i++) { aux.set(k - 1, i); ans[i] = query(aux) ^ xor; } io.print(&quot;! &quot;); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static int query(List&lt;Integer&gt; aux) { io.print(&quot;? &quot;); for (int x : aux) { io.print(x + 1 + &quot; &quot;); } io.println(); io.flush(); return io.nextInt();}","link":"/2023/08/07/AtCoder%20Beginner%20Contest%20313/"},{"title":"第 110 场力扣夜喵双周赛","text":"取整购买后的账户余额方法一：模拟 比赛时没看明白，写复杂了一点。 12345class Solution { public int accountBalanceAfterPurchase(int purchaseAmount) { return 100 - (purchaseAmount + 5) / 10 * 10; }} 复杂度分析 时间复杂度：\\(O(1)\\)。 空间复杂度：\\(O(1)\\)。 在链表中插入最大公约数方法一：模拟 123456789101112131415class Solution { public ListNode insertGreatestCommonDivisors(ListNode head) { ListNode cur = head; while (cur.next != null) { cur.next = new ListNode(gcd(cur.val, cur.next.val), cur.next); cur = cur.next.next; } return head; } private int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }} 复杂度分析 时间复杂度：\\(O(n\\log m)\\)，其中 \\(m\\) 表示节点的最大值。 空间复杂度：\\(O(1)\\)。 使循环数组所有元素相等的最少秒数方法一：枚举 假设最后数组中的元素是 \\(x\\)，那么需要的最少秒数就是所有值为 \\(x\\) 的元素之间的最大间距的一半向上取整。由于数组是循环数组，我们可以在遍历时添加两次，或者在处理哈希表中的列表时特殊处理最后一个元素与第一个元素的间距。 123456789101112131415161718class Solution { public int minimumSeconds(List&lt;Integer&gt; nums) { int n = nums.size(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 2 * n; i++) { map.computeIfAbsent(nums.get(i % n), k -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = Integer.MAX_VALUE; for (var list : map.values()) { int m = list.size(), max = 0; for (int i = 0; i &lt; m - 1; i++) { max = Math.max(max, list.get(i + 1) - list.get(i) - 1); } ans = Math.min(ans, (max + 1) / 2); } return ans; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 使数组和小于等于 x 的最少时间方法一：动态规划 比赛时其实很多点都想到了，当时遇到的问题就是不知道如何对 \\(nums1[i]+nums2[i]\\times t\\) 排序，没想到要用动态规划，而且动态规划的建模方式有点技巧性，利用了排序来确定选择的第 \\(j\\) 个数就是在时间 \\(j\\) 操作的数。 状态定义：\\(dp[i][j]\\) 表示从前 \\(i\\) 个数中选择 \\(j\\) 个数进行操作，可以使元素和减少的最大值（相对于不进行任何操作）。因为我们将 \\(aux\\) 按照 \\(nums_{2}\\) 从小到大排序，所以如果 \\(i\\) 是选择的第 \\(j\\) 个数，那么就表示在时间 \\(j\\) 操作 \\(i\\)，因此减少的时间为 \\(nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j\\)。 状态转移方程：\\(dp[i+1][j]=\\max(dp[i][j],dp[i][j-1]+nums_{1}[aux[i]]+nums_{2}[aux[i]]\\times j)\\)。 可以将空间复杂度优化为 \\(O(n)\\)，此处略过。 1234567891011121314151617181920212223242526class Solution { public int minimumTime(List&lt;Integer&gt; nums1, List&lt;Integer&gt; nums2, int x) { int n = nums1.size(), sum1 =0, sum2 = 0; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; sum1 += nums1.get(i); sum2 += nums2.get(i); } Arrays.sort(aux, (a, b) -&gt; nums2.get(a) - nums2.get(b)); // 动态规划 int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = n; j &gt; 0; j--) { dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - 1] + nums1.get(aux[i]) + nums2.get(aux[i]) * j); } } // 枚举答案 for (int i = 0; i &lt;= n; i++) { if (sum1 + sum2 * i - dp[n][i] &lt;= x) { return i; } } return -1; }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n^{2})\\)。","link":"/2023/08/07/%E7%AC%AC%20110%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 357 场力扣周赛","text":"故障键盘方法一：暴力模拟 比赛直接暴力模拟。 12345678910class Solution { public String finalString(String s) { StringBuilder sb = new StringBuilder(); for (char c : s.toCharArray()) { if (c != 'i') sb.append(c); else sb.reverse(); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(n)\\)。 方法二：双端队列 123456789101112131415161718class Solution { public String finalString(String s) { int n = s.length(); boolean reverse = false; Deque&lt;Character&gt; q = new LinkedList&lt;&gt;(); for (char c : s.toCharArray()) { if (c == 'i') reverse = !reverse; else if (reverse) q.offerFirst(c); else q.offerLast(c); } StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { if (reverse) sb.append(q.pollLast()); else sb.append(q.pollFirst()); } return sb.toString(); }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(n)\\)。 判断是否能拆分数组方法一：正难则反 题目要求将数组拆分为单个元素，因为从拆分角度不太好模拟，所以可以考虑怎么将单个元素合并为整个数组。如果数组长度小于等于 \\(2\\)，则必定满足要求。如果数组长度大于 \\(2\\)，要想将所有元素合并成完整的数组，则必须有一个大于等于 \\(m\\) 的合并。 123456789101112class Solution { public boolean canSplitArray(List&lt;Integer&gt; nums, int m) { int n = nums.size(); if (n &lt;= 2) return true; for (int i = 1; i &lt; n; i++) { if (nums.get(i) + nums.get(i - 1) &gt;= m) { return true; } } return false; }} 复杂度分析 时间复杂度：\\(O(n)\\)。 空间复杂度：\\(O(1)\\)。 找出最安全路径纯暴力做法是使用 \\(O(n^{2})\\) 的时间判断当前点的的安全系数是否大于等于指定的安全系数，总时间复杂度是 \\(O(n^{4}\\log n)\\)。而我在比赛时预处理了一下小偷的位置，最坏情况其实也是 \\(O(n^{4}\\log n)\\)，结果通过了，我想大概是因为如果小偷的数量很多，那么 BFS 的限制就多，如果小偷的数量很少，那么 BFS 的限制就少，所以复杂度也不会真的到达最坏情况吧。比较好的做法是多源 BFS + 二分，以每个小偷为起点进行多源 BFS，标记每个位置的最小安全系数，然后在二分的 BFS 时就可以花 \\(O(1)\\) 的时间判断当前点是否合法。 方法一：多源 BFS + 二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { int n; int[][] dis; int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; public int maximumSafenessFactor(List&lt;List&lt;Integer&gt;&gt; grid) { n = grid.size(); // 以每个小偷为起点进行多源 BFS dis = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dis[i], -1); } Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid.get(i).get(j) == 1) { dis[i][j] = 0; q.offer(new int[]{i, j}); } } } while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || dis[nx][ny] &gt;= 0) continue; dis[nx][ny] = dis[x][y] + 1; q.offer(new int[]{nx, ny}); } } // 二分答案 int lo = 0, hi = Math.min(dis[0][0], dis[n - 1][n - 1]); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (check(mid)) lo = mid + 1; else hi = mid - 1; } return hi; } private boolean check(int mid) { boolean[][] vis = new boolean[n][n]; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.offer(new int[]{0, 0}); vis[0][0] = true; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny] || dis[nx][ny] &lt; mid) continue; vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } return vis[n - 1][n - 1]; }} 复杂度分析 时间复杂度：\\(O(n^{2}\\log n)\\)。 空间复杂度：\\(O(n^{2})\\)。 子序列最大优雅度方法一：贪心 刚看见题目不知道怎么做，想了想动态规划好像不太行，一个是时间复杂度不行，一个是找不到递推关系（感觉）。然后就想这个数据量，可以排序试一下，然后不知怎么就想到正确答案了。首先贪心取利润最大的 \\(k\\) 个元素，然后每当遇到一个未选过的类别，则用其替换之前的重复类别中的利润最小的元素，每次计算都更新答案。具体分析如下： 如果第 \\(k+1\\) 个元素的类别是重复的，那么使用其替换之前的元素不会使优雅度变大，因为 distinct_categories 不变，并且数组元素按照利润降序排列，所以 total_profit 可能会变小或者不变。 反之，我们可以尝试使用当前元素替换之前的元素：① 如果替换之前不重复的元素，那么显然不会优雅度不会变大；② 如果替换之前重复的元素，那么肯定优先选择利润最小的重复元素，distinct_categories 变大，total_profit 变小，优雅度有变大的可能。 反复执行上述操作，就一定可以遍历到最优的情况。比赛时代码很乱，赛后参考了灵神的代码。 1234567891011121314151617181920class Solution { public long findMaximumElegance(int[][] items, int k) { int n = items.length; long ans = 0, sum = 0; Arrays.sort(items, (a, b) -&gt; b[0] - a[0]); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { int profit = items[i][0], category = items[i][1]; if (i &lt; k) { sum += profit; if (!set.add(category)) q.push(profit); } else if (!q.isEmpty() &amp;&amp; set.add(category)) { sum += profit - q.pop(); } ans = Math.max(ans, sum + (long) set.size() * set.size()); } return ans; }} 复杂度分析 时间复杂度：\\(O(n\\log n)\\)。 空间复杂度：\\(O(n)\\)。","link":"/2023/08/07/%E7%AC%AC%20357%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"禁用编译器扩展以确保程序符合 C++ 标准","text":"g++ 编译器可以通过添加 -pedantic-errors 选项来禁用扩展： 1g++ main.cpp -pedantic-errors 程序示例： 12345int main() { int n = 1024; int a[n]; return 0;} 运行结果： 12// 禁用前正常运行error: ISO C++ forbids variable length array 'a' // 禁用后报错","link":"/2023/08/12/%E7%A6%81%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E7%A1%AE%E4%BF%9D%E7%A8%8B%E5%BA%8F%E7%AC%A6%E5%90%88%20C++%20%E6%A0%87%E5%87%86/"},{"title":"Codeforces Round 891 (Div. 3)","text":"Array Coloring要将数组分为奇偶性相同的两部分，那么奇数的个数一定要是偶数。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n; i++) { sum += io.nextInt(); } io.println(sum % 2 == 0 ? &quot;YES&quot; : &quot;NO&quot;);} Maximum Rounding题目有点难读，其实就是大于等于 \\(5\\) 的数可以向前进位，并且包括自己在内的所有低位全部置为 \\(0\\)。 123456789101112public static void solve() { char[] s = io.next().toCharArray(); int n = s.length, c = 0, p = n; for (int i = n - 1; i &gt; 0; i--) { if (s[i] &gt;= '5') { s[i - 1]++; p = i; } } if (s[0] &gt;= '5') io.println(&quot;1&quot; + &quot;0&quot;.repeat(n)); else io.println(new String(s, 0, p) + &quot;0&quot;.repeat(n - p));} Assembly via Minimums对数组排序，最小值会出现 \\(n - 1\\) 次，次小值会出现 \\(n - 2\\) 次，以此类推，次大值出现 \\(1\\) 次，最大值出现 \\(0\\) 次，所以最后需要补一个最大值。 123456789101112public static void solve() { int n = io.nextInt(), m = n * (n - 1) / 2; int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); for (int i = 0; i &lt; m; i += --n) { io.print(b[i] + &quot; &quot;); } io.println(b[m - 1]);} Strong Vertices将公式变形，易知 \\(a_{u} - b_{u}\\) 的值最大的元素是强壮的。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int max = Integer.MIN_VALUE, cnt = 0; for (int i = 0; i &lt; n; i++) { a[i] -= io.nextInt(); if (a[i] &gt; max) { max = a[i]; cnt = 1; } else if (a[i] == max) { cnt++; } } io.println(cnt); for (int i = 0; i &lt; n; i++) { if (a[i] == max) { io.print(i + 1 + &quot; &quot;); } } io.println();} Power of Points对于每个 \\(x_{i}\\) 构成的区间，\\(\\sum_{p=1}^{10^9}f_{p}\\) 表示所有区间包含的元素的个数的和。暴力计算的时间复杂度是 \\(O(n^{2})\\)，但是我们可以考虑 \\(x\\) 从从小到大转移时，元素个数的变化量，从而使用 \\(O(n\\log n)\\) 的时间复杂度计算出所有答案。（也可以像官解一样推公式） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); long sum = 0L; int[] x = new int[n]; Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); sum += x[i]; aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; x[i] - x[j]); long[] ans = new long[n]; ans[aux[0]] = sum -= (long) n * (x[aux[0]] - 1); for (int k = 1; k &lt; n; k++) { sum += (long) (k - (n - k)) * (x[aux[k]] - x[aux[k - 1]]); ans[aux[k]] = sum; } for (long s : ans) io.print(s + &quot; &quot;); io.println();} Sum and Product解方程。。因为要求是整数解，所以根号下必须是完全平方数。还有要注意 \\(\\Delta\\) 小于零的情况，不过 Java 的开根函数在小于零的情况下会返回 NaN，转成整数就是零，在该题目的判断中不会引发问题，但还是最好特判一下。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge((long) io.nextInt(), 1, Integer::sum); } int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { long x = io.nextInt(), y = io.nextLong(); long d = x * x - 4 * y, s = (long) Math.sqrt(d); if (d &lt; 0 || s * s != d) { io.print(0 + &quot; &quot;); continue; } long c1 = map.getOrDefault((x + s) / 2, 0); long c2 = map.getOrDefault((x - s) / 2, 0); if (s != 0) io.print(c1 * c2 + &quot; &quot;); else io.print(c1 * (c1 - 1) / 2 + &quot; &quot;); } io.println();} Counting Graphs如果要在 \\(u\\) 和 \\(v\\) 之间添加一条边，那么首先要求 \\(u\\) 和 \\(v\\) 之间没有直接相连的边，并且新添加的边的权重要大于 \\(w\\) 小于 \\(S\\)，这样才能保证最小生成树是给定的树。暴力求解的时间复杂度是 \\(O(n^{2})\\)，我们可以利用 Kruskal 算法优化，对边按权重从小到大排序，然后在连接两个顶点时计算两棵树之间顶点连接的方案数，将所有计算结果相乘就是答案。 12345678910111213141516171819private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), S = io.nextInt(); List&lt;int[]&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt(), v = io.nextInt(), w = io.nextInt(); edges.add(new int[]{u, v, w}); } edges.sort((a, b) -&gt; a[2] - b[2]); long ans = 1L; UnionFind uf = new UnionFind(n + 1); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2]; ans = (ans * fastPower(S - w + 1, (long) uf.size(u) * uf.size(v) - 1)) % MOD; uf.union(u, v); } io.println(ans);}","link":"/2023/08/14/Codeforces%20Round%20891%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 314","text":"3.1412345public static void solve() { String s = &quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;; int n = io.nextInt(); io.println(s.substring(0, n + 2));} Roulette12345678910111213141516171819public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] arr = new List[37]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); int[] cnt = new int[n]; for (int i = 0; i &lt; n; i++) { cnt[i] = io.nextInt(); for (int j = 0; j &lt; cnt[i]; j++) { arr[io.nextInt()].add(i); } } int x = io.nextInt(), min = 37; for (int i : arr[x]) min = Math.min(min, cnt[i]); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i : arr[x]) if (cnt[i] == min) ans.add(i); io.println(ans.size()); for (int t : ans) io.print(t + 1 + &quot; &quot;); io.println();} Rotate Colored Subsequence123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); List&lt;Integer&gt;[] arr = new List[m]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { arr[io.nextInt() - 1].add(i); } for (var v : arr) { if (v.size() == 0) continue; char c = s[v.get(v.size() - 1)]; for (int i = v.size() - 2; i &gt;= 0; i--) { s[v.get(i + 1)] = s[v.get(i)]; } s[v.get(0)] = c; } io.println(new String(s));} LOWER记录时间，每次进行全局操作时将当前时间加一，并记录操作的编号，每次进行局部操作时将对应位置的操作时间更新为当前时间。如果最后某个位置的时间小于当前时间，则需要变换大小写；否则，不需要变换大小写。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); int[] time = new int[n]; int q = io.nextInt(), curTime = 0, flag = 0; while (q-- != 0) { int t = io.nextInt(), x = io.nextInt() - 1; char c = io.next().charAt(0); if (t == 1) { s[x] = c; time[x] = curTime; } else { flag = t; curTime++; } } for (int i = 0; i &lt; n; i++) { if (time[i] &lt; curTime) { if (flag == 2) s[i] = Character.toLowerCase(s[i]); else s[i] = Character.toUpperCase(s[i]); } } io.println(new String(s));}","link":"/2023/08/14/AtCoder%20Beginner%20Contest%20314/"},{"title":"Codeforces Round 892 (Div. 2)","text":"United We Stand要使数组 \\(c_{j}\\) 不是 \\(b_{i}\\) 的约数，只要让数组 \\(b\\) 中只存最小的数，或者让数组 \\(c\\) 中只存最大的数，就可以满足要求。特别的，如果所有数都相等，那么不存在解。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = io.nextInt(); } Arrays.sort(arr); if (arr[0] == arr[n - 1]) { io.println(-1); return; } int it = 0; while (arr[it] == arr[0]) it++; io.println(it + &quot; &quot; + (n - it)); for (int i = 0; i &lt; it; i++) io.print(arr[i] + &quot; &quot;); io.println(); for (int i = it; i &lt; n; i++) io.print(arr[i] + &quot; &quot;); io.println();} Olya and Game with Arrays要最大化 \\(\\sum_{i=1}^{n}\\min_{j=1}^{m_{i}}a_{i,j}\\)，一开始想到最大化最小值，二分？但是有点不太对。然后发现规律，只需要关注数组的最小值和次小值就行。首先所有数组的最小值的最小值一定会被包含在内，这样只要把其他数组的最小值移动到该最最小值所属的数组就可以让答案最大。也就是说答案等于所有数组次小值的和加上最最小值，再减去最最小值对应的次小值。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; long sum = 0; List&lt;Integer&gt;[] arr = new List[n]; Arrays.setAll(arr, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int m = io.nextInt(); for (int j = 0; j &lt; m; j++) { arr[i].add(io.nextInt()); } // 可以不排序，直接遍历找 Collections.sort(arr[i]); sum += arr[i].get(1); min1 = Math.min(min1, arr[i].get(0)); min2 = Math.min(min2, arr[i].get(1)); } io.println(sum - min2 + min1);} Another Permutation Problem题目要求 \\((\\sum_{i=1}^{n}p_{i}\\cdot i)-(\\max_{j=1}^{n}p_{j}\\cdot j)\\) 的最大值，前半部分的最大值的情况就是从小到大排列，但是后半部分不好处理，所以考虑枚举后半部分。从大到小枚举 \\(\\max_{j=1}^{n}p_{j}\\cdot j\\) 的值，然后在不超过该值的情况下尽可能使 \\(\\sum_{i=1}^{n}p_{i}\\cdot i\\) 的值变大。要让求和的部分变大，也就是让大的 \\(p\\) 尽可能靠后，可以使用 \\(\\frac{\\max_{j=1}^{n}p_{j}\\cdot j}{p}\\) 求得 \\(p\\) 可以放置的最大 \\(i\\) 是多少，然后如果该位置已经占用，那么就向左寻找第一个未占用的位置。我们可以使用并查集维护位置的占用情况，如果当前位置占用就将它和左边的位置合并，这样 find(Math.min(n, i)) 就是左边第一个的未占用的位置。如果可以放置的位置不存在，那么说明枚举值太小，终止枚举。（也可以使用栈来维护位置的占用情况） 12345678910111213141516171819202122232425262728293031323334private static int[] f;private static int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x];}public static void solve() { int n = io.nextInt(), ans = 0; // 枚举公式的后半部分的值 for (int mx = n * n; mx &gt;= 1; mx--) { int sum = 0; boolean ok = true; f = new int[n + 1]; for (int i = 0; i &lt;= n; i++) { f[i] = i; } // 枚举排列的值 for (int i = n; i &gt;= 1; i--) { // 该值可以放置的最大位置 int x = find(Math.min(n, mx / i)); if (x == 0) { ok = false; break; } sum += i * x; // 当前位置已占用，f[x] 存储左边可以放置的第一个位置 f[x] = f[x - 1]; } if (!ok) break; ans = Math.max(ans, sum - mx); } io.println(ans);} 还有一个解法，但是不知道如何证明正确性，也是可以过的。其实比赛的时候我就猜了这个结论，但是当时没试。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; // 枚举一个位置，然后反转它以及它后面的值 for (int i = 1; i &lt;= n; i++) { int sum = 0, max = 0; for (int j = 1; j &lt;= n; j++) { int x = j &lt; i ? j : n - j + i; sum += x * j; max = Math.max(max, x * j); } ans = Math.max(ans, sum - max); } io.println(ans);} Andrey and Escape from Capygrad首先，显然向左传送不会比向右传送到达更远的地方。考虑只有一个区间的情况：如果起点在 \\([l,b]\\) 之间，那么可以最远到达 \\(b\\) 点；如果起点在 \\((b,r]\\) 之间（即不在 \\([l,b]\\) 之间），那么当前点就是最远的点。可以发现，能够到达的最远位置只与 \\(l\\) 和 \\(b\\)，以及起点位置有关。所以考虑将所有区间 \\([l,b]\\) 合并，对每个查询都查找当前起点所在的区间。如果在某个区间内，最远位置即为该区间的右端点；如果不在任何区间内，那么最远位置即为当前位置。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); int[][] portals = new int[n][2]; // 只需要考虑 l 和 b for (int i = 0; i &lt; n; i++) { portals[i][0] = io.nextInt(); io.nextInt(); io.nextInt(); portals[i][1] = io.nextInt(); } // 区间合并 Arrays.sort(portals, (a, b) -&gt; a[0] - b[0]); List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;(); intervals.add(new int[]{Integer.MIN_VALUE, Integer.MIN_VALUE}); for (int i = 0; i &lt; n; i++) { int m = intervals.size(); if (intervals.get(m - 1)[1] &lt; portals[i][0]) { intervals.add(new int[]{portals[i][0], portals[i][1]}); } else { intervals.get(m - 1)[1] = Math.max(intervals.get(m - 1)[1], portals[i][1]); } } // 二分找区间 int q = io.nextInt(); for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); int lo = 0, hi = intervals.size() - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (intervals.get(mid)[0] &gt; x) hi = mid - 1; else lo = mid + 1; } io.print(Math.max(x, intervals.get(hi)[1]) + &quot; &quot;); } io.println();}","link":"/2023/08/14/Codeforces%20Round%20892%20(Div.%202)/"},{"title":"第 358 场力扣周赛","text":"数组中的最大数对和赛时直接暴力做，赛后优化代码参考自灵神。就是维护每个最大数位对应的最大值，然后可以优化掉一个 \\(n\\)。 12345678910111213141516class Solution { public int maxSum(int[] nums) { int ans = -1; int[] maxVal = new int[10]; Arrays.fill(maxVal, Integer.MIN_VALUE); for (int x : nums) { int maxD = 0; for (int y = x; y &gt; 0; y /= 10) { maxD = Math.max(maxD, y % 10); } ans = Math.max(ans, x + maxVal[maxD]); maxVal[maxD] = Math.max(maxVal[maxD], x); } return ans; }} 翻倍以链表形式表示的数字做乘法惯性思维，就想着从最低位开始乘然后进位，结果可以从高位开始乘，因为乘二时低位最多就进一位。（如果从低位开始乘，就转数组或者反转链表吧） 123456789101112class Solution { public ListNode doubleIt(ListNode head) { if (head.val &gt; 4) head = new ListNode(0, head); for (ListNode cur = head; cur != null; cur = cur.next) { cur.val = cur.val * 2 % 10; if (cur.next != null &amp;&amp; cur.next.val &gt; 4) { cur.val++; } } return head; }} 限制条件下元素之间的最小绝对差一开始没反应过来，以为找最大值和最小值就行。结果发现是让绝对值最小，要找最接近当前值的那个值，那就可以使用 TreeSet。但是我又搞复杂了，其实只要维护一个方向就可以，但是我维护了左右方向距离为 \\(x\\) 的值。 1234567891011121314class Solution { public int minAbsoluteDifference(List&lt;Integer&gt; nums, int x) { int n = nums.size(), ans = Integer.MAX_VALUE; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(Integer.MAX_VALUE); set.add(Integer.MIN_VALUE / 2); for (int i = x; i &lt; n; i++) { set.add(nums.get(i - x)); int cur = nums.get(i); ans = Math.min(ans, Math.min(cur - set.floor(cur), set.ceiling(cur) - cur)); } return ans; }} 操作使得分最大吐血吐血，赛后 Debug 发现分解质因数的代码打错一个变量，改了就能 AC。一开始也看错题目了，以为答案是乘质数分数，结果答案是乘数组中的值，那么优先选最大的数就是最优的。问题就变成给定某个数，选择它为目标值的数组有多少个。数组的个数等于左边质数分数小于当前值能到达的最远位置，乘右边质数分数大于等于当前值能到达的最远位置。所以我们可以先对质数分数降序排序，相同分数再对下标升序排序，按照这个顺序处理元素，使用 TreeSet 维护已处理的值，就可以比较方便的得到左右两边的边界，从而得到以当前值为目标值的数组个数。最后，按照值从大到小来做乘法。 计算每个位置有多少数组还可以使用单调栈（更快），详情见题解区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { private static final int MOD = (int) 1e9 + 7; private static final int N = (int) 1e5 + 1; private static int[] f = new int[N]; // 素数筛 static { for (int i = 2; i &lt; N; i++) { if (f[i] == 0) { for (int j = i; j &lt; N; j += i) { f[j]++; } } } } public int maximumScore(List&lt;Integer&gt; nums, int k) { // 计算每个位置有多少个数组 int n = nums.size(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(-1); set.add(n); var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; { int x = nums.get(a), y = nums.get(b); return f[x] != f[y] ? f[y] - f[x] : a - b; }); long[] cnt = new long[n]; for (int i : aux) { long l = i - set.ceiling(i); long r = set.floor(i) - i; cnt[i] = l * r; set.add(i); } // 从大到小枚举值，计算答案 long ans = 1L; for (int i = 0; i &lt; n; i++) aux[i] = i; Arrays.sort(aux, (a, b) -&gt; nums.get(b) - nums.get(a)); for (int i = 0; k &gt; 0; i++) { int t = (int) Math.min(cnt[aux[i]], k); ans = (ans * power(nums.get(aux[i]), t)) % MOD; k -= t; } return (int) ans; } private long power(long x, int n) { long res = 1L; while (n != 0) { if (n % 2 == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; }}","link":"/2023/08/14/%E7%AC%AC%20358%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 893 (Div. 2)","text":"Buttons优先选择公共按钮，当且仅当先手的按钮数量大于后手的按钮数量时，先手者胜。 12345public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (a + c % 2 &gt; b) io.println(&quot;First&quot;); else io.println(&quot;Second&quot;);} The Walkway模拟题，特别需要注意头尾的边界处理，加上哨兵真的会方便很多。可以假设位置 \\(1-d\\) 和位置 \\(n+1\\) 有卖家，这样就不用特判，可以直接处理！！！ 123456789101112131415161718192021222324252627public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] s = new int[m + 2]; for (int i = 1; i &lt;= m; i++) { s[i] = io.nextInt(); } s[0] = 1 - d; s[m + 1] = n + 1; int ans = m - 1, delta = Integer.MAX_VALUE, cnt = 0; for (int i = 1; i &lt;= m; i++) { int A = (s[i] - s[i - 1] - 1) / d; int B = (s[i + 1] - s[i] - 1) / d; int C = (s[i + 1] - s[i - 1] - 1) / d; int D = C - A - B; if (D &lt; delta) { delta = D; cnt = 1; } else if (D == delta) { cnt++; } ans += A; } ans += (s[m + 1] - s[m] - 1) / d + delta - 1; io.println(ans + &quot; &quot; + cnt);} Yet Another Permutation Problem构造题，首先需要发现什么公约数不可能出现，很明显不可能得到 \\(d_{i}=\\gcd (a_{i},a_{(i\\bmod n)+1})&gt; \\lfloor \\frac{n}{2}\\rfloor\\)。然后考虑所有小于等于 \\(\\lfloor \\frac{n}{2}\\rfloor\\) 的数是否能被包含，可以发现对于每个 \\(a_{i}=x\\leq \\lfloor \\frac{n}{2}\\rfloor\\) 总有 \\(a_{(i\\bmod n)+1}=2\\cdot x\\leq n\\)，所以我们可以枚举所有奇数乘以二的幂来构造答案。 12345678910111213public static void solve() { int n = io.nextInt(), idx = 0; int[] ans = new int[n]; for (int i = 1; i &lt;= n; i += 2) { for (int j = i; j &lt;= n; j *= 2) { ans[idx++] = j; } } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} Trees and Segments难以描述，看代码吧，调试半天。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[][] prefix = new int[n + 1][k + 1]; int[][] suffix = new int[n + 1][k + 1]; // 枚举可以在 k 次操作内变为全 0 的子数组，并将其长度记录到所属的前后缀中 for (int i = 0; i &lt; n; i++) { int cnt1 = 0; for (int j = i; j &lt; n; j++) { cnt1 += s[j] - '0'; if (cnt1 &gt; k) break; prefix[j + 1][cnt1] = Math.max(prefix[j + 1][cnt1], j - i + 1); suffix[i][cnt1] = Math.max(suffix[i][cnt1], j - i + 1); } } // 在前缀 [0, i] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= k; j++) { prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i][j]); if (j &gt; 0) prefix[i + 1][j] = Math.max(prefix[i + 1][j], prefix[i + 1][j - 1]); } } // 在后缀 [i, n - 1] 中最多操作 j 次，可以得到的连续 0 的最长长度 for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt;= k; j++) { suffix[i][j] = Math.max(suffix[i][j], suffix[i + 1][j]); if (j &gt; 0) suffix[i][j] = Math.max(suffix[i][j], suffix[i][j - 1]); } } // 枚举连续 1 的起点和终点，并记录该连续 1 的长度对应的连续 0 的最长长度（注意包含长度为 0 的情况） int[] max0by1 = new int[n + 1]; Arrays.fill(max0by1, -1); max0by1[0] = suffix[0][k]; for (int i = 0; i &lt; n; i++) { int cnt0 = 0; for (int j = i; j &lt; n; j++) { cnt0 += (s[j] - '0') ^ 1; if (cnt0 &gt; k) break; max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], prefix[i][k - cnt0]); max0by1[j - i + 1] = Math.max(max0by1[j - i + 1], suffix[j + 1][k - cnt0]); } } // 计算答案 int[] ans = new int[n + 1]; for (int a = 1; a &lt;= n; a++) { for (int i = 0; i &lt;= n; i++) { if (max0by1[i] == -1) continue; ans[a] = Math.max(ans[a], i + max0by1[i] * a); } } for (int i = 1; i &lt;= n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}","link":"/2023/08/16/Codeforces%20Round%20893%20(Div.%202)/"},{"title":"第 111 场力扣夜喵双周赛","text":"统计和小于目标的下标对数目使用排序 + 双指针优化。如果 \\(nums[lo]+nums[hi]&lt;target\\)，那么 \\([lo+1,hi]\\) 范围内的数都能与 \\(nums[lo]\\) 组成对，\\(lo\\) 加一；反之，\\([lo,hi-1]\\) 范围内的数都不能与 \\(nums[hi]\\) 组成对，\\(hi\\) 减一。 Java 123456789101112131415class Solution { public int countPairs(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int lo = 0, hi = nums.size() - 1, ans = 0; while (lo &lt; hi) { if (nums.get(lo) + nums.get(hi) &lt; target) { ans += hi - lo; lo++; } else { hi--; } } return ans; }} C++ 12345678910111213141516class Solution {public: int countPairs(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans = 0; for (int i = 0, j = n - 1; i &lt; j; ) { if (nums[i] + nums[j] &lt; target) { ans += j - i; i++; } else { j--; } } return ans; }}; 循环增长使字符串子序列等于另一个字符串贪心取就行。 Java 1234567891011class Solution { public boolean canMakeSubsequence(String str1, String str2) { int m = str1.length(), n = str2.length(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1.charAt(i) == str2.charAt(j) || (str1.charAt(i) + 1 - 'a') % 26 == str2.charAt(j) - 'a') { j++; } } return j == n; }} C++ 123456789101112class Solution {public: bool canMakeSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(), j = 0; for (int i = 0; i &lt; m &amp;&amp; j &lt; n; i++) { if (str1[i] == str2[j] || (str1[i] + 1 - 'a') % 26 == str2[j] - 'a') { j++; } } return j == n; }}; 将三个组排序要将 \\(nums\\) 变为美丽数组，就要将 \\(nums\\) 变为非递减的形式，所以问题就变为求最长非递减子序列。 Java 动态规划： 12345678910111213141516class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), ans = 1; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 0; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (nums.get(i) &gt;= nums.get(j)) { dp[i] = Math.max(dp[i], dp[j] + 1); } } ans = Math.max(ans, dp[i]); } return n - ans; }} 贪心 + 二分： 1234567891011121314151617class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int n = nums.size(), maxLen = 0; int[] aux = new int[n]; for (int x : nums) { int lo = 0, hi = maxLen - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (aux[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } aux[lo] = x; if (lo == maxLen) maxLen++; } return n - maxLen; }} 状态机 DP： 有点妙啊，\\(dp[i][j]\\) 表示将子数组 \\([0,i]\\) 变为以 \\([1,j]\\) 为结尾的美丽数组所需的最小修改次数，然后可以空间优化。 1234567891011class Solution { public int minimumOperations(List&lt;Integer&gt; nums) { int[] dp = {Integer.MAX_VALUE, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = Math.min(dp[i - 1], dp[i] + (x == i ? 0 : 1)); } } return dp[3]; }} C++ 123456789101112class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { int dp[4] = {INT_MAX, 0, 0, 0}; for (int x : nums) { for (int i = 1; i &lt;= 3; i++) { dp[i] = min(dp[i - 1], dp[i] + (x != i)); } } return dp[3]; }}; 范围中美丽整数的数目经典数位 DP 没什么好说的，主要是记忆化取模，边乘边取模。 Java 1234567891011121314151617181920212223242526class Solution { public int numberOfBeautifulIntegers(int low, int high, int k) { return f(0, 10, 0, true, false, high + &quot;&quot;, k, new Integer[10][20][k]) - f(0, 10, 0, true, false, low - 1 + &quot;&quot;, k, new Integer[10][20][k]); } private int f(int i, int diff, int mod, boolean isLimit, boolean isNum, String s, int k, Integer[][][] dp) { if (i == s.length()) { return isNum &amp;&amp; diff == 10 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff][mod] != null) { return dp[i][diff][mod]; } int res = 0; if (!isNum) res += f(i + 1, diff, mod, false, false, s, k, dp); int lo = isNum ? 0 : 1, hi = isLimit ? s.charAt(i) - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += f(i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true, s, k, dp); } if (!isLimit &amp;&amp; isNum) { dp[i][diff][mod] = res; } return res; }} C++ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int numberOfBeautifulIntegers(int low, int high, int k) { string s; const int BASE = 10; int dp[10][20][k]; auto f = [&amp;](auto self, int i, int diff, int mod, bool isLimit, bool isNum) { if (i == s.size()) { return isNum &amp;&amp; diff == 0 &amp;&amp; mod == 0 ? 1 : 0; } if (!isLimit &amp;&amp; isNum &amp;&amp; dp[i][diff + BASE][mod] != -1) { return dp[i][diff + BASE][mod]; } int res = 0; if (!isNum) res += self(self, i + 1, diff, mod, false, false); int lo = isNum ? 0 : 1, hi = isLimit ? s[i] - '0' : 9; for (int d = lo; d &lt;= hi; d++) { res += self(self, i + 1, diff + d % 2 * 2 - 1, (mod * 10 + d) % k, isLimit &amp;&amp; d == hi, true); } if (!isLimit &amp;&amp; isNum) dp[i][diff + BASE][mod] = res; return res; }; auto calc = [&amp;](int x) { s = to_string(x); memset(dp, -1, sizeof(dp)); return f(f, 0, 0, 0, true, false); }; return calc(high) - calc(low - 1); }};","link":"/2023/08/21/%E7%AC%AC%20111%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 359 场力扣周赛","text":"判别首字母缩略词Java 123456789101112class Solution { public boolean isAcronym(List&lt;String&gt; words, String s) { int n = words.size(), m = s.length(); if (n != m) return false; for (int i = 0; i &lt; n; i++) { if (words.get(i).charAt(0) != s.charAt(i)) { return false; } } return true; }} C++ 12345678910111213class Solution {public: bool isAcronym(vector&lt;string&gt;&amp; words, string s) { int m = words.size(), n = s.size(); if (m != n) return false; for (int i = 0; i &lt; n; i++) { if (words[i][0] != s[i]) { return false; } } return true; }}; k-avoiding 数组的最小总和贪心。 Java 123456class Solution { public int minimumSum(int n, int k) { int m = Math.min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }} C++ 1234567class Solution {public: int minimumSum(int n, int k) { int m = min(k / 2, n); return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) / 2; }}; 销售利润最大化不从动态规划的角度思考，我首先用的是对左端点排序。如果用动态规划，那么根据转移方程就会对右端点排序，处理方式也比对左端点排序简单一些。还可以不排序做，使用桶存储相同 \\(end\\) 的 \\(offer\\)，分别处理每个桶。 Java 1234567891011121314class Solution { public int maximizeTheProfit(int n, List&lt;List&lt;Integer&gt;&gt; offers) { Collections.sort(offers, (a, b) -&gt; a.get(1) - b.get(1)); offers.add(List.of(n - 1, n - 1, 0)); int m = offers.size(), i = 0; int[] leftMax = new int[n + 1]; for (var offer : offers) { int s = offer.get(0), e = offer.get(1), g = offer.get(2); for (; i &lt;= e; i++) leftMax[i + 1] = leftMax[i]; leftMax[e + 1] = Math.max(leftMax[e + 1], leftMax[s] + g); } return leftMax[n]; }} C++ 1234567891011121314151617class Solution {public: int maximizeTheProfit(int n, vector&lt;vector&lt;int&gt;&gt;&amp; offers) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; groups(n); for (auto &amp;offer : offers) { groups[offer[1]].emplace_back(offer[0], offer[2]); } vector&lt;int&gt; f(n + 1); for (int end = 0; end &lt; n; end++) { f[end + 1] = f[end]; for (auto &amp;[start, gold] : groups[end]) { f[end + 1] = max(f[end + 1], f[start] + gold); } } return f[n]; }}; 找出最长等值子数组Java 滑动窗口： 12345678910111213141516171819class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int lo = 0, hi = 0, ans = 0; while (hi &lt; n) { map.merge(nums.get(hi++), 1, Integer::sum); if (hi - lo - map.get(nums.get(lo)) &gt; k) { map.merge(nums.get(lo++), -1, Integer::sum); } ans = Math.max(ans, map.get(nums.get(lo))); } while (lo + 1 &lt; n) { map.merge(nums.get(lo++), -1, Integer::sum); ans = Math.max(ans, map.get(nums.get(lo))); } return ans; }} 滑动窗口（优化）： 优化一：观察到 \\(1\\leq nums[i]\\leq nums.lenth\\)，所以可以用数组模拟哈希表。 优化二：滑动窗口直接枚举右端点，这样可以枚举到所有情况。但是如何保证删除的元素数量小于等于 \\(k\\) 呢？当左端点的值 \\(nums[i]\\) 不能构成等值数组，则将左端点右移。为什么这样可以保证？当 \\(nums[i]\\neq nums[j]\\) 时，移动左端点不影响答案；当 \\(nums[i]=nums[j]\\) 时，移动左端点可以保证删除的元素数量小于等于 \\(k\\)。 1234567891011121314class Solution { public int longestEqualSubarray(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; int[] map = new int[n + 1]; for (int i = 0, j = 0; j &lt; n; j++) { map[nums.get(j)]++; if (j - i + 1 - map[nums.get(i)] &gt; k) { map[nums.get(i++)]--; } ans = Math.max(ans, map[nums.get(j)]); } return ans; }} C++ 分组 + 双指针： 123456789101112131415161718192021class Solution {public: int longestEqualSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(), ans = 0; vector&lt;vector&lt;int&gt;&gt; pos(n + 1); for (int i = 0; i &lt; n; i++) { pos[nums[i]].push_back(i); } for (auto &amp;ps : pos) { int left = 0; for (int right = 0; right &lt; ps.size(); right++) { while (ps[right] - ps[left] - right + left &gt; k) { left++; } ans = max(ans, right - left + 1); } } return ans; }};","link":"/2023/08/21/%E7%AC%AC%20359%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 315","text":"tcdr模拟。 Java 123456789public static void solve() { String s = io.next(); var sb = new StringBuilder(); Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); for (char c : s.toCharArray()) { if (!set.contains(c)) sb.append(c); } io.println(sb.toString());} C++ 12345678void solve() { string s; cin &gt;&gt; s; s.erase(remove_if(s.begin(), s.end(), [&amp;](char c) { return set{'a', 'e', 'i', 'o', 'u'}.count(c); }), s.end()); cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;} The Middle Day模拟。 Java 1234567891011121314151617public static void solve() { int m = io.nextInt(); int[] d = new int[m]; int tot = 0; for (int i = 0; i &lt; m; i++) { d[i] = io.nextInt(); tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { io.println(i + 1 + &quot; &quot; + mid); return; } mid -= d[i]; }} C++ 123456789101112131415161718void solve() { int m; cin &gt;&gt; m; int tot = 0; vector&lt;int&gt; d(m); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; d[i]; tot += d[i]; } int mid = (tot + 1) / 2; for (int i = 0; i &lt; m; i++) { if (mid &lt;= d[i]) { cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot;\\n&quot;; return; } mid -= d[i]; }} Flavors模拟。 Java 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] buckets = new List[n + 1]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int f = io.nextInt(), s = io.nextInt(); buckets[f].add(s); } int ans = 0, max1 = 0, max2 = 0; for (var bucket : buckets) { if (bucket.isEmpty()) continue; Collections.sort(bucket, (a, b) -&gt; b - a); int a = bucket.get(0); if (a &gt; max1) { max2 = max1; max1 = a; } else if (a &gt; max2) { max2 = a; } if (bucket.size() &lt; 2) continue; int b = bucket.get(1); ans = Math.max(ans, a + b / 2); } ans = Math.max(ans, max1 + max2); io.println(ans);} C++ 12345678910111213141516171819202122232425void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; buckets(n + 1); for (int i = 0; i &lt; n; i++) { int f, s; cin &gt;&gt; f &gt;&gt; s; buckets[f].push_back(s); } int ans = 0, max1 = 0, max2 = 0; for (auto &amp;bucket : buckets) { if (bucket.empty()) continue; nth_element(bucket.begin(), bucket.begin() + 1, bucket.end(), greater()); if (bucket[0] &gt; max1) { max2 = max1; max1 = bucket[0]; } else if (bucket[0] &gt; max2) { max2 = bucket[0]; } if (bucket.size() &lt; 2) continue; ans = max(ans, bucket[0] + bucket[1] / 2); } ans = max(ans, max1 + max2); cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;} Magical Cookies算是暴力吧。首先最多执行 \\(m+n\\) 次操作，然后每次操作将所有行和列遍历，判断是否可以标记。如果不优化，那么遍历的复杂度是 \\(O(mn)\\)，总时间复杂度就是 \\(O(mn(m+n))\\)，会超时。可以维护剩余的行数 \\(r\\) 和剩余的列数 \\(c\\)，那么如果某行的某颜色的数量等于列数，那么就说明可以标记该行，列同理。这样我们就可以只维护行列中的每个颜色有多少饼干，而不需要维护位置关系，从而将遍历的时间复杂度降为 \\(O(26(m+n))\\)。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] arr = new String[m]; for (int i = 0; i &lt; m; i++) { arr[i] = io.next(); } int[][] row = new int[m][26]; int[][] col = new int[n][26]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { row[i][arr[i].charAt(j) - 'a']++; col[j][arr[i].charAt(j) - 'a']++; } } int r = m, c = n; boolean[] vr = new boolean[m]; boolean[] vc = new boolean[n]; for (int k = 0; k &lt; m + n; k++) { List&lt;int[]&gt; mr = new ArrayList&lt;&gt;(); List&lt;int[]&gt; mc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { if (vr[i]) continue; for (int j = 0; j &lt; 26; j++) { if (row[i][j] == c &amp;&amp; c &gt;= 2) { mr.add(new int[]{i, j}); } } } for (int i = 0; i &lt; n; i++) { if (vc[i]) continue; for (int j = 0; j &lt; 26; j++) { if (col[i][j] == r &amp;&amp; r &gt;= 2) { mc.add(new int[]{i, j}); } } } for (int[] p : mr) { r--; vr[p[0]] = true; for (int i = 0; i &lt; n; i++) { col[i][p[1]]--; } } for (int[] p : mc) { c--; vc[p[0]] = true; for (int i = 0; i &lt; m; i++) { row[i][p[1]]--; } } } io.println(r * c);} Prerequisites首先找到第 \\(1\\) 本书的所有前置书，然后对所有书进行拓扑排序，将之前找到的前置书按拓扑排序的倒序打印即可。或者直接 DFS。。 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(); int[] indegree = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); for (int j = 0; j &lt; c; j++) { int q = io.nextInt() - 1; g[i].add(q); indegree[q]++; } } boolean[] mark = new boolean[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while (!q.isEmpty()) { int x = q.poll(); for (int y : g[x]) { if (mark[y]) continue; mark[y] = true; q.offer(y); } } for (int i = 0; i &lt; n; i++) { if (indegree[i] == 0) { q.offer(i); } } Deque&lt;Integer&gt; ans = new ArrayDeque&lt;&gt;(); while (!q.isEmpty()) { int x = q.poll(); if (mark[x]) ans.push(x); for (int y : g[x]) { if (--indegree[y] == 0) { q.offer(y); } } } while (!ans.isEmpty()) io.print(ans.pop() + 1 + &quot; &quot;); io.println();} C++ 123456789101112131415161718192021222324252627282930313233void solve() { int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) { int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; j++) { int q; cin &gt;&gt; q; q--; adj[i].push_back(q); } } vector&lt;bool&gt; mark(n); auto dfs = [&amp;](auto self, int x) { if (mark[x]) { return; } for (auto y : adj[x]) { self(self, y); } mark[x] = true; if (x != 0) { std::cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot;; } }; dfs(dfs, 0); cout &lt;&lt; &quot;\\n&quot;;} Shortcuts动态规划，调试好久。。如果所有点都选，那么答案最多为 \\(10^{9}\\)，所以可以确定不选的点不会超过 \\(30\\)。然后定义状态 \\(dp[i][j]\\) 表示到达第 \\(i\\) 个点并且总共跳过 \\(j\\) 个点的最短距离。如何想到定义该状态呢，因为答案和具体选哪几个点无关，只和最短距离以及跳过多少个点有关，大概是这样吧。 Java 1234567891011121314151617181920212223242526272829public static void solve() { int c = 30; int n = io.nextInt(); int[] x = new int[n]; int[] y = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } double[][] dp = new double[n][c]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } dp[0][0] = 0; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; c; j++) { for (int k = i + 1; k &lt; n &amp;&amp; k - i - 1 + j &lt; c; k++) { int nj = j + k - i - 1; dp[k][nj] = Math.min(dp[k][nj], dp[i][j] + Math.sqrt((x[i] - x[k]) * (x[i] - x[k]) + (y[i] - y[k]) * (y[i] - y[k]))); } } } double ans = Integer.MAX_VALUE; for (int i = 0; i &lt; c; i++) { ans = Math.min(ans, dp[n - 1][i] + (i == 0 ? 0 : 1 &lt;&lt; (i - 1))); } io.println(ans);}","link":"/2023/08/21/AtCoder%20Beginner%20Contest%20315/"},{"title":"Educational Codeforces Round 153 (Rated for Div. 2)","text":"Not a Substring构造题。如果 \\(s\\) 中存在连续相同的括号，则可以构造交替出现的括号；如果 \\(s\\) 是交替出现的括号，那么就构造连续的括号，此时包含的唯一交替的括号就是 \\(()\\)，特判一下即可。 123456789101112131415161718public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = false; for (int i = 1; i &lt; n; i++) { if (s[i] == s[i - 1]) { ok = true; break; } } if (new String(s).equals(&quot;()&quot;)) { io.println(&quot;NO&quot;); return; } io.println(&quot;YES&quot;); if (ok) io.println(&quot;()&quot;.repeat(n)); else io.println(&quot;(&quot;.repeat(n) + &quot;)&quot;.repeat(n));} Fancy Coins数学题。假设最终使用 \\(x\\) 枚价值为 \\(1\\) 的硬币，\\(y\\) 枚价值为 \\(k\\) 的硬币。如果 \\(x\\) 大于等于 \\(k\\)，我们总是将其合成为价值为 \\(k\\) 的硬币，所以可以保证 \\(x\\) 小于 \\(k\\)。显然 \\(x=m\\bmod k\\)，\\(y=\\frac{m}{k}\\)。那么需要补充多少花色硬币呢？易知，需要补充 \\(\\max(0,x-a_{1})\\) 个价值为 \\(1\\) 的花色硬币，和 \\(\\max (0,y-a_{k}-\\max (0,\\frac{a_{1}-x}{k}))\\) 个价值为 \\(k\\) 的花色硬币。 12345public static void solve() { int m = io.nextInt(), k = io.nextInt(), a1 = io.nextInt(), ak = io.nextInt(); int ans = Math.max(0, m % k - a1) + Math.max(0, m / k - ak - Math.max(0, a1 - m % k) / k); io.println(ans);} Game on Permutation一开始的想法是，如果某个元素左边恰好只有一个小于它的元素，那么该位置就是胜位。然而暴力找每个位置左边比它小的元素个数的时间复杂度是 \\(O(n^{2})\\)，赛时就不知道怎么优化。其实我们可以知道，给定一个序列，胜位是固定不变的。所以可以考虑维护左边的最小元素（表示下一步是否可以下棋）和最小的胜位（如果大于最小胜位，则当前位必输），然后就可以很方便的模拟出答案。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] p = new int[n]; int ans = 0, min = n + 1, minWin = n + 1; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); if (min &lt; p[i] &amp;&amp; p[i] &lt;= minWin) { ans++; minWin = Math.min(minWin, p[i]); } min = Math.min(min, p[i]); } io.println(ans);} Balanced String不会不会。。o(╥﹏╥)o","link":"/2023/08/21/Educational%20Codeforces%20Round%20153%20(Rated%20for%20Div.%202)/"},{"title":"Project #0 - C++ Primer","text":"项目准备项目地址：Project #0 - C++ Primer。 准备工作：创建项目仓库，学习 Git 分支，复习 C++，阅读谷歌 C++ 风格指南，学习 GDB。 Task #1 - Copy-On-Write Trie实现Get 函数 没有什么特别需要注意的，实现比较简单。 实现逻辑： 如果 root_ == nullptr 为真，则返回 nullptr。 沿着 Trie 树遍历，如果节点不存在，则返回 nullptr。 如果目标节点不是 TrieNodeWithValue 类型，则返回 nullptr。 否则，返回目标节点的值。 Put 函数 一开始比较疑惑的点是，智能指针存储的都是 const 修饰的节点，如果要修改就必须克隆。但是沿着树遍历的话，如果需要修改子节点，那么同样也需要让父结点指向克隆后的子节点，然后一直向上到根节点，看上去似乎使用栈比较合理。那么能不能不使用栈呢？ 其实通过观察可以发现，从根节点一直到目标节点（表示字符串的节点）都是需要克隆的，如果节点存在的话。那么这样我们就可以在遍历的过程中克隆，只需要维护新克隆节点的非 const 指针就能做到。 本来想加个冗余节点减少判断的代码，但是感觉好像怎么弄都逃不过判断 key.empty() 和 root_ == nullptr。 实现逻辑： 如果 key.empty() 为真： 如果 root_ == nullptr 为真，则使用 value​ 构造 Trie 树并返回。 否则，使用 root_-&gt;children_ 和 value 构造 Trie 树并返回。 根据 root_ == nullptr 条件初始化新 Trie 树的 root。 沿着旧 Trie 树克隆新 Trie 树的节点（最后一个字符对应的节点需要特殊处理）： 如果克隆完所有字符，则返回新 Trie 树。 否则，新 Trie 树继续创建旧 Trie 树不包含的节点，然后返回新 Trie 树。 Remove 函数 需要使用栈辅助删除，优化后代码好看多了，不像之前那么复杂（大概）。有以下几点需要注意： ① 节点不包含值需要转换为 TrieNode 类型，也就是说拷贝的时候需要调用 TrieNode::Clone()。 ② 如果节点满足 children_.empty() &amp;&amp; !is_value_node_ 条件，则需要移除该节点。一个节点的移除，可能会导致该节点的父节点也满足移除条件。移除时，记得 erase 父节点中 map 的 key。 实现逻辑： 如果 root_ == nullptr 为真，则返回 *this。 如果 key.empty() 为真，则调用 root_-&gt;TrieNode::Clone() 克隆，并返回新 Trie 树。 沿着旧 Trie 树遍历，并将对应的节点入栈，如果节点不存在，则返回 *this。 将栈顶的元素依次弹出，如果当前节点需要移除，则将其移除。 否则，依次克隆栈中的元素，然后返回新 Trie 树。 补充C++ 因为平时用的 Java，所以有几个使用 C++ 的坑点需要注意一下。 ① 使用 at 访问 const map 对象，因为 [] 运算符可能会自动添加键值。 123const map&lt;int,int&gt; m;cout &lt;&lt; m[1024]; // 错误，No viable overloaded operator[] for type 'const map&lt;int, int&gt;'cout &lt;&lt; m.at(1024); // 正确 ② = 拷贝对象的底层结构，不像 Java 中拷贝的是对象的地址（相当于 C++ 中的指针吧）。 12345map&lt;int,int&gt; m;m[1024] = 1024;auto n = m;n[1024] = 2048;cout &lt;&lt; m[1024]; // 输出：1024 ③ 在 Java 中只要是对象就可以和 null 比较，而 C++ 中只有指针可以和 nullptr 比较。 GDB ① 使用 GDB 调试经常会看到 Python Exception &lt;class ‘gdb.error’&gt;: There is no member named _M_p，点击此处产生该问题的原因，以及相应的解决方案告诉我下载 libstdc++6-dbgsym，完美解决问题。本来不想管这个问题的，结果任务三需要在调试时打印字符串。 ② 之前做 CSAPP 的二进制炸弹实验用过 GDB，可以在此查看该课程提供的 GDB 教程。以及可以阅读：GDB Tutorial: Finding Segmentation Faults。 ③ 使用 GDB 调试时，最后会报错 LeakSanitizer has encountered a fatal error，因为 LeakSanitizer 不能在 GDB 下工作。不用去管这个错误，只要在不用 GDB 的情况下测试通过就行。 CMake 项目推荐使用 clang-14 作为编译器，解决方案在此。 Task #2 - Concurrent Key-Value Store实现因为 Trie 是写时复制的，所以似乎不需要考虑其他复杂的上锁操作，只需要简单的使用 std::mutex 即可。读操作在获取 root_ 时上锁，获取完即可解锁。写操作同理，并且需要在整个操作内对 write_lock_ 上锁。Put 时记得使用 std::move()，因为值可能是不可复制的。 补充① 关于线程和锁的知识，推荐阅读 CS110 Lecture 10: Threads and Mutexes。 ② C++ 有个复制省略（Copy elision）的优化。 ③ 关于 C++ 模板的 FAQ、template 关键字的讨论 和 Dependent names 的定义。（好复杂啊）之所以查这些内容，是因为 CLion 给我生成了不同的表达式： 123auto value = root.template Get&lt;T&gt;(key);root = root.template Put(key, std::move(value));root = root.Remove(key); 以我现在的理解，模板类型是根据实参推断的，如果无法推断则需要在调用时显示添加 &lt;&gt; 来指定类型。然后何时使用 template 没怎么弄明白。 Task #3 - Debugging实现挺简单的，文件 trie_debug_test.cpp 指出在 28 行打断点，但我是在 Put 时打断点调试的，应该差不多吧。 补充无语的是，在修复上个问题时无意间下载了 gcc-12，导致在 make 时报错：/usr/bin/ld: cannot find -lstdc++: No such file or directory，问题原因以及解决方案在此。 Task #4 - SQL String Functions实现文件的路径：./src/include/execution/expressions 和 ./src/planner/plan_func_call.cpp。实现大小写转换比较简单，但是如果使用 std::tolower 或许有一些注意事项。注册函数时，需要保证参数是有效的，即参数只有一个并且是 VARCHAR 类型。 测试结果就是过不去 TrieDebugger.TestCase，结果发现不是我的问题，而是因为本地的随机数和测试的随机数不同，详情见 Discord 讨论。 修改之后通过！ 项目小结任务一是项目的核心，主要还是把逻辑理清楚，以及注意到 key 为空串的特殊用例。一开始很多东西都不懂，查找资料学习花费了很多时间，还有就是 Debug 任务一也费了一番功夫，因为当时边界条件没弄清楚。","link":"/2023/08/26/Project%200%20-%20C++%20Primer/"},{"title":"Codeforces Round 894 (Div. 3)","text":"Gift Carpet从左到右每列贪心取即可。 12345678910111213141516171819202122public static void solve() { int m = io.nextInt(), n = io.nextInt(); String[] g = new String[m]; for (int i = 0; i &lt; m; i++) { g[i] = io.next(); } int idx = 0; String s = &quot;vika&quot;; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (g[j].charAt(i) == s.charAt(idx)) { idx++; break; } } if (idx == s.length()) { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Sequence Game构造题。当 \\(b_{i-1}&gt;b_{i}\\) 时，在两个数中间添加一个 \\(1\\) 即可。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(b[0]); for (int i = 1; i &lt; n; i++) { if (b[i] &lt; b[i - 1]) ans.add(1); ans.add(b[i]); } io.println(ans.size()); for (int x : ans) io.print(x + &quot; &quot;); io.println();} Flower City Fence阅读理解。题目中的“对角线对称”这个概念根本不用管，就是不断对区间做加法，然后判断是否和原数组相等，可以使用差分 + 前缀和解决。看完题解，发现其实也可以 \\(O(1)\\) 空间解决，因为数组是非递增的，按顺序遍历就行，具体见代码。 123456789101112131415public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } for (int i = 0, j = n; i &lt; n; i++) { for (; j &gt; 0 &amp;&amp; a[j - 1] &lt;= i; j--) ; if (a[i] != j) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Ice Cream Balls题目描述很有问题，其实就是问从一个长度为 \\(m\\) 的序列中选两个值组成集合，使得不同集合的数目恰好为 \\(n\\) 的 \\(m\\) 是多少。可以先二分求 \\(x\\)，使得 \\(C_{x}^{2}\\leq n\\) 且 \\(C_{x+1}^{2}&gt;n\\)。然后答案就是 \\(x+(n-C_{x}^{2})\\)，表示 \\([1,n-C_{x}^{2}]\\) 范围内的每个数各取两个，以及 \\([n-C_{x}^{2}+1,x]\\) 范围内的每个数各取一个。PS：读题很容易漏掉恰好两个字。 12345678910public static void solve() { long n = io.nextLong(); long lo = 2, hi = (long) 1e9 * 2; while (lo &lt;= hi) { long mid = lo + (hi - lo) / 2; if (mid * (mid - 1) / 2 &lt;= n) lo = mid + 1; else hi = mid - 1; } io.println(hi + (n - hi * (hi - 1) / 2));} Kolya and Movie Theatre做这道题时漏掉“开业前一天去过电影院”这个条件，导致想了半天。答案要求最多看 \\(m\\) 部电影的最大娱乐价值，首先我们可以观察到娱乐值的下降幅度只与最后一次去电影院的日期 \\(x\\) 有关，即下降幅度为 \\(x\\cdot d\\)。所以我们可以从前往后枚举 \\(x\\)，并且维护最大长度为 \\(m\\) 的优先队列，来保证最多看 \\(m\\) 部电影。需要注意电影的娱乐值可能是负数，而我们只需要在优先队列中存储正数即可。 123456789101112131415public static void solve() { int n = io.nextInt(), m = io.nextInt(), d = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = io.nextInt(); PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); long sum = 0L, ans = 0L; for (int i = 0; i &lt; n; i++) { if (a[i] &lt;= 0) continue; q.offer(a[i]); sum += a[i]; if (q.size() &gt; m) sum -= q.poll(); ans = Math.max(ans, sum - (long) d * (i + 1)); } io.println(ans);} Magic Will Save the World初见时想到的是二分时间 + 动态规划，赛后优化发现可以直接动态规划做。我是用背包做的，\\(dp[i][j]\\) 表示前 \\(i\\) 个怪物使用 \\(j\\) 点法术值能够击败的怪物总强度最大是多少，然后枚举水法术值计算答案。但是其实可以不用这样，我们只需要知道怪物的子集的所有可能强度是多少，然后枚举所有能够到达的强度即可。（C++ 位图很方便） 12345678910111213141516171819202122public static void solve() { int w = io.nextInt(), f = io.nextInt(), n = io.nextInt(); int sum = 0; int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); sum += s[i]; } boolean[] dp = new boolean[sum + 1]; dp[0] = true; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= s[i]; j--) { dp[j] = dp[j] || dp[j - s[i]]; } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt;= sum; i++) { if (!dp[i]) continue; ans = Math.min(ans, Math.max((i + w - 1) / w, (sum - i + f - 1) / f)); } io.println(ans);} The Great Equalizer很容易就可以得出结论，设备的输出值是数组的最大值 + 排序后相邻元素的最大差值，但是不知道怎么维护。使用 C++ 的 multiset 很容易写，详细见大佬的代码。","link":"/2023/08/26/Codeforces%20Round%20894%20(Div.%203)/"},{"title":"AtCoder Beginner Contest 317","text":"Potions二分。 12345678910111213141516public static void solve() { int n = io.nextInt(), h = io.nextInt(), x = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt(); } x = x - h; int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (p[mid] &lt; x) lo = mid + 1; else hi = mid - 1; } io.println(lo + 1);} MissingNo.求和公式。 12345678910111213public static void solve() { int n = io.nextInt(); int sum = 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); sum += a; min = Math.min(min, a); max = Math.max(max, a); } io.println((min + max) * (max - min + 1) / 2 - sum);} Remembering the Days暴力 DFS。 12345678910111213141516171819202122232425262728293031private static int ans = Integer.MIN_VALUE;public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, w = io.nextInt(); g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { dfs(i, 0, g, vis); } io.println(ans);}private static void dfs(int x, int dis, List&lt;int[]&gt;[] g, boolean[] vis) { vis[x] = true; ans = Math.max(ans, dis); for (int[] t : g[x]) { int y = t[0], w = t[1]; if (!vis[y]) { dfs(y, dis + w, g, vis); } } vis[x] = false;} President01 背包，比赛时转移方程弄错了一个细节，本来以为和答案是等价的，赛后改下就过了。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); int sum = 0; int[] x = new int[n]; int[] y = new int[n]; int[] z = new int[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); z[i] = io.nextInt(); sum += z[i]; } long[] dp = new long[sum + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[0] = 0; for (int i = 0; i &lt; n; i++) { for (int j = sum; j &gt;= z[i]; j--) { if (dp[j - z[i]] == Long.MAX_VALUE) continue; dp[j] = Math.min(dp[j], dp[j - z[i]] + Math.max(0, (y[i] - x[i] + 1) / 2)); } } long ans = Long.MAX_VALUE; for (int i = (sum + 1) / 2; i &lt;= sum; i++) { ans = Math.min(ans, dp[i]); } io.println(ans);} Avoid Eye Contact模拟题，比赛时想复杂了，直接模拟就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void solve() { int h = io.nextInt(), w = io.nextInt(); String[] a = new String[h]; for (int i = 0; i &lt; h; i++) { a[i] = io.next(); } int s = -1, g = -1; boolean[][] mark = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { char c = a[i].charAt(j); if (c == 'S') { s = i * w + j; } else if (c == 'G') { g = i * w + j; } else if (c == '#') { mark[i][j] = true; } else if (c == '^') { mark[i][j] = true; for (int k = i - 1; k &gt;= 0 &amp;&amp; a[k].charAt(j) == '.'; k--) { mark[k][j] = true; } } else if (c == 'v') { mark[i][j] = true; for (int k = i + 1; k &lt; h &amp;&amp; a[k].charAt(j) == '.'; k++) { mark[k][j] = true; } } else if (c == '&lt;') { mark[i][j] = true; for (int k = j - 1; k &gt;= 0 &amp;&amp; a[i].charAt(k) == '.'; k--) { mark[i][k] = true; } } else if (c == '&gt;') { mark[i][j] = true; for (int k = j + 1; k &lt; w &amp;&amp; a[i].charAt(k) == '.'; k++) { mark[i][k] = true; } } } } int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1}; int[] dis = new int[h * w]; Arrays.fill(dis, -1); dis[s] = 0; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(s); while (!q.isEmpty()) { int z = q.poll(); int x = z / w, y = z % w; for (int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; 0 || nx &gt;= h || ny &lt; 0 || ny &gt;= w || mark[nx][ny]) continue; int nz = nx * w + ny; if (dis[nz] != -1) continue; dis[nz] = dis[z] + 1; q.offer(nz); } } io.println(dis[g]);}","link":"/2023/08/28/AtCoder%20Beginner%20Contest%20317/"},{"title":"Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2)","text":"Increasing and Decreasing比赛时漏看第三个条件，搞半天。而且似乎倒着减会比较容易做（差不多）。 123456789101112131415public static void solve() { int x = io.nextInt(), y = io.nextInt(), n = io.nextInt(); int z = (1 + n - 1) * (n - 1) / 2; if (z &gt; y - x) { io.println(-1); return; } io.print(x + &quot; &quot;); int d = x + y - x - z; for (int i = n - 1; i &gt;= 1; i--) { d += i; io.print(d + &quot; &quot;); } io.println();} Swap and Reverse找规律。第一个操作表明奇数下标相互连通，偶数下标相互连通。第二个操作，如果 \\(k\\) 是奇数，则连通性不会改变，分别对奇偶字母排序，然后构造即可；如果 \\(k\\) 是偶数，则奇数下标和偶数下标相互连通，对所有字母排序即可。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); if (k % 2 == 0) { Arrays.sort(s); io.println(new String(s)); } else { PriorityQueue&lt;Character&gt; list1 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; list2 = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) list1.add(s[i]); else list2.add(s[i]); } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) sb.append(list1.poll()); else sb.append(list2.poll()); } io.println(sb.toString()); }} Divisor Chain比赛时瞎猜 AC 的，当时是想从 \\(1\\) 开始构造到 \\(x\\)，过程比答案复杂。正解是从 \\(x\\) 一直减去最低有效位的一（必定是除数），直到 \\(x\\) 等于 \\(2\\) 的幂（只剩一个一），然后让 \\(x\\) 一直减去 \\(\\frac{x}{2}\\) 即可。 123456789101112131415161718public static void solve() { int x = io.nextInt(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); ans.add(x); while ((x &amp; (x - 1)) != 0) { x &amp;= (x - 1); ans.add(x); } while (x != 1) { x /= 2; ans.add(x); } io.println(ans.size()); for (int y : ans) { io.print(y + &quot; &quot;); } io.println();} Matrix Cascade使用差分数组维护从上到下的翻转次数，需要注意的是正负需要分开存，正数每层左移一位，负数每层右移一位。PS：这题 \\(p\\) 和 \\(q\\) 总是写错，Debug 很久。以及大佬的代码看不懂。 1234567891011121314151617181920212223242526272829303132public static void solve() { int n = io.nextInt(); char[][] a = new char[n][]; for (int i = 0; i &lt; n; i++) { a[i] = io.next().toCharArray(); } int ans = 0; int[] p = new int[n + 1]; int[] q = new int[n + 1]; int[] sum = new int[n + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (a[i][j] - '0' != sum[j + 1] % 2) { ans++; p[j] ^= 1; q[j + 1] ^= 1; } } p[0] ^= p[1]; for (int j = 1; j &lt; n; j++) { p[j] = p[j + 1]; } q[n] ^= q[n - 1]; for (int j = n - 1; j &gt; 0; j--) { q[j] = q[j - 1]; } for (int j = 0; j &lt; n; j++) { sum[j + 1] = sum[j] ^ p[j] ^ q[j]; } } io.println(ans);} Guess Game有点难以描述，超出能力范围了。这是一个比较好理解的做法，分别考虑每一位。从最低位开始，如果前缀相同，那么就计算当前位 \\(0\\) 和 \\(1\\) 的个数，只有爱丽丝拿 \\(1\\)，鲍勃拿 \\(1\\) 或 \\(0\\) 的情况，当前位才会多走一轮。初始时，设置答案为 \\(n \\times n\\)，因为每个组合至少会走一轮。最后需要使用快速幂求 \\(n\\) 的逆元。 1234567891011121314151617181920212223242526272829303132333435363738private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); long ans = (long) n * n; for (int t = 0; t &lt; 30; t++) { for (int l = 0, r = 0; l &lt; n; l = r) { int[] cnt = new int[2]; while (r &lt; n &amp;&amp; a[l] / 2 == a[r] / 2) { cnt[a[r] % 2]++; r++; } ans += (long) cnt[1] * (cnt[1] + cnt[0]); } for (int i = 0; i &lt; n; i++) { a[i] /= 2; } } ans = ans % MOD * pow(n, MOD - 2) % MOD * pow(n, MOD - 2) % MOD; io.println(ans);}private static int pow(int a, int n) { long res = 1, x = a; while (n != 0) { if (n % 2 == 1) { res = (res * x) % MOD; } x = (x * x) % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/08/28/Harbour.Space%20Scholarship%20Contest%202023-2024%20(Div.%201%20+%20Div.%202)/"},{"title":"第 360 场力扣周赛","text":"距离原点最远的点核心：要距离原点最远，那么可选的位置肯定是向同一个方向移动。 123456789101112class Solution { public int furthestDistanceFromOrigin(String moves) { int n = moves.length(), dis = 0, cnt = 0; for (int i = 0; i &lt; n; i++) { char c = moves.charAt(i); if (c == 'L') dis--; else if (c == 'R') dis++; else cnt++; } return Math.max(cnt - dis, cnt + dis); }} 找出美丽数组的最小和和上周一样的题目。 123456class Solution { public long minimumPossibleSum(int n, int target) { long m = Math.min(target / 2, n); return (m * (m + 1) + (target * 2 + n - m - 1) * (n - m)) / 2; }} 使子序列的和等于目标的最少操作次数比赛时思路满天飞，各种乱写。其实最后的思路是对的，但是基于之前的代码改写，导致有很多 Bug。赛后 15 分钟 AC。从低位到高位枚举 \\(target\\) 中的 \\(1\\)，假设当前 \\(1\\) 对应的值为 \\(x\\)，那么 \\(nums\\) 中所有小于等于 \\(x\\) 的值都可以用来填补 \\(x\\)，如果不够那么肯定需要将下一个大于 \\(x\\) 的值分解为 \\(x\\)。（更优的做法） 123456789101112131415161718192021class Solution { public int minOperations(List&lt;Integer&gt; nums, int target) { Collections.sort(nums); int n = nums.size(); int idx = 0, sum = 0, ans = 0; for (int i = target; i != 0; ) { int x = i &amp; -i; i -= x; while (idx &lt; n &amp;&amp; nums.get(idx) &lt;= x) { sum += nums.get(idx++); } sum -= x; if (sum &lt; 0) { if (idx == n) return -1; ans += Integer.numberOfTrailingZeros(nums.get(idx) / x); sum += nums.get(idx++); } } return ans; }} 在传球游戏中最大化函数值参考大佬的题解。 方法一：倍增 DP 因为 CPU 缓存的原因，数组开成 new int[35][n] 会更快。因为这样转移的时候只从上一行转移，具有空间局部性；而下面的代码是从左边一列转移，不具有空间局部性。 1234567891011121314151617181920212223242526272829class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); int[][] f = new int[n][35]; long[][] w = new long[n][35]; for (int i = 0; i &lt; n; i++) { f[i][0] = receiver.get(i); w[i][0] = i; } for (int j = 1; j &lt; 35; j++) { for (int i = 0; i &lt; n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; w[i][j] = w[i][j - 1] + w[f[i][j - 1]][j - 1]; } } long ans = 0L; for (int i = 0; i &lt; n; i++) { long cur = 0L; int pos = i; for (int j = 0; j &lt; 35; j++) { if ((k &gt;&gt; j &amp; 1) == 0) continue; cur += w[pos][j]; pos = f[pos][j]; } ans = Math.max(ans, cur + pos); } return ans; }} 方法二：内向基环树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution { public long getMaxFunctionValue(List&lt;Integer&gt; receiver, long k) { int n = receiver.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[receiver.get(i)]++; reverse[receiver.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[receiver.get(x)] == 0) { q.offer(receiver.get(x)); } } // 计算每个环的前缀和，并记录每个节点在哪个环的哪个位置 int[] cirNum = new int[n]; int[] cirPos = new int[n]; boolean[] vis = new boolean[n]; List&lt;List&lt;Long&gt;&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { List&lt;Long&gt; cir = new ArrayList&lt;&gt;(); cir.add(0L); // 前缀和的冗余节点 // 存储环的节点，并记录每个节点在哪个环的哪个位置 for (int cur = i; !vis[cur]; cur = receiver.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cirPos[cur] = cir.size(); cir.add((long) cur); } // 重复存储环的节点，方便计算从任意节点开始和结束的价值和 for (int t = cir.size() - 1, j = 1; t &gt; 0; t--, j++) { cir.add(cir.get(j)); } // 计算前缀和 for (int j = 1; j &lt; cir.size(); j++) { cir.set(j, cir.get(j) + cir.get(j - 1)); } circles.add(cir); } } // 对环内的每个节点向环外进行 dfs，从而计算出以每个节点作为起点的价值和 long ans = 0L; // 存储环外节点的前缀和 List&lt;Long&gt; outSum = new ArrayList&lt;&gt;(); outSum.add(0L); for (int i = 0; i &lt; n; i++) { // 注意传递 k + 1，表示总节点数量 if (in[i] != 0) ans = Math.max(ans, dfs(i, circles.get(cirNum[i]), cirPos[i], reverse, in, outSum, k + 1)); } return ans; } private long dfs(int x, List&lt;Long&gt; cir, int pos, List&lt;Integer&gt;[] reverse, int[] in, List&lt;Long&gt; outSum, long k) { long res = 0L; int outLen = outSum.size() - 1; if (outLen &lt; k) { int n = cir.size() / 2; // 因为 cir 多存储了 n - 1 个环内节点，以及一个冗余节点，所以 cir.size() / 2 就是环的长度 res = (k - outLen) / n * cir.get(n) + cir.get(pos + (int) ((k - outLen) % n) - 1) - cir.get(pos - 1); } res += outSum.get(outLen) - outSum.get((int) Math.max(0L, outLen - k)); for (int y : reverse[x]) { if (in[y] != 0) continue; outSum.add(outSum.get(outLen) + y); res = Math.max(res, dfs(y, cir, pos, reverse, in, outSum, k)); outSum.remove(outLen + 1); } return res; }}","link":"/2023/08/28/%E7%AC%AC%20360%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Homework #1 - SQL","text":"作业准备项目地址：Homework #1 - SQL。 准备工作：阅读 Chapters 1-2 27 3-5，学习 Lecture #01 #02，以及阅读课堂笔记。 Q1 [0 points] (q1_sample):Ctrl + C，Ctrl +V。 Q2 [5 points] (q2_not_the_same_title):查询只涉及 titles 表，比较简单。 1234567891011121314SELECT premiered, primary_title || ' (' || original_title || ')'FROM titlesWHERE primary_title != original_title AND type = 'movie' AND genres LIKE '%Action%'ORDER BY premiered DESC, primary_titleLIMIT 10; Q3 [5 points] (q3_longest_running_tv):题目描述很不清晰啊，类型都不知道具体是什么。 12345678910111213SELECT primary_title, IIF(ended IS NULL, 2023, ended) - premiered AS runtimeFROM titlesWHERE primary_title IS NOT NULL AND type = 'tvSeries'ORDER BY runtime DESC, primary_titleLIMIT 20; Q4 [10 points] (q4_directors_in_each_decade):唯一要注意的就是使用 DISTINCT。 12345678910111213SELECT CAST(born / 10 * 10 AS TEXT) || 's' AS decade, COUNT(DISTINCT(people.person_id)) AS num_directorsFROM people INNER JOIN crew USING(person_id)WHERE category = 'director' AND born &gt;= 1900GROUP BY decadeORDER BY decade; Q5 [10 points] (q5_german_type_ratings):德语的缩写是 de。 12345678910111213141516SELECT t.type, ROUND(AVG(r.rating), 2) AS avg_rating, MIN(r.rating), MAX(r.rating)FROM akas as a INNER JOIN ratings as r USING(title_id) INNER JOIN titles as t USING(title_id)WHERE a.language = 'de' AND a.types IN ('imdbDisplay', 'original')GROUP BY t.typeORDER BY avg_rating; Q6 [10 points] (q6_who_played_a_batman):坑点就是模糊查询时 Batman 两边要加上双引号，即 &quot;Batman&quot;。以及在连接 people 和 crew 表时，顺序很重要，如果使用 crew INNRE JOIN people USING(person_id) 会很慢（查询大概有 5 秒），具体不知道为什么，以下是它们的执行计划。 12345678910111213crew INNER JOIN people USING(person_id)QUERY PLAN|--SCAN crew USING INDEX ix_crew_person_id|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCTpeople INNER JOIN crew USING(person_id)QUERY PLAN|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--USE TEMP B-TREE FOR DISTINCT 12345678910111213141516171819202122232425WITH t AS ( SELECT DISTINCT(person_id), name FROM people INNER JOIN crew USING(person_id) WHERE category = 'actor' AND characters LIKE '%&quot;Batman&quot;%')SELECT name, ROUND(AVG(rating), 2) AS avg_ratingFROM t INNER JOIN crew USING(person_id) INNER JOIN ratings USING(title_id)GROUP BY person_idORDER BY avg_rating DESCLIMIT 10; Q7 [15 points] (q7_born_with_prestige):SQL 很容易写，但是性能和官解差两秒，等以后学习怎么优化再来看吧。 123456789SELECT COUNT(DISTINCT(person_id))FROM titles INNER JOIN people ON titles.premiered = people.born INNER JOIN crew USING(person_id)WHERE primary_title = 'The Prestige' AND category IN ('actor', 'actress'); 12345QUERY PLAN|--USE TEMP B-TREE FOR count(DISTINCT)|--SCAN crew|--SEARCH people USING INDEX sqlite_autoindex_people_1 (person_id=?)`--SEARCH titles USING INDEX ix_titles_primary_title (primary_title=?) Q8 [15 points] (q8_directing_rose.sql):比官解快一秒。注意使用 Rose% 而不是 Rose %。 12345678910111213141516171819SELECT DISTINCT(name)FROM crew INNER JOIN people USING(person_id)WHERE category = 'director' AND title_id IN ( SELECT title_id FROM crew INNER JOIN people USING(person_id) WHERE category = 'actress' AND name LIKE 'Rose%' )ORDER BY name; Q9 [15 points] (q9_ode_to_the_dead):这就是窗口函数么，学习了。 123456789101112131415161718192021222324252627282930313233343536373839WITH t AS ( SELECT category, name, died, primary_title, runtime_minutes, DENSE_RANK() OVER( PARTITION BY category ORDER BY died, name ) AS rank_died_name, DENSE_RANK() OVER( PARTITION BY category, person_id ORDER BY runtime_minutes DESC, title_id ) AS rank_runtime_title FROM crew INNER JOIN people USING(person_id) INNER JOIN titles USING(title_id) WHERE died IS NOT NULL AND runtime_minutes IS NOT NULL)SELECT category, name, died, primary_title, runtime_minutes, rank_died_nameFROM tWHERE rank_died_name &lt;= 5 AND rank_runtime_title = 1ORDER BY category, rank_died_name; Q10 [15 points] (q10_all_played_by_leo):不会。。json_each 函数有点神奇，也看了下递归 CTE 的实现，只能说真想不出来。 123456789101112131415161718192021222324252627WITH t1(characters) AS ( SELECT characters FROM people INNER JOIN crew USING(person_id) WHERE name = 'Leonardo DiCaprio' AND born = 1974),t2(value) AS ( SELECT DISTINCT(value) FROM t1, json_each(t1.characters) WHERE value != '' AND value NOT LIKE '%SELF%' ORDER BY value)SELECT GROUP_CONCAT(value)FROM t2; 作业小结最难的是最后两题，前面几题还可以接受。因为比较在意连接顺序对查询性能的影响，所以多花了点时间。（虽然还没弄明白就是了）","link":"/2023/08/29/Homework%201%20-%20SQL/"},{"title":"Pinely Round 2 (Div. 1 + Div. 2)","text":"Channel如果同时在线人数到达 \\(n\\)，就表示所有人都阅读过；否则，如果总上线人数大于等于 \\(n\\)，则有可能所有人阅读过；否则，不可能所有人阅读过。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), a = io.nextInt(), q = io.nextInt(); String s = io.next(); int cur = a, tot = a; for (int i = 0; i &lt; q &amp;&amp; cur &lt; n; i++) { if (s.charAt(i) == '+') { cur++; tot++; } else { cur--; } } if (cur == n) { io.println(&quot;YES&quot;); } else if (tot &gt;= n) { io.println(&quot;MAYBE&quot;); } else { io.println(&quot;NO&quot;); }} Split Sort对于每个 \\(p_{i}=k+1\\) 和 \\(p_{j}=k\\) 并且 \\(i&lt;j\\)，那么就一定要选一次 \\(x=k+1\\)。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] p = new int[n]; for (int i = 0; i &lt; n; i++) { p[i] = io.nextInt() - 1; } int[] map = new int[n]; for (int i = 0; i &lt; n; i++) { map[p[i]] = i; } int ans = 0; for (int i = 1; i &lt; n; i++) { if (map[i] &lt; map[i - 1]) { ans++; } } io.println(ans);} MEX Repetition每执行一次操作，就会去除最后一个数，并将 \\(MEX\\) 添加到序列头部。所以可以通过在数组末尾加上原始数组的 \\(MEX\\)，将操作看成是向左移动循环数组的起始索引。求原始数组的 \\(MEX\\) 可以使用求和公式。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); long sum = 0L; int[] a = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } a[n] = (int) ((long) (1 + n) * n / 2 - sum); k = k % (n + 1); for (int i = 0; i &lt; n; i++) { io.print(a[(-k + n + 1 + i) % (n + 1)] + &quot; &quot;); } io.println();} Two-Colored Dominoes横放的牌只会对列有影响，竖放的牌只会对行有影响，所以分别处理。按行遍历竖放的牌，每当遇到 \\(U\\) 就染上和上次相反的颜色，如果该行只包含奇数个 \\(U\\)，就返回 \\(-1\\)。横放的牌同理。 123456789101112131415161718192021222324252627282930313233343536373839public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } final char[] aux = {'B', 'W'}; for (int i = 0; i &lt; n - 1; i++) { int xor = 0; for (int j = 0; j &lt; m; j++) { if (s[i][j] == 'U') { s[i][j] = aux[xor]; s[i + 1][j] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int j = 0; j &lt; m - 1; j++) { int xor = 0; for (int i = 0; i &lt; n; i++) { if (s[i][j] == 'L') { s[i][j] = aux[xor]; s[i][j + 1] = aux[xor ^ 1]; xor ^= 1; } } if (xor != 0) { io.println(-1); return; } } for (int i = 0; i &lt; n; i++) { io.println(new String(s[i])); }} Speedrun其实思路是知道的，就是不知道怎么写。这个解法看着有点懵，可能其他解法会更好理解一点。注意题目给定 \\(a_{i}&lt;b_{i}\\)。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); int[] h = new int[n]; for (int i = 0; i &lt; n; i++) { h[i] = io.nextInt(); } List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, idx -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1; g[a].add(b); } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从 h[i] 开始） long[] dp = new long[n]; for (int i = n - 1; i &gt;= 0; i--) { for (int j : g[i]) { dp[i] = Math.max(dp[i], dp[j] + (h[j] - h[i] + k) % k); } } // dp[i] 表示完成所有依赖第 i 个任务的任务需要的时间（从零开始） long max = 0L; for (int i = 0; i &lt; n; i++) { dp[i] += h[i]; max = Math.max(max, dp[i]); } // 按照 h[i] 的大小，从小到大枚举起点 Integer[] aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; h[i] - h[j]); long ans = Long.MAX_VALUE; for (int i : aux) { ans = Math.min(ans, max - h[i]); // 如果起点大于 h[i]，那么任务 i 的完成时间需要加 k，从而导致 dp[i] + k // 其实只要枚举入度为 0 的任务就行，但是即使任务 i 不是入度为 0 任务也没有关系，因为对答案没有影响 max = Math.max(max, dp[i] + k); } io.println(ans);}","link":"/2023/08/31/Pinely%20Round%202%20(Div.%201%20+%20Div.%202)/"},{"title":"Educational Codeforces Round 154 (Rated for Div. 2)","text":"Prime Deletion从 \\(1\\) 到 \\(9\\) 的序列中删除一些数（至少保留两位），使得结果为质数。可以发现 \\(13\\) 和 \\(31\\) 都是质数，所以判断 \\(1\\) 和 \\(3\\) 的先后顺序，然后输出即可。 12345678910111213public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; for (int i = 0; i &lt; n; i++) { if (s[i] == '1') { io.println(13); return; } else if(s[i] == '3') { io.println(31); return; } }} Two Binary Strings比赛时我是从左往右遍历记录不相等的数量，如果有不相等的，那么就需要一个 \\(0\\)，否则遇到 \\(1\\) 就输出 YES。和正解的思路是一样的，就是麻烦一点。正解是有相同的 \\(01\\) 出现时就输出 YES。 123456789101112public static void solve() { char[] a = io.next().toCharArray(); char[] b = io.next().toCharArray(); int n = a.length; for (int i = 0; i &lt; n - 1; i++) { if (a[i] == b[i] &amp;&amp; a[i] == '0' &amp;&amp; a[i + 1] == b[i + 1] &amp;&amp; a[i + 1] == '1') { io.println(&quot;YES&quot;); return; } } io.println(&quot;NO&quot;);} Queries for the Array比较简单的写法就是用一个标记数组做记录，递增会向左传递，递减会向右传递，然后判断是否冲突即可。更进一步观察，可以发现只需要记录最大的递增位置，和最小的递减位置。 1234567891011121314151617181920212223242526272829public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; boolean ok = true; int pos = -1, neg = n, cur = -1; for (char c : s) { if (c == '+') { cur++; } else if (c == '-') { if (cur-- == neg) { neg = n; } pos = Math.min(pos, cur); } else if (c == '0') { if (cur == pos || cur &lt;= 0) { ok = false; break; } neg = Math.min(neg, cur); } else { if (neg &lt;= cur) { ok = false; break; } pos = cur; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Sorting By Multiplication没想到啊。枚举负数前缀的长度：在负数前缀中，如果 \\(a[i]&lt;=a[i+1]\\)，就需要操作一次；在正数后缀中，如果 \\(a[i]&gt;=a[i+1]\\) 就需要操作一次。（下面的代码很妙啊，不需要加额外的判断语句。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int cnt = 0; for (int i = 0; i &lt; n - 1; i++) { if (a[i] &gt;= a[i + 1]) { cnt++; } } int ans = cnt; for (int i = 1; i &lt; n; i++) { if (a[i - 1] &gt;= a[i]) cnt--; ans = Math.min(ans, cnt + 1); if (a[i - 1] &lt;= a[i]) cnt++; } io.println(ans);}","link":"/2023/09/04/Educational%20Codeforces%20Round%20154%20(Rated%20for%20Div.%202)/"},{"title":"AtCoder Beginner Contest 318","text":"Full Moon模拟。 1234public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); io.println(n &lt; m ? 0 : (n - m) / p + 1);} Overlapping sheets比赛时没什么思路，想到扫描线，就用扫描线 + 区间合并来做了。结果一看题解，暴力标记每个点，没想到。 1234567891011121314public static void solve() { int n = io.nextInt(), ans = 0; int[][] g = new int[100][100]; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(), b = io.nextInt(); int c = io.nextInt(), d = io.nextInt(); for (int x = a; x &lt; b; x++) { for (int y = c; y &lt; d; y++) { if (g[x][y]++ == 0) ans++; } } } io.println(ans);} Blue Spring看到大佬的解法后，感觉我模拟的方式好蠢啊。当时我是枚举是否要买 \\(d\\) 张票，有点麻烦，原来枚举买当日的票更简单。 1234567891011121314public static void solve() { int n = io.nextInt(), d = io.nextInt(), p = io.nextInt(); int[] f = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { f[i] = io.nextInt(); } Arrays.sort(f); long ans = Long.MAX_VALUE, sum = 0L; for (int i = 0; i &lt;= n; i++) { sum += f[i]; ans = Math.min(ans, sum + (long) (n - i + d - 1) / d * p); } io.println(ans);} General Weighted Max Matching动态规划有点不太会，赛时瞎搞 AC 的。记忆化搜索会很好写，然后 DP 的话，我是用三层循环解决的，下面的解法优化掉一层循环。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[][] d = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { d[i][j] = io.nextInt(); } } long[] dp = new long[1 &lt;&lt; n]; for (int k = 2; k &lt; 1 &lt;&lt; n; k++) { int i = Integer.numberOfTrailingZeros(k &amp; -k); dp[k] = dp[k ^ (1 &lt;&lt; i)]; for (int j = i + 1; j &lt; n; j++) { if ((k &gt;&gt; j &amp; 1) == 1) { dp[k] = Math.max(dp[k], dp[k ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j)] + d[i][j]); } } } io.println(dp[(1 &lt;&lt; n) - 1]);} Sandwiches比较显然的做法是把相同的数分为一组，然后组内枚举中间的数。对于每个中间的数，让答案加上 \\(L\\times R\\)，其中 \\(L\\) 和 \\(R\\) 分别是左右两边相等的数的个数，枚举时可以一次性枚举间隔内所有数。 第二个解法是参考大佬的代码得到的，相当于枚举右端点吧。对于每个右端点，它的贡献可以根据下面代码中的公式得出，感觉比较巧妙。 12345678910111213public static void solve() { int n = io.nextInt(); int[] cnt = new int[n]; long[] sum = new long[n]; long ans = 0L; for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; ans += (long) i * cnt[a] - sum[a] - (long) (1 + cnt[a]) * cnt[a] / 2; cnt[a]++; sum[a] += i; } io.println(ans);} Octopus有点抽象，不是很懂。大概是枚举了 \\(N^{2}\\) 个极限位置，然后分别对每个位置判断可行性。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int N = io.nextInt(); long[] X = new long[N]; long[] L = new long[N]; for (int i = 0; i &lt; N; i++) { X[i] = io.nextLong(); } for (int i = 0; i &lt; N; i++) { L[i] = io.nextLong(); } List&lt;Long&gt; pos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { pos.add(X[i] - L[j]); pos.add(X[i] + L[j] + 1); } } Collections.sort(pos); long ans = 0L; for (int i = 0; i &lt; pos.size() - 1; i++) { long[] dis = new long[N]; for (int j = 0; j &lt; N; j++) { dis[j] = Math.abs(pos.get(i) - X[j]); } Arrays.sort(dis); boolean ok = true; for (int j = 0; j &lt; N; j++) { if (dis[j] &gt; L[j]) { ok = false; break; } } if (ok) { ans += pos.get(i + 1) - pos.get(i); } } io.println(ans);}","link":"/2023/09/04/AtCoder%20Beginner%20Contest%20318/"},{"title":"第 112 场力扣夜喵双周赛","text":"判断通过操作能否让字符串相等 I同下。 判断通过操作能否让字符串相等 II模拟。也可以手动比较，就是适用性不好。（PS：想出一个写法，结果被自己 Hack 掉了~） 1234567891011class Solution { public boolean checkStrings(String s1, String s2) { int n = s1.length(); int[][] c1 = new int[2][26], c2 = new int[2][26]; for (int i = 0; i &lt; n; i++) { c1[i &amp; 1][s1.charAt(i) - 'a']++; c2[i &amp; 1][s2.charAt(i) - 'a']++; } return Arrays.deepEquals(c1, c2); }} 几乎唯一子数组的最大和滑动窗口。 12345678910111213141516171819class Solution { public long maxSum(List&lt;Integer&gt; nums, int m, int k) { int n = nums.size(); long sum = 0L, ans = 0L; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { map.merge(nums.get(i), 1, Integer::sum); sum += nums.get(i); if (i &gt;= k - 1) { if (map.size() &gt;= m) ans = Math.max(ans, sum); if (map.merge(nums.get(i - k + 1), -1, Integer::sum) == 0) { map.remove(nums.get(i - k + 1)); } sum -= nums.get(i - k + 1); } } return ans; }} 统计一个字符串的 k 子序列美丽值最大的数目因为和选择的顺序没有关系，所以贪心的选择出现次数最大的字母就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { private static final long MOD = (long) 1e9 + 7; public int countKSubsequencesWithMaxBeauty(String s, int k) { char[] ss = s.toCharArray(); int[] cnt = new int[26]; for (char c : ss) { cnt[c - 'a']++; } TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((a, b) -&gt; b - a); for (int i = 0; i &lt; 26; i++) { map.merge(cnt[i], 1, Integer::sum); } long ans = 1L; for (var e : map.entrySet()) { int key = e.getKey(), val = e.getValue(); if (val &gt;= k) { return (int) (ans * comb(val, k) % MOD * pow(key, k) % MOD); } k -= val; ans = (ans * pow(key, val)) % MOD; } return 0; } private long pow(long x, int n) { long res = 1L; while (n != 0) { if ((n &amp; 1) == 1) res = (res * x) % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return res; } private long comb(long n, int k) { long res = n; for (int i = 2; i &lt;= k; i++) { res = res * --n / i; } return res % MOD; }}","link":"/2023/09/04/%E7%AC%AC%20112%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 361 场力扣周赛","text":"统计对称整数的数目模拟。 12345678910111213141516171819202122class Solution { public int countSymmetricIntegers(int low, int high) { int ans = 0; for (int i = low; i &lt;= high; i++) { int x = i, n = 0; int[] aux = new int[10]; for (; x != 0; x /= 10) { aux[n++] = x % 10; } if (n % 2 == 0) { int sum = 0; for (int j = 0; j &lt; n / 2; j++) { sum += aux[j] - aux[j + n / 2]; } if (sum == 0) { ans++; } } } return ans; }} 生成特殊数字的最少操作比较简洁的暴力写法，当然从个位开始找 \\(25,75,50,00,0\\) 更快。 1234567891011121314151617class Solution { public int minimumOperations(String num) { int n = num.length(), ans = n; for (int i = 0; i &lt; n; i++) { if (num.charAt(i) == '0') { ans = Math.min(ans, n - 1); } for (int j = i + 1; j &lt; n; j++) { int x = (num.charAt(i) - '0') * 10 + num.charAt(j) - '0'; if (x % 25 == 0) { ans = Math.min(ans, n - i - 2); } } } return ans; }} 统计趣味子数组的数目最开始的思路是，找到所有满足 \\(nums[i]\\bmod modulo=k\\) 的下标放入新的列表，然后在新列表中枚举左端点 \\(i\\)，此时满足条件的右端点就是 \\(i+k-1+j\\times modulo\\)。暴力解决的时间复杂度 \\(O(n^{2})\\)，所以可以倒序枚举左端点，顺便记录间隔为 \\(modulo\\) 的后缀和。但是，这样解决还需要特判 \\(k=0\\) 的情况，总之很麻烦。 更好的做法是利用同余的性质。将所有 \\(nums[i]\\bmod modulo=k\\) 的数字看作 \\(1\\)，其他数字看作 \\(0\\)，这样我们要求的就是满足 \\((sum[r+1]-sum[l])\\bmod modulo=k\\) 的所有子数组的数目。我们可以枚举右端点，找到满足 \\((sum[r+1]-k)\\equiv sum[l]\\pmod{modulo}\\) 的左端点的个数，使用前缀和 + 哈希表即可。 12345678910111213141516class Solution { public long countInterestingSubarrays(List&lt;Integer&gt; nums, int modulo, int k) { long ans = 0L; int n = nums.size(), sum = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); for (int x : nums) { if (x % modulo == k) { sum = (sum + 1) % modulo; } ans += map.getOrDefault((sum - k + modulo) % modulo, 0); map.merge(sum, 1, Integer::sum); } return ans; }} 边权重均等查询树上倍增求最近公共祖先，同时维护边权的计数。详细见灵神题解。（发现汪佬的写法更简单，在 DFS 的同时进行倍增，以及通过拷贝数组来维护边权的计数信息。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution { private static final int M = 14; public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { int u = e[0], v = e[1], w = e[2] - 1; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] depth = new int[n]; int[][] cnt = new int[n][26]; int[][] parent = new int[M][n]; dfs(0, -1, g, depth, parent, cnt); // 查询 int k = queries.length; int[] ans = new int[k]; while (k-- != 0) { int x = queries[k][0], y = queries[k][1]; int z = lca(x, y, depth, parent), max = 0; for (int i = 0; i &lt; 26; i++) { max = Math.max(max, cnt[x][i] + cnt[y][i] - 2 * cnt[z][i]); } ans[k] = depth[x] + depth[y] - 2 * depth[z] - max; } return ans; } // DFS 的同时进行倍增，以及维护边权的计数 private void dfs(int x, int fa, List&lt;int[]&gt;[] g, int[] depth, int[][] parent, int[][] cnt) { for (int i = 1; 1 &lt;&lt; i &lt;= depth[x]; i++) { parent[i][x] = parent[i - 1][parent[i - 1][x]]; } for (int[] t : g[x]) { int y = t[0], w = t[1]; if (y != fa) { parent[0][y] = x; System.arraycopy(cnt[x], 0, cnt[y], 0, 26); cnt[y][w]++; depth[y] = depth[x] + 1; dfs(y, x, g, depth, parent, cnt); } } } // 求最近公共祖先 private int lca(int x, int y, int[] depth, int[][] parent) { if (depth[x] &gt; depth[y]) { int t = x; x = y; y = t; } // 先向上跳到相同深度 int step = depth[y] - depth[x]; for (int i = 0; i &lt; 32; i++) { if ((step &gt;&gt; i &amp; 1) != 0) { y = parent[i][y]; } } // 尽量向上跳 if (x != y) { for (int i = M - 1; i &gt;= 0; i--) { int px = parent[i][x], py = parent[i][y]; if (px != py) { x = px; y = py; } } x = parent[0][x]; } return x; }}","link":"/2023/09/04/%E7%AC%AC%20361%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 362 场力扣周赛","text":"与车相交的点差点又想区间合并做，看下数据范围，直接暴力，更好的做法是差分数组。 123456789101112131415class Solution { public int numberOfPoints(List&lt;List&lt;Integer&gt;&gt; nums) { int[] d = new int[102]; for (var num : nums) { d[num.get(0)]++; d[num.get(1) + 1]--; } int ans = 0; for (int i = 1; i &lt;= 100; i++) { d[i] += d[i - 1]; if (d[i] &gt; 0) ans++; } return ans; }} 判断能否在给定时间到达单元格题目说恰好第 \\(t\\) 秒到达，我还以为之前都不能到达，结果可以。那么特殊情况就是起点和终点相同，并且 \\(t=1\\)。 1234567class Solution { public boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) { if (sx == fx &amp;&amp; sy == fy &amp;&amp; t == 1) return false; int a = Math.abs(sx - fx), b = Math.abs(sy - fy); return Math.max(a, b) &lt;= t; }} 将石头分散到网格图的最少移动次数方法一：回溯 记录所有等于零和大于一的位置，然后 DFS 搜索每个零从哪个位置获取一。 12345678910111213141516171819202122232425262728293031class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); else if (grid[i][j] &gt; 1) b.add(new int[]{i, j}); } } dfs(0, grid, a, b, 0); return ans; } private void dfs(int i, int[][] grid, List&lt;int[]&gt; a, List&lt;int[]&gt; b, int cnt) { if (i == a.size()) { ans = Math.min(ans, cnt); return; } int[] p = a.get(i); for (int j = 0; j &lt; b.size(); j++) { int[] q = b.get(j); if (grid[q[0]][q[1]] &gt; 1) { grid[q[0]][q[1]]--; dfs(i + 1, grid, a, b, cnt + Math.abs(p[0] - q[0]) + Math.abs(p[1] - q[1])); grid[q[0]][q[1]]++; } } }} 方法二：状压 DP 不是很懂，具体解释可以看大佬的题解。 123456789101112131415161718192021222324252627282930class Solution { int ans = Integer.MAX_VALUE; public int minimumMoves(int[][] grid) { List&lt;int[]&gt; a = new ArrayList&lt;&gt;(), b = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { if (grid[i][j] == 0) a.add(new int[]{i, j}); for (int k = 2; k &lt;= grid[i][j]; k++) b.add(new int[]{i, j}); } } int n = a.size(); int[] f = new int[1 &lt;&lt; n]; for (int i = 1; i &lt; 1 &lt;&lt; n; i++) { f[i] = Integer.MAX_VALUE; int m = Integer.bitCount(i); for (int j = 0; j &lt; n; j++) { if ((i &gt;&gt; j &amp; 1) == 1) { f[i] = Math.min(f[i], f[i ^ (1 &lt;&lt; j)] + distance(a.get(m - 1), b.get(j))); } } } return f[(1 &lt;&lt; n) - 1]; } private int distance(int[] x, int[] y) { return Math.abs(x[0] - y[0]) + Math.abs(x[1] - y[1]); }} 字符串转换KMP + 矩阵快速幂，详细见灵神题解，学习 KMP 看代码随想录，还有各种其他解法可以看题解区（很不错！）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution { private static final int MOD = (int) 1e9 + 7; public int numberOfWays(String s, String t, long k) { int n = s.length(); char[] text = (s + s.substring(0, n - 1)).toCharArray(); char[] pattern = t.toCharArray(); int c = kmp(text, pattern); // f[0][0] = s.equals(t) ? 1 : 0; // f[0][1] = s.equals(t) ? 0 : 1; // f[i][0] = f[i - 1][0] * (c - 1) + f[i - 1][1] * c; // f[i][1] = f[i - 1][0] * (n - c) + f[i - 1][1] * (n - c - 1); long[][] m = {{c - 1, c}, {n - c, n - c - 1}}; m = pow(m, k); return s.equals(t) ? (int) m[0][0] : (int) m[0][1]; } private int kmp(char[] text, char[] pattern) { int m = text.length, n = pattern.length; int[] next = new int[n]; for (int i = 1, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) { j = next[j - 1]; } if (pattern[i] == pattern[j]) j++; next[i] = j; } int cnt = 0; for (int i = 0, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) { j = next[j - 1]; } if (text[i] == pattern[j]) j++; if (j == n) { cnt++; j = next[j - 1]; } } return cnt; } private long[][] pow(long[][] a, long n) { long[][] res = {{1, 0}, {0, 1}}; while (n != 0) { if ((n &amp; 1) == 1) res = mul(res, a); a = mul(a, a); n &gt;&gt;= 1; } return res; } private long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % MOD; } } return c; }}","link":"/2023/09/11/%E7%AC%AC%20362%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 896 (Div. 2)","text":"Make It Zero挺简单的一道题，偶数长度的数组操作两次就可以，如果是奇数长度，则额外操作两次。写的时候，把 \\(n\\) 错写成 \\(n-1\\)，找 BUG 花了一倍的时间。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } if (n % 2 == 0) { io.println(2); io.println(1 + &quot; &quot; + n); io.println(1 + &quot; &quot; + n); return; } io.println(4); io.println(1 + &quot; &quot; + (n - 1)); io.println(1 + &quot; &quot; + (n - 1)); io.println((n - 1) + &quot; &quot; + n); io.println((n - 1) + &quot; &quot; + n);} 2D Traveling\\(a\\) 和 \\(b\\) 的最短距离有两种情况，一个是 \\(a\\) 和 \\(b\\) 的曼哈顿距离，另一个是 \\(a\\) 和 \\(b\\) 经过 \\(k\\) 的曼哈顿距离，该情况只要求 \\(k\\) 个点中距离 \\(a\\) 和距离 \\(b\\) 最近的距离就行。比赛时遇到个坑点，两个 Long.MAX_VALUE 相加会溢出，所以初始时除以二。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(), a = io.nextInt(), b = io.nextInt(); long[] x = new long[n], y = new long[n]; for (int i = 0; i &lt; n; i++) { x[i] = io.nextInt(); y[i] = io.nextInt(); } long ak = Long.MAX_VALUE / 2, bk = Long.MAX_VALUE / 2; for (int i = 0; i &lt; k; i++) { ak = Math.min(ak, Math.abs(x[i] - x[a - 1]) + Math.abs(y[i] - y[a - 1])); bk = Math.min(bk, Math.abs(x[i] - x[b - 1]) + Math.abs(y[i] - y[b - 1])); } long ab = Math.abs(x[b - 1] - x[a - 1]) + Math.abs(y[b - 1] - y[a - 1]); io.println(Math.min(ab, ak + bk));} Fill in the Matrix比赛时代码很乱，赛后总是可以优化成比较简单的形式。分类讨论，\\(n\\) 和 \\(m\\) 的大小关系，可以直接得出最大美丽值，需要注意特判 \\(m=1\\) 的情况。然后就是构造，当 \\(n\\leq m-1\\) 时，让一个从 \\(0\\) 开始的数组循环左移来构造行，这样可以保证得到最大美丽值；当 \\(n&gt;m-1\\) 时，前 \\(m-1\\) 行与之前一样构造，之后多余的行只需要和最后一行相同即可（保证不会影响美丽值）。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(), m = io.nextInt(); if (m == 1) { io.println(0); } else if (n &lt;= m - 1) { io.println(n + 1); } else { io.println(m); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (i &lt; Math.min(n, m - 1)) { io.print((j + i) % m + &quot; &quot;); } else { io.print(j + &quot; &quot;); } } io.println(); }} Candy Party (Easy Version)找 BUG 花了半个小时，将判断 hi 是否是二的幂写成 hi % 2 != 0，修改为 Long.bitCount(hi) != 1 后通过，也可以写成 (hi &amp; hi - 1) != 0。因为每个人都需要发送和接收糖果，计算每个人和平均糖果数的差值 \\(x\\)，如果 \\(x\\) 的二进制位不是由连续的 \\(1\\) 组成，那么就无解，否则总是有唯一的 \\(lo\\) 和 \\(hi\\)（都是二的幂），使得 \\(hi-lo=|x|\\)。这样可以计算出每个人发送和接收多少糖果，如果最后相互抵消，则存在满足题目要求的交换方案。 12345678910111213141516171819202122232425262728293031323334353637383940public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); long lo = x &amp; -x, hi = x + lo; if (Long.bitCount(hi) != 1) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 0; i &lt; 32; i++) { if (cnt[i] != 0) { io.println(&quot;NO&quot;); return; } } io.println(&quot;YES&quot;);} Candy Party (Hard Version)考虑什么人可以不发送或者不接收糖果，必定是持有糖果数与平均糖果数的差值为二的幂的人，它们比原来多出一种选择，就是只执行一次发送或接收。具体操作见代码，有点说不清。最后大概是从高位到低位遍历，如果当前位不满足条件，就将低一位的差值与平均糖果数为二的幂的数分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void solve() { int n = io.nextInt(); long sum = 0L; long[] a = new long[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } if (sum % n != 0) { io.println(&quot;NO&quot;); return; } long avg = sum / n; int[] cnt = new int[32]; int[] in = new int[32], out = new int[32]; for (int i = 0; i &lt; n; i++) { if (a[i] == avg) continue; long x = Math.abs(a[i] - avg); if ((x &amp; x - 1) == 0) { int r = Long.numberOfTrailingZeros(x); if (a[i] &lt; avg) in[r]++; else out[r]++; continue; } long lo = x &amp; -x, hi = x + lo; if ((hi &amp; hi - 1) != 0) { io.println(&quot;NO&quot;); return; } int p = Long.numberOfTrailingZeros(lo); int q = Long.numberOfTrailingZeros(hi); if (a[i] &gt; avg) { cnt[p]--; cnt[q]++; } else { cnt[q]--; cnt[p]++; } } for (int i = 31; i &gt;= 0; i--) { cnt[i] += out[i] - in[i]; if (i == 0) break; in[i - 1] -= cnt[i]; out[i - 1] += cnt[i]; if (in[i - 1] &lt; 0 || out[i - 1] &lt; 0) { io.println(&quot;NO&quot;); return; } } io.println(cnt[0] == 0 ? &quot;YES&quot; : &quot;NO&quot;);}","link":"/2023/09/11/Codeforces%20Round%20896%20(Div.%202)/"},{"title":"Project #1 - Buffer Pool","text":"项目准备项目地址：Project #1 - Buffer Pool 准备工作：阅读 Chapter 12.1-12.4 13.2-13.3 24.2，学习 Lecture #03 #04，以及阅读课堂笔记。 项目结构buffer_pool_manager pages_ 数组相当于缓冲池，frame_id 是该数组的下标，也就唯一标识一个 Page，即标识一个缓冲页面。一个 Page 可以存储不同的物理页面，Page 的数据成员 page_id_ 唯一标识一个物理页面。因为不管是 FetchPage，还是 DeletePage 等函数，我们都是针对实际的物理页面做操作，所以 buffer_pool_manager 中的函数的形参都是提供 page_id。 lru_k_replacer 该类提供缓冲页面的淘汰策略，即淘汰某个 fram_id 对应的缓冲页面。一个缓冲页面会有一个对应的 LRUKNode，它负责记录该缓冲页面的访问历史。 page_guard 主要有三个类：BasicPageGuard，ReadPageGuard 和 WritePageGuard。BasicPageGuard 的作用是保证缓冲页面在使用完后会进行 UnpinPage 操作。而 ReadPageGuard 和 WritePageGuard，它们和 BasicPageGuard 是组合关系，它们的作用在 BasicPageGuard 的基础上保证页面在使用完后会解除读写锁。 Task #1 - LRU-K Replacement Policy实现① 一开始以为 current_timestamp_ 自动就是当前时间戳，调试时发现一直是 \\(0\\)，我真笨。可以直接从 \\(0\\) 开始手动模拟时间戳，调用 RecordAccess 时，让当前时间戳加 \\(1\\) 即可。 ② 在 Evict 的注释中有：If multiple frames have inf backward k-distance, then evict frame with earliest timestamp* based on LRU。我以为淘汰的是最后一次访问时间最早的 frame，结果淘汰的是第一次访问时间最早的 frame。 ③ 在 ListNode 中使 history_ 的长度不超过 k_，如果超过就调用 pop_front()，这样每次获取之前第 k_ 个访问记录只需要调用 front() 函数。 ④ 在 RecordAccess 的注释中有：If frame id is invalid (ie. larger than replacer_size_), throw an exception。但其实应该是大于等于吧，因为 BufferPoolManager 构造函数的实现如下： 12345678// we allocate a consecutive memory space for the buffer poolpages_ = new Page[pool_size_];replacer_ = std::make_unique&lt;LRUKReplacer&gt;(pool_size, replacer_k);// Initially, every page is in the free list.for (size_t i = 0; i &lt; pool_size_; ++i) { free_list_.emplace_back(static_cast&lt;int&gt;(i));} 上述代码说明 frame_id 是小于 pool_size 的，所以大于等于 pool_size 的 fram_id 都应该抛出异常。（或许小于零的也应该抛出异常） 补充① 测试时将 DISABLED_SampleTest 改为 SampleTest。 ② 忘记 C++ 的 = 是拷贝，传引用加上 &amp;： 1auto node = node_store_.at(frame_id); // 错误：拷贝 ③ LRU 的中文翻译是“最近最少使用”，实在让人很无语，我以后就将其称为“最久未被使用”吧。 Task #2 - Buffer Pool Manager实现① NewPage 和 FetchPage 有很多逻辑相同的部分，可以加个辅助函数来获取 frame_id。 ② 注意，在 FetchPage 时，如果页面在内存中并且 pin_count_ = 0，则需要将其设置为不可淘汰的。 ③ 在 UnpinPage 中，更新 is_dirty 属性时使用或运算，因为可能某个线程修改了页面数据，而其他线程没有修改。 ④ 在 FlushPage 中，注释表示 REGARDLESS of the dirty flag，应该说的是函数调用者，我们在实现时可以根据 is_dirty 来判断是否实际刷盘。 补充① 提交 GradeScope 报错时，下面会显示一堆 LeakSanitizer: detected memory leaks。但是没有关系，这应该是由于测试程序提前终止引发的，直接解决上面的错误就行。 ② 实现 FetchPage 时，有个情况我忘记调用 RecordAccess，竟然通过所有线上测试了，后来检查代码才发现，修改后 QPS 快了一些。 Task #3 - Read/Write Page Guards实现① 使用移动构造和移动赋值后，需要清除 that 的元数据。 ② 移动赋值的调用者，也就是 this，如果其 page_ != nullptr，那么需要先将其 Drop，再进行赋值操作。 ③ 实现读写页面守卫的移动构造函数，可以直接赋值 std::move(that.guard_)，相当于调用之前实现的 BasicPageGuard 的移动赋值运算符。 ④ 实现读写页面守卫的 Drop 时，需要注意在调用 guard_.Drop() 之后再解锁页面，所以在 Drop 之前需要保存一下指向页面的指针。 ⑤ 在实现 BufferPoolManager 中的 FetchPageRead 和 FetchPageWrite 时，为页面加读写锁。 ⑥ 和 PageGuard 有关的 FetchPage 函数会返回一个 PageGuard 对象，但是如果所有缓存页已经被 pin，那么该返回什么。一开始我是直接拿 nullptr 构造 PageGuard，但是发现不对，因为 PageGuard 对象并没有检查 page_ == nullptr 的函数，所以页面必须被 Fetch 到。要不就一直自旋，要不就使用条件变量，但是使用条件变量又要加个锁，防止通知丢失，那样锁竞争会很激烈啊。（不是很想改，BufferPoolManager 和 B+Tree 的线上测试都能过，暂时不管） Leaderboard Task (Optional)准备性能分析 看到CMU 15-445 2023 P1 优化攻略中使用火焰图做性能分析，之前从来没听说过，打算学习一下。以下是几个不错的网站，奈何感觉很复杂啊。一开始我是用 perf 做分析，然后使用 speedscope 进行可视化，但是捣鼓半天还没弄明白，遇到很多问题，有空再搞吧。 Brendan Gregg’s Homepage How to use flamegraphs for performance profiling profiling 与性能优化总结 speedscope LRU-K（对优化似乎没有帮助） 关于 LRU-K 的论文：The LRU-K Page Replacement Algorithm For Database Disk Buffering。 LRU 存在的问题：仅根据页面的最后一次访问时间进行淘汰，它不知道页面是否经常访问，从而可能将不经常访问的页面长时间保留在缓冲区中。（论文中对此有两个场景分析） 解决方案：① 页面池调优，缺点是需要人工操作，并且不能适应移动热点；② 查询执行计划分析，缺点是在多用户的场景下，查询优化器可能会以复杂的方式重叠；③ LRU-K，自适应的。（有点不是很懂） LRU-K 和 LFU 的区别：LRU-K 有一个“老化”的概念，即只考虑对页面的最后 K 次引用，而 LFU 无法区分最近和过去的引用频率，因此无法应对不断变化的访问模式。 LRU-K 存在的问题：① Early Page Replacement，新加入缓冲池的页面因为访问次数不足 K（\\(K\\geq 2\\)），所以相对于有 K 次访问历史的页面更容易被淘汰，但是该页面之后可能会有相关访问（原文是称作 Correlated References，并介绍了事务内、事务重试、进程内、进程间的相关访问）；② Page Reference Retained Information Problem，当页面被淘汰时，它的访问历史需要保留一段时间，如果超时再进行删除操作。 实现更新：以下内容存在一些错误，将会在下一节纠正。 ① 初次提交，所有函数开头一把大锁。提交相同的代码，排名波动挺大的，可能是因为没优化的代码跑分都差不多，QPS 大概四五千左右。 ② 并行 IO 优化，尝试在进行 IO 操作时将大锁切换为单独的页锁（针对 frame_id，即缓冲池页面的锁），简单来说就是在 IO 之前拿到页锁，然后释放大锁。一定需要注意加锁和解锁的顺序，如果有部分代码先加大锁再加页锁，另一部分代码先加页锁再加大锁，那么就会产生死锁。优化半天，遇到不少 BUG，但是没遇到死锁，QPS 提升至五万多。（注意，我们优化的是磁盘页面读写，而不是缓存页面读写，不要混淆，说的就是我） ③ 死锁警告，调试最久的一次，线上提交五十多次（当时不知道本地有 bpm-bench 测试），结果发现是我理解有问题。尝试使用读写锁在 BufferPoolManager 内部锁定页面，但是读写锁是依赖于访问类型的，因为有 Unknown 类型的存在，实际上根本无法执行该优化，并且该优化并不会提高 IO 的并行量。PS：仔细想想后发现甚至根本就不可能这样做，因为 FetchPage 时需要修改共享变量肯定不能用读写锁。并且根本就不可能有什么性能提升，因为优化的部分不涉及 IO 等耗时操作，所以瞎折腾半天后放弃。 ④ 参考CMU 15-445 2023 P1 优化攻略，似乎用的是写时复制的思想，刷盘的时候复制一份数据在新线程刷，这样就可以让当前线程做 ResetMemory 操作而不会产生冲突，具体的优化思路见文章。单纯的写时复制优化我觉得还行，刷盘之后就会释放复制页面占用的内存空间，读取的时候也可以重复利用。但是如果像文中那样固定为每个页面都保存缓存，那就相当于变相增加了缓冲池的容量，那还不如用下面的方法简单粗暴，并且时间和空间都应该是更优的。 ⑤ 有个无耻的优化方式，把所有页面全部存到内存缓存中，读盘的时候读缓存，刷盘的时候刷缓存，最后析构的时候再进行实际的物理刷盘。具体实现的时候，不能在析构的时候刷盘，因为线上测试会在析构 BufferPoolManager 之前析构 DiskManager，但是这样也是可以通过线上测试的，QPS 两百多万（其实大部分测试结果只有一百多万）。然而，这已经不能算优化了，磁盘数据库不可能这么操作的，因为内存不太可能存下所有页面。 ⑥ 本来想优化 LRU-K 的，但是想不到怎么根据访问类型来优化，怎么利用 zipfian 分布，暂时搁置。突然想到优化方法了，因为 Scan 线程是进行全表扫描，所以只被 Scan 线程访问过的页面就可以直接淘汰掉。我们可以在 LRUKNode 中维护一个布尔值，表示当前页面是否只被 Scan 线程访问，如果是就可以在 Evict 中直接淘汰，并且优先淘汰此类页面。回归正轨，基于 ② 优化提升大概三万 QPS，排名 12。（这优化完全是针对基准测试做的，没有什么适用性） Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 61 ALEX 111924 104867 261 484 5123 32 ALEX 102401 96293 4886 5221 57123 2 ALEX 120664 123402 182590 248050 2663116 12 ALEX 143562 133514 3813 8132 85169 重做实现纠错 在做 B+Tree 时发现上面第 ② 个实现有个 Bug，如果我新建一个缓存页面，然后它被淘汰刷盘，在刷盘之前，我会拿到该缓存页面的锁，然后释放缓冲池的独占锁，这会存在问题。为了避免死锁，加锁解锁的顺序是固定的，所以我释放缓冲池的独占锁后，不会再去尝试对它加锁。那么我就需要释放独占锁之前，修改完所有和缓冲池有关的共享变量（例如 page_table_），但是，如果在刷盘过程中，有另一个线程读取该页面，它在 page_table_ 中找不到该页面，所以它会去读取磁盘，这时页面还没有写入磁盘中，就会出现 “page not exist” 错误，错误在 disk_manager_memory.h 中被检测： 1234if (page_id &gt;= static_cast&lt;int&gt;(data_.size()) || page_id &lt; 0) { LOG_WARN(&quot;page not exist&quot;); return;} 所以第 ② 种优化方式是不完善的。可以额外搞个哈希表存正在进行刷盘的 page_id 和 frame_id，然后加个锁，在刷盘的时候加到该表里，刷完的时候删除（注意在添加到表时持有 page_table_ 的锁，以确保在其他线程 FetchPage 时，表中已有该 page_id）。这时如果有其他线程 Fetch 该 page_id，不会直接从磁盘读，而是读这个表拿到之前的 frame_id，然后拷贝到当前缓存页。（之所以另开哈希表，而不是保留在原来的表里，是因为如果这样会导致混乱，当有其他线程 FetchPage 该 page_id 时，会发生已淘汰又被 pin 的情况，还会发生其他很复杂的情况） 如何优化 既然 B+Tree 把我打回来修复 Bug，那么我就想，有没有更好的优化方案。自己独自优化总觉得找不到方向，并且可能设计就是错的，而且优化方式很幼稚。在网上搜也搜不到具体的优化方案，我就想尝试看一看开源数据库都是怎么做的，最后在 PostgreSQL 项目中发现一份超级详细的 README（MySQL 为什么没有），省去我看源码的时间，以下是对它的简单概述（使用我们项目中的变量来解释）： ① 缓存页面的访问规则 读写页面时必须 pin 页面，并拿到相应的读写锁。（文中要求必须在上锁之前 pin） 在读页面时，可以释放页面的读锁，因为已经拿到页面的 pin。 在写页面时，必须拿到 pin 和写锁，并且需要检查 pincount_ == 1，如果不相等，则释放写锁并返回或者使用条件变量等待唤醒。（因为在读页面时会提前释放读锁，但没有 unpin，所以拿到写锁时，还需要等待）当进行写操作时，有可能页面会被 pin，但是没有关系，因为当前线程拿到写锁，其他线程 pin 之后还需要拿锁才能读写页面。 我们的项目和上面的描述不一样，但是无伤大雅，基本上 PageGuard 和 FetchPage 等函数已经提供了这些功能。 ② 缓冲池管理器的内部锁定 访问 page_table_ 前需要拿到 page_table 的读写锁（文中称作 BufMappingLock）。如果是读页面，则在释放锁之前，需要拿到缓存页面的 pin。在修改 page_table_，或者修改缓存页面头部字段（应该是指 Page 的除 data_ 以外的成员变量，在本项目中就是 page_id_、pin_count_ 和 is_dirty_），或者从磁盘读物理页面到缓存页面时，需要拿到 page_table_ 的写锁。 可以将 BufMappingLock 拆分为 NUM_BUFFER_PARTITIONS 个锁，每个锁负责映射的一部分。每个 page_id_ 属于哪个分区，由 page_id_ 的哈希值的低比特位决定（其实就是有多个 page_table_，每个 page_id 会根据哈希函数来确定存放在哪个 page_table_ 中）。如果要同时锁定多个分区，则需要按照分区编号顺序锁定，以避免死锁。 为空闲列表和页面替换提供独占的自旋锁 buffer_strategy_lock ，当拿到该锁时，不应该去获取任何其他锁。 每个缓存页面都有一个自旋锁，在读写缓存页面头部字段时使用（疑问，如果有这个锁，在修改头部字段时似乎就不需要持有 BufMappingLock 锁）。 BM_IO_IN_PROGRESS 标志是一种锁，用来等待缓存页面的 IO。在从磁盘读物理页面到缓存页面，或者将缓存页面刷到磁盘的过程中，会将该标志置位，操作完成后清除标志位。等待标志位被清除的线程会使用条件变量休眠（疑问，如果有这个标志，那么在从磁盘读物理页面到缓存页面时，就不需要持有 BufMappingLock 锁吧）。 缓冲池管理器的优化就靠这部分内容，但是有些描述还是不太清晰（是不是我理解错误，并且文中涉及日志相关的内容，不是很好懂），实现的时候再想吧。然后文中还提出了如何对线性扫描做优化，但是我认为单纯在缓冲池管理器里面做不了这个优化，因为没办法识别当前操作是否是线性扫描，而且优化需要另开一个小缓冲池，这应该是查询优化器的任务。 ③ 后台线程刷盘 按照淘汰顺序扫描页面，选择 is_dirty_ == true &amp;&amp; pin_count_ == 0 的页面，然后 pin 该页面并刷盘，最后回收到空闲列表。 还有一些优化方式，没看懂就不翻译了。 总结一下，该文件中提到的优化，有一些可能跟它的页面替换算法相关（PostgreSQL 使用的是时钟扫描算法），或者和该数据库的其它特性相关（提示位之类的），看得云里雾里的，我们能够做的优化大概就是上面提到的这些，具体怎么实现还是走一步看一步吧。 尝试实现 重构代码，轻松通过本地测试，哭死。惊了，线上就一个测试没过。 ① FetchPage 在判断 page_id 是否在 page_table_ 时，需要使用 page_table_ 的独占锁。并且如果页面不在 page_table_ 中，则在函数返回 nullptr 或修改 page_table_ 之前不能释放该锁，以防止多次 FetchPage 同一个 page_id 时，多次从 free_list_ 中获取页面或者多次淘汰页面。 ② 因为在 FetchPage 将淘汰页面刷盘时，我会释放所有锁，这时页面是可以被 pin 的，所以之后设置 pin_count_ 时，不能直接设置为 1，而是进行 ++ 操作。 第一次重构没有拆分 BufMappingLock，没有使用自旋锁，其他的锁基本都加了。QPS 和之前的第 ② 个优化差不多，其实也可以想到，毕竟只是加了一些锁保证正确性，基本上没有提高并行性。本来想使用自旋锁的，但是因为需要条件等待，而条件变量只能用 unique_lock 作为参数，并且 atomic_flag 的原子等待只有在 C++ 20 才有，不好实现，遂放弃挣扎（而且估计不会有什么提升）。不搞了，像个小丑，没意思。 Rank Submission Name scan_qps_0ms get_qps_0ms scan_qps_1ms get_qps_1ms QPS 26 ALEX 92024 80293 5082 5287 57971 调试① 优化的时候一步一步优化，然后进行测试，要不然调试半天，都不知道 BUG 在代码的哪个位置。 ② 优化时容易出问题的点就是 NewPage 和 FetchPage，以及 UnpinPage。像是 FlushPage、FlushAllPage 以及 DeletePage 都可以暂时不管（可以直接 return），这样比较方便调试。 补充① 在 C++ 20 之前，结构化绑定不能被 lambda 表达式捕获。 ② 遇到 Reference to non-static member function must be called 问题，解决方案在此。 ③ MySQL Buffer Pool 的实现 15.5.1 Buffer Pool。 ④ Linus Torvalds 发表的一篇评论：do not use spinlocks in user space, unless you actually know what you’re doing。 ⑤ 条件变量如果使用不当，可能会导致唤醒丢失，必须利用锁保证不会在等待前执行唤醒操作。 ⑥ 发现一个感觉不错的博客：MC++。 测试结果测试通过！本地的测试数据比较弱，而且没有并发测试。如果线上测试遇到问题，可以通过添加打印语句，线上看输出来调试。基本上没遇到什么大问题，都是细节问题，很容易漏判断一些条件。另外，加锁优化是可选的，暴力加锁就可以通过测试。 优化任务让我的提交记录暴涨，特别是在尝试第 ③ 个优化方案时。一般等 4 分钟才能出结果，有时候评测机还会出问题，算下来等结果的时间都有 8 小时，离谱。 每次本地测试都需要输入很多命令，提交线上又要格式化，如果手动输入太麻烦了，可以写个 shell 脚本来执行： 123456789#!/bin/bashmake lru_k_replacer_test buffer_pool_manager_test page_guard_test -j$(nproc)./test/lru_k_replacer_test./test/buffer_pool_manager_test./test/page_guard_testmake formatmake check-lintmake check-clang-tidy-p1make submit-p1 项目小结① 在做项目的时候，总是会想某个地方是不是有更优的写法，但是当时对整个项目结构不太清楚，以及代码实现是否正确也不清楚，所以基本上都是浪费时间。据此，我的收获就是先让代码跑起来，其他的之后再说。 ② 虽然做的时候很艰辛，但是做完之后发现，好像也没有什么工作量，bpm 优化也就是简单减少锁的粒度，lru 的优化也完全是针对基准测试做的，感觉我的优化方式很烂，有没有更牛逼的优化方式啊。 ③ 我好菜啊！！！前三个任务花了两天，优化花了好几天。 更新：发现 Lecture #06 就是讲 BufferPool 优化的（课堂笔记），不知道能不能在这用上，等做完所有 Project 再来试试。","link":"/2023/09/12/Project%201%20-%20Buffer%20Pool/"},{"title":"Codeforces Round 897 (Div. 2)","text":"green_gold_dog, array and permutation让最小值减去最大值，就一定可以得到 \\(n\\) 个不同的差值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; a[i] - a[j]); int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { int t = aux[i]; ans[t] = n - i; } for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();} XOR Palindromes算是简单的分类讨论，比赛时写的稀烂。 123456789101112131415161718public static void solve() { int n = io.nextInt(), cnt = 0; char[] s = io.next().toCharArray(); for (int i = 0; i &lt; n / 2; i++) { if (s[i] != s[n - i - 1]) { cnt++; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt;= n; i++) { if (i &lt; cnt || i &gt; n - cnt || (i - cnt) % 2 == 1 &amp;&amp; n % 2 == 0) { sb.append('0'); } else { sb.append('1'); } } io.println(sb);} Salyg1n and the MEX Game比赛调试一小时，疯狂超时，结果是限制太强的原因。（浪费时间。） 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] s = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); } Arrays.sort(s); int x = n; for (int i = 0; i &lt; n ; i++) { if (s[i] != i) { x = i; break; } } while (x != -1) { io.println(x); io.flush(); x = io.nextInt(); }} Cyclic Operations做了一个多小时 AC，有点像之前做的内向基环树，该题每个点都有个出边，所以至少有一个环。首先要特判 \\(k=1\\) 的情况，该情况每个位置都必须自成一个环，即 \\(a_{i}=i\\)；其他情况所有环的长度都必须为 \\(k\\)，这样可以保证答案存在。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[b[i]]++; } Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } while (!q.isEmpty()) { int x = q.poll(); if (--in[b[x]] == 0) { q.offer(b[x]); } } int cnt = 0; boolean[] vis = new boolean[n]; for (int i = 0; i &lt; n; i++) { if (in[i] == 0 || vis[i]) continue; int len = 0; for ( ; !vis[i]; i = b[i]) { vis[i] = true; len++; } if (len != k) { io.println(&quot;NO&quot;); return; } cnt++; } if (k == 1 &amp;&amp; cnt != n) { io.println(&quot;NO&quot;); } else { io.println(&quot;YES&quot;); }} Salyg1n and Array (simple version)注意，\\(n\\) 和 \\(k\\) 都是偶数！手推的话可能可以做出来吧。 12345678910111213141516public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } for (; i &lt;= n; i++) { io.println(&quot;? &quot; + (i - k + 1)); io.flush(); ans ^= io.nextInt(); } io.println(&quot;! &quot; + ans); io.flush();} Salyg1n and Array (hard version)技巧性有点强，真想不到。就是如果多出一部分，可以通过两次异或算出来。 123456789101112131415161718public static void solve() { int n = io.nextInt(), k = io.nextInt(); int ans = 0, i; for (i = 1; i + k - 1 &lt;= n; i += k) { io.println(&quot;? &quot; + i); io.flush(); ans ^= io.nextInt(); } int t = n - i + 1; io.println(&quot;? &quot; + (n - k + 1 - t / 2)); io.flush(); ans ^= io.nextInt(); io.println(&quot;? &quot; + (n - k + 1)); io.flush(); ans ^= io.nextInt(); io.println(&quot;! &quot; + ans); io.flush();}","link":"/2023/09/17/Codeforces%20Round%20897%20(Div.%202)/"},{"title":"AtCoder Beginner Contest 320","text":"Leyland Number模拟。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(); int x = 1; for (int i = 0; i &lt; b; i++) { x *= a; } int y = 1; for (int i = 0; i &lt; a; i++) { y *= b; } io.println(x + y);} Longest Palindrome模拟。 123456789101112131415public static void solve() { String s = io.next(); int n = s.length(); int ans = 1; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { String a = s.substring(i, j + 1); String b = new StringBuilder(a).reverse().toString(); if (a.equals(b)) { ans = Math.max(ans, j - i + 1); } } } io.println(ans);} Slot Strategy 2 (Easy)暴力枚举每个转盘的时间。 1234567891011121314151617181920212223public static void solve() { int n = 3, m = io.nextInt(); int ans = Integer.MAX_VALUE; String[] s = new String[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.next(); } for (int i = 0; i &lt; n * m; i++) { char a = s[0].charAt(i % m); for (int j = 0; j &lt; n * m; j++) { if (i == j) continue; char b = s[1].charAt(j % m); for (int k = 0; k &lt; n * m; k++) { if (i == k || j == k) continue; char c = s[2].charAt(k % m); if (a == b &amp;&amp; b == c) { ans = Math.min(ans, Math.max(i, Math.max(j, k))); } } } } io.println(ans == Integer.MAX_VALUE ? -1 : ans);} Relative PositionDFS 模拟，需要注意给的不是一棵树，所以在 DFS 时要使用访问数组，而不能用父结点。 1234567891011121314151617181920212223242526272829303132333435public static void solve() { int n = io.nextInt(), m = io.nextInt(); List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int a = io.nextInt() - 1, b = io.nextInt() - 1, x = io.nextInt(), y = io.nextInt(); g[a].add(new int[]{b, x, y}); g[b].add(new int[]{a, -x, -y}); } long[] X = new long[n]; long[] Y = new long[n]; Arrays.fill(X, Long.MAX_VALUE); Arrays.fill(Y, Long.MAX_VALUE); boolean[] vis = new boolean[n]; dfs(0, vis, g, 0, 0, X, Y); for (int i = 0; i &lt; n; i++) { if (X[i] != Long.MAX_VALUE &amp;&amp; Y[i] != Long.MAX_VALUE) { io.println(X[i] + &quot; &quot; + Y[i]); } else { io.println(&quot;undecidable&quot;); } }}private static void dfs(int i, boolean[] vis, List&lt;int[]&gt;[] g, long x, long y, long[] X, long[] Y) { X[i] = x; Y[i] = y; vis[i] = true; for (int[] t : g[i]) { int j = t[0]; if (vis[j]) continue; long nx = t[1] + x, ny = t[2] + y; dfs(j, vis, g, nx, ny, X, Y); }} Somen Nagashi还是模拟，可以一边输入一边处理，减少代码量。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), m = io.nextInt(); long[] ans = new long[n], re = new long[n]; PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; p = new PriorityQueue&lt;&gt;((a, b) -&gt; Long.compare(re[a], re[b])); for (int i = 0; i &lt; n; i++) { q.offer(i); } while (m-- != 0) { int t = io.nextInt(), w = io.nextInt(), s = io.nextInt(); while (!p.isEmpty() &amp;&amp; re[p.peek()] &lt;= t) q.offer(p.poll()); if (q.isEmpty()) continue; int x = q.peek(); ans[x] += w; re[x] = t + s; p.offer(q.poll()); } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }}","link":"/2023/09/17/AtCoder%20Beginner%20Contest%20320/"},{"title":"第 113 场力扣夜喵双周赛","text":"使数组成为递增数组的最少右移次数直接从最小值开始判断数组是否递增，或者可以找到第一个递减的位置，然后再判断数组是否递增（因为如果数组满足条件，则其最多只有一个递减段）。 12345678910111213141516class Solution { public int minimumRightShifts(List&lt;Integer&gt; nums) { int n = nums.size(), idx = -1, min = 101; for (int i = 0; i &lt; n; i++) { if (nums.get(i) &lt; min) { min = nums.get(i); idx = i; } } for (int i = 0; i &lt; n - 1; i++) { int x = (idx + i) % n, y = (x + 1) % n; if (nums.get(x) &gt; nums.get(y)) return -1; } return (n - idx) % n; }} 删除数对后的最小数组长度贪心，比赛时我是用双指针做的，前半部分和后半部分进行匹配（当时边界想了很久，真笨！）。其他做法，参考题解：【小羊肖恩】数学 + 贪心：解决较长数组脑筋急转弯问题的关键。（因为 HashMap 很慢，所以用双指针会更快。） 方法一：贪心 1234567891011class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), i = 0; for (int j = (n + 1) / 2; j &lt; n; j++) { if (nums.get(i) &lt; nums.get(j)) { i++; } } return n - i * 2; }} 方法二：贪心 + 数学 12345678910class Solution { public int minLengthAfterRemovals(List&lt;Integer&gt; nums) { int n = nums.size(), max = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { max = Math.max(max, map.merge(x, 1, Integer::sum)); } return 2 * max &lt;= n ? n % 2 : n - (n - max) * 2; }} 统计距离为 k 的点对枚举 \\(x_{1}\\oplus x_{2}\\) 的值为 \\(p\\)，可以得到 \\(y_{1}\\oplus y_{2}\\) 的值为 \\(k-p\\)。可以使用 HashMap 对前缀中的值计数来求解，需要注意循环的顺序，如果调换顺序会使代码变复杂，会花费更多的时间计算答案。 1234567891011121314class Solution { public int countPairs(List&lt;List&lt;Integer&gt;&gt; coordinates, int k) { int ans = 0; Map&lt;List&lt;Integer&gt;, Integer&gt; map = new HashMap&lt;&gt;(); for (var c : coordinates) { int x = c.get(0), y = c.get(1); for (int i = 0; i &lt;= k; i++) { ans += map.getOrDefault(List.of(x ^ i, y ^ (k - i)), 0); } map.merge(c, 1, Integer::sum); } return ans; }} 可以到达每一个节点的最少边反转次数换根 DP，关键是要想到建立反向边，并为边添加相应的边权。 12345678910111213141516171819202122232425262728293031323334class Solution { public int[] minEdgeReversals(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(new int[]{v, 0}); g[v].add(new int[]{u, 1}); } int[] ans = new int[n]; ans[0] = dfs(0, -1, g); dfs2(0, -1, g, ans); return ans; } private int dfs(int x, int fa, List&lt;int[]&gt;[] g) { int res = 0; for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; res += dfs(y, x, g) + w; } return res; } private void dfs2(int x, int fa, List&lt;int[]&gt;[] g, int[] ans) { for (int t[] : g[x]) { int y = t[0], w = t[1]; if (y == fa) continue; ans[y] = ans[x] + (w == 0 ? 1 : -1); dfs2(y, x, g, ans); } }}","link":"/2023/09/17/%E7%AC%AC%20113%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 363 场力扣周赛","text":"计算 K 置位下标对应元素的和模拟。 1234567891011class Solution { public int sumIndicesWithKSetBits(List&lt;Integer&gt; nums, int k) { int n = nums.size(), ans = 0; for (int i = 0; i &lt; n; i++) { if (Integer.bitCount(i) == k) { ans += nums.get(i); } } return ans; }} 让所有学生保持开心的分组方法数比赛时又写复杂了，当时是想到所有相同的数都必须同时选，所以加了一层循环来跳过相同的数。但是相同的数天然的不满足判断条件，所以不需要这样写。这题唯一需要注意的就是特判全都不选的情况，以及全都选的情况必定满足，可以直接加到答案里（以减少判断代码）。 12345678910111213class Solution { public int countWays(List&lt;Integer&gt; nums) { Collections.sort(nums); int n = nums.size(), ans = 1; if (nums.get(0) &gt; 0) ans++; for (int i = 0; i &lt; n - 1; i++) { if (i + 1 &gt; nums.get(i) &amp;&amp; i + 1 &lt; nums.get(i + 1)) { ans++; } } return ans; }} 最大合金数比赛时又又写复杂了，当时是把所有的库存都清除了再二分的，其实可以直接二分！！ 12345678910111213141516171819class Solution { public int maxNumberOfAlloys(int n, int k, int budget, List&lt;List&lt;Integer&gt;&gt; composition, List&lt;Integer&gt; stock, List&lt;Integer&gt; cost) { int ans = 0; for (var cur : composition) { int lo = 0, hi = (int) 2e8; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; long cnt = 0L; for (int i = 0; i &lt; n; i++) { cnt += Math.max((long) cur.get(i) * mid - stock.get(i), 0L) * cost.get(i); } if (cnt &lt;= budget) lo = mid + 1; else hi = mid - 1; } ans = Math.max(ans, hi); } return ans; }} 完全子集的最大元素和注意题目的描述是每对元素的乘积都是完全平方数。朴素的想法就是对下标进行质因数分解，将所有出现次数为奇数质因数相乘，其结果作为桶的下标，把所有同类的数放在同一个桶里面，然后对每个桶求和取最大值，这样的时间复杂度是 \\(O(n\\sqrt{n})\\)。但是有 \\(O(n)\\) 的解法，如下所示。 1234567891011121314class Solution { public long maximumSum(List&lt;Integer&gt; nums) { long ans = 0L; int n = nums.size(); for (int i = 1; i &lt;= n; i++) { long sum = 0L; for (int j = 1; i * j * j &lt;= n; j++) { sum += nums.get(i * j * j - 1); } ans = Math.max(ans, sum); } return ans; }}","link":"/2023/09/17/%E7%AC%AC%20363%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 321","text":"321-like Checker模拟。 1234567891011public static void solve() { int n = io.nextInt(); String s = String.valueOf(n); for (int i = 0; i &lt; s.length() - 1; i++) { if (s.charAt(i) &lt;= s.charAt(i + 1)) { io.println(&quot;No&quot;); return; } } io.println(&quot;Yes&quot;);} Cutoff比赛时是暴力做的，赛后这个 \\(O(1)\\) 还想了半天。不多解释，代码还是比较好理解的。 12345678910111213141516public static void solve() { int n = io.nextInt(), x = io.nextInt(); int min = 101, max = -1, sum = 0; for (int i = 0; i &lt; n - 1; i++) { int t = io.nextInt(); sum += t; min = Math.min(min, t); max = Math.max(max, t); } int t = x - (sum - min - max); if (t &gt; max) { io.println(-1); } else { io.println(t &lt;= min ? 0 : t); }} 321-like Searcher原来是使用十个二进制位来表示对应数字是否存在，通过暴力枚举算出所有可能的数，最后排序获取对应的位置即可，真的没想到。 123456789101112131415public static void solve() { int k = io.nextInt(); List&lt;Long&gt; ans = new ArrayList&lt;&gt;(); for (int i = 2; i &lt; 1 &lt;&lt; 10; i++) { long x = 0L; for (int j = 9; j &gt;= 0; j--) { if ((i &gt;&gt; j &amp; 1) == 1) { x = x * 10 + j; } } ans.add(x); } Collections.sort(ans); io.println(ans.get(k - 1));} Set Menu二分，状态真差，把加法和乘法混淆了。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), m = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b); long[] sum = new long[m + 1]; for (int i = 0; i &lt; m; i++) { sum[i + 1] = sum[i] + b[i]; } long ans = 0L; for (int i = 0; i &lt; n; i++) { int x = p - a[i]; int lo = 0, hi = m - 1; while (lo &lt;= hi) { int mid= lo + (hi - lo) / 2; if (b[mid] &lt;= x) lo = mid + 1; else hi = mid - 1; } ans += ((long) lo * a[i] + sum[lo]) + (long) (m - lo) * p; } io.println(ans);}","link":"/2023/09/27/AtCoder%20Beginner%20Contest%20321/"},{"title":"第 364 场力扣周赛","text":"最大二进制奇数模拟。 12345678910111213141516class Solution {public: string maximumOddBinaryNumber(string s) { int n = s.size(), cnt = 0; for (char c : s) { if (c == '1') cnt++; } string ans; for (int i = 0; i &lt; n - 1; i++) { if (i &lt; cnt - 1) ans.push_back('1'); else ans.push_back('0'); } ans.push_back('1'); return ans; }}; 美丽塔 I同下。 美丽塔 II枚举以每个位置作为山顶，可以得到的最大高度和。通过使用单调栈 + 前后缀分解，可以 \\(O(n)\\) 的时间算出答案。 1234567891011121314151617181920212223242526class Solution {public: long long maximumSumOfHeights(vector&lt;int&gt;&amp; maxHeights) { int n = maxHeights.size(); vector&lt;long long&gt; left(n + 1), right(n + 1); stack&lt;int&gt; stk; stk.push(-1); for (int i = 0; i &lt; n; i++) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); left[i + 1] = left[stk.top() + 1] + 1LL * maxHeights[i] * (i - stk.top()); stk.push(i); } stk = stack&lt;int&gt;(); stk.push(n); for (int i = n - 1; i &gt;= 0; i--) { while (stk.size() &gt; 1 &amp;&amp; maxHeights[stk.top()] &gt; maxHeights[i]) stk.pop(); right[i] = right[stk.top()] + 1LL * maxHeights[i] * (stk.top() - i); stk.push(i); } long long ans = 0; for (int i = 0; i &lt; n; i++) { ans = max(ans, left[i] + right[i]); } return ans; }}; 统计树中的合法路径数目树型 DP，对于每个节点，计算以该节点为根的子树中，经过该节点的有效路径数，我们只需要维护子树中不包含质数的路径数和只包含一个质数的路径数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { private static final int N = (int) 1e5; private static final boolean[] np = new boolean[N + 1]; static { np[0] = np[1] = true; for (int i = 2; i &lt;= N / i; i++) { if (!np[i]) { for (int j = i; j &lt;= N / i; j++) { np[j * i] = true; } } } } long ans = 0L; public long countPaths(int n, int[][] edges) { List&lt;Integer&gt;[] g = new List[n + 1]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int[] e : edges) { g[e[0]].add(e[1]); g[e[1]].add(e[0]); } dfs(1, 0, g); return ans; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g) { int zero = 0, one = 0; if (np[x]) zero = 1; else one = 1; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g); ans += (long) zero * t[1] + (long) one * t[0]; if (np[x]) { zero += t[0]; one += t[1]; } else { one += t[0]; } } return new int[]{zero, one}; }}","link":"/2023/09/27/%E7%AC%AC%20364%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 899 (Div. 2)","text":"Increasing Sequence模拟，注意最后答案要减一。 1234567891011121314public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int b = 1; for (int i = 0; i &lt; n; i++) { if (b == a[i]) b += 2; else b += 1; } io.println(b - 1);} Sets and Union比赛时写复杂了，就是枚举不选哪个数，使用位运算会很简单。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); long xor = 0L; long[] s = new long[n]; for (int i = 0; i &lt; n; i++) { int k = io.nextInt(); for (int j = 0; j &lt; k; j++) { s[i] |= 1L &lt;&lt; io.nextInt(); } xor |= s[i]; } int ans = 0; for (int i = 1; i &lt;= 50; i++) { if ((xor &gt;&gt; i &amp; 1) != 1) continue; long res = 0L; for (int j = 0; j &lt; n; j++) { if ((s[j] &gt;&gt; i &amp; 1) != 1) { res |= s[j]; } } ans = Math.max(ans, Long.bitCount(res)); } io.println(ans);} Card Game思维题，没想出来。不管前两张牌如何操作，都必定可以拿到之后的所有正数牌，然后对前两张牌分类讨论即可。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } long ans = 0L; for (int i = 2; i &lt; n; i++) { ans += Math.max(0, a[i]); } ans += Math.max(0, a[0] + Math.max(0, n &gt; 1 ? a[1] : 0)); io.println(ans);} Tree XOR很典的换根 DP，因为第三题花费太长时间，导致差几分钟 AC。只要相邻的两个节点值不相同，它们就需要做一次操作。先以一个节点为根做 DFS，并记录所有节点的子树大小，和以该节点为根的成本。然后再做一次 DFS，换根计算代价的差值。（比赛时犯蠢，在换根的过程中打印答案，但是遍历不能保证从 \\(1\\) 到 \\(n\\) 的顺序，所以是错的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static long[] ans;private static int[] value, sz;private static List&lt;Integer&gt;[] g;public static void solve() { int n = io.nextInt(); value = new int[n]; for (int i = 0; i &lt; n; i++) { value[i] = io.nextInt(); } g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1; g[u].add(v); g[v].add(u); } sz = new int[n]; ans = new long[n]; dfs1(0, -1); dfs2(0, -1); for (int i = 0; i &lt; n; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs1(int x, int fa) { sz[x] = 1; for (int y : g[x]) { if (y == fa) continue; dfs1(y, x); sz[x] += sz[y]; ans[0] += (long) sz[y] * (value[x] ^ value[y]); }}private static void dfs2(int x, int fa) { for (int y : g[x]) { if (y == fa) continue; ans[y] = ans[x] + (long) (sz[0] - sz[y] - sz[y]) * (value[x] ^ value[y]); dfs2(y, x); }}","link":"/2023/09/27/Codeforces%20Round%20899%20(Div.%202)/"},{"title":"Educational Codeforces Round 155 (Rated for Div. 2)","text":"Rigged!模拟。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] s = new int[n]; int[] e = new int[n]; for (int i = 0; i &lt; n; i++) { s[i] = io.nextInt(); e[i] = io.nextInt(); } for (int i = 1; i &lt; n; i++) { if (s[i] &gt;= s[0] &amp;&amp; e[i] &gt;= e[0]) { io.println(-1); return; } } io.println(s[0]);} Chips on the Board有两种情况，每行都放一个或者每列都放一个，然后模拟即可。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] b = new int[n]; long suma = 0L; int mina = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); suma += a[i]; mina = Math.min(mina, a[i]); } long sumb = 0L; int minb = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); sumb += b[i]; minb = Math.min(minb, b[i]); } io.println(Math.min(suma + (long) minb * n, sumb + (long) mina * n));} Make it Alternating所有连续重复数的个数就是最少操作次数，然后就是简单的应用组合数学。 1234567891011121314151617181920private static final int MOD = 998244353;public static void solve() { char[] s = io.next().toCharArray(); int n = s.length; long cnt = n, sum = 1L; for (int i = 0; i &lt; n; ) { int j = i + 1; while (j &lt; n &amp;&amp; s[j] == s[j - 1]) { j++; } sum = sum * (j - i) % MOD; cnt--; i = j; } for (long i = 1; i &lt;= cnt; i++) { sum = sum * i % MOD; } io.println(cnt + &quot; &quot; + sum);} Sum of XOR Functions固定右端点，然后分别考虑每一位，计算答案，公式如下： $$ \\sum_{r=1}^{n}\\sum_{l=1}^{r}f(l,r)\\cdot (r-l+1) =\\sum_{r=1}^{n}\\sum_{i=0}^{31}\\sum_{l=1}^{r}(f_{i}(1,r)\\oplus f_{i}(1,l-1))\\cdot (r-(l-1)) $$ 可以发现对于每一位，\\(f_{i}(1,r)\\oplus f_{i}(1,l-1)\\) 的值不是 \\(1\\) 就是 \\(0\\)，只有当值为 \\(1\\) 时才会对答案有贡献。如果 \\(f_{i}(1,r)=1\\)，那么右端点 \\(r\\) 的第 \\(i\\) 位对答案的贡献为 \\((cnt[i][0]\\cdot r-sum[i][0])\\cdot 2^{i}\\)（其中 \\(cnt[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的个数，\\(sum[i][0]\\) 表示前缀中 \\(f_{i}=0\\) 的区间长度之和），另一种情况同理。 12345678910111213141516171819202122private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] s = new int[n + 1]; for (int i = 0; i &lt; n; i++) { s[i + 1] = s[i] ^ io.nextInt(); } long ans = 0L; long[][] cnt = new long[32][2]; long[][] sum = new long[32][2]; for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt; 32; j++) { int x = s[i] &gt;&gt; j &amp; 1; ans = (ans + (cnt[j][x ^ 1] * i - sum[j][x ^ 1]) % MOD * (1 &lt;&lt; j)) % MOD; cnt[j][x]++; sum[j][x] += i; } } io.println(ans);}","link":"/2023/09/27/Educational%20Codeforces%20Round%20155%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 900 (Div. 3)","text":"How Much Does Daytona Cost?所有长度为 \\(1\\) 的子数组，包含的元素必定是众数，所以只需判断 \\(k\\) 是否存在于数组中。 12345678910public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean ok = false; for (int i = 0; i &lt; n; i++) { if (k == io.nextInt()) { ok = true; } } io.println(ok ? &quot;YES&quot; : &quot;NO&quot;);} Aleksa and Stack两个奇数相加得到偶数，两个奇数相乘得到奇数，奇数不会被偶数整除，所以构造一个全是奇数的序列即可。 1234567public static void solve() { int n = io.nextInt(); for (int i = 0; i &lt; n; i++) { io.print(i * 2 + 1 + &quot; &quot;); } io.println();} Vasilije in Cacak只要 \\(x\\) 在最小值和最大值之间，就总是可以被表示出来。 12345678public static void solve() { int n = io.nextInt(), k = io.nextInt(); long x = io.nextLong(); long a = (long) (1 + k) * k / 2; long b = (long) (n - k + 1 + n) * k / 2; if (x &gt;= a &amp;&amp; x &lt;= b) io.println(&quot;YES&quot;); else io.println(&quot;NO&quot;);} Reverse Madness数组被 \\(l\\) 和 \\(r\\) 分段，每一段都是相互独立的，可以单独考虑段内的反转情况。可以发现段内反转总是中心对称的，每个元素是否反转，取决于该元素位置被反转次数的奇偶性，可以用两边向中间求累加和的方式统计，也可以用差分数组。（比赛时我没有统计奇偶性，而是抵消相邻的反转的相同部分） 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), k = io.nextInt(); char[] s = io.next().toCharArray(); int[] l = new int[k]; for (int i = 0; i &lt; k; i++) { l[i] = io.nextInt() - 1; } int[] r = new int[k]; for (int i = 0; i &lt; k; i++) { r[i] = io.nextInt() - 1; } int q = io.nextInt(); int[] cnt = new int[n]; for (int i = 0; i &lt; q; i++) { cnt[io.nextInt() - 1]++; } for (int i = 0; i &lt; k; i++) { int sum = 0; for (int a = l[i]; a &lt;= (l[i] + r[i]) / 2; a++) { int b = r[i] + l[i] - a; sum += cnt[a] + cnt[b]; if (sum % 2 == 1) { char c = s[a]; s[a] = s[b]; s[b] = c; } } } io.println(new String(s));} Iva &amp; Pav比较简单的做法是，计算每个比特位的前缀和，然后对每个查询二分答案的位置，将二分位置的值和 \\(k\\) 比较来判断二分的走向。比赛时我是用下面的方法做的，就是没想到二分，其实也可以不用二分，但是没看明白为什么，代码在此。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } // next[i][j] 表示 a[i] 的第 j 位等于 0 的下一个位置 int[][] next = new int[n + 1][32]; Arrays.fill(next[n], n); for (int i = n - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; 32; j++) { next[i][j] = next[i + 1][j]; if ((a[i] &gt;&gt; j &amp; 1) == 0) { next[i][j] = i; } } } int q = io.nextInt(); while (q-- != 0) { int l = io.nextInt() - 1, k = io.nextInt(); if (a[l] &lt; k) { io.print(&quot;-1 &quot;); continue; } int lo = l, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; int cur = 0; for (int i = 0; i &lt; 32; i++) { if (next[mid][i] &gt; mid &amp;&amp; next[mid][i] == next[l][i]) { cur |= 1 &lt;&lt; i; } } if (cur &gt;= k) lo = mid + 1; else hi = mid - 1; } io.print(hi + 1 + &quot; &quot;); } io.println();}","link":"/2023/09/27/Codeforces%20Round%20900%20(Div.%203)/"},{"title":"CodeTON Round 6 (Div. 1 + Div. 2, Rated, Prizes!)","text":"MEXanized Array分类讨论，一开始以为不能有重复，花了很多时间。（菜） 12345public static void solve() { int n = io.nextInt(), k = io.nextInt(), x = io.nextInt(); if (n &lt; k || x &lt; k - 1) io.println(-1); else io.println((k - 1) * k / 2 + (n - k) * (x == k ? k - 1 : x));} Friendly Arrays又看错题了，其实是道很简单的题。 123456789101112131415161718public static void solve() { int n = io.nextInt(), m = io.nextInt(); int a = 0; for (int i = 0; i &lt; n; i++) { a ^= io.nextInt(); } int b = 0; for (int i = 0; i &lt; m; i++) { b |= io.nextInt(); } int min = a, max = a; if (n % 2 == 0) { min = a ^ (a &amp; b); } else { max = a | b; } io.println(min + &quot; &quot; + max);} Colorful Table一个数可以向外扩展到大于等于它的的数的位置，我们可以按 \\(k\\) 的大小记录左右端点，然后按照从大到小遍历，来扩展边界，最后计算答案。注意，排除不在数组中的数。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), k = io.nextInt(); boolean[] mark = new boolean[k]; int[] l = new int[k], r = new int[k]; Arrays.fill(l, n); Arrays.fill(r, -1); for (int i = 0; i &lt; n; i++) { int a = io.nextInt() - 1; mark[a] = true; l[a] = Math.min(l[a], i); r[a] = i; } for (int i = k - 2; i &gt;= 0; i--) { l[i] = Math.min(l[i], l[i + 1]); r[i] = Math.max(r[i], r[i + 1]); } for (int i = 0; i &lt; k; i++) { if (!mark[i]) io.print(0 + &quot; &quot;); else io.print(2 * (r[i] - l[i] + 1) + &quot; &quot;); } io.println();} Prefix Purchase又又犯蠢了，题目都没读明白。如果右边有更小的数，那么肯定选更小的数是更优的，可以从右向左遍历，将右边的最小值传递到当前位置。然后就是依次处理每个位置，细节见代码。 1234567891011121314151617181920void solve() { int n; cin &gt;&gt; n; vector&lt;int&gt; c(n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c[i]; } int k; cin &gt;&gt; k; for (int i = n - 2; i &gt;= 0; i--) { c[i] = min(c[i], c[i + 1]); } int m = k; for (int i = 0; i &lt; n; i++) { int x = i == 0 ? c[i] : c[i] - c[i - 1]; if (x != 0) m = min(m, k / x); k -= x * m; cout &lt;&lt; m &lt;&lt; &quot; \\n&quot;[i == n - 1]; }}","link":"/2023/09/27/CodeTON%20Round%206%20(Div.%201%20+%20Div.%202,%20Rated,%20Prizes!)/"},{"title":"Project #2 - B+Tree","text":"项目准备项目地址：Project #2 - B+Tree 准备工作：阅读 Chapter 14.5 24.5 14.1-14.4 18.10.2，学习 Lecture #07 #08 #09，以及阅读课堂笔记。 Task #1 - B+Tree Pages实现① 第一个比较迷惑的点就是 max_size_ 的含义，对官方提供的B+Tree进行插入操作，发现叶子节点的 size_ 不会到达 max_size_。难道叶子节点实际只能包含 max_size_ - 1 个 key 吗？通过查看项目地址中的 Requirements and Hints 可以发现，官方建议叶子节点在插入后大小达到 max_size_ 时，进行分裂，内部节点在插入前大小达到 max_size_ 时进行分裂。所以对于内部节点，max_size_ 表示它能包含的指针数量；对于叶子节点，max_size_ 表示它能包含的键值对数量。 ② GetMinSize 的实现，同样参考官方示例，对于非叶子节点，返回 (max_size_ + 1) / 2；对于叶子节点，返回 max_size_ / 2。为什么要这样，参考第 ① 点也就明白了，这样可以保证分裂后的两个节点的大小都至少为最小大小，所以该方法的实现实际上取决于分裂的具体实现（即何时分裂）。 补充① 如何理解 MappingType array_[0]，注释表示它是 Flexible array member for page data，参见维基百科Flexible array member。似乎是 C 语言的特性，C++ 标准不支持，但是 C++ 的编译器普遍会支持。 ② 在内部节点和叶子节点中，array_ 的唯一区别就是在搜索内部节点时不能使用 array[0]_.first，因为它并不能准确表示 array_[0].second 中 key 的范围（向 array_[0].second 中插入一个更小的 key，它就失效了）。 Task #2a - B+Tree Insertion and Search for Single Values实现① 比较纠结的是既然要使用二分查找，如何保证节点内部 key 的有序性，因为是使用数组存储的，所以似乎只能花费 \\(O(n)\\) 时间来移动元素了？或者可以加一个数据结构存下标，来保证有序性，但是涉及分裂和删除操作还是比较难搞的，暂时不优化。 ② 可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Search 函数，来实现二分查找指定 key。内部节点一定可以找到一个满足条件的位置（因为我们找的实际上是指针），而叶子节点如果找不到指定 key，那么就返回 -index - 1（方便之后插入，类似 Java 中的 BinarySearch）。具体的实现逻辑： 内部节点从位置 1 开始找第一个大于 key 的键，返回它左边位置，即 index - 1。 叶子节点从位置 0 开始找第一个大于等于 key 的键，如果越界或者键值不等于 key，则返回 -index - 1，否则返回 index。 ③ 特别注意 PageGuard 的使用，只有当操作完页面之后，才对其进行 Drop 操作（移动赋值以及匿名对象的析构都会导致该操作）。并且用完页面后及时 Drop，这样可以尽早释放页面的锁以及 Unpin 页面。插入时，利用 latch crabbing 技巧，先拿到下个页面的锁，然后根据页面大小判断是否 Drop 上个页面（使用 Context）。注意拿锁和 Drop 的顺序，以及该大小判断依赖于分裂的实现，详细见 Task #1 - B+Tree Pages ①。 ④ 获取页面需要进行类型转换，如果只读不写就使用 page_guard.h 中提供的 As 函数，只有需要写页面时才使用 AsMut 函数，因为该函数会将页面置为脏页。先将其转换为 BPlusTreePage，然后再根据页面类型，将其转换为内部节点或叶子节点，注意 BPlusTree 类中已经为我们提供了别名： 12using InternalPage = BPlusTreeInternalPage&lt;KeyType, page_id_t, KeyComparator&gt;;using LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;; 一开始我没有注意，在对内部节点转换时，误将其 page_id_t 转为 ValueType，导致完全误解了整个项目的结构。 ⑤ 分裂叶子节点和内部节点时，注意判断当前节点是否是根节点。我们可以在 BPlusTreeInternalPage 和 BPlusTreeLeafPage 中添加 Split 函数，来实现分裂。 叶子节点的分裂操作比较简单，就是移动然后设置大小，为了不让页面类和其他类耦合（BufferPoolManager，Context），我将分裂函数的参数设计为 BPlusTreeInternalPage &amp;new_page，它会返回将插入到上层的 key，即新节点的第一个 key。 内部节点的分裂操作比较复杂，并发测试时遇到边界样例才发现，因为内部节点的分裂是插入前分裂，所以还需要考虑插入的那个键的大小。如果 key 比 array_[GetMinSize() - 1] 小，则插入到当前节点，否则插入到新分裂的节点。并且，在插入新分裂的节点时，可能会插入到索引为 0 的位置，这一点要特别注意。最后，也是返回新节点的第一个 key（指的是 array_[0].first，因为分裂的时候复制了）。 ⑥ 同理，在内部页面和叶子页面类中可以添加 Insert 函数。需要注意的是，这两个函数的实现有些点不同。对于内部节点，当 B+Tree 的根节点分裂时，该情况会将 page_id 插入到内部节点的第一个没有键的位置，所以我们可以将参数设计为 const std::optional&lt;KeyType&gt; &amp;opt 来区分这种情况。对于叶子节点，由于不能有相同的键，所以根据 Search 的实现，当 index ≥ 0 时返回 false，否则继续插入。 调试调试时可以先使用可视化网站查看 B+ 树，方便定位问题，我们可以使用 shell 脚本一键生成文件（解决方案）： 123#!/bin/bashmake b_plus_tree_printer -j$(nproc){ echo 2 3; echo i 1; echo i 2; echo g my-tree.txt; echo q; } | ./bin/b_plus_tree_printer 在生成文件时可能会报 [b_plus_tree.cpp:356:Draw] WARN - Drawing an empty tree 错误，原因是我们没有实现 b_plus_tree.cpp 中的 IsEmpty 函数。 补充① 如何使用 upper_bound 和 lower_bound（Java 选手表示踩了很多坑），可以看看 cppreference 的示例代码，尤其注意 lambda 表达式的使用（参数顺序，以及大小的比较）。 ② 测试时忽略 iterators 的测试。 ③ GetValue 注意特判根节点是否存在，否则可能引发空指针异常（依赖于 BufferPoolManager 的实现）。 Task #2b - B+Tree Deletions实现① 删除操作可以分为两种情况，相邻节点重新分配和相邻节点合并。进一步可以划分为操作当前节点的左节点，还是右节点。需要注意的是，我们只有对相同父节点的两个子节点执行上述操作，一个非根节点必定有一个同父的左节点或右节点。（如果不这样限制，实现起来会很麻烦，需要找到最近公共祖先，做键值的替换。）为了能够获取左右节点的页面，我们在从上到下找 key 对应的页面时，可以同时保存左右页面的 page_id。 ② 重新分配操作，需要区分左右。如果从右节点取，则需要更新右节点对应父节点中的 key；如果从左节点取，则需要更新当前节点对应父节点中的 key。操作完可以直接返回。 ③ 合并操作同理，只不过不是更新，而是删除对应父节点中的 key（递归删除）。注意，如果合并叶子节点，需要同时更新 next_page_id_。（合并之后右侧的页面永远都不会被使用，或许需要对其执行 DeletePage 操作，在 DeletePage 之前需要 Drop/Unpin 页面。有个疑问，DeletePage 之前 Drop 之后，如果有线程 Fetch，那么删除页面的操作就会失败。） 调试实现的思路弄明白后，大方向上就不会出错，但是很多细节容易写错：变量名字，重复执行 pop_back() 操作，删除页面后对页面进行操作等等。不过，说实话官方提供的可视化类真好用，Debug 全靠可视化来定位问题。磨磨蹭蹭，花费一天时间，做得有点慢。 Task #3 - An Iterator for Leaf Scans基本上没有难度，遇到唯一的错误就是把 GetSize 打成了 GetMaxSize（因为用的自动补全）。 Task #4 - Concurrent Index① 遇到问题，先定位它是什么问题。首先，应该解决非并发问题，我们可以在插入和删除的开头加一把大锁，然后利用并发测试 MixTest2，来混合查找、插入和删除操作，看看是否存在问题。为了尽可能引发问题，可以将叶子节点和内部节点的最大大小修改为 2 3，将 total_keys 修改为 1000，尽可能的触发分裂和合并操作（这个测试，比线上测试还强，多跑几次线上能过的给报错了）。在混合时，可以分别混合查找和插入，查找和删除，插入和删除，这样方便定位问题出在哪里。然后，再去进行并发优化，一点一点优化，边优化边测试，这样就不会因为找不到 Bug 的位置而发愁啦。 ② 遇到错误，[disk_manager_memory.h:104:ReadPage] WARN - page not exist，发现是 BufferPoolManager 的 Bug，需要跑回去修复。一天后，终于真正的把 Bug 修好了，代码也稍微重构了一下，哈哈，真的 99% 不会报错（有个 FetchPageBasic/Read/Write 返回 nullptr 的错误没修复，报错概率很低，以后有问题再修），不得不说本地测试用例修改后是真的强劲，线上强度不够啊。（但是重构了个寂寞，效率没变，难受啊） ③ B+Tree 的并发问题其实基本没有，都是单线程问题或者 BPM 的并发问题，B+Tree 的并发只要注意 Fetch 和 Drop 的顺序就 OK。 (Optional) Leaderboard Task① 初次提交通过，排名还挺高。额，多次提交能差七八万。感觉测试有问题，平均 QPS 也就十万多。 ② 优化暂时搁置。 Rank Submission Name read_qps write_qps total_qps 36 ALEX 200376 603 200980 测试结果Checkpoint #1 说简单也不简单，感觉有些细节总是写错，包括下标的处理，C++ 二分查找函数的使用，变量名称，以及一些边界条件。说难也不难，线上测试首次提交就通过了。总共花了一天半吧。 Checkpoint #2 总共花了两天，任务三四没什么难度，主要时间还是在删除操作，以及修复插入操作中的 Bug。 12345678910#!/bin/bashmake b_plus_tree_insert_test b_plus_tree_sequential_scale_test b_plus_tree_delete_test b_plus_tree_concurrent_test -j$(nproc)./test/b_plus_tree_insert_test./test/b_plus_tree_sequential_scale_test./test/b_plus_tree_delete_test./test/b_plus_tree_concurrent_testmake formatmake check-lintmake check-clang-tidy-p2make submit-p2 项目小结开始做项目之前，对插入和删除具体怎么操作还是比较迷糊的，实际实现起来发现原来是这样的。特别需要注意别打错变量名，我用自动补全总是搞混 MaxSize 和 MinSize，还有各种变量都敲错，运行起来找 Bug 就头疼了。还要注意，内部节点和叶子节点分裂的时机不同，实现也不同，以及在分裂时如何对待内部节点的第一个 key。然后删除操作就是个分类讨论，弄明白就不难了。并发错误我也真是见识到了，BPM 优化需谨慎啊。（做得还是很慢，对大佬来说，其实就是个复杂点的模拟题吧）","link":"/2023/09/29/Project%202%20-%20B+Tree/"},{"title":"AtCoder Beginner Contest 322","text":"First ABC 2123456public static void solve() { int n = io.nextInt(); String s = io.next(); int ans = s.indexOf(&quot;ABC&quot;); io.println(ans &lt; 0 ? -1 : ans + 1);} Prefix and Suffix1234567891011121314public static void solve() { int n = io.nextInt(), m = io.nextInt(); String s = io.next(), t = io.next(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (s.charAt(i) != t.charAt(i)) { ans |= 2; } if (s.charAt(i) != t.charAt(m - n + i)) { ans |= 1; } } io.println(ans);} Festival1234567891011121314151617public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] ans = new int[n]; Arrays.fill(ans, -1); for (int i = 0; i &lt; m; i++) { int x = io.nextInt() - 1; ans[x] = 0; } for (int i = n - 2; i &gt;= 0; i--) { if (ans[i] == -1) { ans[i] = ans[i + 1] + 1; } } for (int i = 0; i &lt; n; i++) { io.println(ans[i]); }} Polyomino模拟题，使用位运算似乎更简单，题解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public static void solve() { char[][][] G = new char[3][4][4]; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 4; j++) { G[i][j] = io.next().toCharArray(); } } io.println(dfs(0, G, new char[4][4]) ? &quot;Yes&quot; : &quot;No&quot;);}private static boolean dfs(int i, char[][][] G, char[][] C) { if (C == null) return false; if (i == 3) return check(C); for (int j = 0; j &lt; 4; j++) { for (int dx = -3; dx &lt;= 3; dx++) { for (int dy = -3; dy &lt;= 3; dy++) { char[][] T = move(dx, dy, G[i]); if (T == null) continue; if (dfs(i + 1, G, add(T, C))) return true; } } G[i] = rotate(G[i]); } return false;}private static char[][] rotate(char[][] A) { char[][] B = new char[4][4]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { B[i][j] = A[3 - j][i]; } } return B;}private static char[][] move(int dx, int dy, char[][] G) { char[][] res = new char[4][4]; for (int i = 0; i &lt; 4; i++) { Arrays.fill(res[i], '.'); } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { int nx = i + dx, ny = j + dy; if(G[i][j] == '#') { if (nx &lt; 0 || nx &gt;= 4 || ny &lt; 0 || ny &gt;= 4) { return null; } res[nx][ny] = G[i][j]; } } } return res;}private static char[][] add(char[][] T, char[][] C) { char[][] res = new char[4][4]; for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (C[i][j] == '#' &amp;&amp; T[i][j] == '#') return null; if (C[i][j] == '#' || T[i][j] == '#') res[i][j] = '#'; else res[i][j] = '.'; } } return res;}private static boolean check(char[][] C) { for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 4; j++) { if (C[i][j] != '#') return false; } } return true;} Product Development动态规划，\\(dp[i][j]\\) 表示从前 \\(i\\) 个计划中选择开发计划，使得参数到达 \\(j\\)，需要的最小成本，其中 \\(j\\) 表示 \\(a_{1},a_{2},\\dots,a_{k}\\) 的某个取值，通过将序列看作 \\(p+1\\) 进制数，可以将一个序列转换为某个数值（在这里就是 \\(j\\)）。 12345678910111213141516171819202122232425262728293031323334public static void solve() { int n = io.nextInt(), k = io.nextInt(), p = io.nextInt(); int[] pw = new int[k + 1]; pw[0] = 1; for (int i = 1; i &lt;= k; i++) { pw[i] = pw[i - 1] * (p + 1); } long[] dp = new long[pw[k]]; Arrays.fill(dp, -1L); dp[0] = 0; for (int i = 0; i &lt; n; i++) { int c = io.nextInt(); int[] a = new int[k]; for (int j = 0; j &lt; k; j++) { a[j] = io.nextInt(); } for (int s = pw[k] - 1; s &gt;= 0; s--) { int t = 0; for (int j = 0; j &lt; k; j++) { int cur = s / pw[j] % (p + 1); int nxt = Math.min(p, cur + a[j]); t += nxt * pw[j]; } if (dp[s] != -1 &amp;&amp; (dp[t] == -1 || dp[t] &gt; dp[s] + c)) { dp[t] = dp[s] + c; } } } io.println(dp[pw[k] - 1]);}","link":"/2023/10/02/AtCoder%20Beginner%20Contest%20322/"},{"title":"Codeforces Round 901 (Div. 2)","text":"Jellyfish and Undertale每个工具对答案的贡献为 \\(\\min(a-1,x_{i})\\)，并且答案可能会爆 \\(long\\)，状态好差，WA 两次。 12345678public static void solve() { int a = io.nextInt(), b = io.nextInt(), n = io.nextInt(); long ans = b; for (int i = 0; i &lt; n; i++) { ans += Math.min(a - 1, io.nextInt()); } io.println(ans);} Jellyfish and Game数学题。当 \\(k\\bmod 2=1\\) 时，先手会得到 \\(\\min(0,maxb-mina)\\)；反之，后手此时必然有最小价值的苹果 \\(\\min(mina,minb)\\)，而先手此时会有最大价值的苹果 \\(\\max(maxa,maxb)\\)，做一次交换即可。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); long suma = 0L; int mina = Integer.MAX_VALUE, maxa = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) { int x = io.nextInt(); suma += x; mina = Math.min(mina, x); maxa = Math.max(maxa, x); } int minb = Integer.MAX_VALUE, maxb = Integer.MIN_VALUE; for (int i = 0; i &lt; m; i++) { int x = io.nextInt(); minb = Math.min(minb, x); maxb = Math.max(maxb, x); } if (k % 2 == 1) { io.println(suma + Math.max(0, maxb - mina)); } else { io.println(suma + Math.max(0, maxb - mina) - Math.max(maxa, maxb) + Math.min(mina, minb)); }} Jellyfish and Green Apple完了，官方解法看不懂，下面是我的解法，就是一直乘二求余，贪心的拆分。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(), m = io.nextInt(); int x = n % m, y = m / gcd(n, m); if ((y &amp; (y - 1)) != 0) { io.println(-1); return; } long ans = 0L; while (x != 0) { ans += x; x *= 2; x %= m; } io.println(ans);}private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} 下面是官解，大概懂了。\\(\\frac{a}{b}\\) 表示最终每个人得到的苹果价值的小数部分（可以表示为 \\(\\sum_{i\\in S}\\frac{1}{2^{i}}\\)），因为 \\(b\\) 必须是二的幂，所以 \\(a\\) 中 \\(1\\) 的个数就表示这个人所需的最小苹果片数（就是集合 \\(S\\) 中元素的个数），乘以 \\(m\\) 就表示最后总共的苹果片数，然后减去最开始的 \\(n\\) 片就是需要进行操作的次数（因为每次操作会增加 \\(1\\) 片）。（这个题解很详细，提供了另一种视角） 12345678910111213141516public static void solve() { int n = io.nextInt(), m = io.nextInt(); n %= m; int x = gcd(n, m), a = n / x, b = m / x; if ((b &amp; (b - 1)) != 0) { io.println(-1); } else { io.println((long) Integer.bitCount(a) * m - n); }}private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} Jellyfish and Mex其实是很简单的动态规划，但就是动不起来啊。定义 \\(dp[i]\\) 为将 \\(MEX\\) 变为 \\(i\\) 需要的最小代价，然后从大到小转移即可。 12345678910111213141516171819202122private static final int N = 5001;public static void solve() { int n = io.nextInt(); int[] cnt = new int[N]; for (int i = 0; i &lt; n; i++) { int x = io.nextInt(); if (x &lt; n) cnt[x]++; } int mex = 0; while (cnt[mex] &gt; 0) mex++; long[] dp = new long[mex + 1]; Arrays.fill(dp, Long.MAX_VALUE); dp[mex] = 0; for (int i = mex - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt;= mex; j++) { dp[i] = Math.min(dp[i], dp[j] + (long) (cnt[i] - 1) * j + i); } } io.println(dp[0]);}","link":"/2023/10/02/Codeforces%20Round%20901%20(Div.%202)/"},{"title":"第 365 场力扣周赛","text":"有序三元组中的最大值 I同下。 有序三元组中的最大值 II方法一：枚举 j 比赛时第一想法是枚举 \\(j\\)，然后取左边和右边的最大值计算答案。 123456789101112131415161718class Solution { public long maximumTripletValue(int[] nums) { int n = nums.length; int[] pre = new int[n + 1]; int[] suf = new int[n + 1]; for (int i = 0; i &lt; n; i++) { pre[i + 1] = Math.max(pre[i], nums[i]); } for (int i = n - 1; i &gt;= 0; i--) { suf[i] = Math.max(suf[i + 1], nums[i]); } long ans = 0L; for (int j = 1; j &lt; n - 1; j++) { ans = Math.max(ans, (long) (pre[j] - nums[j]) * suf[j + 1]); } return ans; }} 方法二：枚举 k 参考灵神的题解，可以枚举 \\(k\\)，使空间复杂度降为 \\(O(1)\\)。主要想法就是枚举时，维护前缀最大差值。 123456789101112class Solution { public long maximumTripletValue(int[] nums) { long ans = 0; int maxDiff = 0, preMax = 0; for (int x : nums) { ans = Math.max(ans, (long) maxDiff * x); maxDiff = Math.max(maxDiff, preMax - x); preMax = Math.max(preMax, x); } return ans; }} 无限数组的最短子数组比赛时思路很快出来，但是实现的时候漏掉一些边界条件，导致 WA 多次，本来有机会进第一页的。比较直接的想法是枚举起始位置，然后利用前缀和二分结束的位置，如果满足条件就记入答案。也可以使用哈希表来优化，避免二分。这里贴一下灵神的滑动窗口解法，时间复杂度 \\(O(n)\\)，空间复杂度 \\(O(1)\\)。 12345678910111213141516171819class Solution { public int minSizeSubarray(int[] nums, int target) { int n = nums.length; long sum = 0L, pre = 0L; for (int x : nums) sum += x; int q = (int) (target / sum), r = (int) (target % sum); int lo = 0, hi = 0, ans = Integer.MAX_VALUE; while (hi &lt; 2 * n) { pre += nums[hi++ % n]; while (pre &gt; r) { pre -= nums[lo++ % n]; } if (pre == r) { ans = Math.min(ans, hi - lo); } } return ans == Integer.MAX_VALUE ? -1 : ans + q * n; }} 有向图访问计数看完题目就知道是内向基环树，直接修改上次的代码，轻松通过，本题是上次的简化版。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { public int[] countVisitedNodes(List&lt;Integer&gt; edges) { int n = edges.size(); // 建立环外节点的反向边 int[] in = new int[n]; List&lt;Integer&gt;[] reverse = new List[n]; Arrays.setAll(reverse, r -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n; i++) { in[edges.get(i)]++; reverse[edges.get(i)].add(i); } // 拓扑序去除环外节点 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) q.add(i); } while (!q.isEmpty()) { int x = q.poll(); if (--in[edges.get(x)] == 0) { q.offer(edges.get(x)); } } // 记录每个节点在哪个环 int[] cirNum = new int[n]; boolean[] vis = new boolean[n]; List&lt;Integer&gt; circles = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; in[i] != 0) { int cnt = 0; for (int cur = i; !vis[cur]; cur = edges.get(cur)) { vis[cur] = true; cirNum[cur] = circles.size(); cnt++; } circles.add(cnt); } } // 对环内的每个节点向环外进行 dfs int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) { if (in[i] != 0) dfs(i, reverse, in, circles.get(cirNum[i]), ans); } return ans; } private void dfs(int x, List&lt;Integer&gt;[] reverse, int[] in, int len, int[] ans) { ans[x] = len; for (int y : reverse[x]) { if (in[y] != 0) continue; dfs(y, reverse, in, len + 1, ans); } }} 有个非常简单的写法，参考题解。 12345678910111213141516171819202122232425262728class Solution { public int[] countVisitedNodes(List&lt;Integer&gt; edges) { int n = edges.size(); int[] ans = new int[n]; int[] vis = new int[n]; for (int i = 0; i &lt; n; i++) { if (ans[i] == 0) { int cnt = 0, cirLen = 0, totLen = 0, pos = i; while (vis[pos] == 0) { vis[pos] = ++cnt; pos = edges.get(pos); } if (ans[pos] == 0) { cirLen = cnt - vis[pos] + 1; totLen = cnt; } else { totLen = cnt + ans[pos]; } pos = i; while (ans[pos] == 0) { ans[pos] = Math.max(totLen--, cirLen); pos = edges.get(pos); } } } return ans; }}","link":"/2023/10/02/%E7%AC%AC%20365%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 366 场力扣周赛","text":"分类求和并作差数学性质，\\([1,n]\\) 中能被 \\(m\\) 整除的数有 \\(\\lfloor \\frac{n}{m}\\rfloor\\) 个。 12345class Solution { public int differenceOfSums(int n, int m) { return (1 + n) * n / 2 - (1 + (n / m)) * (n / m) * m; }} 最小处理时间排序 + 贪心。 1234567891011class Solution { public int minProcessingTime(List&lt;Integer&gt; processorTime, List&lt;Integer&gt; tasks) { Collections.sort(processorTime); Collections.sort(tasks, (a , b) -&gt; b - a); int n = processorTime.size(), ans = 0; for (int i = 0; i &lt; n; i++) { ans = Math.max(ans, processorTime.get(i) + tasks.get(i * 4)); } return ans; }} 执行操作使两个字符串相等方法一：动态规划 今天脑子有点笨啊，本来做出来了，但是我将 dp 的初始值设置为 Integer.MAX_VALUE，将 dfs 不满足条件时的返回值也设置为该值，而判断是否记忆化的条件也设置为该值，所以所有不满足条件的方案都没有记忆化上。 我经常会写出从上到下记忆化的代码，但是每次都比从下到上的记忆化慢，经过分析，原因如下：从下到上的记忆化，只要该节点计算过，就会直接返回；而从上到下的记忆化，只有在当前节点的值比记忆化的值大时，才会直接返回，也就是说，这样的代码只会将所有大于记忆化的值的方案给剪枝掉，所有小于记忆化的值的方案会重复计算。 12345678910111213141516171819202122232425262728293031class Solution { public int minOperations(String s1, String s2, int x) { int n = s1.length(); int[][][] dp = new int[n][n + 1][2]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n + 1; j++) { Arrays.fill(dp[i][j], -1); } } int ans = dfs(0, 0, 0, s1, s2, x, dp); return ans &gt;= (int) 1e9 ? -1 : ans; } private int dfs(int i, int c, int r, String s1, String s2, int x, int[][][] dp) { if (i == s1.length()) { if (c % 2 == 0 &amp;&amp; r == 0) { return -c / 2 * x; } return (int) 1e9; } if (dp[i][c][r] != -1) return dp[i][c][r]; int res = 0; if ((s1.charAt(i) == s2.charAt(i)) == (r == 0)) { res = dfs(i + 1, c, 0, s1, s2, x, dp); } else { res = dfs(i + 1, c + 1, 0, s1, s2, x, dp) + x; res = Math.min(res, dfs(i + 1, c, 1, s1, s2, x, dp) + 1); } return dp[i][c][r] = res; }} 方法二：动态规划 时间复杂度 \\(O(n)\\)，空间复杂度 \\(O(1)\\) 的解法，其实比赛时第一眼差不多就想到这种解法，但是没有细想。 1234567891011121314151617class Solution { public int minOperations(String s1, String s2, int x) { int n = s1.length(); int pre = -1, cnt = 0; int dp0 = (int) 1e9, dp1 = 0; for (int i = 0; i &lt; n; i++) { if (s1.charAt(i) != s2.charAt(i)) { cnt ^= 1; int t = dp1; dp1 = Math.min(dp1 + (cnt == 1 ? x : 0), dp0 + i - pre); dp0 = t; pre = i; } } return cnt == 1 ? -1 : dp1; }} 对数组执行操作使平方和最大挺简单一道题，T3 卡太久，脑子短路没时间做这题。对于每一位，每次操作其实就是交换两个数之间的 \\(0\\) 和 \\(1\\)，我们应该总是把 \\(1\\) 交换到更大的数上，这样平方和最大。所以统计每一位的 \\(1\\) 的个数，贪心的组合成最大的数，然后取平方加入答案即可。 1234567891011121314151617181920212223242526class Solution { private static final int MOD = (int) 1e9 + 7; public int maxSum(List&lt;Integer&gt; nums, int k) { int[] cnt = new int[30]; for (int x : nums) { for (int i = 0; i &lt; 30; i++) { cnt[i] += x &gt;&gt; i &amp; 1; } } long ans = 0L; while (k-- != 0) { int x = 0; for (int i = 0; i &lt; 30; i++) { if (cnt[i] &gt; 0) { cnt[i]--; x |= 1 &lt;&lt; i; } } ans = (ans + (long) x * x) % MOD; } return (int) ans; }}","link":"/2023/10/09/%E7%AC%AC%20366%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round)","text":"Goals of Victory所有效率之和等于零。 1234567public static void solve() { int n = io.nextInt(), sum = 0; for (int i = 0; i &lt; n - 1; i++) { sum += io.nextInt(); } io.println(-sum);} Helmets in Night Light贪心选择最小花费的通知，注意维护已经被通知的下标，根据该下标判断是否需要加 \\(p\\)，并且如果某个人通知其他人的成本大于 \\(p\\)，则他不会通知其他人。发现大佬的解法好简单，取一个最小值，维护一个剩余人数即可。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(), p = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; b[i] - b[j]); long ans = p; int r = n - 1; for (int i : aux) { int x = Math.min(r, a[i]); ans += (long) x * Math.min(p, b[i]); r -= x; } io.println(ans);} Joyboard分类讨论，注意被 \\(n\\) 整除的数。 1234567public static void solve() { int n = io.nextInt(), m = io.nextInt(), k = io.nextInt(); if (k == 3) io.println(Math.max(0, m - n - m / n + 1)); else if (k == 2) io.println(m / n + Math.min(n - 1, m)); else if (k == 1) io.println(1); else io.println(0);} Effects of Anti Pimples很容易的想到计算选择每个索引位置，能够得到的最大分数，时间复杂度为 \\(O(n\\log{n})\\)。然后计算每个位置有多少种方案，比赛时我以为选择一个索引位置，默认就选择了它的所有倍数位置，导致不会做。其实只要排序，然后每个位置的方案数就是它左边的数选或不选的方案数，这样可以保证不会重复计算，所以快速幂计算方案数（可以在遍历的时候计算方案数），再乘以得分累加到答案即可。 123456789101112131415161718192021222324private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); int[] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { dp[i] = io.nextInt(); } dp[0] = Integer.MAX_VALUE; for (int i = 1; i &lt;= n; i++) { for (int j = 2 * i; j &lt;= n; j += i) { dp[i] = Math.max(dp[i], dp[j]); } } Arrays.sort(dp); long ans = 0L, pow = 1L; for (int i = 0; i &lt; n; i++) { ans = (ans + dp[i] * pow) % MOD; pow = pow * 2 % MOD; } io.println(ans);} Autosynthesis方法一：内向基环树 对于每个 \\(i\\)，建立一条从 \\(i\\) 指向 \\(a_{i}\\) 的边，最终会得到多个内向基环树。规则一：入度为零的节点不会被选择；规则二：如果一个节点的所有入度节点都被选择，那么它不会被选择；规则三：如果一个节点不被选择，那么它指向的节点会被选择。（以上规则可以使用拓扑序 + 染色法实现） 如图，数组为 \\([2,3,4,5,6,3,3,4]\\)，剩余索引 \\([1,5,7,8]\\)，剩余元素 \\([2,6,3,4]\\)，选择索引 \\([2,6,3,4]\\)。应用规则一，得出索引 \\([1,7,8]\\) 不被选择；应用规则三，得出索引 \\([2,3,4]\\) 被选择；应用规则二，得出索引 \\([5]\\) 不被选择；应用规则三，得出索引 \\([6]\\) 被选择。 特殊情况，如果内向基环树没有环外节点，无法应用上述规则，那么需要单独对环交替染色，若此时环的长度为奇数，则没有解，其他情况均有解。也就是说，当且仅当内向基环树没有环外节点，且环的长度为奇数时，无解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt() - 1; } int[] in = new int[n]; for (int i = 0; i &lt; n; i++) { in[a[i]]++; } // 拓扑序染色（-1 表示不选择，1 表示选择） int[] col = new int[n]; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); col[i] = -1; } } while (!q.isEmpty()) { int x = q.poll(), y = a[x]; if (col[y] != 0) continue; if (--in[y] == 0 || col[x] == -1) { q.offer(y); col[y] = -col[x]; } } // 单独处理没有环外节点的基环树 for (int i = 0; i &lt; n; i++) { if (col[i] != 0) continue; int j = i, pre = -1; while (col[j] == 0) { col[j] = -pre; pre = col[j]; j = a[j]; } if (col[j] == pre) { io.println(-1); return; } } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (col[i] == -1) ans.add(a[i] + 1); } io.println(ans.size()); for (int x : ans) { io.print(x + &quot; &quot;); } io.println();} 方法二：外向基环树 好像有建立外向基环树的解法，没时间看，在此。","link":"/2023/10/09/Codeforces%20Round%20902%20(Div.%202,%20based%20on%20COMPFEST%2015%20-%20Final%20Round)/"},{"title":"JDK-8299339 : HashMap merge and compute methods can cause odd resizing pathologies","text":"贴一下去年发现的 Bug，嘿嘿。 导致 Bug 的示例代码如下： 12345678910111213public class Main { public static void main(String[] args) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(2); map.merge(1, 1, Integer::sum); map.merge(2, 1, Integer::sum); map.forEach((k, v) -&gt; { map.merge(k, -1, Integer::sum); System.out.println(k); }); }} Java Bug DataBase 链接，里面比较详细的讨论了发生的问题，由于当时急着发出去，我的评论有点乱，而且是中文翻译为英文的，有点拉。 今天重新回顾一下 Bug，顺便简单解释一下。上述代码的输出为 2，期望输出是 2 和 1（顺序不重要）。问题在于，在两次 merge 之后，map 包含的元素数量 2 已经超过扩容阈值 1，下一次扩容发生在迭代中，导致不正确的输出。具体来说，在 resize 方法中，有 oldTab[j] = null; 操作，即转移元素到新数组时，会将旧数组的所有元素置为 null，从而旧数组的迭代器扫描不到剩余的元素。总的来说，即使在遍历的过程中，没有发生结构性的修改，在特定情况下使用 merge 方法修改 HashMap 依然会导致问题。特定情况是指，在遍历之前 HashMap 的包含的元素数量超过扩容阈值，然后在遍历的过程中使用 merge 方法。 ORACLE 的内部人员首先说明，由于调用 Map 上的方法可能产生破坏迭代的副作用，所以不建议在迭代的过程中调用 Map 上的方法，特别是具有副作用的方法，建议重写代码避免这种情况。然后提到 merge 方法确实有问题，即元素数量超过阈值也没有立即扩容，它和 put 方法的实现不同。评论中还列出其他具有类似副作用的方法，以及其他产生副作用的情况，详细看链接。","link":"/2023/10/09/JDK-8299339%20HashMap%20merge%20and%20compute%20methods%20can%20cause%20odd%20resizing%20pathologies/"},{"title":"Educational Codeforces Round 156 (Rated for Div. 2)","text":"Sum of Three当 n &lt;= 6 || n == 9 时，不能凑出三个不同的不能被 \\(3\\) 整除的正整数，其他情况均可以通过以下方式凑出。 1234567891011121314public static void solve() { int n = io.nextInt(); if (n &lt;= 6 || n == 9) { io.println(&quot;NO&quot;); return; } int a = 1, b = 2, c = n - 3; if (c % 3 == 0) { c -= 2; b += 2; } io.println(&quot;YES&quot;); io.println(a + &quot; &quot; + b + &quot; &quot; + c);} Fear of the Dark可以分为四种情况：点 \\(O\\) 和 点 \\(P\\) 在圆 \\(A\\) 内/上；点 \\(O\\) 和 点 \\(P\\) 在圆 \\(B\\) 内/上；点 \\(O\\) 和 点 \\(P\\) 分别在圆 \\(A\\) 和圆 \\(B\\) 内/上，并且圆 \\(A\\) 和圆 \\(B\\) 相切/相交；点 \\(O\\) 和 点 \\(P\\) 分别在圆 \\(B\\) 和圆 \\(A\\) 内/上，并且圆 \\(A\\) 和圆 \\(B\\) 相切/相交。 方法一：浮点二分 12345678910111213141516171819202122public static void solve() { double px = io.nextInt(), py = io.nextInt(); double ax = io.nextInt(), ay = io.nextInt(); double bx = io.nextInt(), by = io.nextInt(); double lo = 0, hi = 1e4; while (hi - lo &gt; 1e-9) { double mid = lo + (hi - lo) / 2; boolean oToA = dist(0, 0, ax, ay) &lt;= mid; boolean aToP = dist(ax, ay, px, py) &lt;= mid; boolean oToB = dist(0, 0, bx, by) &lt;= mid; boolean bToP = dist(bx, by, px, py) &lt;= mid; boolean aToB = dist(ax, ay, bx, by) &lt;= 2 * mid; if ((oToA &amp;&amp; aToP) || (oToB &amp;&amp; bToP) || (oToA &amp;&amp; aToB &amp;&amp; bToP) || (oToB &amp;&amp; aToB &amp;&amp; aToP)) hi = mid; else lo = mid; } io.println(hi);}private static double dist(double x1, double y1, double x2, double y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));} 方法二：直接计算 123456789101112131415161718192021public static void solve() { double px = io.nextInt(), py = io.nextInt(); double ax = io.nextInt(), ay = io.nextInt(); double bx = io.nextInt(), by = io.nextInt(); double oToA = dist(0, 0, ax, ay); double aToP = dist(ax, ay, px, py); double oToB = dist(0, 0, bx, by); double bToP = dist(bx, by, px, py); double aToB = dist(ax, ay, bx, by); double ans = Math.max(oToA, aToP); ans = Math.min(ans, Math.max(oToB, bToP)); ans = Math.min(ans, Math.max(oToA, Math.max(aToB / 2, bToP))); ans = Math.min(ans, Math.max(oToB, Math.max(aToB / 2, aToP))); io.println(ans);}private static double dist(double x1, double y1, double x2, double y2) { return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));} Decreasing String二分删除的字符数 \\(p\\)，可以通过计算得到 \\(q=pos-\\frac{(n+(n-p+1))\\cdot p}{2}\\)，则答案为 \\(s_{1+p}[q]\\)，可以使用单调栈删除字符，然后获取答案即可。 1234567891011121314151617181920212223public static void solve() { String s = io.next(); long pos = io.nextLong(); int n = s.length(); int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if ((long) (n + n - mid + 1) * mid / 2 &lt; pos) lo = mid + 1; else hi = mid - 1; } int p = hi, q = (int) (pos - (long) (n + n - hi + 1) * hi / 2); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) { while (p &gt; 0 &amp;&amp; !sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - 1) &gt; s.charAt(i)) { sb.deleteCharAt(sb.length() - 1); p--; } sb.append(s.charAt(i)); } io.print(sb.charAt(q - 1));} Monocarp and the Set很容易想到当 s[0] == '?' 时，方案数为 \\(0\\)，并且 &gt; 和 &lt; 符号的位置放什么数都是确定的，也就是说只有 ? 位置对答案有贡献。分别考虑每个 ? 位置（从位置 \\(1\\) 开始，因为位置 \\(0\\) 不能是 ?），假设该位置的下标为 \\(i\\)，那么它是第 \\(i+2\\) 个的数（因为添加第 \\(1\\) 个数时，不会记录字符到 \\(s\\) 中，并且下标从 \\(0\\) 开始，所以加 \\(2\\)），第 \\(i+2\\) 个数必须要大于前 \\(i+1\\) 个数的最小值，小于前 \\(i+1\\) 个数的最大值。我们可以将前 \\(i+1\\) 个数排成有序的序列，然后根据大小将第 \\(i+2\\) 个数插入到序列中，总共有 \\(i+2\\) 个插入位置，但在限制条件下，我们只能选择 \\(i\\) 个位置进行插入，对所有 ? 位置累乘 \\(i\\) 即可得到当前字符串的插入方案数。 看半天才懂，很多题解只提到插入法，根本没提到有序序列，只要知道是根据大小插入就很简单了。也就是说，插入时根本不关心当前是什么数，只关心当前数在前面数的最大值和最小值之间。在将所有的数插入完成后，所有 ? 位置是什么数就随之确定，也就确定了一种方案。 12345678910111213141516171819202122232425262728293031323334353637383940private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), m = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 1L; for (int i = 1; i &lt; n - 1; i++) { if (s[i] == '?') ans = ans * i % MOD; } query(s, ans); while (m-- != 0) { int i = io.nextInt() - 1; char c = io.next().charAt(0); if (i != 0 &amp;&amp; s[i] == '?') { ans = ans * pow(i, MOD - 2) % MOD; } s[i] = c; if (i != 0 &amp;&amp; s[i] == '?') { ans = ans * i % MOD; } query(s, ans); }}private static void query(char[] s, long ans) { if (s[0] == '?') io.println(0); else io.println(ans);}private static int pow(int a, int n) { long res = 1L, x = a; while (n != 0) { if ((n &amp; 1) == 1) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; } return (int) res;}","link":"/2023/10/10/Educational%20Codeforces%20Round%20156%20(Rated%20for%20Div.%202)/"},{"title":"第 115 场力扣夜喵双周赛","text":"上一个遍历的整数模拟。 1234567891011121314151617class Solution { public List&lt;Integer&gt; lastVisitedIntegers(List&lt;String&gt; words) { int idx = -1; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; aux = new ArrayList&lt;&gt;(); for (String word : words) { if (word.equals(&quot;prev&quot;)) { if (idx &lt; 0) ans.add(-1); else ans.add(aux.get(idx--)); } else { aux.add(Integer.valueOf(word)); idx = aux.size() - 1; } } return ans; }} 最长相邻不相等子序列 I贪心。 1234567891011class Solution { public List&lt;String&gt; getWordsInLongestSubsequence(int n, String[] words, int[] groups) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (i == n - 1 || groups[i] != groups[i + 1]) { ans.add(words[i]); } } return ans; }} 最长相邻不相等子序列 II和最长递增子序列有点像，处理的时候记录一下路径就好。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;String&gt; getWordsInLongestSubsequence(int n, String[] words, int[] groups) { int pos = 0; int[] from = new int[n]; int[] maxLen = new int[n]; Arrays.fill(maxLen, 1); for (int i = 1; i &lt; n; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (maxLen[i] &lt; maxLen[j] + 1 &amp;&amp; groups[i] != groups[j] &amp;&amp; words[i].length() == words[j].length()) { int cnt = 0; for (int k = 0; k &lt; words[i].length(); k++) { if (words[i].charAt(k) != words[j].charAt(k) &amp;&amp; ++cnt &gt; 1) { break; } } if (cnt == 1) { maxLen[i] = maxLen[j] + 1; from[i] = j; if (maxLen[i] &gt; maxLen[pos]) { pos = i; } } } } } int m = maxLen[pos]; LinkedList&lt;String&gt; ans = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) { ans.addFirst(words[pos]); pos = from[pos]; } return ans; }} 和带限制的子多重集合的数目明显是多重背包问题，求背包中物品重量在 \\([l,r]\\) 之间的方案数，朴素的转移方程为： $$ dp[i][j]=\\sum_{k=0}^{cnt[i]}{(dp[i-1][j-k\\cdot w[i]])} $$ 这样做的时间复杂度为 \\(O(rn)\\)，其中 \\(n\\) 为 \\(nums\\) 的长度。在题目的数据范围下，复杂度达到 \\(4\\cdot 1e8\\) 数量级，会导致超时。优化方式如下，当 \\(j\\geq(cnt[i]+1)\\cdot w[i]\\) 且 \\(w[i]\\neq 0\\) 时，有： $$ dp[i][j-w[i]]=dp[i-1][j-w[i]]+dp[i-1][j-2\\cdot w[i]]+\\cdots+dp[i-1][j-(cnt[i]+1)\\cdot w[i]] $$ $$ dp[i][j]=dp[i-1][j]+dp[i-1][j-w[i]]+\\cdots+dp[i-1][j-cnt[i]\\cdot w[i]] $$ 然后错位相减，得到： $$ dp[i][j]=dp[i][j-w[i]]+(dp[i-1][j]-dp[i-1][j-(cnt[i]+1)\\cdot w[i]]) $$ 当 \\(j\\geq(cnt[i]+1)\\cdot w[i]\\) 且 \\(w[i]=0\\) 时，直接使用朴素转移方程，得到： $$ dp[i][j]=\\sum_{k=0}^{cnt[i]}{(dp[i-1][j])} $$ 同理可得，当 \\(w[i]\\leq j&lt;(cnt[i]+1)\\cdot w[i]\\) 时，错位相减得到： $$ dp[i][j]=dp[i][j-w[i]]+dp[i-1][j] $$ 当 \\(j&lt;w[i]\\) 时，直接使用朴素转移方程，得到： $$ dp[i][j]=dp[i-1][j] $$ 这样做的时间复杂度为 \\(O(r\\sqrt{S})\\)，其中 \\(S\\) 表示 \\(nums\\) 的元素和，\\(\\sqrt{S}\\) 表示 \\(nums\\) 中不同元素的最大数量。不同元素的最大数量满足 \\(\\frac{(0+(x-1))\\cdot x}{2}\\leq S\\)，解得 \\(x\\leq \\frac{1+\\sqrt{1+8\\cdot S}}{2}\\)。还有一些常数级别的优化，比如减少遍历的上界等。 12345678910111213141516171819202122232425262728293031323334353637class Solution { private static final int MOD = (int) 1e9 + 7; public int countSubMultisets(List&lt;Integer&gt; nums, int l, int r) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { map.merge(x, 1, Integer::sum); } int zero = map.getOrDefault(0, 0); map.remove(0); int m = map.size(); int[] f = new int[r + 1]; int[] g = new int[r + 1]; f[0] = zero + 1; for (var e : map.entrySet()) { int w = e.getKey(), c = e.getValue(); System.arraycopy(f, 0, g, 0, r + 1); for (int j = w; j &lt;= r; j++) { f[j] = (f[j - w] + f[j]) % MOD; if (j - (c + 1) * w &gt;= 0) { f[j] = (f[j] - g[j - (c + 1) * w] + MOD) % MOD; } } } int ans = 0; for (int i = l; i &lt;= r; i++) { ans = (ans + f[i]) % MOD; } return ans; }} 分开处理，先做前缀和，再倒序减去某个前缀和，就可以不使用辅助数组 \\(g\\)： 1234567891011121314151617181920212223242526272829303132333435class Solution { private static final int MOD = (int) 1e9 + 7; public int countSubMultisets(List&lt;Integer&gt; nums, int l, int r) { int n = nums.size(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int x : nums) { map.merge(x, 1, Integer::sum); } int zero = map.getOrDefault(0, 0); map.remove(0); int m = map.size(); int[] f = new int[r + 1]; f[0] = zero + 1; for (var e : map.entrySet()) { int w = e.getKey(), c = e.getValue(); for (int j = w; j &lt;= r; j++) { f[j] = (f[j - w] + f[j]) % MOD; } for (int j = r; j &gt;= (c + 1) * w; j--) { f[j] = (f[j] - f[j - (c + 1) * w] + MOD) % MOD; } } int ans = 0; for (int i = l; i &lt;= r; i++) { ans = (ans + f[i]) % MOD; } return ans; }}","link":"/2023/10/16/%E7%AC%AC%20115%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 367 场力扣周赛","text":"找出满足差值条件的下标 I同下。 最短且字典序最小的美丽子字符串滑动窗口。 1234567891011121314151617181920212223242526class Solution { public String shortestBeautifulSubstring(String s, int k) { int n = s.length(); int lo = s.indexOf('1'); if (lo &lt; 0) { return &quot;&quot;; } String ans = &quot;&quot;; int hi = lo, cnt = 0; while (hi &lt; n) { cnt += s.charAt(hi++) - '0'; while (cnt &gt; k || s.charAt(lo) == '0') { cnt -= s.charAt(lo++) - '0'; } if (cnt == k) { String t = s.substring(lo, hi); if (ans.isEmpty() || t.length() &lt; ans.length() || t.length() == ans.length() &amp;&amp; t.compareTo(ans) &lt; 0) { ans = t; } } } return ans; }} 找出满足差值条件的下标 II维护最大值和最小值就行。 1234567891011121314151617181920212223class Solution { public int[] findIndices(int[] nums, int indexDifference, int valueDifference) { int n = nums.length; int minIndex = 0, maxIndex = 0; for (int j = indexDifference; j &lt; n; j++) { int i = j - indexDifference; if (nums[i] &gt; nums[maxIndex]) { maxIndex = i; } else if (nums[i] &lt; nums[minIndex]) { minIndex = i; } if (nums[maxIndex] - nums[j] &gt;= valueDifference) { return new int[]{maxIndex, j}; } if (nums[j] - nums[minIndex] &gt;= valueDifference) { return new int[]{minIndex, j}; } } return new int[]{-1, -1}; }} 构造乘积矩阵前后缀分解，将二维数组看作一维数组。 1234567891011121314151617181920212223242526class Solution { private static final int MOD = 12345; public int[][] constructProductMatrix(int[][] grid) { int n = grid.length, m = grid[0].length; int[][] p = new int[n][m]; long suf = 1; for (int i = n - 1; i &gt;= 0; i--) { for (int j = m - 1; j &gt;= 0; j--) { p[i][j] = (int) suf; suf = suf * grid[i][j] % MOD; } } long pre = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { p[i][j] = (int) (p[i][j] * pre % MOD); pre = pre * grid[i][j] % MOD; } } return p; }}","link":"/2023/10/16/%E7%AC%AC%20367%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 324","text":"Same12345678public static void solve() { int n = io.nextInt(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) { set.add(io.nextInt()); } io.println(set.size() == 1 ? &quot;Yes&quot; : &quot;No&quot;);} 3-smooth Numbers123456public static void solve() { long n = io.nextLong(); while (n % 2 == 0) n /= 2; while (n % 3 == 0) n /= 3; io.println(n == 1 ? &quot;Yes&quot; : &quot;No&quot;);} Error Correction额，很简单的题，赛时花费很长时间，代码写得很乱。 123456789101112131415161718192021222324252627282930313233public static void solve() { int n = io.nextInt(); String t = io.next(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int k = 0; k &lt; n; k++) { String s = io.next(); int i = 0; for (; i &lt; s.length() &amp;&amp; i &lt; t.length(); i++) { if (s.charAt(i) != t.charAt(i)) { break; } } int j = 0; for (; j &lt; s.length() &amp;&amp; j &lt; t.length(); j++) { if (s.charAt(s.length() - 1 - j) != t.charAt(t.length() - 1 - j)) { break; } } boolean ok = s.length() == t.length() &amp;&amp; i + j &gt;= t.length() - 1; ok |= s.length() == t.length() + 1 &amp;&amp; i + j &gt;= t.length(); ok |= s.length() == t.length() - 1 &amp;&amp; i + j &gt;= t.length() - 1; if (ok) { ans.add(k + 1); } } io.println(ans.size()); ans.forEach(i -&gt; io.print(i + &quot; &quot;)); io.println();} Square Permutation还是直接使用字符串更简单，要不然还要拆位。 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); Arrays.sort(s); long max = (long) Math.pow(10, n); int ans = 0; for (long i = 0; i * i &lt; max; i++) { StringBuilder sb = new StringBuilder(String.valueOf(i * i)); while (sb.length() &lt; n) { sb.append(&quot;0&quot;); } char[] t = sb.toString().toCharArray(); Arrays.sort(t); if (Arrays.equals(s, t)) { ans++; } } io.println(ans);} Joint Two Strings记录每个字符串的子序列匹配目标字符串的最大前后缀的长度，因为答案和下标无关，所以使用排序 + 二分计算答案。 123456789101112131415161718192021222324252627282930313233343536public static void solve() { int n = io.nextInt(); String t = io.next(); int[] prefix = new int[n]; int[] suffix = new int[n]; for (int k = 0; k &lt; n; k++) { String s = io.next(); for (int i = 0; i &lt; s.length() &amp;&amp; prefix[k] &lt; t.length(); i++) { if (s.charAt(i) == t.charAt(prefix[k])) { prefix[k]++; } } for (int i = 0; i &lt; s.length() &amp;&amp; suffix[k] &lt; t.length(); i++) { if (s.charAt(s.length() - 1 - i) == t.charAt(t.length() - 1 - suffix[k])) { suffix[k]++; } } } Arrays.sort(suffix); long ans = 0L; for (int i = 0; i &lt; n; i++) { int lo = 0, hi = n - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (prefix[i] + suffix[mid] &gt;= t.length()) hi = mid - 1; else lo = mid + 1; } ans += n - lo; } io.println(ans);} Beautiful Path二分答案，将除法转化为乘法，因为顶点的边限制 \\(u&lt;v\\)，所以从 \\(1\\) 到 \\(n\\) 处理顶点就是拓扑序，并且一定没有环，拓扑序动态规划求最长路径即可。（额，昨天刚做拓扑序动态规划求最长路径，竟然还没做出这题。） 1234567891011121314151617181920212223242526272829303132333435363738public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] in = new int[n]; List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; m; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1, b = io.nextInt(), c = io.nextInt(); g[u].add(new int[]{v, b, c}); in[v]++; } double lo = 0, hi = 1e4; while (hi - lo &gt;= 1e-10) { double mid = lo + (hi - lo) / 2; if (check(g, in.clone(), mid)) lo = mid; else hi = mid; } io.println(lo);}private static boolean check(List&lt;int[]&gt;[] g, int[] in, double x) { int n = g.length; double[] dist = new double[n]; Arrays.fill(dist, Long.MIN_VALUE); dist[0] = 0; for (int u = 0; u &lt; n; u++) { for (int[] t : g[u]) { int v = t[0], b = t[1], c = t[2]; if (dist[v] &lt; dist[u] + b - c * x) { dist[v] = dist[u] + b - c * x; } } } return dist[n - 1] &gt;= 0;}","link":"/2023/10/16/AtCoder%20Beginner%20Contest%20324/"},{"title":"AtCoder Beginner Contest 325","text":"Takahashi san12345public static void solve() { String s = io.next(); io.next(); io.println(s + &quot; san&quot;);} World Meeting比赛时用滑窗没有做出来，原来要滑两倍的数组长度啊。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] cnt = new int[24]; for (int i = 0; i &lt; n; i++) { int w = io.nextInt(), x = io.nextInt(); cnt[x] += w; } int ans = 0; for (int i = 0; i &lt; 24; i++) { int sum = 0; for (int j = 0; j &lt; 9; j++) { sum += cnt[(i + j) % 24]; } ans = Math.max(ans, sum); } io.println(ans);} Sensors直接 DFS 或者并查集都行。 1234567891011121314151617181920212223242526272829303132public static void solve() { int h = io.nextInt(), w = io.nextInt(); boolean[][] g = new boolean[h][w]; for (int i = 0; i &lt; h; i++) { String s = io.next(); for (int j = 0; j &lt; w; j++) { if (s.charAt(j) == '#') { g[i][j] = true; } } } int ans = 0; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { if (g[i][j]) { ans++; dfs(i, j, g); } } } io.println(ans);}private static void dfs(int x, int y, boolean[][] g) { if (x &lt; 0 || x &gt;= g.length || y &lt; 0 || y &gt;= g[0].length || !g[x][y]) return; g[x][y] = false; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { dfs(x + i, y + j, g); } }} Printing Machine贪心，对于每个时刻，我们选择已经进入传送带的，右端点最小的产品。 1234567891011121314151617181920212223242526272829public static void solve() { int n = io.nextInt(); long[][] aux = new long[n][]; for (int i = 0; i &lt; n; i++) { long t = io.nextLong(), d = io.nextLong(); aux[i] = new long[]{t, t + d}; } Arrays.sort(aux, (a, b) -&gt; Long.compare(a[0], b[0])); int i = 0, ans = 0; Queue&lt;Long&gt; q = new PriorityQueue&lt;&gt;(); for (long t = 0; ; t++) { if (q.isEmpty()) { if (i == n) break; t = aux[i][0]; } while (i &lt; n &amp;&amp; aux[i][0] == t) { q.offer(aux[i++][1]); } while (!q.isEmpty() &amp;&amp; q.peek() &lt; t) { q.poll(); } if (!q.isEmpty()) { ans++; q.poll(); } } io.println(ans);}","link":"/2023/10/24/AtCoder%20Beginner%20Contest%20325/"},{"title":"第 368 场力扣周赛","text":"元素和最小的山形三元组 I同下。 元素和最小的山形三元组 II前后缀分解。 1234567891011121314151617181920class Solution { public int minimumSum(int[] nums) { int n = nums.length; int[] pre = new int[n + 1], suf = new int[n + 1]; pre[0] = suf[n] = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { pre[i + 1] = Math.min(pre[i], nums[i]); } for (int i = n - 1; i &gt;= 0; i--) { suf[i] = Math.min(suf[i + 1], nums[i]); } int ans = Integer.MAX_VALUE; for (int i = 1; i &lt; n - 1; i++) { if (nums[i] &gt; pre[i] &amp;&amp; nums[i] &gt; suf[i + 1]) { ans = Math.min(ans, pre[i] + nums[i] + suf[i + 1]); } } return ans == Integer.MAX_VALUE ? -1 : ans; }} 合法分组的最少组数贪心，不太会，直接看题解。 1234567891011121314151617181920212223242526class Solution { public int minGroupsForValidAssignment(int[] nums) { Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int x : nums) { cnt.merge(x, 1, Integer::sum); } int k = nums.length; for (int x : cnt.values()) { k = Math.min(k, x); } for (; ; k--) { int ans = 0; for (int x : cnt.values()) { if (x / k &lt; x % k) { ans = 0; break; } ans += (x + k) / (k + 1); } if (ans &gt; 0) { return ans; } } }} 得到 K 个半回文串的最少修改次数直接记忆化搜索就能搞定，特别注意子字符串的长度要求至少为 \\(2\\)。当然还可以预处理出所有因子，也可以将记忆化搜索转化为自底向上的动态规划。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public int minimumChanges(String s, int k) { int n = s.length(); int[][] change = new int[n][n]; for (int i = 0; i &lt; n - 1; i++) { for (int j = i + 1; j &lt; n; j++) { change[i][j] = calc(s.substring(i, j + 1)); } } int[][] dp = new int[n][k]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], -1); } return dfs(0, s, n, k - 1, change, dp); } private int calc(String s) { int n = s.length(), res = n; for (int d = 1; d &lt; n; d++) { if (n % d == 0) { int cnt = 0; for (int k = 0; k &lt; d; k++) { for (int i = k, j = n - d + k; i &lt; j; i += d, j -= d) { if (s.charAt(i) != s.charAt(j)) { cnt++; } } } res = Math.min(res, cnt); } } return res; } private int dfs(int i, String s, int n, int k, int[][] change, int[][] dp) { if (k == 0) { return change[i][n - 1]; } if (dp[i][k] != -1) { return dp[i][k]; } int res = n; for (int j = i + 1; j &lt; n - 2 * k; j++) { res = Math.min(res, dfs(j + 1, s, n, k - 1, change, dp) + change[i][j]); } return dp[i][k] = res; }}","link":"/2023/10/24/%E7%AC%AC%20368%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 904 (Div. 2)","text":"Simple Design12345678910111213141516public static void solve() { int x = io.nextInt(), k = io.nextInt(); while (sum(x) % k != 0) { x++; } io.println(x);}private static int sum(int x) { int res = 0; while (x != 0) { res += x % 10; x /= 10; } return res;} Haunted House好难啊，做得很慢。对于每个 \\(i\\)，如果它是满足条件的，那么 \\([n-i,n-1]\\) 需要全为 \\(0\\)，它的最少操作次数为 \\([n-i,n-1]\\) 中所有值为 \\(1\\) 的下标和，减去 \\([0,n-i-1]\\) 中最近的值为 \\(0\\) 的对应个数的下标和。我们可以使用双指针 \\(O(n)\\) 的计算所有 \\(i\\)，具体见代码。指针 \\(j\\) 枚举每个下标，同时求出后缀的下标和，指针 \\(i\\) 指向指针 \\(j\\) 需要的最远的 \\(0\\) 的下标位置，同时求出后缀值为 \\(0\\) 的下标和，它们的差值就是 \\(j\\) 的最少操作次数。 12345678910111213141516171819public static void solve() { int n = io.nextInt(); String s = io.next(); long sum = 0L; int i, j, cnt = 0; for (i = n - 1, j = n - 1; i &gt;= 0; j--) { cnt++; sum += j; for (; i &gt;= 0 &amp;&amp; cnt &gt; 0; i--) { if (s.charAt(i) == '0') { cnt--; sum -= i; } } io.print(cnt &gt; 0 ? &quot;-1 &quot; : sum + &quot; &quot;); } io.println(&quot;-1 &quot;.repeat(j + 1));} 发现一个超级简单的写法，基本思路就是从低到高放置 \\(0\\)，操作次数即为 \\(0\\) 的移动次数，废话不多说，代码很好懂。 123456789101112131415public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 0L; int l = n - 1, r = n - 1; for (; l &gt;= 0; l--) { if (s[l] == '0') { ans += r - l; r--; io.print(ans + &quot; &quot;); } } io.println(&quot;-1 &quot;.repeat(r + 1));} Medium Design最小值一定在位置 \\(1\\) 或位置 \\(m\\)，我们可以考虑处理区间不包含 \\(1\\) 和不包含 \\(m\\) 两种情况下，能够得到的最大值，根据简单的推导可以知道问题是等价的。如何计算最大值，根据题解所说似乎是扫描线算法，使用 \\((l,1)\\) 表示进入某个区间，\\((r,-1)\\) 表示离开某个区间，注意初始时我们将每个左端点减 \\(1\\)，表示从区间 \\(0\\) 开始算，\\((l,r)\\) 是左闭右开区间，所以 \\(r\\) 表示离开某个区间，然后每当处理完某个端点就更新答案。（其实也可以使用差分哈希表进行区间求和） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] l = new int[n]; int[] r = new int[n]; for (int i = 0; i &lt; n; i++) { l[i] = io.nextInt() - 1; r[i] = io.nextInt(); } // 第一次扫描，不包含第一个位置 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (l[i] != 0) { list.add(new int[]{l[i], 1}); list.add(new int[]{r[i], -1}); } } list.sort((a, b) -&gt; a[0] - b[0]); int ans = sweep(list); // 第二次扫描，不包含最后一个位置 list.clear(); for (int i = 0; i &lt; n; i++) { if (r[i] != m) { list.add(new int[]{l[i], 1}); list.add(new int[]{r[i], -1}); } } list.sort((a, b) -&gt; a[0] - b[0]); ans = Math.max(ans, sweep(list)); io.println(ans);}private static int sweep(List&lt;int[]&gt; list) { // cnt 表示在多少个区间内 // lst 表示上次处理的端点 int res = 0, cnt = 0, lst = 0; for (int[] t : list) { if (t[0] &gt; lst) { res = Math.max(res, cnt); } cnt += t[1]; lst = t[0]; } return res;} Counting Rhyme一对数 \\(x,y\\) 不能同时被数组中的数整除，即 \\(\\gcd(x,y)\\) 不能被数组中的数整除。我们首先可以计算出数组中有多少对数它们的 \\(\\gcd=1,2,3\\dots,n\\)，然后排除掉能够被数组中的数整除的 \\(\\gcd\\)，剩下的 \\(\\gcd\\) 对应的对数之和就是答案。第一步可以使用动态规划求解，转移方程如下： $$ sum = cnt[i]+cnt[2\\times i]+\\cdots+cnt[k\\times i] \\\\ dp[i]= \\frac{sum\\times (sum-1)}{2}-(dp[2\\times i]+dp[3\\times i]+\\cdots+dp[k\\times i]) $$ 第二步切记不能枚举数组中的数来排除，这样在所有值都为 \\(1\\) 的样例下时间复杂度会达到 \\(O(n^{2})\\)，除非将数组去重，或者像下面代码一样枚举。最后计算答案即可。本题的另一种解法是 GCD 卷积，暂时不学。 123456789101112131415161718192021222324252627282930313233public static void solve() { int n = io.nextInt(); int[] a = new int[n]; int[] cnt = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); cnt[a[i]]++; } long[] dp = new long[n + 1]; for (int i = n; i &gt; 0; i--) { long tot = 0L; for (int j = i; j &lt;= n; j += i) { tot += cnt[j]; dp[i] -= dp[j]; } dp[i] += tot * (tot - 1) / 2; } for (int i = 1; i &lt;= n; i++) { if (cnt[i] != 0) { for (int j = i; j &lt;= n; j += i) { dp[j] = 0; } } } long ans = 0L; for (int i = 1; i &lt;= n; i++) { ans += dp[i]; } io.println(ans);}","link":"/2023/10/24/Codeforces%20Round%20904%20(Div.%202)/"},{"title":"Codeforces Round 905 (Div. 2)","text":"Chemistry只要奇数字母的个数不大于 \\(k+1\\) 即可，因为回文串最多有一个奇数字母。 1234567891011121314151617public static void solve() { int n = io.nextInt(), k = io.nextInt(); String s = io.next(); int[] cnt = new int[26]; for (int i = 0; i &lt; n; i++) { cnt[s.charAt(i) - 'a']++; } int sum = 0; for (int x : cnt) { if (x % 2 == 1) { sum++; } } io.println(sum - 1 &gt; k ? &quot;NO&quot; : &quot;YES&quot;);} Raspberries当 \\(k=2,3,5\\) 时，因为 \\(k\\) 是质数，如果所有数的乘积能够被 \\(k\\) 整除，必定存在一个数能够被 \\(k\\) 整除，所以单独计算每个数即可。当 \\(k=4\\) 时，需要计算存在一个数能被 \\(4\\) 整除的最少操作数，还需要计算存在两个能被 \\(2\\) 整除的数的最少操作数，答案为两者的最小值。 123456789101112131415161718192021public static void solve() { int n = io.nextInt(), k = io.nextInt(); int cnt = 0; int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); if (a[i] % 2 == 0) { cnt++; } } int ans = k; for (int i = 0; i &lt; n; i++) { ans = Math.min(ans, (k - a[i] % k) % k); } if (k == 4) { ans = Math.min(ans, Math.max(0, 2 - cnt)); } io.println(ans);} You Are So Beautiful如果某个子数组作为子序列只出现过一次，因为子数组本身就是子序列，所以没有其他方式能够构成该子数组，即子数组的左端点左边没有和它相同的数，右端点的右边也没有和它相同的数。我们可以使用集合 + 前缀和的方式预先计算每个位置及其左边满足条件的左端点个数，然后倒序处理数组，对每个满足条件的右端点，都将其对应的左端点的个数添加到答案。 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int[] prefix = new int[n + 1]; for (int i = 0; i &lt; n; i++) { prefix[i + 1] = prefix[i] + (set.add(a[i]) ? 1 : 0); } set.clear(); long ans = 0L; for (int i = n - 1; i &gt;= 0; i--) { if (set.add(a[i])) { ans += prefix[i + 1]; } } io.println(ans);} Dances (Easy version)题目真难读，简单版只会在数组 \\(a\\) 中添加一个 \\(1\\)，然后计算最少操作数，可以使用排序 + 双指针进行处理。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; a[0] = 1; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(a); Arrays.sort(b); int k = 0; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { k++; j++; } } io.println(k);} Dances (Hard Version)困难版，计算在数组中分别添加 \\([1,m]\\) 需要的最少操作数。通过观察可以发现（真发现不了），改变 \\(a[0]\\) 最多只会使操作次数加 \\(1\\)，所以我们可以二分该边界值，然后计算答案即可。 12345678910111213141516171819202122232425262728293031323334353637public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(b); int k = calc(a, b, 1); int lo = 1, hi = m; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (calc(a, b, mid) == k) lo = mid + 1; else hi = mid - 1; } io.println((long) m * k + (m - lo + 1));}private static int calc(int[] a, int[] b, int x) { a[0] = x; a = a.clone(); Arrays.sort(a); int n = a.length, k = 0; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { k++; j++; } } return k;} 竟然还有更简单的方法，首先计算 \\(a\\) 中 \\(n-1\\) 个数对应 \\(b\\) 中 \\(n\\) 个数的最少删除次数，并同时维护 \\(b\\) 中不满足 \\(a[i]&lt;b[j]\\) 的最后一个值，该值就是操作次数的分界点，直接计算答案即可。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; a[0] = Integer.MAX_VALUE; for (int i = 1; i &lt; n; i++) { a[i] = io.nextInt(); } int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt(); } Arrays.sort(a); Arrays.sort(b); int k = 0, val = m + 1; for (int i = 0, j = 0; i &lt; n - k; i++, j++) { while (j &lt; n &amp;&amp; a[i] &gt;= b[j]) { val = b[j]; k++; j++; } } io.println((long) m * (k - 1) + Math.max(0, m - val + 1));}","link":"/2023/10/24/Codeforces%20Round%20905%20(Div.%202)/"},{"title":"动态规划","text":"本文内容参考《算法导论》，OI Wiki。 基础知识 动态规划方法通常用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。 适合应用动态规划方法求解的最优化问题应该具备两个要素：最优子结构和重叠子问题。 最优子结构：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。 重叠子问题：如果问题的递归算法会反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。 子问题图 子问题图是一个有向图，每个顶点唯一的对应一个子问题。若求子问题 \\(x\\) 的最优解时需要直接用到子问题 \\(y\\) 的最优解，那么在子问题图中就会有一条从子问题 \\(x\\) 的顶点到子问题 \\(y\\) 的顶点的有向边。 自顶向下动态规划处理子问题图中顶点的顺序为拓扑序，自底向上动态规划处理子问题图中顶点的顺序为逆拓扑序。 通常情况下，动态规划算法的运行时间与子问题图中顶点和边的数量呈线性关系。 选择自顶向下，还是自底向上 通常情况下，如果每个子问题都必须至少求解一次，自底向上动态规划算法会更快，因为没有递归调用的开销，而且对于某些问题，可以利用表的访问模式降低时空开销。如果子问题空间中的某些子问题完全不必求解，自顶向下动态规划算法会更快，因为它只会求解那些必要的子问题。 背包 DP 题目：有 \\(n\\) 种物品和一个容量为 \\(W\\) 的背包，每种物品有数量 \\(k_{i}\\)、重量 \\(w_{i}\\) 和价值 \\(v_{i}\\) 三种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。 0-1 背包 每种物品只能取一次，即 \\(k_{i}=1\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max{(dp[i-1][j],dp[i-1][j-w[i]]+v[i])} $$ 空间优化（倒序枚举）： $$ dp[j]=\\max{(dp[j],dp[j-w[i]]+v[i])} $$ 完全背包 每种物品可以取无限次，即 \\(k_{i}=\\infty\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max_{k=0}^{\\infty}{dp[i-1][j-k\\cdot w[i]]+k\\cdot v[i]} $$ 方程优化： $$ dp[i][j]=\\max{(dp[i-1][j],dp[i][j-w[i]]+v[i])} $$ 空间优化（正序枚举）： $$ dp[j]=\\max(dp[j],dp[j-w[i]]+v[i]) $$ 多重背包 每种物品可以取 \\(k_{i}\\) 次，即 \\(k_{i}\\in\\mathbb{N}\\) 对任意 \\(i\\) 都成立。 转移方程： $$ dp[i][j]=\\max_{k=0}^{k[i]}{dp[i-1][j-k\\cdot w[i]]+k\\cdot v[i]} $$ 二进制分组优化：将每种物品的 \\(k_{i}\\) 拆分为多个组，每组的数量为 \\(2^{0},2^{1},\\dots,2^{\\lfloor{\\log{k_{i}+1}}\\rfloor -1}\\)，如果 \\(k_{i}+1\\) 不是二的幂，就将多余的数量作为一组，最后将 \\(k_{i}\\) 拆出来的每组都看作数量为 \\(1\\) 的新物品，从而转化为 0-1 背包。可以证明，如果选择 \\(x\\) 次第 \\(i\\) 种物品，其中 \\(x\\in[0,k_{i}]\\)，则该选择方式总是可以由分组后的新物品的某个组合表示。 例题 线性 DP：1143. 最长公共子序列，300. 最长递增子序列，72. 编辑距离。 背包 DP：416. 分割等和子集，322. 零钱兑换，2902. 和带限制的子多重集合的数目。 区间 DP：516. 最长回文子序列，1000. 合并石头的最低成本。 树形 DP：2646. 最小化旅行的价格总和，834. 树中距离之和，2867. 统计树中的合法路径数目。 状压 DP：526. 优美的排列，Mondriaan’s Dream。 数位 DP：233. 数字 1 的个数，1012. 至少有 1 位重复的数字。 概率 DP：D. Bag of mice，E - Roulettes。","link":"/2023/10/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"排序算法","text":"本文内容参考 sorting-algorithms，《算法》，《算法导论》。（强迫症，最后还是把描述性的文字删了，只贴代码） 验证算法的正确性，可以使用：912. 排序数组，148. 排序链表，164. 最大间距。 简单概述 理想的排序算法 稳定性：相同键不会重新排序。 原地排序：不使用额外空间存储排序数据。 最坏情况 \\(O(n\\log{n})\\) 次比较，\\(O(n)\\) 次交换。 适应性：当数据接近排序或唯一键很少时，时间复杂度为 \\(O(n)\\)。 如何看待常数因子的改进方案 摘抄自《算法》的一段内容：在每一节中，我们会将书中的每个算法都看做某种应用的关键。但在整体上，我们希望学习的是为每种应用找到最合适的算法。我们并不是在推荐读者一定要实现所有提到的改进方法，而是提醒大家不要对算法初始实现的性能盖棺定论。研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。实现那些只能把运行时间缩短某个常数因子的改进措施可能并不值得。你需要用实验来检验一项改进，正如本书练习所演示的那样。 冒泡排序 稳定性：稳定。 时间复杂度：\\(O(n^{2})\\)。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n)\\)。 1234567891011121314private static void bubbleSort(int[] nums) { int n = nums.length, pos; for (int i = n - 1; i &gt; 0; i = pos) { pos = 0; for (int j = 0; j &lt; i; j++) { // 稳定性的关键 if (nums[j] &gt; nums[j + 1]) { swap(nums, j, j + 1); // 将最后交换的位置，作为下次冒泡的上界 pos = j; } } }} 选择排序 稳定性：不稳定。 时间复杂度：\\(O(n^{2})\\)。元素的交换次数最少的排序算法。 空间复杂度：\\(O(1)\\)。 123456789101112private static void selectionSort(int[] nums) { int n = nums.length; for (int i = 0; i &lt; n; i++) { int minIndex = i; for (int j = i + 1; j &lt; n; j++) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } if (minIndex != i) swap(nums, minIndex, i); }} 插入排序 稳定性：稳定。 时间复杂度：\\(O(n^{2})\\)。元素的交换次数等于逆序数。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n)\\)。 1234567891011private static void insertionSort(int[] nums) { int n = nums.length; for (int i = 1; i &lt; n; i++) { int j = i - 1, t = nums[i]; // 稳定性的关键 for (; j &gt;= 0 &amp;&amp; nums[j] &gt; t; j--) { nums[j + 1] = nums[j]; } nums[j + 1] = t; }} 希尔排序 稳定性：不稳定。 时间复杂度：使用 Knuth 增量序列 \\(O(n^{\\frac{3}{2}})\\)，。Knuth 增量序列：\\(1,4,13,40,\\dots,\\frac{3^{k}-1}{2}\\)，相当于首项为 \\(1\\)，公比为 \\(3\\) 的数列的前缀和。 空间复杂度：\\(O(1)\\)。 数据接近排序时，时间复杂度为 \\(O(n\\log{n})\\)。 1234567891011121314private static void insertionSort(int[] nums) { int n = nums.length, h = 1; while (h &lt; n / 3) h = 3 * h + 1; while (h &gt;= 1) { for (int i = h; i &lt; n; i++) { int j = i - h, t = nums[i]; for (; j &gt;= 0 &amp;&amp; nums[j] &gt; t; j -= h) { nums[j + h] = nums[j]; } nums[j + h] = t; } h /= 3; }} 归并排序 稳定性：稳定的。 时间复杂度：\\(O(n\\log{n})\\)。 空间复杂度：排序数组 \\(O(n)\\)；自顶向下排序链表 \\(O(\\log{n})\\)（递归的空间），自底向上排序链表 \\(O(1)\\)。 顺序访问数据，缓存友好。 实现一：自顶向下（数组） 123456789101112131415161718192021222324252627private static void mergeSort(int[] nums) { int n = nums.length; int[] aux = new int[n]; mergeSort(nums, aux, 0, n - 1);}private static void mergeSort(int[] nums, int[] aux, int lo, int hi) { if (lo &gt;= hi) return; int mid = lo + (hi - lo) / 2; mergeSort(nums, aux, lo, mid); mergeSort(nums, aux, mid + 1, hi); merge(nums, aux, lo, mid, hi);}private static void merge(int[] nums, int[] aux, int lo, int mid, int hi) { for (int i = lo; i &lt;= hi; i++) { aux[i] = nums[i]; } int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; // 稳定性的关键 else if (aux[i] &lt;= aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; }} 实现二：自底向上（数组） 1234567891011121314151617181920212223private static void mergeSort(int[] nums) { int n = nums.length; int[] aux = new int[n]; for (int len = 1; len &lt; n; len += len) { for (int i = 0; i + len &lt; n; i += len &lt;&lt; 1) { merge(nums, aux, i, i + len - 1, Math.min(n - 1, i + (len &lt;&lt; 1) - 1)); } }}private static void merge(int[] nums, int[] aux, int lo, int mid, int hi) { for (int i = lo; i &lt;= hi; i++) { aux[i] = nums[i]; } int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) nums[k] = aux[j++]; else if (j &gt; hi) nums[k] = aux[i++]; // 稳定性的关键 else if (aux[i] &lt;= aux[j]) nums[k] = aux[i++]; else nums[k] = aux[j++]; }} 实现三：自顶向下（链表） 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static ListNode mergeSort(ListNode head) { if (head == null || head.next == null) { return head; } // 分为两个子链表 ListNode mid = middleNode(head); ListNode next = mid.next; mid.next = null; head = mergeSort(head); next = mergeSort(next); return merge(head, next);}// 返回合并链表的头节点private static ListNode merge(ListNode head1, ListNode head2) { ListNode dummy = new ListNode(), curr = dummy; while (head1 != null &amp;&amp; head2 != null) { // 稳定性的关键 if (head1.val &lt;= head2.val) { curr.next = head1; head1 = head1.next; } else { curr.next = head2; head2 = head2.next; } curr = curr.next; } curr.next = head1 != null ? head1 : head2; return dummy.next;}// 调用保证 head != null，并且如果有两个中间节点，则返回前一个（不然会无限递归）// 使用 fast = head.next 可以保证返回前一个中间节点// 使用 fast = head 可以保证返回后一个中间节点private static ListNode middleNode(ListNode head) { if (head == null) return head; ListNode slow = head, fast = head.next; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow;} 实现四：自底向上（链表） 下面这个是没有提前计算链表长度，没有断开链表的解法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static ListNode mergeSort(ListNode head) { if (head == null || head.next == null) return head; int len = 1; ListNode dummy = new ListNode(-1, head); while (true) { // 两个子链表的头节点的前一个节点 ListNode prev1, prev2; prev1 = prev2 = dummy; while (true) { for (int i = 0; i &lt; len &amp;&amp; prev2 != null; i++) { prev2 = prev2.next; } if (prev2 == null || prev2.next == null) break; prev1 = prev2 = merge(prev1, prev2, len); } // 如果该轮没有进行合并操作，则排序完成 if (prev1 == dummy) break; len += len; } return dummy.next;}// 返回合并链表的尾节点private static ListNode merge(ListNode prev1, ListNode prev2, int len) { // 判断条件：第一个链表未结束 &amp;&amp; 第二个链表未结束（考虑长度不足的情况） while (prev1 != prev2 &amp;&amp; len != 0 &amp;&amp; prev2.next != null) { // 稳定性的关键 if (prev1.next.val &gt; prev2.next.val) { // 将 prev2.next 插入到 prev1 之后 ListNode temp = prev2.next; prev2.next = prev2.next.next; temp.next = prev1.next; prev1.next = temp; len--; } prev1 = prev1.next; } // 使 prev2 指向合并链表的尾节点 while (len-- != 0 &amp;&amp; prev2.next != null) prev2 = prev2.next; return prev2;} 快速排序 稳定性：不稳定。 时间复杂度：期望 \\(O(n\\log{n})\\)。 空间复杂度：期望 \\(O(\\log{n})\\)。 如果使用三路快排，数据包含大量重复元素时，时间复杂度为 \\(O(n)\\)。 实现一：二路快排 1234567891011121314151617181920212223242526272829private static void quickSort(int[] nums) { int n = nums.length; quickSort(nums, 0, n - 1);}private static void quickSort(int[] nums, int lo, int hi) { if (lo &gt;= hi) return; int index = partition(nums, lo, hi); quickSort(nums, lo, index - 1); quickSort(nums, index + 1, hi);}private static int partition(int[] nums, int lo, int hi) { // 三数取中 int mid = median3(nums, lo, lo + (hi - lo) / 2, hi); swap(nums, lo, mid); int key = nums[lo]; int i = lo, j = hi + 1; while (true) { // 和切分元素相等的元素也会停顿并交换 while (nums[++i] &lt; key &amp;&amp; i != hi); while (nums[--j] &gt; key); if (i &gt;= j) break; swap(nums, i, j); } swap(nums, lo, j); return j;} 实现二：三路快排 12345678910111213141516171819202122232425private static final Random RANDOM = new Random();private static void quickSort(int[] nums) { int n = nums.length; quickSort(nums, 0, n - 1);}private static void quickSort(int[] nums, int lo, int hi) { if (lo &gt;= hi) return; // 随机选择 int randomIndex = lo + RANDOM.nextInt(hi - lo + 1); swap(nums, randomIndex, lo); int key = nums[lo]; int lt = lo, gt = hi, i = lo + 1; while (i &lt;= gt) { if (nums[i] &lt; key) swap(nums, i++, lt++); else if (nums[i] &gt; key) swap(nums, i, gt--); else i++; } quickSort(nums, lo, lt - 1); quickSort(nums, gt + 1, hi);} 堆排序 稳定性：不稳定。 时间复杂度：\\(O(n\\log{n})\\)。 空间复杂度：\\(O(1)\\)。 随机访问数据，缓存不友好。 12345678910111213141516171819202122232425262728public static void heapSort(int[] nums) { int n = nums.length; // 建堆 - 时间复杂度 O(n) for (int i = n / 2 - 1; i &gt;= 0; i--) { sink(nums, i, n - 1); } // 排序 - 时间复杂度 O(nlog(n)) for (int i = n - 1; i &gt; 0; ) { swap(nums, 0, i--); sink(nums, 0, i); }}private static void sink(int[] nums, int i, int n) { int t = nums[i]; while (2 * i + 1 &lt;= n) { int j = 2 * i + 1; if (j + 1 &lt;= n &amp;&amp; nums[j + 1] &gt; nums[j]) { j++; } if (t &gt;= nums[j]) break; nums[i] = nums[j]; i = j; } nums[i] = t;} 计数排序 稳定性：稳定。 时间复杂度：\\(O(n+k)\\)。 空间复杂度：\\(O(n+k)\\)。 12345678910111213141516171819202122// 元素取值范围 [0,k)private static int[] countingSort(int[] nums, int k) { int n = nums.length; int[] cnt = new int[k]; int[] res = new int[n]; // 计数 for (int x : nums) { cnt[x]++; } // 前缀和 for (int i = 1; i &lt; k; i++) { cnt[i] += cnt[i - 1]; } // 排序（倒序遍历，保证稳定性） for (int i = n - 1; i &gt;= 0; i--) { res[--cnt[nums[i]]] = nums[i]; } return res;} 基数排序 稳定性：稳定。 时间复杂度：\\(O(d\\cdot (n+k))\\)。 空间复杂度：\\(O(n+k)\\)。 12345678910111213141516171819202122232425262728293031323334353637// 元素最多有 d 位private static int[] radixSort(int[] nums, int d) { int n = nums.length; int[] cnt = new int[10]; int[] aux = new int[n]; int divisor = 1; for (int i = 0; i &lt; d; i++) { countingSort(nums, cnt, aux, divisor); Arrays.fill(cnt, 0); divisor *= 10; int[] t = nums; nums = aux; aux = t; } return nums;}private static void countingSort(int[] nums, int[] cnt, int[] aux, int divisor) { int n = nums.length; // 计数 for (int x : nums) { cnt[x / divisor % 10]++; } // 前缀和 for (int i = 1; i &lt; 10; i++) { cnt[i] += cnt[i - 1]; } // 排序（倒序遍历，保证稳定性） for (int i = n - 1; i &gt;= 0; i--) { aux[--cnt[nums[i] / divisor % 10]] = nums[i]; }} 桶排序 稳定性：取决于桶内的排序策略。 时间复杂度：期望 \\(O(n)\\)。（输入数据均匀分布时） 空间复杂度：\\(O(n+m)\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static void bucketSort(int[] nums) { int n = nums.length; if (n &lt;= 1) return; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int x : nums) { min = Math.min(min, x); max = Math.max(max, x); } // 小心除以零 int inter = Math.max(1, (max - min) / (n - 1)); int bucketSize = (max - min) / inter + 1; List&lt;Integer&gt;[] buckets = new List[bucketSize]; Arrays.setAll(buckets, k -&gt; new ArrayList&lt;&gt;()); for (int x : nums) { int i = (x - min) / inter; buckets[i].add(x); // 插入排序 int j = buckets[i].size() - 1; for (; j &gt; 0 &amp;&amp; buckets[i].get(j - 1) &gt; x; j--) { buckets[i].set(j, buckets[i].get(j - 1)); } buckets[i].set(j, x); } int idx = 0; for (var bucket : buckets) { for (int x : bucket) { nums[idx++] = x; } }}","link":"/2023/10/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"字符串","text":"本文内容参考《算法》，《算法导论》，OI Wiki。 字符串匹配 例题 28. 找出字符串中第一个匹配项的下标。 暴力 时间复杂度：最坏 \\(O(NM)\\)，平均 \\(O(N)\\)。 空间复杂度：\\(O(1)\\)。 12345678910111213private static int bruteForce(String text, String pattern) { int i, j; int n = text.length(), m = pattern.length(); for (i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) { if (text.charAt(i) == pattern.charAt(j)) { j++; } else { i -= j; j = 0; } } return j == m ? i - m : -1;} KMP 时间复杂度：\\(O(N)\\)。 空间复杂度：\\(O(M)\\)。 12345678910111213141516171819202122232425262728293031private static int kmp(String text, String pattern) { int n = text.length(), m = pattern.length(); if (m &gt; n) return -1; // 处理模式串 // next[i] 表示 pattern 的子串 [0, i] 的最长相等前后缀的长度 int[] next = new int[m]; for (int i = 1, j = 0; i &lt; m; i++) { while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j)) { j = next[j - 1]; } if (pattern.charAt(i) == pattern.charAt(j)) { j++; } next[i] = j; } // 匹配文本串 for (int i = 0, j = 0; i &lt; n; i++) { while (j &gt; 0 &amp;&amp; text.charAt(i) != pattern.charAt(j)) { j = next[j - 1]; } if (text.charAt(i) == pattern.charAt(j)) { j++; } if (j == m) { return i - m + 1; } } return -1;} Boyer-Moore 时间复杂度：最坏 \\(O(NM)\\)，平均 \\(O(\\frac{N}{M})\\)。 空间复杂度：\\(O®\\)。 1System.out.println(&quot;TODO&quot;); Rabin-Karp 时间复杂度：\\(O(N)\\)。 空间复杂度：\\(O(1)\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041private static final int P = 13331;// MOD = 2^64private static int rabinKarp(String text, String pattern) { int n = text.length(), m = pattern.length(); if (m &gt; n) return -1; long PM = pow(P, m - 1); long patHash = hash(pattern, m); long txtHash = hash(text, m); if (txtHash == patHash) { return 0; } for (int i = m; i &lt; n; i++) { txtHash = txtHash - text.charAt(i - m) * PM; txtHash = txtHash * P + text.charAt(i); if (txtHash == patHash) { return i - m + 1; } } return -1;}private static long pow(int a, int n) { long res = 1L, x = a; for (; n != 0; x *= x, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res *= x; } } return res;}private static long hash(String s, int m) { long h = 0L; for (int i = 0; i &lt; m; i++) { h = h * P + s.charAt(i); } return h;} 字符串哈希 例题 E. Compress Words（这题使用 \\(MOD=2^{64}\\) 一直在第 65 个测试点 WA，看来还是模质数比较好）。 实现 时间复杂度：预处理 \\(O(N)\\)，获取哈希值 \\(O(1)\\)。 空间复杂度：\\(O(N)\\)。 123456789101112131415161718192021222324252627282930313233343536373839404142class StringHash { private final int K = 2; private static final long[] b = {131, 13331}; private static final long[] m = {1_000_000_007, 998244353}; private int index; private final long[][] h, p; public StringHash(int n) { h = new long[K][n + 1]; p = new long[K][n + 1]; for (int i = 0; i &lt; K; i++) { p[i][0] = 1; } } public StringHash(char[] s) { this(s.length); for (char c : s) add(c); } public void add(char c) { for (int j = 0; j &lt; K; j++) { p[j][index + 1] = p[j][index] * b[j] % m[j]; h[j][index + 1] = (h[j][index] * b[j] + c) % m[j]; } index++; } public long[] get(int l, int r) { long[] res = new long[K]; for (int i = 0; i &lt; K; i++) { long t = h[i][r + 1] - h[i][l] * p[i][r - l + 1]; res[i] = (t % m[i] + m[i]) % m[i]; } return res; } public int length() { return index; }} 字典树（Trie） 例题 208. 实现 Trie (前缀树)。 1803. 统计异或值在范围内的数对有多少。 实现 时间复杂度：插入和查找都是 \\(O(k)\\)，其中 \\(k\\) 为字符串的长度。 空间复杂度：\\(O(nR)\\)，其中 \\(n\\) 为节点总数，\\(R\\) 为字母表大小。 12345678910111213141516171819202122232425262728293031323334353637class Trie { private static final int R = 26; private final Node root; private static class Node { boolean exist; Node[] next = new Node[R]; } public Trie() { root = new Node(); } public void insert(String word) { Node node = root; for (int i = 0; i &lt; word.length(); i++) { int idx = word.charAt(i) - 'a'; if (node.next[idx] == null) { node.next[idx] = new Node(); } node = node.next[idx]; } node.exist = true; } public boolean search(String word) { Node node = root; for (int i = 0; i &lt; word.length(); i++) { int idx = word.charAt(i) - 'a'; if (node.next[idx] == null) { return false; } node = node.next[idx]; } return node.exist; }} AC 自动机 例题 P5357 【模板】AC 自动机（二次加强版）。 实现 时间复杂度：插入 \\(O(k)\\)，构建 \\(O(nR)\\)，查询 \\(O(k+n)\\)，其中 \\(k\\) 为字符串的长度。 空间复杂度：\\(O(nR)\\)，其中 \\(n\\) 为节点总数，\\(R\\) 为字母表大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class AhoCorasickAutomaton { private static final int R = 26; private final Node root; // 按插入顺序存储模式串尾字符对应的节点 private final List&lt;Node&gt; patternNodes; // 所有节点按层次遍历顺序存储（代码没有存根节点） private final List&lt;Node&gt; levelOrderNodes; private static class Node { int cnt; // 节点出现在文本串中的次数，懒更新 Node fail; // 节点的失配指针，指向当前节点的最长后缀节点 Node[] next = new Node[R]; } public AhoCorasickAutomaton() { root = new Node(); patternNodes = new ArrayList&lt;&gt;(); levelOrderNodes = new ArrayList&lt;&gt;(); } // 插入模式串 public void insert(String pattern) { Node node = root; for (int i = 0; i &lt; pattern.length(); i++) { int idx = pattern.charAt(i) - 'a'; if (node.next[idx] == null) { node.next[idx] = new Node(); } node = node.next[idx]; } patternNodes.add(node); } // 构建失配指针和 Trie 图 public void build() { // 将根节点的直接子节点入队，并构建节点的失配指针和 Trie 图 // 提前入队是因为根节点和其直接子节点与其他节点的处理逻辑不同 root.fail = root; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; R; i++) { if (root.next[i] == null) { root.next[i] = root; } else { root.next[i].fail = root; q.offer(root.next[i]); } } // 层次遍历，构建失配指针和 Trie 图 while (!q.isEmpty()) { Node node = q.poll(); levelOrderNodes.add(node); for (int i = 0; i &lt; R; i++) { if (node.next[i] == null) { node.next[i] = node.fail.next[i]; } else { node.next[i].fail = node.fail.next[i]; q.offer(node.next[i]); } } } } // 查询每个模式串在文本串中的出现次数 public void query(String text, int[] cnt) { // 懒更新出现次数 Node node = root; for (int i = 0; i &lt; text.length(); i++) { int idx = text.charAt(i) - 'a'; node = node.next[idx]; node.cnt++; } // 倒序层次遍历，进一步沿着失配指针传递出现次数 // 倒序遍历是因为失配指针必然在更上层，所以从下向上传递可以保证正确性 for (int i = levelOrderNodes.size() - 1; i &gt;= 0; i--) { node = levelOrderNodes.get(i); node.fail.cnt += node.cnt; } // 获取每个模式串的出现次数 for (int i = 0; i &lt; patternNodes.size(); i++) { cnt[i] += patternNodes.get(i).cnt; } }} 正则表达式 例题 10. 正则表达式匹配。使用动态规划或者构造非确定有限状态自动机（NFA）。 实现 时间复杂度：构造 NFA \\(O(m)\\)，匹配 \\(O(nm)\\)，其中 \\(m\\) 为正则表达式的长度，\\(n\\) 为文本串的长度。 空间复杂度：构造 NFA \\(O(m)\\)，匹配 \\(O(m)\\)。 1System.out.println(&quot;TODO&quot;);","link":"/2023/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"数学","text":"本文内容参考《算法导论》，OI Wiki。（数学好难，暂时搁置） 快速幂 例题 P1226 【模板】快速幂。 509. 斐波那契数。 整数 时间复杂度：\\(O(\\log{n})\\)。 1234567891011private static final long MOD = 1_000_000_007;private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;} 矩阵 时间复杂度：\\(O(\\log{n})\\)。 1234567891011121314151617181920212223private static final int MOD = 1_000_000_007;private static long[][] pow(long[][] x, long n) { long[][] res = {{1, 0}, {0, 1}}; for (; n != 0; x = mul(x, x), n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = mul(res, x); } } return res;}private static long[][] mul(long[][] a, long[][] b) { long[][] c = new long[2][2]; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) { c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % MOD; } } } return c;} 数论 例题 204. 计数质数。 2521. 数组乘积中的不同质因数数目。 2447. 最大公因数等于 K 的子数组数目。 1250. 检查「好数组」。 判断质数 时间复杂度 \\(O(n\\sqrt{n})\\)。 1234567private static boolean isPrime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i++) { if (x % i == 0) return false; } return true;} 质数筛法 埃氏筛 时间复杂度 \\(O(n\\log{\\log{n}})\\)，筛掉质数的倍数，每个合数都会被筛它的质因数的个数次。 123456789101112private static boolean[] sieveOfEratosthenes(int n) { boolean[] np = new boolean[n + 1]; np[0] = np[1] = true; for (int i = 2; i &lt;= n / i; i++) { if (np[i]) continue; for (int j = i; j &lt;= n / i; j++) { np[j * i] = true; } } return np;} 欧拉筛 时间复杂度 \\(O(n)\\)，每个合数都只被它的最小质因数筛掉。 123456789101112131415private static boolean[] sieveOfEuler(int n) { int cnt = 0; int[] p = new int[n + 1]; boolean[] np = new boolean[n + 1]; np[0] = np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) p[cnt++] = i; for (int j = 0; p[j] &lt;= n / i; j++) { np[p[j] * i] = true; if (i % p[j] == 0) break; } } return np;} 分解质因数 时间复杂度 \\(O(\\sqrt{n})\\)。 1234567891011private static Map&lt;Integer, Integer&gt; primeFactors(int x) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 2; i &lt;= x / i; i++) { while (x % i == 0) { x /= i; map.merge(i, 1, Integer::sum); } } if (x &gt; 1) map.merge(x, 1, Integer::sum); return map;} 欧拉函数 欧拉函数 \\(\\phi(n)\\)，表示 \\([1,n]\\) 范围内和 \\(n\\) 互质的数的个数，有如下性质： 若 \\(\\gcd(a,b)=1\\)，则 \\(\\phi(a\\times b)=\\phi(a)\\times \\phi(b)\\)。 若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，其中 \\(p_{i}\\) 为质数，则 \\(\\phi(n)=n\\times\\prod_{i=1}^{k}(1-\\frac{1}{p_{i}})\\)。 我们可以使用分解质因数求解某个数的欧拉函数，时间复杂度为 \\(O(\\sqrt{n})\\)；也可以使用欧拉筛来求解 \\([1,n]\\) 范围内所有数的欧拉函数，时间复杂度为 \\(O(n)\\)。在欧拉筛中，每个合数都是被它的最小质因子筛掉，设 \\(p\\) 是 \\(n\\) 的最小质因子，则 \\(n=n^{\\prime}\\times p\\)，分类讨论： 如果 \\(n^{\\prime}\\bmod p\\neq 0\\)，因为 \\(p\\) 是质数，所以 \\(\\gcd(n^{\\prime},p)=1\\)，则 \\(\\phi(n)=\\phi(n^{\\prime})\\times \\phi(p)=\\phi(n^{\\prime})\\times (p-1)\\)。 如果 \\(n^{\\prime}\\bmod p=0\\)，则 \\(\\phi(n)=p\\times n^{\\prime}\\times\\prod_{i=1}^{k}(1-\\frac{1}{p_{i}})=p\\times \\phi(n^{\\prime})\\)。 123456789101112131415161718192021222324private static int[] sieveOfEuler(int n) { int cnt = 0; int[] p = new int[n + 1]; int[] phi = new int[n + 1]; boolean[] np = new boolean[n + 1]; phi[1] = 1; np[0] = np[1] = true; for (int i = 2; i &lt;= n; i++) { if (!np[i]) { p[cnt++] = i; phi[i] = i - 1; } for (int j = 0; p[j] &lt;= n / i; j++) { np[p[j] * i] = true; if (i % p[j] == 0) { phi[p[j] * i] = p[j] * phi[i]; break; } phi[p[j] * i] = (p[j] - 1) * phi[i]; } } return phi;} 最大公约数 欧几里得算法 时间复杂度 \\(O(\\log{\\max(a,b)})\\)。求得最大公约数之后，使用 \\(\\gcd(a,b)\\times\\operatorname{lcm}(a,b)=a\\times b\\) 公式可以得到最小公倍数。 1234private static int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b);} 扩展欧几里得算法 常用于求解 \\(ax+by=\\gcd(a,b)\\) 的一组解。 1234567891011121314private static int x, y;private static int exgcd(int a, int b) { if (b == 0) { x = 1; y = 0; return a; } int d = exgcd(b, a % b); int t = x - a / b * y; x = y; y = t; return d;} 其他知识 约数个数 若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，则 \\(d_{n}=\\prod_{i=1}^{k}(c_{i}+1)\\)。 约数之和 若 \\(n=\\prod_{i=1}^{k}{p_{i}^{c_{i}}}\\)，则 \\(s_{n}=\\prod_{i=1}^{k}\\sum_{j=0}^{c_{i}}{p_{i}^{j}}\\)。 裴蜀定理 若 \\(a,b\\) 是整数，则对于任意的整数 \\(x,y\\)，\\(ax+by\\) 总是 \\(\\gcd(a,b)\\) 的倍数，并且存在整数 \\(x,y\\)，使得 \\(ax+by=\\gcd(a,b)\\)。特别的，若存在整数 \\(x,y\\) 使得 \\(ax+by=1\\)，则 \\(\\gcd(a,b)=1\\)，即 \\(a,b\\) 互质。 费马小定理 若 \\(p\\) 是质数，\\(\\gcd(a,p)=1\\)，则 \\(a^{p-1}\\equiv 1\\pmod{p}\\)。 欧拉定理 若 \\(\\gcd(a,n)=1\\)，则 \\(a^{\\phi(n)}\\equiv 1\\pmod{n}\\)。 模乘法逆元 若 \\(p\\) 是质数，根据费马小定理，有 \\(a\\times a^{-1}\\equiv 1\\equiv a^{p-1}\\pmod{p}\\)，得到 \\(a^{-1}\\equiv a^{p-2}\\pmod{p}\\)。 若 \\(b\\) 是任意整数，求 \\(a\\) 的逆元，等价于求 \\(ax\\equiv 1\\pmod{b}\\) 的解，等价于求 \\(ax+by=1\\) 的解。如果 \\(\\gcd(a,b)=1\\)，则可以使用扩展欧几里得算法求解该方程。如果 \\(\\gcd(a,b)\\neq 1\\)，根据裴蜀定理可知方程无解（或者可以将方程变换为 \\(\\frac{a}{g}x+\\frac{b}{g}y=\\frac{1}{g}\\)，等式左边是整数，右边不是整数，方程无解），即逆元不存在。 线性同余方程 求 \\(ax\\equiv c\\pmod{b}\\) 的解，等价于求 \\(ax+by=c\\) 的解，同样的，当 \\(\\gcd(a,b)\\mid c\\) 时方程有解。使用扩展欧几里得算法可以求出 \\(ax+by=\\gcd(a,b)\\) 的解，然后将方程变换为 \\(a\\frac{c}{\\gcd(a,b)}x_{0}+b\\frac{c}{\\gcd(a,b)}y_{0}=c\\)，可以得到方程的解。","link":"/2023/10/26/%E6%95%B0%E5%AD%A6/"},{"title":"数据结构","text":"本文内容参考 OI Wiki。 并查集 例题 P3367 【模板】并查集。 实现 123456789101112131415161718192021222324252627282930313233343536373839class UnionFind { private final int[] f, s; private int c; public UnionFind(int n) { c = n; f = new int[n]; s = new int[n]; for (int i = 0; i &lt; n; i++) { f[i] = i; s[i] = 1; } } public int find(int x) { if (x != f[x]) f[x] = find(f[x]); return f[x]; } public void union(int x, int y) { int rx = find(x), ry = find(y); if (rx == ry) return; f[ry] = rx; s[rx] += s[ry]; c--; } public boolean connected(int x, int y) { return find(x) == find(y); } public int size(int x) { return s[find(x)]; } public int count() { return c; }} 树状数组 例题 #130. 树状数组 1 ：单点修改，区间查询。 #131. 树状数组 2 ：区间修改，单点查询。 #132. 树状数组 3 ：区间修改，区间查询。 实现 单点修改，区间查询 123456789101112131415161718192021222324252627class BIT { private final int n; private final long[] t; public BIT(int n) { this.n = n; t = new long[n + 1]; } public void add(int i, int k) { for (; i &lt;= n; i += i &amp; -i) { t[i] += k; } } public long sum(int x) { long res = 0; for (; x &gt; 0; x &amp;= x - 1) { res += t[x]; } return res; } public long get(int l, int r) { return sum(r) - sum(l - 1); }} 区间修改，单点查询 1234567891011121314151617181920212223242526272829303132class BIT { private final int n; private final long[] t; public BIT(int n) { this.n = n; t = new long[n + 1]; } private void add(int i, int k) { for (; i &lt;= n; i += i &amp; -i) { t[i] += k; } } public void add(int l, int r, int k) { add(l, k); add(r + 1, -k); } public long sum(int x) { long res = 0L; for (int i = x; i &gt; 0; i &amp;= i - 1) { res += t[i]; } return res; } public long get(int x) { return sum(x); }} 区间修改，区间查询 123456789101112131415161718192021222324252627282930313233343536class BIT { private final int n; private final long[] t1, t2; public BIT(int n) { this.n = n; t1 = new long[n + 1]; t2 = new long[n + 1]; } private void add(int i, int k) { long p = (long) k * i; for (; i &lt;= n; i += i &amp; -i) { t1[i] += k; t2[i] += p; } } public void add(int l, int r, int k) { add(l, k); add(r + 1, -k); } public long sum(int x) { long s1 = 0, s2 = 0; for (int i = x; i &gt; 0; i &amp;= i - 1) { s1 += t1[i]; s2 += t2[i]; } return s1 * (x + 1) - s2; } public long get(int l, int r) { return sum(r) - sum(l - 1); }} 线段树 例题 P3372 【模板】线段树 1。 P3373 【模板】线段树 2。 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class SegmentTree { private final int n; private final long[] t, z; public SegmentTree(int[] a) { n = a.length; t = new long[4 * n]; z = new long[4 * n]; build(a, 1, 1, n); } private void build(int[] a, int i, int l, int r) { if (l == r) { t[i] = a[l - 1]; return; } int mid = l + (r - l) / 2; build(a, 2 * i, l, mid); build(a, 2 * i + 1, mid + 1, r); t[i] = t[2 * i] + t[2 * i + 1]; } private void lazy(int i, int lo, int hi, long k) { t[i] += k * (hi - lo + 1); z[i] += k; } private void down(int i, int lo, int hi) { if (z[i] == 0) { return; } int mid = lo + (hi - lo) / 2; lazy(2 * i, lo, mid, z[i]); lazy(2 * i + 1, mid + 1, hi, z[i]); z[i] = 0; } public void add(int l, int r, int k) { if (l &gt; r) return; add(1, 1, n, l, r, k); } private void add(int i, int lo, int hi, int l, int r, int k) { if (lo &gt;= l &amp;&amp; hi &lt;= r) { lazy(i, lo, hi, k); return; } down(i, lo, hi); int mid = lo + (hi - lo) / 2; if (l &lt;= mid) add(2 * i, lo, mid, l, r, k); if (r &gt; mid) add(2 * i + 1, mid + 1, hi, l, r, k); t[i] = t[2 * i] + t[2 * i + 1]; } public long get(int l, int r) { if (l &gt; r) return 0L; return get(1, 1, n, l, r); } private long get(int i, int lo, int hi, int l, int r) { if (lo &gt;= l &amp;&amp; hi &lt;= r) { return t[i]; } down(i, lo, hi); long res = 0L; int mid = lo + (hi - lo) / 2; if (l &lt;= mid) res += get(2 * i, lo, mid, l, r); if (r &gt; mid) res += get(2 * i + 1, mid + 1, hi, l, r); return res; }} 稀疏表（Sparse Table） 例题 P3865 【模板】ST 表。 实现 1System.out.println(&quot;TODO&quot;);","link":"/2023/10/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"AtCoder Beginner Contest 326","text":"2UP3DOWN12345678public static void solve() { int x = io.nextInt(), y = io.nextInt(); if (y - x &gt;= -3 &amp;&amp; y - x &lt;= 2) { io.println(&quot;Yes&quot;); } else { io.println(&quot;No&quot;); }} 326-like Numbers123456789public static void solve() { int n = io.nextInt(); for (; ; n++) { if (n / 100 * (n / 10 % 10) == n % 10) { io.println(n); return; } }} Peak1234567891011121314151617public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); int ans = 0; for (int i = 0, j = 0; j &lt; n; j++) { while (a[j] - a[i] &gt;= m) { i++; } ans = Math.max(ans, j - i + 1); } io.println(ans);} ABC Puzzle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void solve() { int n = io.nextInt(); char[] r = io.next().toCharArray(); char[] c = io.next().toCharArray(); int[] row = new int[n]; int[] col = new int[n]; char[][] ans = new char[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(ans[i], '.'); } boolean ok = dfs(0, 0, r, c, ans, row, col, 0); if (!ok) { io.println(&quot;No&quot;); return; } io.println(&quot;Yes&quot;); for (int i = 0; i &lt; n; i++) { io.println(new String(ans[i])); }}private static boolean dfs(int x, int y, char[] r, char[] c, char[][] ans, int[] row, int[] col, int cnt) { int n = r.length; if (x == n) { return cnt == 3 * n; } if (n - 1 - y &gt;= 3 - Integer.bitCount(row[x])) { if (dfs(x + (y + 1) / n, (y + 1) % n, r, c, ans, row, col, cnt)) { return true; } } for (int i = 0; i &lt; 3; i++) { if ((row[x] &gt;&gt; i &amp; 1) == 1 || (col[y] &gt;&gt; i &amp; 1) == 1) { continue; } if (row[x] == 0 &amp;&amp; r[x] != 'A' + i) { continue; } if (col[y] == 0 &amp;&amp; c[y] != 'A' + i) { continue; } row[x] |= 1 &lt;&lt; i; col[y] |= 1 &lt;&lt; i; ans[x][y] = (char) ('A' + i); if (dfs(x + (y + 1) / n, (y + 1) % n, r, c, ans, row, col, cnt + 1)) { return true; } row[x] ^= 1 &lt;&lt; i; col[y] ^= 1 &lt;&lt; i; ans[x][y] = '.'; } return false;} Revenge of “The Salary of AtCoder Inc.”概率 DP，答案为 \\(\\sum_{i=1}^{n}{A_{i}P_{i}}\\)，而 \\(P_{i}=\\frac{1}{N}\\sum_{j=0}^{i-1}{P_{j}}=P_{i-1}+\\frac{1}{N}P_{i-1}\\)。（这么简单，真没想到） 1234567891011121314151617181920212223private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); long invn = pow(n, MOD - 2); long ans = 0L, p = invn; for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); ans = (ans + p * a) % MOD; p = (p + invn * p) % MOD; } io.println(ans);}private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;}","link":"/2023/10/29/AtCoder%20Beginner%20Contest%20326/"},{"title":"第 116 场力扣夜喵双周赛","text":"子数组不同元素数目的平方和 I同下。 使二进制字符串变美丽的最少修改次数长度为偶数的字符串要满足条件，那么将数组分为长度为 \\(2\\) 的各个小段，使各个子数组满足条件一定是最优的。 123456789class Solution { public int minChanges(String s) { int n = s.length(), ans = 0; for (int i = 0; i &lt; n; i += 2) { ans += (s.charAt(i) ^ s.charAt(i + 1)) &amp; 1; } return ans; }} 和为目标值的最长子序列的长度0-1 背包，转移方程为 \\(dp[i][j]=\\max(dp[i-1][j],dp[i-1][j-nums[i]]+1)\\)，注意初始化为 \\(-1\\)，并在转移时判断有效性。 12345678910111213141516class Solution { public int lengthOfLongestSubsequence(List&lt;Integer&gt; nums, int target) { int n = nums.size(); int[] dp = new int[target + 1]; Arrays.fill(dp, -1); dp[0] = 0; for (int x : nums) { for (int j = target; j &gt;= x; j--) { if (dp[j - x] != -1) { dp[j] = Math.max(dp[j], dp[j - x] + 1); } } } return dp[target]; }} 子数组不同元素数目的平方和 II动态规划 + 线段树，刚学的线段树就用上了，但是不太熟练，忘记我的线段树板子是从下标一开始操作，并且没有特判，如果操作的右端点比左端点小，那么就会导致数组越界，之后得修改一下板子。假设以 \\(i\\) 为右端点的所有子数组的不同计数的平方和为 \\(dp[i]\\)，考虑如何转移到 \\(dp[i+1]\\)。 如果在 \\([0,i]\\) 中和 \\(nums[i+1]\\) 相等的数为 \\(nums[j]\\)，则添加 \\(nums[i+1]\\) 会使左端点在 \\([j+1,i]\\) 范围内的子数组的不同计数加 \\(1\\)，而左端点在 \\([0,j]\\) 范围内子数组的不同计数不变，最后不要忘记加上左端点在 \\(i+1\\) 的子数组的不同计数的平方。我们可以得到如下转移方程，其中 \\(x_{i,j}\\) 表示子数组 \\(nums[i,j]\\) 的不同计数。 $$ \\begin{align} dp[i] &=x_{0,i}^{2}+x_{1,i}^{2}+\\cdots+x_{i,i}^{2} \\\\ dp[i+1] &=x_{0,i}^{2}+\\cdots+x_{j,i}^{2}+(x_{j+1,i}+1)^{2}+\\cdots+(x_{i,i}+1)^{2}+x_{i+1,i+1}^{2} \\end{align} $$ 然后我们将 \\(dp[i]\\) 代入到 \\(dp[i+1]\\) 中，得到： $$ dp[i+1]=dp[i]+2\\sum_{k=j+1}^{i}x_{k,i}+(i-j)+x_{i+1,i+1}^{2} $$ 首先我们需要得到每个数，它左边第一个相同的数的位置，这可以在遍历的过程中使用哈希表得到。然后我们需要维护以当前位置为右端点，所有左端点表示的子数组的不同计数（区间修改），并且需要快速的求区间和，那么就可以使用线段树，这样我们只需要花费 \\(O(\\log{n})\\) 的时间进行转移。转移之后，不要忘记更新左端点在 \\([j+1,i+1]\\) 范围内的子数组的不同计数。 12345678910111213141516171819class Solution { private static final int MOD = (int) 1e9 + 7; public int sumCounts(int[] nums) { int n = nums.length; long ans = 0L, sum = 0L; var st = new SegmentTree(n); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= n; i++) { int j = map.getOrDefault(nums[i - 1], 0); map.put(nums[i - 1], i); sum = (sum + 2 * st.get(j + 1, i) + i - j) % MOD; ans = (ans + sum) % MOD; st.add(j + 1, i, 1); } return (int) ans; }}","link":"/2023/10/29/%E7%AC%AC%20116%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 369 场力扣周赛","text":"找出数组中的 K-or 值模拟。 123456789101112131415class Solution { public int findKOr(int[] nums, int k) { int ans = 0; for (int i = 0; i &lt; 31; i++) { int cnt = 0; for (int x : nums) { cnt += x &gt;&gt; i &amp; 1; } if (cnt &gt;= k) { ans |= 1 &lt;&lt; i; } } return ans; }} 数组的最小相等和分类讨论。所有 \\(0\\) 都必须被替换为正整数，那么首先将所有 \\(0\\) 替换为 \\(1\\)。如果两个数组中都有 \\(0\\)，则此时得到的最大的数组和就应该是答案，因为较小的一方总是可以使用更大的正整数替换 \\(0\\)，使得两个数组的元素和相等。如果某个数组的和不等于最大和，并且数组中不包含 \\(0\\)，那么就无法使两个数组的元素和相等。 123456789101112131415161718class Solution { public long minSum(int[] nums1, int[] nums2) { int cnt1 = 0, cnt2 = 0; long sum1 = 0L, sum2 = 0L; for (int x : nums1) { if (x == 0) cnt1++; sum1 += x; } for (int x : nums2) { if (x == 0) cnt2++; sum2 += x; } long max = Math.max(sum1 + cnt1, sum2 + cnt2); if (sum1 != max &amp;&amp; cnt1 == 0) return -1; if (sum2 != max &amp;&amp; cnt2 == 0) return -1; return max; }} 使数组变美的最小增量运算数按照灵神的题解，每个位置的状态就是它右边有多少个数小于 \\(k\\)，加上这个维度就可以做记忆化搜索，然后转递推真的很妙。题解区还有其他的状态定义方式，可以看看。代码就贴灵神的。（这题感觉很不错，没有见过的类型） 123456789101112class Solution { public long minIncrementOperations(int[] nums, int k) { long f0 = 0, f1 = 0, f2 = 0; for (int x : nums) { long inc = f0 + Math.max(k - x, 0); f0 = Math.min(inc, f1); f1 = Math.min(inc, f2); f2 = inc; } return f0; }} 收集所有金币可获得的最大积分当我们遍历到某个节点时，它的状态就是需要除以多少次 \\(2\\)，由数据范围可知每个节点最多有 \\(15\\) 个状态。我们可以从子问题的最优解推出原问题的最优解，并且子问题可以独立求解，符合最优子结构；如果当前节点处于某个状态，它可能是由不同的路径转移得到的，即存在重叠子问题。所以我们可以使用树型 DP 求解该问题，列出如下状态转移方程： $$ dp[x][i]=\\max(\\sum_{y}{dp[y][i]}+(coins[x]>>i)-k,\\sum_{y}{dp[y][i + 1]}+(coins[x]>>(i+1))) $$ 其中 \\(dp[i][j]\\) 表示到达节点 \\(i\\)，需要除以 \\(2^{j}\\)，该状态下以节点 \\(i\\) 为根的子树能够得到的最大积分。 1234567891011121314151617181920212223242526272829303132class Solution { public int maximumPoints(int[][] edges, int[] coins, int k) { int n = coins.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, t -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } return dfs(0, -1, g, coins, k)[0]; } private int[] dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] coins, int k) { int[] sum1 = new int[15]; int[] sum2 = new int[15]; for (int y : g[x]) { if (y == fa) continue; int[] t = dfs(y, x, g, coins, k); for (int i = 0; i &lt; 14; i++) { sum1[i] += t[i]; sum2[i] += t[i + 1]; } } for (int i = 0; i &lt; 14; i++) { sum1[i] = Math.max(sum1[i] + (coins[x] &gt;&gt; i) - k, sum2[i] + (coins[x] &gt;&gt; (i + 1))); } return sum1; }}","link":"/2023/10/29/%E7%AC%AC%20369%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 907 (Div. 2)","text":"Sorting with Twos因为每次只能操作区间 \\([1,2^{m}]\\)，所以 \\([2^{m}+1,2^{m+1}]\\) 内的所有数是同时进行操作的，它们需要满足非递减的性质，最后不要忘记结尾不能操作的数也需要满足条件。 123456789101112131415161718public static void solve() { int n = io.nextInt(); int[] a = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { a[i] = io.nextInt(); } for (int i = 1; 1 &lt;&lt; i &lt;= n; i++) { int j = Math.min(1 &lt;&lt; (i + 1), n); for (int k = (1 &lt;&lt; i) + 1; k &lt; j; k++) { if (a[k] &gt; a[k + 1]) { io.println(&quot;NO&quot;); return; } } } io.println(&quot;YES&quot;);} Deja Vu如果一个数能够被 \\(2^{i}\\) 整除，那么操作之后，它只能被所有小于等于 \\(2^{i-1}\\) 的二的幂整除。所以预处理所有修改，只保留满足递减顺序的修改，然后模拟即可。或者也可以直接修改，不用预处理，在修改之前判断一下是否比上次小就行。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(), q = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int mask = 0; for (int i = 0; i &lt; q; i++) { int x = io.nextInt(); if (mask == 0 || (1 &lt;&lt; x) &lt;= (mask &amp; -mask)) { mask |= 1 &lt;&lt; x; } } for (int i = 0; i &lt; n; i++) { for (int j = 30; j &gt;= 0; j--) { if ((mask &gt;&gt; j &amp; 1) == 1 &amp;&amp; a[i] % (1 &lt;&lt; j) == 0) { a[i] += 1 &lt;&lt; (j - 1); } } } for (int i = 0; i &lt; n; i++) { io.print(a[i] + &quot; &quot;); } io.println();} Smilo and Monsters比赛时我是排序 + 相向双指针模拟的，先干前面的怪物，如果计数和最后一个的怪物群数量相等，则使用终极攻击，比较麻烦的是双指针到达同一个位置时，需要特判一些情况。然后下面的解法，很简洁啊。似乎总是可以使用普通攻击干掉怪物总数的一半向上取整，并且使用终极攻击干掉总数的一半向下取整。然后排序数组并倒序遍历，使得一次终极攻击干掉尽可能多的怪物，这样就得到最少攻击次数。 1234567891011121314151617public static void solve() { int n = io.nextInt(); int[] a = new int[n]; long sum = 0L; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); sum += a[i]; } Arrays.sort(a); long ans = (sum + 1) / 2; sum /= 2; for (int i = n - 1; i &gt;= 0 &amp;&amp; sum &gt; 0; i--) { sum -= a[i]; ans++; } io.println(ans);} Suspicious logarithms\\(f(x)\\) 表示 \\(x\\) 的二进制表示中最高位的 \\(1\\) 所在的位数 \\(y\\)，而 \\(g(x)\\) 表示满足 \\(y^{z}&lt;= x\\) 条件的最大的 \\(z\\)。可以发现如果 \\(y=2,x=10^{18}\\)，则 \\(z=59\\)。我们可以枚举所有 \\(y\\in[2,59]\\)，对于特定的 \\(y\\)，枚举不同的 \\(z\\) 覆盖的区间范围。得到各个区间范围内所有数的 \\(z\\) 值，我们就可以在 \\(O(\\log{(r-l+1)})\\) 的时间复杂度内执行查询。为了避免乘法溢出，在进行比较时需要使用除法。其他人代码有直接使用 \\(\\log\\) 的，也比较简单啊，我还以为很麻烦，结果溢出没想到换除法。当然也可以维护前缀和，然后二分区间位置来进行查询。 12345678910111213141516171819202122232425262728293031323334private static final int MOD = (int) 1e9 + 7;private static final List&lt;long[]&gt;[] list = new List[60];static { Arrays.setAll(list, k -&gt; new ArrayList&lt;&gt;()); for (int f = 2; f &lt; 60; f++) { long l = 1L &lt;&lt; f, r = (1L &lt;&lt; f + 1) - 1; long k = f, g = 1; while (k &lt;= l / f) { k *= f; g++; } for (; l &lt;= r; l = k + 1, g++) { k = k &lt;= r / f ? k * f - 1 : r; list[f].add(new long[]{l, k, g}); } }}public static void solve() { long ans = 0L; long l = io.nextLong(), r = io.nextLong(); int i = 63 - Long.numberOfLeadingZeros(l); int j = 63 - Long.numberOfLeadingZeros(r); for (; i &lt;= j; i++) { for (long[] t : list[i]) { ans = (ans + (Math.max(0, Math.min(t[1], r) - Math.max(t[0], l) + 1)) * t[2]) % MOD; } } io.println(ans);} A Growing Tree每个节点的编号是添加该节点时树的大小，因为修改操作不会影响还未添加到树上的节点，所以我们对每个修改操作添加一个编号（时间），表示修改所影响的范围。我们可以使用单点修改、区间查询的树状数组维护修改操作的编号，然后按照 DFS 序遍历树，每当遍历到一个节点，使用树状数组进行单点修改，因为遍历是 DFS 序，所以当前节点的祖先节点已经进行过修改操作，那么当前节点的答案就是所有大于等于该节点编号的修改操作之和。 那么有没有可能该答案会包含其他满足编号大于当前节点的非祖先节点的修改操作呢，不会包含，因为遍历是 DFS 序，DFS 返回时会取消对节点的修改操作，所以每当遍历到一个节点，修改操作只会包含其祖先节点的修改操作。特别注意，数组开 \\(q+2\\) 的大小，因为初始时有一个根节点，所以节点数量最多为 \\(q+1\\)，然后编号从 \\(1\\) 开始。 12345678910111213141516171819202122232425262728293031323334353637public static void solve() { int q = io.nextInt(), sz = 1; List&lt;int[]&gt;[] queries = new List[q + 2]; Arrays.setAll(queries, k -&gt; new ArrayList&lt;&gt;()); List&lt;Integer&gt;[] g = new List[q + 2]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; q; i++) { int t = io.nextInt(); if (t == 1) { int v = io.nextInt(); g[v].add(++sz); } else { int v = io.nextInt(), x = io.nextInt(); queries[v].add(new int[]{sz, x}); } } var bit = new BIT(sz); long[] ans = new long[sz + 1]; dfs(1, sz, g, queries, bit, ans); for (int i = 1; i &lt;= sz; i++) { io.print(ans[i] + &quot; &quot;); } io.println();}private static void dfs(int x, int sz, List&lt;Integer&gt;[] g, List&lt;int[]&gt;[] queries, BIT bit, long[] ans) { for (int[] q : queries[x]) { bit.add(q[0], q[1]); } ans[x] = bit.get(x, sz); for (int y : g[x]) { dfs(y, sz, g, queries, bit, ans); } for (int[] q : queries[x]) { bit.add(q[0], -q[1]); }}","link":"/2023/10/31/Codeforces%20Round%20907%20(Div.%202)/"},{"title":"图论","text":"本文内容参考《算法》，《算法导论》，OI Wiki。 拓扑排序 例题 B3644 【模板】拓扑排序 / 家谱树。 实现 时间复杂度为 \\(O(n+m)\\)。 12345678910111213141516171819202122232425262728293031323334private static int[] topologicalSort(int n, int[][] edges) { int[] in = new int[n]; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); in[v]++; } Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { q.offer(i); } } int idx = 0; int[] res = new int[n]; while (!q.isEmpty()) { int x = q.poll(); res[idx++] = x; for (int y : g[x]) { if (--in[y] == 0) { q.offer(y); } } } // 拓扑排序不存在 assert idx == n; return res;} 最小生成树 例题 P3366 【模板】最小生成树。 Prim 实现一：朴素版本 时间复杂度为 \\(O(n^{2})\\)。 12345678910111213141516171819202122232425262728293031323334353637383940private static int prim(int n, int[][] edges) { int[][] g = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(g[i], Integer.MAX_VALUE); g[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; if (g[u][v] &gt; w) { g[u][v] = g[v][u] = w; } } int[] d = new int[n]; Arrays.fill(d, Integer.MAX_VALUE); boolean[] vis = new boolean[n]; int res = 0; d[0] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 0; j &lt; n; j++) { if (!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) { t = j; } } // 不是连通图，最小生成树不存在 assert d[t] != Integer.MAX_VALUE; vis[t] = true; res += d[t]; for (int j = 0; j &lt; n; j++) { d[j] = Math.min(d[j], g[t][j]); } } return res;} 实现二：优先队列优化 时间复杂度为 \\(O(m\\log{m})\\)。 12345678910111213141516171819202122232425262728293031323334353637private static int prim(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); g[v].add(new int[]{u, w}); } int[] d = new int[n]; Arrays.fill(d, Integer.MAX_VALUE); boolean[] vis = new boolean[n]; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]); int res = 0, cnt = 0; d[0] = 0; q.offer(new int[]{0, 0}); while (!q.isEmpty()) { int u = q.poll()[0]; if (vis[u]) continue; vis[u] = true; res += d[u]; if (++cnt == n) break; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (!vis[v] &amp;&amp; d[v] &gt; w) { d[v] = w; q.offer(new int[]{v, d[v]}); } } } // 不是连通图，最小生成树不存在 assert cnt == n; return res;} Kruskal 时间复杂度为 \\(O(m\\log{m})\\)。 123456789101112131415161718private static int kruskal(int n, int[][] edges) { Arrays.sort(edges, (a, b) -&gt; a[2] - b[2]); int cnt = 1, res = 0; UnionFind uf = new UnionFind(n); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; if (uf.connected(u, v)) continue; uf.union(u, v); res += w; if (++cnt == n) break; } // 不是连通图，最小生成树不存在 assert cnt == n; return res;} 最短路 例题 P4779 【模板】单源最短路径（标准版）。 B3647 【模板】Floyd。 Dijkstra 使用场景：解决边权非负的单源最短路问题。 实现一：朴素版本 时间复杂度为 \\(O(n^{2})\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static final int INF = (int) 1e9;private static int dijkstra(int n, int[][] edges) { int[][] g = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(g[i], INF); g[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u][v] = Math.min(g[u][v], w); } int[] d = new int[n]; Arrays.fill(d, INF); boolean[] vis = new boolean[n]; d[0] = 0; while (true) { int t = -1; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; (t == -1 || d[t] &gt; d[i])) { t = i; } } if (t == n - 1 || d[t] == INF) { break; } vis[t] = true; for (int i = 0; i &lt; n; i++) { d[i] = Math.min(d[i], d[t] + g[t][i]); } } return d[n - 1] == INF ? -1 : d[n - 1];} 实现二：优先队列优化 时间复杂度为 \\(O(m\\log{m})\\)。 123456789101112131415161718192021222324252627282930313233private static final int INF = (int) 1e9;private static int dijkstra(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); } int[] d = new int[n]; Arrays.fill(d, INF); boolean[] vis = new boolean[n]; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]); d[0] = 0; q.offer(new int[]{0, 0}); while (!q.isEmpty()) { int u = q.poll()[0]; if (u == n - 1) break; if (vis[u]) continue; vis[u] = true; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (d[v] &gt; d[u] + w) { d[v] = d[u] + w; q.offer(new int[]{v, d[v]}); } } } return d[n - 1] == INF ? -1 : d[n - 1];} Bellman-Ford 时间复杂度为 \\(O(nm)\\)。 使用场景：解决任意边权的单源最短路问题；判断是否存在负环；解决有边数限制的单源最短路问题。 实现一：朴素版本 1234567891011121314151617private static final int INF = (int) 1e9;private static int bellmanFord(int n, int[][] edges) { int[] d = new int[n]; Arrays.fill(d, INF); d[0] = 0; for (int i = 0; i &lt; n; i++) { for (var e : edges) { int u = e[0], v = e[1], w = e[2]; d[v] = Math.min(d[v], d[u] + w); } } // d[n - 1] == INF 时，最短路不存在 return d[n - 1];} 实现二：队列优化（不能存在负环） 123456789101112131415161718192021222324252627282930313233343536private static final int INF = (int) 1e9;private static int spfa(int n, int[][] edges) { List&lt;int[]&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1], w = e[2]; g[u].add(new int[]{v, w}); } int[] d = new int[n]; Arrays.fill(d, INF); Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); boolean[] on = new boolean[n]; d[0] = 0; q.offer(0); on[0] = true; while (!q.isEmpty()) { int u = q.poll(); on[u] = false; for (int[] t : g[u]) { int v = t[0], w = t[1]; if (d[v] &gt; d[u] + w) { d[v] = d[u] + w; if (!on[v]) { q.offer(v); on[v] = true; } } } } // d[n - 1] == INF 时，最短路不存在 return d[n - 1];} Floyd-Warshall 时间复杂度为 \\(O(n^{3})\\)。 使用场景：解决任意边权的多源最短路问题。 123456789101112131415161718192021222324private static final int INF = (int) 1e9;private static int[][] floyd(int n, int[][] edges) { int[][] dp = new int[n][n]; for (int i = 0; i &lt; n; i++) { Arrays.fill(dp[i], INF); dp[i][i] = 0; } for (var e : edges) { int u = e[0], v = e[1], w = e[2]; dp[u][v] = Math.min(dp[u][v], w); } for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (dp[i][k] != INF &amp;&amp; dp[k][j] != INF) { dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]); } } } } return dp;} 最近公共祖先 例题 P3379 【模板】最近公共祖先（LCA）。 倍增 预处理时间复杂度为 \\(O(n\\log{n})\\)，查询时间复杂度为 \\(O(\\log{n})\\)。 原理：\\(f[i][j]\\) 表示节点 \\(j\\) 的第 \\(2^{i}\\) 个祖先，当利用倍增得到 \\(f\\) 时，对于任意两个节点 \\(x,y\\)，先将较深的节点向上跳到相同深度，然后两个节点贪心的向上跳到 \\(\\operatorname{lca}\\) 下方距离它最近的节点，最后得到的节点就是 \\(\\operatorname{lca}\\) 的直接子节点。（在进行倍增时，根节点的父节点可以是任何值，因为该值不会影响算法的正确性） 123456789101112131415161718192021222324252627282930313233343536private static void dfs(int x, int fa, List&lt;Integer&gt;[] g, int[][] f, int[] d) { f[0][x] = fa; for (int i = 1; 1 &lt;&lt; i &lt;= d[x]; i++) { f[i][x] = f[i - 1][f[i - 1][x]]; } for (int y : g[x]) { if (y != fa) { d[y] = d[x] + 1; dfs(y, x, g, f, d); } }}private static int lca(int x, int y, int[][] f, int[] d) { if (d[x] &gt; d[y]) { int t = x; x = y; y = t; } int diff = d[y] - d[x]; for (int i = 0; i &lt; 31; i++) { if ((diff &gt;&gt; i &amp; 1) == 1) { y = f[i][y]; } } if (x != y) { for (int i = 30; i &gt;= 0; i--) { if (f[i][x] != f[i][y]) { x = f[i][x]; y = f[i][y]; } } x = f[0][x]; } return x;} Tarjan 离线查询算法，时间复杂度为 \\(O((n+m)\\log{n})\\)。更精确的复杂度分析可以使用反阿克曼函数。 原理：每当处理完一个子树，就将该子树的根节点和其父节点合并，特别注意合并的方向是 \\(f[y]=x\\)。然后我们会遍历包含当前节点 \\(x\\) 的查询，如果另一个节点 \\(y\\) 访问过，则 \\(\\operatorname{lca}(x,y)=\\operatorname{find}(y)\\)。至于为什么是这样，可以通过分类讨论得到。注意 \\(q\\) 需要像无向图一样，为单个查询存储双向边。 12345678910111213141516private static void tarjan(int x, List&lt;Integer&gt;[] g, boolean[] vis, UnionFind uf, List&lt;int[]&gt;[] q, int[] ans) { vis[x] = true; for (int y : g[x]) { if (!vis[y]) { tarjan(y, g, vis, uf, q, ans); uf.union(x, y); // 注意 f[y] = x } } for (int[] t : q[x]) { int y = t[0], i = t[1]; if (vis[y]) { ans[i] = uf.find(y); } }} 树链剖分 预处理时间复杂度为 \\(O(n)\\)，查询时间复杂度为 \\(O(\\log{n})\\)。 原理：将树划分为若干重链，树中的每条路径不会包含超过 \\(\\log{n}\\) 条不同的重链，所以查询的时间复杂度为 \\(O(\\log{n})\\)。第一次 DFS 得到每个节点的父节点，深度，以及根据子树大小得到每个节点的重子节点。第二次 DFS 通过优先遍历重子节点，再遍历轻子节点，从而得到每个节点所在重链的头节点。然后就可以进行查询，通过比较 \\(x,y\\) 所在重链的头节点，来向上跳跃，最终得到 \\(\\operatorname{lca}\\)。 1234567891011121314151617181920212223242526272829303132333435363738private static void dfs1(int x, int fa, List&lt;Integer&gt;[] g, int[] f, int[] d, int[] s, int[] h) { f[x] = fa; s[x] = 1; h[x] = -1; for (int y : g[x]) { if (y != fa) { d[y] = d[x] + 1; dfs1(y, x, g, f, d, s, h); s[x] += s[y]; if (h[x] == -1 || s[h[x]] &lt; s[y]) { h[x] = y; } } }}private static void dfs2(int x, int head, List&lt;Integer&gt;[] g, int[] f, int[] h, int[] t) { t[x] = head; if (h[x] == -1) { return; } dfs2(h[x], head, g, f, h, t); for (int y : g[x]) { if (y != f[x] &amp;&amp; y != h[x]) { dfs2(y, y, g, f, h, t); } }}private static int lca(int x, int y, int[] f, int[] d, int[] t) { while (t[x] != t[y]) { if (d[t[x]] &gt; d[t[y]]) { x = f[t[x]]; } else { y = f[t[y]]; } } return d[x] &lt; d[y] ? x : y;} 强连通分量 例题 P2863 [USACO06JAN] The Cow Prom S。 Tarjan 时间复杂度为 \\(O(n+m)\\)。 原理：\\(dfn[x]\\) 表示节点 \\(x\\) 的 DFS 编号；\\(low[x]\\) 表示节点 \\(x\\) 能够到达的节点的最小的 DFS 编号。我们将图看作一棵树，并定义四种边，那么强连通分量的根节点就是该分量中第一个被遍历到的节点，满足 \\(dfn[x]=low[x]\\)，所以，过程很复杂，难以描述，直接看 wiki 吧。（注意使用的时候，将 \\(dfn\\) 初始化为 \\(-1\\)，并且对所有节点调用该算法前，需要判断 \\(dfn=-1\\) 是否成立） 1234567891011121314151617181920212223242526private static int dfnCnt, sccCnt;private static void tarjan(int x, List&lt;Integer&gt;[] g, int[] dfn, int[] low, Deque&lt;Integer&gt; stk, boolean[] on, int[] scc, int[] size) { dfn[x] = low[x] = dfnCnt++; stk.push(x); on[x] = true; for (int y : g[x]) { if (dfn[y] == -1) { tarjan(y, g, dfn, low, stk, on, scc, size); low[x] = Math.min(low[x], low[y]); } else if (on[y]) { low[x] = Math.min(low[x], dfn[y]); } } if (dfn[x] == low[x]) { for (int y = -1; y != x; ) { y = stk.pop(); on[y] = false; scc[y] = sccCnt; size[sccCnt]++; } sccCnt++; }}","link":"/2023/10/31/%E5%9B%BE%E8%AE%BA/"},{"title":"Project #3 - Query Execution","text":"项目准备项目地址：Project #3 - Query Execution。 准备工作：阅读 Chapter 15 16 22，学习 Lecture #10 #11 #12 #13 #14，以及阅读课堂笔记。 项目结构通过查看 sqllogictest.cpp，可以知道 SQL 语句的整个执行流程。首先调用 SQLLogicTestParser::Parse 将测试文件解析为多个测试记录，然后根据记录的类型分别处理。目前我们主要关注查询语句，只需查看 BustubInstance::ExecuteSqlTxn 函数的代码。如项目介绍描述的那样，代码分别执行 Binder,Planner,Optimize,ExecutionEngine。然后，本来想详细分析一下整个流程，但是由于时间原因，以及项目确实比较复杂，所以暂时搁置。 Task #1 - Access Method Executors实现① 遇到第一个问题，如何在 SeqScanExecutor 中遍历表，可以发现 exec_ctx 成员所属的类 ExecutorContext 中有一个 GetCatalog 方法，只要拿到 Catalog 就可以根据 plan_ 中的信息拿到 TableHeap 的迭代器 TableIterator。然后第二个问题就是如何存储迭代器，TableIterator 是不可复制的，我们可以使用 unique_ptr 来存储迭代器，并使用 make_unique 初始化。（注意，不能在构造函数初始化，一定要在 Init 函数中初始化，不然多次全表扫描会出问题！） ② 实现 Insert 时报错 “The executor will produce a single tuple of integer type as the output, indicating how many rows have been inserted into the table”，并且可以看到 Next 函数的注释中表示 “tuple The integer tuple indicating the number of rows inserted into the table”。说实话有点难以理解，我一开始以为每次调用 Next 会像迭代器模式一样，只执行一次插入，但是这样实现就会报上面的错误。然后通过查看 Discord 的讨论，发现是一次性插入所有记录，因为只要返回 true 就会打印插入的行数，返回 false 就不会打印。当插入零行时，还必须打印一个零，这说明，Next 必定要先返回 true，再返回 false。并且在构造 tuple 时需要使用 BIGINT 类型，不然会报其他错误（明明注释说的是 INTEGER 额）。 ③ 在 Insert 的同时需要更新索引，一开始我是直接用普通的 tuple 作为 InsertEntry 的参数，结果在测试 p3.05-index-scan.slt 时报 stack buffer overflow 错误。通过 Debug 发现，在 InsertEntry 时会调用 GenericKey 类的 SetFromKey 函数，该函数会将 tuple 的数据拷贝到该类的 data_ 成员中，作为索引的 key 使用。所以传入的 tuple 必须只包含 key，那么如何确定 tuple 中的哪个数据是 key 呢。可以发现 Tuple 类中有 KeyFromTuple 函数，它的会生成只包含 key 的 tuple，因为需要的索引的 key，那么该函数必定需要传入和索引相关的模式，以及 key 所在列的下标，这些信息可以在 IndexInfo 中找到。（之前我有点迷糊，当成 MySQL 默认使用主键索引了，BusTub 使用的是 TableHeap，也就是说表默认是没有索引的） ④ 实现时不要使用 GetTableOid 函数，因为线上测试的函数名是 TableOid，可能是因为我 fork 的版本太新了，仓库的代码和测试代码不一样，所以只能直接使用 table_oid_ 成员。 ⑤ 实现 update 时要注意，在创建新 tuple 时，使用的是 child_executor_-&gt;GetOutputSchema()，而不是 GetOutputSchema()。 ⑥ 实现 index_scan 时，会使用到 b_plus_tree_index.h 中定义的别名，如 BPlusTreeIndexIteratorForTwoIntegerColumn。 ⑧ 在 IndexScan 的提示中有这么一句话，“do not emit tuples that are deleted”，但是当从表中删除 tuple 时，也会从索引中删除对应的 key，所以应该不会遍历到已经删除的 key 才对，也就是说此时应该不用特判 TupleMeta 中的 is_deleted_ 成员。 ⑨ 测试 p3.06-empty-table.slt 时，遇到 B+Tree 迭代器实现问题。当 B+Tree 的为 empty 时，获取迭代器我原来是抛出异常，现在改为返回一个默认构造的迭代器。 补充① 当没有显示声明复制/移动构造函数或复制/移动运算符，以及析构函数时，编译器才会隐式生成这些函数（其他更复杂的情况可以查看 cppreference.com）。 ② 创建 TupleMeta 时，会将 insertion_txn 和 deletion_txn_ 都初始化为 INVALID_TXN_ID，提示表示这些成员会在以后切换到 MVCC 存储时使用，有点遗憾没能体验一下。 ③ vector 的 reserve 只会影响 capacity 的大小，而不会影响 size，讨论在此。 ④ 重载前置和后置 ++ 的区别，前置 ++ 的重载声明为 operator++()，后置 ++ 的重载声明为 operator++(int)。 ⑤ 为什么应该将移动构造声明为 noexcept，可以阅读 Friendly reminder to mark your move constructors noexcept。 Task #2 - Aggregation &amp; Join Executors实现① 一开始实现真摸不着头脑，AggregationPlanNode 里面怎么这么多东西。group_bys 是指 GROUP BY 时对列的求值表达式，aggregates 是指使用聚合函数时对列的求值表达式，agg_types 是指聚合函数的类型。例如：GROUP BY DAY(col)、MIN(col1 + col2)。我们使用 InsertCombine 函数向哈希表插入值，参数可以使用 MakeAggregateKey 和 MakeAggregateValue 函数获得。 ② 根据项目介绍，AggregationExecutor::Next 返回的 tuple 应该包含 key 和 value（我没看到，找错好难）。特别需要注意，当哈希表为空时，应该返回什么：如果是对某列进行 GROUP BY 操作，那么就返回 false，因为有个测试用例有注释 no groups, no output；否则，返回 true，并且 tuple 存储聚合函数的默认值。（可以通过判断 key 模式的列数是否为零，或者 value 模式的列数是否等于 plan_ 输出模式的列数，来判断当前是否对某列进行 GROUP BY 操作） ③ 实现 NestedLoopJoinExecutor：外层循环遍历左表，内层循环遍历右表，只有当右表遍历完，才会获取下一个左表中的元组。但是，因为每找到一个匹配就会返回，所以我们应该将左表的元组作为数据成员，并且添加一个标志表示右表是否遍历完。每当右表遍历完成，都需要重置标志，获取左表中的下一个元组，并且重新 Init 右表。我们调用 EvaluateJoin 判断元组是否匹配，如果匹配，就将两个元组合并为一个元组。特别注意，如果当前是左连接，并且左元组没有匹配任何右元组，仍然需要返回一个为右元组填充 null 值的合并元组。比较迷惑的是怎么表示 null，我的想法是根据列类型获取对应的 null 值，但是找不到这样的函数，所以我就直接返回 BUSTUB_INT32_NULL 了。突然看到聚合执行器里用到 ValueFactory::GetNullValueByType 函数，太久没写项目给忘了。我还遇到一个 BUG，调试半天，发现我没有在 Init 函数中初始化 SeqScanExecutor 的迭代器，导致重复调用 Init 时不会重置迭代器。 ④ 实现 HashJoin：根据提示我们可以参考 SimpleAggregationHashTable 的实现建立一个哈希表，我们创建一个 JoinKey 类作为键，然后创建一个 hash&lt;bustub::JoinKey&gt; 类，直接复制 aggregation_plan.h 中的代码改个名字就行（不然 C++ 真不熟，又要搞半天）。在哈希表中，将 vector&lt;Tuple&gt; 作为值以处理哈希冲突。搞定哈希的方式之后，我们可以像 aggregation_executor.h 一样添加两个辅助函数 MakeLeftJoinKey 和 MakeRightJoinKey。然后直接在 Init 中对左表建立哈希表，在 Next 中遍历右表，类似 NestedLoopJoinExecutor 的实现，只不过此时需要维护更多的数据成员。特别需要注意如何处理左连接，因为我们是将左表建为哈希表，那么在遍历完右表后，还需要处理没有任何匹配的左表中的元组。这可以在匹配时将元组的地址存储在 unordered_set 中，然后在遍历完右表后再遍历一次左表，并检查 unordered_set 来判断是否输出。（之前我是将元组的 RID 存储到集合中作为标识，但是这是错误的，因为左表可能是临时表，其中元组的 RID 是无效的内容；我们也可以为右表建立哈希表而不是左表，这样对于左连接来说，更好处理） ⑤ 实现 Optimizing NestedLoopJoin to HashJoin：非常的神奇，参考 nlj_as_index_join.cpp 瞎改，感觉代码是一坨，但是竟然没有任何错误，直接通过测试（激动半天）。具体实现的话，一开始我以为传入的参数就是 NestedLoopJoin 计划节点，但是似乎不是，所以我们需要遍历当前计划的子节点，递归的进行优化。之前比较令我迷惑的一点，怎么判断表达式是否是某个类型，我查找很久 API 都没有找到类似的函数，然后想到 Project #0 中好像是直接做 dynamic_cast 转换，如果返回值为 nullptr 就表示类型不匹配，查看 nlj_as_index_join.cpp 发现果然是这样。搞定表达式类型判断之后，就可以根据 ColumnValueExpression::GetTupleIdx 值来交换左右表达式，并返回转换后的节点。 Task #3 - Sort + Limit Executors and Top-N OptimizationEasy！只有两点需要注意：一个是每次调用 Init 时都要初始化所有数据成员，不然下次调用会包含上次调用的数据；第二个是 C++ 的 priority_queue 默认是大顶堆，并且比较器和 Java 中的用法完全相反。 Optional Leaderboard Tasks① 初次提交。 ② 之后优化。 Rank Submission Name Q1 Q2 Q3 Time 123 ALEX 740 30000 4839 4754 测试结果 123456789101112131415161718192021222324252627282930#!/bin/bashmake sqllogictest -j$(nproc)./bin/bustub-sqllogictest ../test/sql/p3.00-primer.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.01-seqscan.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.02-insert.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.04-delete.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.03-update.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.05-index-scan.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.06-empty-table.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.07-simple-agg.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.08-group-agg-1.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.09-group-agg-2.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.10-simple-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.11-multi-way-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.12-repeat-execute.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.14-hash-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.15-multi-way-hash-join.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.16-sort-limit.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.17-topn.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.18-integration-1.slt --verbose./bin/bustub-sqllogictest ../test/sql/p3.19-integration-2.slt --verbosemake formatmake check-lintmake check-clang-tidy-p3make submit-p3 项目小结项目难度主要在项目理解上，常常是不理解某些变量的实际含义，或者知道该怎么做，却找不到对应的 API，或者对返回值理解有错误，而函数文档也不清晰。最后，看到实现的代码能够执行各种 SQL 语句，感觉还是很不错的。","link":"/2023/11/03/Project%203%20-%20Query%20Execution/"},{"title":"2023 OceanBase 数据库大赛","text":"比赛信息 大赛报名。 MiniOB-2023 赛题。 2023 OceanBase 数据库大赛FAQ。 使用 Docker 搭建开发环境 启动报错 Docker Desktop - Unexpected WSL error，搜索半天解决方案，结果是没开 Windows Hypervisor Platform，解决方案在此。 如何在 CLion 中使用 Docker。 遇到 CLion 的 Bug，在 CLion 内置的 Docker 终端无法进行输入，我们直接使用 Docker 客户端打开终端。 终端使用上下左右方向键显示奇怪的编码，似乎是因为默认使用的是 shell，它不支持方向键，我们可以使用 bash 来解决问题，解决方案。 使用 build 构建项目时，报错 $'\\r': command not found，这是 Windows 的换行符和 Linux 不同导致的。为了避免在 clone 时进行换行符的转换，可以添加 autocrlf=false 到全局配置文件，或者可以在克隆的命令中添加该参数，更多详细的设置方法可以参考 GitHub 文档。","link":"/2023/11/03/2023%20OceanBase%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E8%B5%9B/"},{"title":"Educational Codeforces Round 157 (Rated for Div. 2)","text":"Treasure Chest至少走 \\(\\max(x,y)\\) 步，因为最多能扛起箱子 \\(k\\) 秒，所以会往回走 \\(\\max(0,y-x-k)\\) 步。 1234public static void solve() { int x = io.nextInt(), y = io.nextInt(), k = io.nextInt(); io.println(Math.max(x, y) + Math.max(0, y - x - k));} Points and Minimum Distance排序，然后将数组分为左右两部分，分别代表 \\(x,y\\) 坐标序列。可以证明，这是最优的。 12345678910111213public static void solve() { int n = io.nextInt(); int[] a = new int[2 * n]; for (int i = 0; i &lt; 2 * n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); io.println(a[n - 1] - a[0] + a[2 * n - 1] - a[n]); for (int i = 0; i &lt; n; i++) { io.println(a[i] + &quot; &quot; + a[i + n]); }} Torn Lucky Ticket对于每个字符串 \\(s_{i}\\)，我们枚举合并字符串的中心位置，这样就可以知道需要在前缀或后缀补上长度以及总和为多少的字符串，使得合并字符串为幸运的。因为合并字符串的中心位置可能不在当前字符串上，所以我们按照长度从小到大处理字符串，这样可以保证不漏掉任何情况。特别的，每个字符串都可以和自身连接成为幸运串。或者也可以进行预处理，这样就不用排序。 12345678910111213141516171819202122232425public static void solve() { int n = io.nextInt(); char[][] arr = new char[n][]; for (int i = 0; i &lt; n; i++) { arr[i] = io.next().toCharArray(); } Arrays.sort(arr, (s1, s2) -&gt; s1.length - s2.length); long ans = 0L; int[][] dp = new int[6][46]; for (char[] s : arr) { int m = s.length; int[] sum = new int[m + 1]; for (int j = 0; j &lt; m; j++) { sum[j + 1] = sum[j] + s[j] - '0'; } for (int j = m / 2 + 1; j &lt;= m; j++) { ans += dp[2 * j - m][Math.max(0, 2 * sum[j] - sum[m])]; ans += dp[2 * j - m][Math.max(0, sum[m] - 2 * sum[m - j])]; } dp[m][sum[m]]++; } io.println(ans + n);} XOR Construction首先构造满足第二个条件的数组 \\(b\\)，我们让 \\(b_{n}=0\\)，然后前面的每个元素 \\(b_{i}=a_{i}\\oplus a_{i+1}\\oplus\\cdots\\oplus a_{n-1}\\)，这样就得到满足第二个条件的数组，可以通过后缀异或得到。那么如何让 \\(b\\) 包含从 \\(0\\) 到 \\(n-1\\) 的每个数，因为数据保证总是可以构造出这样的序列，也就是说我们得到的数组 \\(b\\) 异或某个数，就能够得到目标数组。单独考虑每一位是否需要异或，可以发现，如果该位 \\(1\\) 的数量大于 \\(0\\) 的数量就需要进行异或操作。 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n - 1; i++) { a[i] = io.nextInt(); } for (int i = n - 2; i &gt;= 0; i--) { a[i] = a[i] ^ a[i + 1]; } int[] d = new int[30]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 30; j++) { d[j] += a[i] &gt;&gt; j &amp; 1; } } int mask = 0; for (int i = 0; i &lt; 30; i++) { if (d[i] &gt; n - d[i]) { mask |= 1 &lt;&lt; i; } } for (int i = 0; i &lt; n; i++) { io.print((a[i] ^ mask) + &quot; &quot;); } io.println();}","link":"/2023/11/04/Educational%20Codeforces%20Round%20157%20(Rated%20for%20Div.%202)/"},{"title":"第 370 场力扣周赛","text":"找到冠军 I如果某一列全为 \\(0\\)，则该列表示的队伍会成为冠军。 123456789101112131415class Solution { public int findChampion(int[][] grid) { int n = grid.length; for (int j = 0; j &lt; n; j++) { int cnt = 0; for (int i = 0; i &lt; n &amp;&amp; cnt == 0; i++) { cnt += grid[i][j]; } if (cnt == 0) { return j; } } return -1; }} 找到冠军 II相当于判断入度为 \\(0\\) 的节点是否只有一个。 12345678910111213141516class Solution { public int findChampion(int n, int[][] edges) { int[] in = new int[n]; for (var e : edges) { in[e[1]]++; } int ans = -1; for (int i = 0; i &lt; n; i++) { if (in[i] == 0) { if (ans == -1) ans = i; else return -1; } } return ans; }} 在树上执行操作以后得到的最大分数树形 DP，要求最大分数，可以先求损失的最小分数，然后使用总分减去该分数即可。 123456789101112131415161718192021222324252627282930class Solution { public long maximumScoreAfterOperations(int[][] edges, int[] values) { int n = values.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } long ans = 0L; for (int x : values) { ans += x; } return ans - dfs(0, -1, g, values); } private long dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] values) { if (g[x].size() == 1 &amp;&amp; g[x].get(0) == fa) { return values[x]; } long res = 0L; for (int y : g[x]) { if (y != fa) { res += dfs(y, x, g, values); } } return Math.min(res, values[x]); }} 也可以直接正向做，对于每个节点有两种情况：选择当前节点，要求该节点的每个子树都是健康的；不选当前节点，该节点的所有子节点都可以选。 123456789101112131415161718192021222324252627282930class Solution { public long maximumScoreAfterOperations(int[][] edges, int[] values) { int n = values.length; List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (var e : edges) { int u = e[0], v = e[1]; g[u].add(v); g[v].add(u); } long[] sum = new long[n]; return dfs(0, -1, g, values, sum); } private long dfs(int x, int fa, List&lt;Integer&gt;[] g, int[] values, long[] sum) { sum[x] = values[x]; if (g[x].size() == 1 &amp;&amp; g[x].get(0) == fa) { return 0; } long dp0 = values[x], dp1 = 0; for (int y : g[x]) { if (y != fa) { dp0 += dfs(y, x, g, values, sum); dp1 += sum[y]; } } sum[x] += dp1; return Math.max(dp0, dp1); }} 平衡子序列的最大和离散化 + 树状数组优化 DP，直接看灵神代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 作者：灵茶山艾府// 链接：https://leetcode.cn/problems/maximum-balanced-subsequence-sum/solutions/2513121/shu-zhuang-shu-zu-you-hua-dp-by-endlessc-3zf4/class Solution { public long maxBalancedSubsequenceSum(int[] nums) { int n = nums.length; int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = nums[i] - i; } Arrays.sort(b); BIT t = new BIT(b.length + 1); for (int i = 0; i &lt; n; i++) { // j 为 nums[i]-i 离散化后的值（从 1 开始） int j = Arrays.binarySearch(b, nums[i] - i) + 1; long f = Math.max(t.preMax(j), 0) + nums[i]; t.update(j, f); } return t.preMax(b.length); }}// 树状数组模板（维护前缀最大值）class BIT { private long[] tree; public BIT(int n) { tree = new long[n]; Arrays.fill(tree, Long.MIN_VALUE); } public void update(int i, long val) { while (i &lt; tree.length) { tree[i] = Math.max(tree[i], val); i += i &amp; -i; } } public long preMax(int i) { long res = Long.MIN_VALUE; while (i &gt; 0) { res = Math.max(res, tree[i]); i &amp;= i - 1; } return res; }}","link":"/2023/11/07/%E7%AC%AC%20370%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 908 (Div. 2)","text":"Secret Sport因为题目保证存在合法的 \\(X\\) 和 \\(Y\\)，那么获胜者总是最后一个下棋者，因为如果不是最后一个，那么对局就不会结束。 12345public static void solve() { int n = io.nextInt(); String s = io.next(); io.println(s.charAt(n - 1));} Two Out of Three对于一组相同元素，它只能满足一个条件，如果满足两个条件，那么它必定会满足三个条件。所以至少要有两组出现次数大于等于 \\(2\\) 的元素，然后分别让其满足一个条件即可。 1234567891011121314151617181920212223242526public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } int k = 2; int[] b = new int[n]; Arrays.fill(b, 1); int[] cnt = new int[101]; for (int i = 0; i &lt; n &amp;&amp; k &lt;= 3; i++) { if (++cnt[a[i]] == 2) { b[i] = k++; } } if (k &lt;= 3) { io.println(-1); return; } for (int i = 0; i &lt; n; i++) { io.print(b[i] + &quot; &quot;); } io.println();} Anonymous Informant如果当前数组是通过移动得到，那么它的最后一个元素必定是由定点元素转移过来，所以我们只需要判断最后一个元素是否在 \\([1,n]\\) 范围内，然后不断地回滚左移操作，即不断地找到移动之前的最后一个元素位置，并进行判断即可。 123456789101112131415public static void solve() { int n = io.nextInt(), k = io.nextInt(); int[] b = new int[n]; for (int i = 0; i &lt; n; i++) { b[i] = io.nextInt() - 1; } int i = n - 1; while (b[i] != -1 &amp;&amp; b[i] &lt; n &amp;&amp; --k &gt; 0) { int j = (i - (b[i] + 1) + n) % n; b[i] = -1; i = j; } io.println(k == 0 || b[i] == -1 ? &quot;Yes&quot; : &quot;No&quot;);} Neutral Tonality我们总是可以构造一个数组 \\(c\\)，使得 \\(\\operatorname{LIS}(c)=\\operatorname{LIS}(a)\\)，方法为将数组 \\(b\\) 中的元素 \\(b_{i}\\)，插入到数组 \\(a\\) 中第一个满足 \\(a_{j}\\leq b_{i}\\) 的元素 \\(a_{j}\\) 之前，操作方式类似归并排序。 12345678910111213141516171819202122232425262728293031public static void solve() { int n = io.nextInt(), m = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } var b = new Integer[m]; for (int i = 0; i &lt; m; i++) { b[i] = io.nextInt(); } Arrays.sort(b, ((e1, e2) -&gt; e2 - e1)); int i = 0, j = 0, k = 0; int[] ans = new int[n + m]; while (i &lt; n || j &lt; m) { if (i &gt;= n) { ans[k++] = b[j++]; } else if (j &gt;= m) { ans[k++] = a[i++]; } else if (a[i] &lt;= b[j]) { ans[k++] = b[j++]; } else { ans[k++] = a[i++]; } } for (int x : ans) { io.print(x + &quot; &quot;); } io.println();}","link":"/2023/11/08/Codeforces%20Round%20908%20(Div.%202)/"},{"title":"Project #4 - Concurrency Control","text":"项目准备项目地址：Project #4 - Concurrency Control。 准备工作：阅读 Chapter 18 19，学习 Lecture #15 #16 #17 #18 #19 #20，以及阅读课堂笔记。 项目结构项目的注释中有锁升级的矩阵图，但是没有兼容性的矩阵图，这里贴一下。 Task #1 - Lock Manager实现① 比较关键的一个问题是，LockRequestQueue 里面存什么。我之前漏掉 granted_ 成员，导致整个项目理解都有问题。一个请求会经历未获取锁、已获取锁，已释放锁三个过程，LockRequestQueue 存储所有没有被释放的锁请求，即前两个过程。因为之后能否获取锁，需要和之前已经获取的锁做兼容性判断。 ② 加锁阶段： 代码组织：我们可以根据请求的锁模式来分类讨论，也可以根据事务的锁模式来分类讨论，也可以根据事务是否有锁进行分类讨论。我最后是选择最后一种方式，这样写起来真的简洁。如果当前事务没有该资源的锁，则将请求入队，并且根据该资源是否被其他事务上锁，从而直接拿锁或者进行等待；否则，判断能否进行锁升级。 锁升级： 根据提示，首先判断请求的锁模式是否和事务的锁模式是否相同，如果相同则直接返回 true。我在这里有个比较疑惑的点，如果请求锁模式的级别低于当前持有的锁模式，应该也可以直接返回 true，但是注释中并没有提及，并且线上测试结果告诉我不行，必须抛出异常。似乎是设计的问题，讨论在此，而且这个讨论似乎说的也不完整。 然后判断是否可以锁升级，如果可以，我们需要释放之前的锁，并等待获取升级的锁。这两个步骤可以通过修改队列中的 LockRequest 实现，将锁模式修改为新的锁模式，将 granted_ 修改为 false，然后 cv_.wait() 即可。关键是条件变量的获取锁的条件如何编写。注意，一定要在等待之前从当前事务的锁集中移除原来的锁，因为线上测试会在等待时检查锁集。 获取锁：如何以 FIFO 的方式获取锁，并且使兼容的锁可以同时获取，以及使锁升级的优先级最高。遍历请求队列，如果当前事务是锁升级请求，则只需判断当前请求是否和已 granted_ 的请求兼容。如果当前事务不是锁升级请求，并且存在其他事务的锁升级请求，则直接返回 false，否则不仅需要判断当前请求是否和已 granted_ 的请求兼容，还需要判断当前请求是否和在该请求之前的未 granted_ 的请求兼容。 ③ 解锁阶段：按照注释模拟，需要注意从队列中移除完成的锁请求，并在最后执行 cv_.notify_all()。 ④ 事务的 ABORTED 状态：如果事务被中止，那么应该取消该事务所做的操作，事务中止之后会自动调用 TransactionManager::Abort 函数来进行解锁和还原所有写操作。但是如果事务在等待锁的过程中被中止，那么就需要我们手动重置，因为 Abort 函数不会清除未获取锁的请求。步骤如下：在使用条件变量时，额外判断当前事务的状态是否是 ABORTED，如果是则直接退出等待，并从队列中移除该请求，如果是锁升级还要记得重置 upgrading_，最后调用 cv_.notify_all() 并返回 false。 补充① 一个细节问题，在获取 map 中的 LockRequestQueue 时，我依赖 C++ 在使用 [] 访问会自动创建对象的特性，没有注意到 map 中存的是智能指针，这样默认是创建空指针，结果就会报各种奇怪的错误。 ② 表解锁同样需要改变事务的状态，一开始我天真的以为只需要在行解锁的时候改变就行，因为我以为加表锁必定会加行锁，但是不是这样的，可以只加表锁（或许全表扫描就是只加表锁而不加行锁）。 ③ 线上测试遇到神奇的错误，pthread_mutex_lock.c:94: _pthread_mutex_lock: Assertion ‘mutex-&gt;data.__owner == 0’ failed，而且不是每次测试都会发生。经过排查，发现又是自动补全的锅，导致重复执行 unlock() 操作，有关该错误的讨论在此。 ④ 目前似乎不需要使用事务锁，单个事务加锁/解锁是单线程的。 Task #2 - Deadlock Detection① 构建等待图，使用二重循环遍历 table_lock_map_ 和 row_lock_map_ 来向 waits_for_ 添加从 granted_ == false 请求到 granted_ == true 请求的边。其实这样单纯的加边是比较简单的，但是可能存在锁兼容的情况，这样构成的环是不会造成死锁的，导致误杀事务，不过测试能过就不改代码了。记得加锁。 ② 因为可以存在很多环，如果检测顺序不一样，中止的事务可能完全不同，所以 NOTES 中要求我们从最小的事务开始做 DFS，按照从小到大的顺序遍历相邻节点，如果找到环，则中止环中最大的事务。如果事务被中止，则应该从图中删掉连接该事务的边，或者也可以打标记。有坑！！！HasCycle 应该包含什么代码，之前我是把最小事务编号作为参数传递，然后从该事务开始做 DFS 来检测环。但是线上 GraphTest 测试会调用 HasCycle，按照线上测试代码的逻辑，HashCycle 应该包含整个环检测代码，包括排序 waits_for_，排序 GetEdgeList 得到的边集，以及 DFS。特别注意，不要在 HashCycle 中调用 txn_manager_ 的任何方法，因为 GraphTest 测试根本就没创建事务！！！我是调试半天找不到错，才反应过来，非常无语。 ③ 最后，从 HasCycle 返回时，删除中止事务的边，然后调用 TransactionManager::Abort 函数中止事务。在消除所有环之后清空 waits_for_。 Task #3 - Concurrent Query Execution① 非常非常无语！！！就是我在 Task#1 中提到的，高级锁可以包含低级锁的需求，不应该抛出异常，结果测试不给过，Task#3 又需要我兼容这种情况，那么只能在 Executor 代码中特判了。 ② 根据提示，should not acquire S/X table lock, grab IS/IX instead，只为表加 IS/IX 锁。 ③ 细节问题：行加锁之后再判断行是否删除，这个错误找很长时间才发现；死锁检测在调用 Abort 函数之前，先将事务状态设置为 ABORTED，否则当前事务可能会在之后的解锁过程中被唤醒，触发 LOCK_ON_SHRINKING 异常；实现 Abort 函数时，将恢复阶段放在解锁阶段之前，不然可能会有并发问题。 Leaderboard Task (Optional)① 初次提交。 Rank Submission Name Update QPS Count QPS Weighted QPS 59 ALEX 14 14 14 测试结果 12345678910111213#!/bin/bashmake lock_manager_test -j$(nproc)make deadlock_detection_test -j`nproc`make txn_integration_test -j`nproc`make -j`nproc` terrier-bench ./test/lock_manager_test./test/deadlock_detection_test./test/txn_integration_test./bin/bustub-terrier-bench --duration 30000make formatmake check-lintmake check-clang-tidy-p4make submit-p4 项目小结难点就在项目理解以及代码细节上，Task#1 和 Task#2 被队列和 HashCycle 的理解整晕了，然后要使代码能够在多线程情况下正常运行，一定要注意代码中逻辑的先后顺序！！！实现过程部分参考做个数据库：2022 CMU15-445 Project4 Concurrency Control，Task#1 的解释帮助很大。","link":"/2023/11/14/Project%204%20-%20Concurrency%20Control/"},{"title":"第 371 场力扣周赛","text":"找出强数对的最大异或值 I暴力。 高访问员工模拟。 最大化数组末位元素的最少操作次数两种情况，分类讨论。 找出强数对的最大异或值 II要找满足 \\(\\mid x-y\\mid\\leq\\min(x,y)\\) 的数对，可以排序化简公式，得到 \\(x\\leq y\\leq2x\\)。然后我们可以使用双指针，枚举 \\(y\\) 或者 \\(x\\) 都行，基本上就是把满足条件的数添加到 0-1 trie 树中，把不满足条件的从树中删除，一边枚举一边计算最大异或值。还可以使用哈希表做，参考灵茶山艾府的题解。","link":"/2023/11/14/%E7%AC%AC%20371%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"CUM 15-445 课程总结","text":"幻灯片和笔记，其他同学整理的笔记，Discord 讨论，dbdb.io。 本来想做个课程总结和项目总结的，但是有点没心情做，排行榜优化也暂时搁置吧。:( 更新：还是做一下总结，课程的内容不只下面这些，有很多内容对我来说可能用不到，所以没有记录。 Advanced SQL 查询满足某个条件的记录数量： 12SELECT COUNT(*) FROM t WHERE xx;SELECT SUM(IF(xx, 1, 0)) FROM t; 查询满足某个条件的记录百分率： 1SELECT ROUND(AVG(IFNULL(xx, 0)), 2) FROM t; 窗口函数（文档：12.20 Window Functions）： 12SELECT ROW_NUMBER() OVER(PARTITION BY xx ORDER BY xx) FROM t;SELECT AVG(xx) OVER (PARTITION BY xx ORDER BY xx ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) 日期和时间函数（文档：12.7 Date and Time Functions）： 12SELECT DATE_FORMAT(xx, xx);SELECT DATEDIFF(xx, xx); Database Storage 课程主要介绍面向磁盘的 DBMS，数据库以文件的形式存储在磁盘上，文件以特定于 DBMS 的方式编码，它被表示为页面的集合，每个页面都会有一个唯一标识符（页面 ID），大多数 DBMS 使用哈希表将页面 ID 映射为文件路径和文件内的偏移量。注意区分硬件页面（通常为 4 KB）、操作系统页面（4 KB）和数据库页面（1-16 KB）。存储设备可以保证硬件页面的原子写入，如果数据库页面大于硬件页面，则 DBMS 需要采取额外的措施来保证原子性。 每个页面被分为两部分：页面头部和页面内容。页面头部用于记录有关页面内容的元数据，包括页面大小、校验和、DBMS 版本、事务可见性和自包含（Self-containment）等。页面内容有两种主要的数据布局方式：slotted-pages 和 log-structured。 Storage Models &amp; Compression 三种工作负载：OLTP（在线事务处理），OLAP（在线分析处理），HTAP（混合事务和分析处理）。 两种存储模型：行式存储和列式存储。 Memory Management 缓冲池实际上是一个页面数组，用于缓存磁盘中的页面，为了区分缓冲池页面和磁盘页面，我们将缓冲池页面称为帧（frame）。当 DBMS 请求一个页面时，存储管理器会首先搜索缓冲池，如果页面不在缓冲池中，就将该页面从磁盘复制到空闲的帧中。（有关缓冲池的详细信息可以参考 Project #1） 缓冲池优化方式： 多缓冲池：可以为不同数据库或不同页面类型提供不同的缓冲池，这样可以根据其中的数据定制优化策略。 预取：可以根据查询计划预取页面，通常在顺序访问页面时进行该优化。 扫描共享（同步扫描）：当多个查询扫描的数据存储重叠时，重叠部分可以只进行一次扫描。 缓冲池绕过：顺序扫描或临时数据处理不会将页面存储在缓冲池中，而是为其单独开一块内存，以避免缓冲池污染，因为这些页面通常不会再被访问。 大部分数据库使用直接 I/O 绕过操作系统缓存，以避免多余的页面缓存（Postgres 除外）。 Hash Tables 哈希表的实现由两部分组成： 哈希函数：需要在计算速度和冲突率之间进行权衡。 哈希模式：发生冲突时如何处理。（静态哈希和动态哈希） Trees Indexes 索引的数量越多，查询的速度就越快，但是索引占用的存储空间以及维护成本也会随之提高。 B+ 树是一种平衡查找树，它保持数据有序，并且支持 \\(O(\\log{n})\\) 的查询、插入和删除操作。B+ 树平衡的关键在于，它要求所有节点都至少是半满的。B 树在所有节点中存储值，而 B+ 树只在叶子节点中存储值。B+ 树相比哈希表的优势在于可以进行范围查询以及模糊查询。（有关 B+ 树的详细信息可以参考 Project #2） Index Concurrency Control 区分 Lock 和 Latch： Lock：高级原语，作用是保护数据库的内容（元组、表和数据库），在事务中使用。 Latch：低级原语，作用是保护数据库的内部数据结构，在临界区中使用。 实现 Latch 的底层原语是比较并交换（CAS）原子指令。有多种不同类型的 Latch 可供 DBMS 使用： Blocking OS Mutex：使用操作系统内置的互斥锁基础设施，Linux 提供 futex（fast user-space mutex），它由用户空间的自旋锁和操作系统级别的互斥锁组成。示例 std::mutex，优点是使用简单，缺点是加锁/解锁的时间成本较高并且不可扩展（如果发生竞争，则当前线程会被操作系统阻塞）。 Test-and-Set Spin Latch（TAS）：自旋锁具有更高的灵活性，DBMS 可以控制当存在竞争时应该执行什么操作。示例 std::atomic&lt;T&gt;，优点是加锁/解锁更快，缺点是在竞争比较激烈时，会浪费很多 CPU 资源。 Reader-Writer Latches：示例 std::shared_mutex，优点是可以并发读取，缺点是需要额外的空间存储读/写队列。 B+ 树使用蟹行协议（Latch Crabbing Protocol）来保证自上而下的加锁顺序，当线程的访问模式不包含叶节点扫描时，该实现方式可以避免死锁。因为索引锁不支持死锁检测或避免（疑问：这里的描述和幻灯片第 23 页的内容不太一样），所以叶节点扫描在获取同级锁时遵循无等待模式，即如果获取同级锁失败就立即重启操作。 Sorting &amp; Aggregations Algorithms 排序可能被用在 ORDER BY、GROUP BY、JOIN 和 DISTINCT 操作中。如果数据能够放入内存，则可以使用快速排序（当查询包含 LIMIT 和 ORDER BY 时，可以使用堆排序），否则使用外部归并排序。 外部归并排序由两部分组成： 排序：将数据分为多个可以放入内存的数据块，分别进行排序，然后将排序后的数据写回磁盘。 合并：将排序后的数据块合并。 外部归并排序的 I/O 成本分析： 假设 \\(N\\) 为数据页面的个数，\\(B\\) 为可以使用的缓冲区页面的个数。 在排序阶段，每次可以读取 \\(B\\) 个数据页面到缓冲区，进行排序之后写回磁盘，总共执行 \\(\\lceil \\frac{N}{B}\\rceil\\) 次排序，I/O 成本为 \\(2N\\)（读入缓冲区和写回磁盘各一次）。 在合并阶段，可以使用 \\(B-1\\) 个缓冲区页面存储 \\(B-1\\) 个数据块的第一个页面，剩下一个缓冲区页面存储合并的结果并根据需要写回磁盘，如果将合并的过程看作多叉树，则树的高度为 \\(\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil\\)，每层合并都会将所有数据读写一次，I/O 成本为 \\(2N\\times\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil\\)。 最后，总 I/O 成本为 \\(2N\\times(1+\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil)\\)。 外部归并排序可以使用双缓冲区优化，前台缓冲区进行计算的同时，后台缓冲区预取数据。如果数据在排序键上存在 B+ 树聚集索引，那么可以直接遍历索引得到有序数据。因为，如果是聚集索引，数据访问将是顺序 I/O，成本为 \\(N\\)；如果是非聚集索引，数据访问将是随机 I/O，成本为 \\(N\\times M\\)，其中 \\(M\\) 为每页中的记录个数（缓冲区大小有限，随机 I/O 会导致页面抖动）。 聚合操作有两种实现方式： 排序：首先将数据按照聚合键进行排序，然后对有序数据执行顺序扫描来计算聚合值。 哈希：除非数据已经有序，否则哈希总是比排序更高效。由于内存可能容纳不下整个哈希表，为了避免随机 I/O，肯定不能将哈希表直接溢出到磁盘。我们可以首先进行一次哈希，将数据分区，然后对每个分区单独进行聚合操作，这样每个分区的哈希表大小应该会足够小，最好情况是能放入内存中。 Joins Algorithms 连接操作有两种输出模式： 提前物化（early materialization）：将外表和内表的所有属性都放入临时表。 延迟物化（late materialization）：只将连接键以及外表和内表的记录 ID 放入临时表。 连接算法的 I/O 成本分析（假设连接是等值连接）： 假设外表 \\(R\\) 有 \\(M\\) 页，总共包含 \\(m\\) 个元组；内表 \\(S\\) 有 \\(N\\) 页，总共包含 \\(n\\) 个元组。 Nested Loop Join： 该算法由两个嵌套的 for 循环组成，外层循环遍历外表，内层循环遍历内表，如果两个元组满足连接谓词，则将它们连接并输出。注意，我们总是应该使用较小的表作为外表，因为。 Naive Nested Loop Join：对于外表的每个元组，将其和内表中的每个元组进行比较，I/O 成本为 \\(M+(m\\times N)\\)。 Block Nested Loop Join：对于外表的每个块，将其和内表中的每个元组进行比较。假设有 \\(B\\) 个可用的缓冲区，该算法可以使用 \\(B-2\\) 个缓冲区扫描外表，\\(1\\) 个缓冲区扫描内表，\\(1\\) 个缓冲区存储连接结果，I/O 成本为 \\(M+(\\lceil \\frac{M}{B-2}\\rceil\\times N)\\)。 Index Nested Loop Join：如果内表在连接键上建有索引（或者临时建立索引），那么可以直接使用索引搜索到满足条件的元组，I/O 成本为 \\(M+(m\\times C)\\)，其中 \\(C\\) 为单次索引搜索的成本。 Sort-Merge Join： 首先对外表和内表进行排序，然后使用双指针分别遍历外表和内表，来进行连接谓词判断。如果内表的连接键有重复值，那么内表指针在匹配时可能需要回退。当外表或内表已经有序，或者输出结果要求按照连接键排序时，可以选择使用该算法。 排序成本：外表为 \\(2M\\times(1+\\lceil\\log_{B-1}{\\lceil \\frac{M}{B}\\rceil}\\rceil)\\)，内表为 \\(2N\\times(1+\\lceil\\log_{B-1}{\\lceil \\frac{N}{B}\\rceil}\\rceil)\\)。 合并成本：最坏情况下，两个表中的所有元组的连接键都相等，合并的成本为 \\(MN\\)。一般情况下，连接键大多是唯一的，合并成本为 \\(M+N\\)。 Hash Join： Basic Hash Join：首先将外表的连接键作为 key 构建哈希表，将外表的元组或者元组 ID 作为 value。然后对于内表中的每个元组，可以直接通过哈希表获取匹配的元组。由于可能存在哈希冲突，即使元组被哈希到某个桶，在桶内肯定还需要进行比较来判断元组是否真的匹配，这里我们可以额外使用布隆过滤器来过滤元组，以减少磁盘 I/O。 Grace Hash Join / Partitioned Hash Join：当哈希表无法放入内存时，Basic Hash Join 存在页面抖动问题，解决该问题的方法是进行分区。首先分别对外表和内表构建哈希表，并根据需要写入磁盘，如果单个桶都无法放入内存，则递归的进行分区（前提是桶内的键存在不同，否则会导致无限递归），I/O 成本为 \\(2\\times(M+N)\\)。然后将外表和内表对应的桶进行嵌套循环连接，此时页面都可以放入内存，I/O 成本为 \\(M+N\\)。 假设 \\(M=10^{3}\\)，\\(m=10^{5}\\)，\\(N=5\\times 10^{2}\\)，\\(n=4\\times 10^{4}\\)，\\(B=100\\)，每页的 I/O 花费 \\(0.1\\) 毫秒，各个算法花费的时间如下： Algorithm I/O Cost Example Naive Nested Loop Join \\(M+(m\\times N)\\) 1.4 hours Block Nested Loop Join \\(M+(M\\times N)\\) 50 seconds Index Nested Loop Join \\(M+(m\\times C)\\) Varies Sort-Merge Join \\(M+N+(sort cost)\\) 0.75 seconds Hash Join \\(3\\times(M+N)\\) 0.45 seconds 该表是课程笔记上的，但是有点疑问，Block Nested Loop Join 的 I/O 成本计算公式有问题吧，如果按照之前说的公式计算，I/O 花费的时间是 \\(0.65\\) 秒。 Query Execution DBMS 将 SQL 语句转化为查询计划，查询计划由操作符构成的树表示，数据从叶子节点流向根节点，根节点的输出就是查询的结果。处理模型（processing model）定义系统如何执行查询计划，下面介绍三种处理模型： 迭代器模型/火山模型（Iterator Model）：每个操作符都会实现 Next 函数，该函数由其父节点调用，以获取子节点的输出元组。因为每次调用只会返回单个元组，所以 Next 函数的调用一般放在循环中。调用从根节点传递到叶子节点，数据从叶子节点通过层层处理返回至根节点（实际上就是一个递归的过程，有点像树的后序遍历）。该模型允许以流水线的方式处理元组，有些操作符需要其子节点传递所有元组才能进行计算，包括哈希连接、子查询和排序等，这些操作符被称为流水线破坏者（pipeline breakers）。 物化模型（Materialization Model）：每个操作符都会实现 Output 函数，该函数会返回所有元组。该模型相比迭代器模型可以减少函数的调用次数，适合 OLTP 工作负载，因为其单词查询访问的数据量不大，而 OLAP 工作负载会查询大量数据，操作符的返回结果将会溢出到磁盘，从而增加 I/O 成本。 向量模型（Vectorization Model）：类似迭代器模型，区别在于每次调用 Next 会返回一批元组（即向量）。该模型适合访问大量数据的 OLAP 工作负载，相比迭代器模型，它可以减少函数调用的次数，还可以允许使用 SIMD 指令成批的处理元组。 PS：这些模型实际上是很简单的东西，无非就是返回的数据量不同，写这么多是不是有点浪费笔墨，额。这让我想起之前的一个感想，有些术语看上去很难懂，但是它们的本质其实非常简单，所以有些东西真的是增加学习难度。如无必要，勿增实体，不知道放在这合不合适。 Query Planning &amp; Optimization 应用程序连接到数据库并发送 SQL 查询，该查询可以被重写为不同的形式，然后查询被解析为抽象语法树，绑定器通过查看系统目录，将语法树中的命名对象替换为内部标识，并生成逻辑计划，该逻辑计划同样可以被重写，之后优化器使用成本模型进行估计，将逻辑计划转化为物理计划。 逻辑计划和物理计划的区别：逻辑计划只描述了抽象的关系代数表达式，物理计划将抽象的表达式对应到某个具体实现，例如连接运算符有多种不同实现。逻辑计划和物理计划并不总是一一对应的。 查询优化有启发式优化（heuristics）和基于成本的搜索（cost-based search）两种策略： 启发式方法将查询的各个部分与已知的模式进行匹配，以将其转换为更有效的模式。 基于成本的搜索枚举等价的查询计划，然后选择成本最低的那个。 基于成本的搜索，如何估计谓词的选择性（就是谓词选择的数据占总数据的比率）： 关系 \\(R\\) 中的元组数量 \\(N_{R}\\)，属性 \\(A\\) 的不同值的数量 \\(V(A,R)\\)。使用这两个信息就可以计算出每个属性值的平均记录数 \\(\\frac{N_{R}}{V(A,R)}\\)，称作选择基数（selection cardinality）。DBMS 可以根据选择基数估计谓词的选择性。 由于数据并不是均匀分布的，各个谓词之间也不是相互独立的，所以通过选择基数估计谓词的选择性偏差较大。DBMS 还可以维护等宽/等深直方图，或者对原表进行抽样得到类似原表分布的副本表，然后通过遍历副本表来计算选择性。 Concurrency Control Theory 关键问题：如何避免竞态条件（race condition），以及实现崩溃恢复。 事务的 ACID 原则： 原子性：事务中的操作要么全部执行，要么都不执行。有两种实现方式：日志（主流实现），写时复制。 一致性：数据在逻辑上是正确的，遵循完整性约束。 隔离性：并发执行的事务相互隔离，就像在串行执行一样，通过使用并发控制协议（concurrency control protocol）实现。并发事务之间存在三种冲突：读写冲突（不可重复读），写读冲突（脏读），写写冲突（丢失修改）。 持久性：已提交的事务所做的修改将会持久化到磁盘上。 Two-Phase Locking Concurrency Control 两阶段锁（2PL）是一种悲观的并发控制协议，将事务执行过程分为两个阶段：加锁阶段（Growing）和解锁阶段（Shrinking）。两阶段锁存在脏读和死锁等问题，它有多个变体： Conservative Two-Phase Locking（C2PL）：在事务开始时获取需要的所有锁，此协议可以避免死锁。 Strict Two-Phase Locking（S2PL）：事务结束时释放写锁，读锁可以在解锁阶段逐步释放，此协议可以避免脏读。 Strong Strict Two-Phase Locking（SS2PL）：事务结束时释放读/写锁，此协议在 S2PL 的基础上保证了事务的提交顺序（Commitment Ordering，CO）。 死锁是事务之间发生循环等待的现象，2PL 中有两种处理死锁的方法： 死锁检测：DBMS 定期构建等待图，如果图中存在环，则通过中止环中的某个事务，来打破循环。 死锁预防：当一个事务试图获取另一个事务持有的锁时，DBMS 会中止两个事务中的某个事务，从而避免死锁。 锁兼容矩阵图： 锁升级矩阵图： 持有锁 目标锁 IS S，X，IX，SIX S X，SIX IX X，SIX SIX X 存在的异常：脏读、不可重复读和幻读。隔离级别：读未提交、读已提交、可重复读和可串行化。（基于 2PL 实现的隔离级别、死锁检测可以参考 Project #4） Timestamp Ordering Concurrency Control Timestamp Ordering（T/O）和 Optimistic Concurrency Control（OCC） 都是乐观的并发控制协议，这些协议假设事务之间很少发生冲突，并且使用时间戳而不是锁来控制事务的执行顺序。 Basic Timestamp Ordering（BASIC T/O）：每个事务都会被分配唯一的时间戳，每个数据库对象都会记录最后一次被读/写的时间戳。每当事务读/写数据库对象时，都会将事务时间戳和对象时间戳做比较，以此确定操作是否能够执行。事务还需要保留对象的本地副本，以确保可重复读。 Optimistic Concurrency Control（OCC）：该协议将数据库对象复制到本地进行更改（写时复制），当事务想要提交时，进行冲突检测（比较事务的时间戳），如果通过则将事务的本地更改应用到数据库。 PS：这节课有点没太明白，特别是 OCC 的验证阶段看不懂。 Multi-Version Concurrency Control 多版本并发控制（MVCC）：DBMS 维护数据库中单个逻辑对象的多个物理版本，当事务开始时，DBMS 会创建数据库快照（通过复制事务状态表），然后根据快照来确定事务可见的对象版本。 MCC 有四个重要的设计决策：使用什么并发控制协议（2PL、T/O、OCC），多版本的存储方式，垃圾收集（回收对所有事务都不可见的版本），索引管理（辅助索引存储对象的逻辑指针还是物理指针，主键索引总是存储对象的物理指针）。 Database Logging 崩溃恢复算法的两个关键原语： UNDO：回滚不完整的更改。 REDO：如果已提交事务的更改没有写入磁盘，则重做这些更改。 两个崩溃恢复算法： 写时复制：字面意思。该算法的 UNDO 操作就是删除所有页面副本，没有 REDO 操作，因为事务提交的同时会原子的修改数据库根节点的指针，即已提交的事务必定会将更改落实到数据库中。 预写日志（Write-Ahead Logging，WAL）：日志首先存放在日志缓冲区中，DBMS 必须先将日志写入磁盘（顺序 I/O），然后才能将脏页写入磁盘（不需要立即执行，可以使用后台线程进行写入操作）。只有当日志写入磁盘，事务才能被视为已提交。DBMS 可以通过批量提交事务，来避免频繁的日志 I/O 操作。每个日志记录都包含：事务 ID，对象 ID，之前的值（用于 UNDO），之后的值（用于 REDO）。（这里应该是指物理日志） 日志的模式（Logging Schemes）： 物理日志（Physical Logging）：记录数据的字节级更改。 逻辑日志（Logical Logging）：记录 INSERT、DELETE 和 UPDATE 语句。 混合日志（Physiological Logging）：混合方法，以逻辑地址（页面中的槽号）的方式记录物理日志。 Database Recovery Algorithms for Recovery and Isolation Exploiting Semantics（ARIES） 是由 IBM 在 1990 年代开发出的恢复算法，该算法包含三个关键概念： Write Ahead Logging：先将日志写入磁盘，才能将脏页写入磁盘。 Repeating History During Redo：数据库重启时，重做日志将数据库恢复到崩溃之前的状态。 Logging Changes During Undo：将回滚操作记录到日志中，以确保再次崩溃时不会重复回滚。 该算法为每个日志记录分配全局唯一的日志序列号（log sequence number，LSN），系统中的各个组件会跟踪与其相关的 LSN。每个数据页面会包含最近一次更新对应的 LSN（\\(pageLSN\\)），缓冲池会包含已经刷到磁盘的最大 LSN（\\(flushedLSN\\)），DBMS 在将第 \\(i\\) 页刷新到磁盘之前，必须保证 \\(pageLSN_{i}\\leq flushedLSN\\)，即预写日志。 事务提交：DBMS 首先将 COMMIT 日志记录写入日志缓冲区，然后将日志刷新到磁盘（顺序 I/O）。当日志已经成功刷新到磁盘之后，DBMS 就会向应用程序返回事务提交成功的信息。在之后的某个时刻，DBMS 将 TXN-END 日志记录写入日志缓冲区，表明该事务已经完成。（额，课程中没有说明在这段时间内，事务会执行什么操作） 事务中止：每个日志记录会包含 \\(prevLSN\\) 字段，表示该 LSN 在事务中对应的上一个 LSN 是多少。DBMS 使用 \\(prevLSN\\) 维护事务的日志链表，以方便进行 UNDO 操作。这里引入一个新类型的日志 compensation log record（CLR），表示所执行的 UNDO 操作，该类型的日志不会被 UNDO。事务中止时，DBMS 首先将 ABORT 日志记录写入日志缓冲区，然后根据 ABORT 日志的 \\(prevLSN\\) 回滚事务的更新，当回滚完成时 DBMS 将 TXN-END 日志记录写入日志缓冲区。 为了避免数据库崩溃之后重做整个日志，DBMS 会定期设置检查点（Checkpoint，其实就是存档），在设置检查点时会将缓冲池中的所有脏页都刷新到磁盘中，Checkpoint 有下面几种实现方式： Blocking Checkpoints：首先停止开始新事物，等待活动事务完成，然后将日志和脏页刷新到磁盘，最后将 CHECKPOINT 日志记录写入缓冲区并刷新到磁盘。之所以要停止并等待事务，是为了避免丢失更新。 Slightly Better Blocking Checkpoints：在开始设置检查点时，会记录内部系统的状态，从而不必等待活动事务完成，取而代之的是暂停活动事务。内部系统状态包括：Active Transaction Table（ATT）和 Dirty Page Table（DPT）。 Fuzzy Checkpoints：通过使用额外的日志记录（CHECKPOINT-BEGIN 和 CHECKPOINT-END）跟踪检查点的边界，从而不需要暂停活动事务。 ARIES 算法在 DBMS 崩溃重启之后执行，分为三个阶段： 分析（Analysis）：从 \\(MasterRecord\\) 对应检查点开始扫描日志，以构建 ATT 和 DPT，它们包含崩溃时缓冲池中存在的脏页以及活动的事务信息。 重做（Redo）：从 DPT 的所有脏页中最小的 \\(recLSN\\) 开始重做，即所有脏页中最旧的修改日志记录。 回滚（Undo）：从崩溃时所有活动事务中最旧的日志记录开始，撤销崩溃时活动事务所做的修改。 Introduction to Distributed Databases 并行数据库和分布式数据库的区别： 并行数据库 分布式数据库 节点之间距离较近 节点之间距离较远 节点之间使用高速局域网连接 节点之间使用公共网络连接 通信的成本很小且可靠 通信的成本很高且不可靠 DBMS 的系统架构指定 CPU 可以访问哪些共享资源，有如下四种架构方式： 一致性哈希： 优势：假设有 \\(n\\) 个键，\\(m\\) 个节点，则一致性哈希平均只需要对 \\(\\frac{n}{m}\\) 个键进行再散列。 原理：使用哈希函数将键和节点映射到圆上，每个键都会被分配给在顺时针方向上的下一个节点。每当添加一个节点时，只需要对其顺时针方向的下一个节点上的键进行再散列；每当删除一个节点时，只需要将当前节点的键移动到顺时针方向的下一个节点。（相当于多个节点将圆划分为多个圆弧，每个节点只包含映射到对应圆弧上的键） Distributed OLTP Database Systems 如果某个事务需要访问多个节点上的数据（由于数据分区），则其是分布式事务。提交分布式事务时，根据协议的不同，可能需要得到所有或大多数节点的同意。原子提交协议（Atomic Commit Protocols）有：Two-Phase Commit，Three-Phase Commit，Paxos，Raft，ZAB，Viewstamped Replication。如果节点不可信，则需要使用拜占庭容错（byzantine fault tolerant）协议。 PS：虽然该课程将以上算法统称为原子提交协议，但是 2PC/3PC 和其他共识算法有一个显著的区别，就是 2PC/3PC 通常用于分布式事务，而其他共识算法通常用于数据复制。前者涉及多个节点上的不同数据，且协调器存在单点故障。后者涉及多个节点上的相同数据，且基于多数原则，不存在单点故障。可以将 2PC/3PC 和其他共识算法结合使用，从而消除单点故障（例如 Spanner 分布式数据库所做的）。 CAP 定理（Consistency，Availability，Partition tolerance）：指在发生网络分区故障时，要么选择一致性（指的是可线性化），要么选择可用性（允许读写网络分区节点）。","link":"/2023/11/15/CUM%2015-445%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"第 372 场力扣周赛","text":"使三个字符串相等等价于求字符串的最长公共前缀。 12345678910class Solution { public int findMinimumOperations(String s1, String s2, String s3) { int n = Math.min(s1.length(), Math.min(s2.length(), s3.length())); int i = 0; while (i &lt; n &amp;&amp; s1.charAt(i) == s2.charAt(i) &amp;&amp; s2.charAt(i) == s3.charAt(i)) { i++; } return i == 0 ? -1 : s1.length() + s2.length() + s3.length() - 3 * i; }} 区分黑球与白球将每个 \\(1\\) 右边 \\(0\\) 的个数累加就是需要交换的次数，或者累加每个 \\(0\\) 左边 \\(1\\) 的个数也行。 1234567891011class Solution { public long minimumSteps(String s) { long ans = 0L; int n = s.length(), cnt = 0; for (int i = n - 1; i &gt;= 0; i--) { if (s.charAt(i) == '0') cnt++; else ans += cnt; } return ans; }} 最大异或乘积要求 \\(\\max((a\\oplus x)\\times(b\\oplus x))\\)，可以得出异或只会在两者都为 \\(0\\) 的位上补 \\(1\\)，或者交换两者某位上的 \\(0\\) 和 \\(1\\)。此时 \\((a\\oplus x)+(b\\oplus x)=c\\)，\\(c\\) 为某个定值，从而问题可以转化为求函数 \\(y=x(c-x)\\) 的最大值，可以知道当 \\(x=\\frac{c}{2}\\) 时取到最大值，即我们需要让 \\((a\\oplus x)\\) 和 \\((b\\oplus x)\\) 尽可能相等。 123456789101112131415161718class Solution { private static final int MOD = (int) 1e9 + 7; public int maximumXorProduct(long a, long b, int n) { long p = a &gt;&gt; n &lt;&lt; n, q = b &gt;&gt; n &lt;&lt; n; for (int i = n - 1; i &gt;= 0; i--) { if ((a &gt;&gt; i &amp; 1) == (b &gt;&gt; i &amp; 1)) { p |= 1L &lt;&lt; i; q |= 1L &lt;&lt; i; } else if (p &lt; q) { p |= 1L &lt;&lt; i; } else { q |= 1L &lt;&lt; i; } } return (int) (p % MOD * (q % MOD) % MOD); }} 找到 Alice 和 Bob 可以相遇的建筑离线查询，可以预处理查询序列，然后使用单调栈 + 二分，或者使用最小堆；在线查询，可以使用线段树（暂时不学）。","link":"/2023/11/20/%E7%AC%AC%20372%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 330","text":"Counting Passes模拟。 12345678910public static void solve() { int n = io.nextInt(), l = io.nextInt(); int ans = 0; for (int i = 0; i &lt; n; i++) { if (io.nextInt() &gt;= l) { ans++; } } io.println(ans);} Minimize Abs 1等价于求 \\(y=|x-a_{i}|\\) 在区间 \\([L,R]\\) 内的最小值对应的 \\(x\\)。 1234567891011121314public static void solve() { int n = io.nextInt(), l = io.nextInt(), r = io.nextInt(); for (int i = 0; i &lt; n; i++) { int a = io.nextInt(); if (l &lt;= a &amp;&amp; a &lt;= r) { io.print(a + &quot; &quot;); } else if (a &lt; l) { io.print(l + &quot; &quot;); } else { io.print(r + &quot; &quot;); } } io.println();} Minimize Abs 2对于每个固定的 \\(x\\)，可以在 \\(O(1)\\) 时间内求出 \\(|y^{2}+(x^{2}-D)|\\) 的最小值（也可以二分），我们枚举 \\([0,\\lceil\\sqrt{D}\\rceil]\\) 范围内的所有 \\(x\\)。 12345678910111213141516public static void solve() { long d = io.nextLong(); long ans = Long.MAX_VALUE; long up = (long) Math.sqrt(d) + 1; for (long x = 0; x &lt;= up; x++) { long t = x * x - d; if (t &gt;= 0) { ans = Math.min(ans, t); } else { long y = (long) Math.sqrt(-t); ans = Math.min(ans, Math.abs(y * y + x * x - d)); ans = Math.min(ans, Math.abs((y + 1) * (y + 1) + x * x - d)); } } io.println(ans);} Counting Ls对行列计数，然后枚举交叉点。 12345678910111213141516171819202122232425262728public static void solve() { int n = io.nextInt(); char[][] s = new char[n][]; for (int i = 0; i &lt; n; i++) { s[i] = io.next().toCharArray(); } int[] row = new int[n]; int[] col = new int[n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i][j] == 'o') { row[i]++; col[j]++; } } } long ans = 0L; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (s[i][j] == 'o' &amp;&amp; col[j] &gt; 1) { ans += (long) (col[j] - 1) * (row[i] - 1); } } } io.println(ans);} Mex and Update因为只有 \\(n\\) 个数，所以只需要考虑 \\([0,n]\\) 范围的数的增删，这样集合就可以存储单个数。比赛时没注意，使用的是区间，然后删除区间中的数，需要进行分裂，会麻烦很多，还需要排序以及考虑最左和最右的特殊区间。 123456789101112131415161718192021222324252627282930public static void solve() { int n = io.nextInt(), q = io.nextInt(); int[] a = new int[n]; int[] cnt = new int[n + 1]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); if (a[i] &lt;= n) { cnt[a[i]]++; } } TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt;= n; i++) { if (cnt[i] == 0) { set.add(i); } } while (q-- != 0) { int i = io.nextInt() - 1, x = io.nextInt(); if (a[i] &lt;= n &amp;&amp; --cnt[a[i]] == 0) { set.add(a[i]); } a[i] = x; if (a[i] &lt;= n &amp;&amp; cnt[a[i]]++ == 0) { set.remove(a[i]); } io.println(set.first()); }}","link":"/2023/11/26/AtCoder%20Beginner%20Contest%20330/"},{"title":"第 118 场力扣夜喵双周赛","text":"查找包含给定字符的单词模拟。 1234567891011class Solution { public List&lt;Integer&gt; findWordsContaining(String[] words, char x) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) { if (words[i].contains(x + &quot;&quot;)) { ans.add(i); } } return ans; }} 最大化网格图中正方形空洞的面积分别求出行和列的最长连续线段，然后最大正方形面积就是两者最小值加一的平方。 1234567891011121314151617181920212223class Solution { public int maximizeSquareHoleArea(int n, int m, int[] hBars, int[] vBars) { Arrays.sort(hBars); Arrays.sort(vBars); int maxH = 0, maxV = 0; for (int i = 0, j = 0; j &lt; hBars.length; j++) { if (hBars[j] - hBars[i] == j - i) { maxH = Math.max(maxH, j - i + 1); } else { i = j; } } for (int i = 0, j = 0; j &lt; vBars.length; j++) { if (vBars[j] - vBars[i] == j - i) { maxV = Math.max(maxV, j - i + 1); } else { i = j; } } int len = Math.min(maxH, maxV) + 1; return len * len; }} 购买水果需要的最少金币数动态规划，\\(dp[i]\\) 表示获取 \\([i,n]\\) 范围内所有水果所需的最少金币数，有 \\(dp[i]=prices[i]+\\min_{j=i+1}^{2i+1}{dp[j]}\\)，时间复杂度 \\(O(n^{2})\\)。 12345678910111213class Solution { public int minimumCoins(int[] prices) { int n = prices.length; for (int i = (n + 1) / 2 - 1; i &gt; 0; i--) { int min = Integer.MAX_VALUE; for (int j = i + 1; j &lt;= 2 * i + 1; j++) { min = Math.min(min, prices[j - 1]); } prices[i - 1] += min; } return prices[0]; }} 单调队列优化，时间复杂度 \\(O(n)\\)。 12345678910111213141516171819class Solution { public int minimumCoins(int[] prices) { int n = prices.length; Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for (int i = n; i &gt; 0; i--) { while (!q.isEmpty() &amp;&amp; q.peekFirst() &gt; 2 * i + 1) { q.pollFirst(); } if (i &lt;= (n + 1) / 2 - 1) { prices[i - 1] += prices[q.peekFirst() - 1]; } while (!q.isEmpty() &amp;&amp; prices[q.peekLast() - 1] &gt;= prices[i - 1]) { q.pollLast(); } q.offerLast(i); } return prices[q.peekLast() - 1]; }} 找到最大非递减数组的长度单调队列优化 DP，随缘补题。","link":"/2023/11/26/%E7%AC%AC%20118%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 373 场力扣周赛","text":"循环移位后的矩阵相似检查模拟。有个性质，如果左移 \\(k\\) 位之后相等，则右移 \\(k\\) 位也必定相等。 12345678910111213class Solution { public boolean areSimilar(int[][] mat, int k) { int m = mat.length, n = mat[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] != mat[i][((j + (i % 2 == 0 ? 1 : -1) * k) % n + n) % n]) { return false; } } } return true; }} 统计美丽子字符串 I将元音字母看作 \\(1\\)，非元音字母看作 \\(-1\\)，使用前缀和 + 哈希表的技巧，可以得到若干个分组，每组中任意两个下标构成的子数组都满足条件一。然后我们可以暴力判断所有满足条件一的子数组的长度是否满足条件二，时间复杂度为 \\(O(n^{2})\\)。（补充：可以纯暴力做，不需要分组。） 123456789101112131415161718192021222324class Solution { public int beautifulSubstrings(String s, int k) { int n = s.length(), sum = 0; Set&lt;Character&gt; set = Set.of('a', 'e', 'i', 'o', 'u'); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); map.computeIfAbsent(0, t -&gt; new ArrayList&lt;&gt;()).add(-1); for (int i = 0; i &lt; n; i++) { sum += set.contains(s.charAt(i)) ? 1 : -1; map.computeIfAbsent(sum, t -&gt; new ArrayList&lt;&gt;()).add(i); } int ans = 0; for (var list : map.values()) { for (int j = 0; j &lt; list.size() ; j++) { for (int i = 0; i &lt; j; i++) { int len = (list.get(j) - list.get(i)) / 2; if (len * len % k == 0) { ans++; } } } } return ans; }} 交换得到字典序最小的数组如果 \\(|nums[i]-nums[j]|&lt;=limit\\)，那么就可以交换 \\(nums[i]\\) 和 \\(nums[j]\\)，该交换的性质具有传递性，所以我们可以对原数组进行排序，只要相邻元素的差值小于等于 \\(limit\\)，它们就在同一个可交换集合中。这样可以将原数组划分为若干可交换集合，然后对每个集合排序，从小到大排列即可。 12345678910111213141516171819202122232425262728293031class Solution { public int[] lexicographicallySmallestArray(int[] nums, int limit) { int n = nums.length; var aux = new Integer[n]; for (int i = 0; i &lt; n; i++) { aux[i] = i; } Arrays.sort(aux, (i, j) -&gt; nums[i] - nums[j]); int pre = -limit; List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(); for (int i : aux) { if (nums[i] - pre &gt; limit) { buckets.add(new ArrayList&lt;&gt;()); } buckets.get(buckets.size() - 1).add(i); pre = nums[i]; } int[] ans = new int[n]; for (var bucket : buckets) { List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); pos.addAll(bucket); Collections.sort(pos); for (int i = 0; i &lt; pos.size(); i++) { ans[pos.get(i)] = nums[bucket.get(i)]; } } return ans; }} 统计美丽子字符串 II朴素做法的瓶颈在 \\((\\frac{L}{2})^{2}\\bmod{k}=0\\) 的判断上，可以通过将条件二变换为 \\(L\\bmod{k^{\\prime}}=0\\)，然后使用前缀和以及下标模 \\(k^{\\prime}\\) 的值来分组，这样同组内的下标两两组合得到的必定是满足两个条件的子数组。灵神题解，时间复杂度 \\(O(n+\\sqrt{k})\\)。还有另一种枚举的做法，题解。","link":"/2023/11/26/%E7%AC%AC%20373%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 911 (Div. 2)","text":"Cover in Water只要存在三个连续的空格，就可以执行两次操作一，再多次执行操作二，来装满所有空格。 123456789101112131415public static void solve() { int n = io.nextInt(); String s = io.next(); String[] arr = s.split(&quot;#&quot;); int ans = 0; for (String t : arr) { int m = t.length(); if (m &gt;= 3) { io.println(2); return; } ans += m; } io.println(ans);} Laura and Operations注意题目说的是剩下一种类型的数字，而不是一个数字。如果剩下数字 \\(1\\)，那么首先将 \\(2\\) 和 \\(3\\) 抵消，如果 \\(2\\) 多于 \\(3\\)，那么多出的数量如果是偶数，就可以将该数量的一半执行操作，再做一次抵消，最后就只剩下 \\(1\\)；反之亦然。 123456789101112public static void solve() { int a = io.nextInt(), b = io.nextInt(), c = io.nextInt(); if (Math.abs(b - c) % 2 == 0) io.print(1); else io.print(0); io.print(&quot; &quot;); if (Math.abs(a - c) % 2 == 0) io.print(1); else io.print(0); io.print(&quot; &quot;); if (Math.abs(a - b) % 2 == 0) io.print(1); else io.print(0); io.println();} Anji’s Binary Tree做一次后序遍历即可。题目说的是选择任意字母替换，而不是选择其他节点上的字母替换。 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(); String s = io.next(); int[][] g = new int[n][]; for (int i = 0; i &lt; n; i++) { int l = io.nextInt() - 1, r = io.nextInt() - 1; g[i] = new int[]{l, r}; } io.println(dfs(0, g, s));}private static int dfs(int x, int[][] g, String s) { if (g[x][0] == -1 &amp;&amp; g[x][1] == -1) { return 0; } int res = Integer.MAX_VALUE; if (g[x][0] != -1) { res = Math.min(res, dfs(g[x][0],g, s) + (s.charAt(x) != 'L' ? 1 : 0)); } if (g[x][1] != -1) { res = Math.min(res, dfs(g[x][1],g, s) + (s.charAt(x) != 'R' ? 1 : 0)); } return res;} Small GCD\\(f(a,b,c)\\) 表示 \\(a,b,c\\) 中最小的两个数的 \\(\\gcd\\)，而我们要求出给定数组的所有不同下标构成的三元组的 \\(f\\) 之和。暴力的想法是枚举中间值，然后计算以该值为中心构成的三元组的 \\(\\gcd\\) 之和，时间复杂度为 \\(O(n^{2})\\)。正确的做法：由于数据范围比较小，我们可以首先计算出 \\([1,N]\\) 范围内每个数的所有约数，然后排序数组，对数组中的每个数枚举它的约数，从而计算出以该约数的倍数作为最大公约数的三元组的个数，然后利用容斥原理得到以该约数作为最大公约数的三元组的个数，最后可以计算出答案。 123456789101112131415161718192021222324252627282930313233343536373839private static final int N = 100000;private static final List&lt;Integer&gt;[] aux;static { aux = new List[N + 1]; Arrays.setAll(aux, k -&gt; new ArrayList&lt;&gt;()); for (int i = 1; i &lt;= N; i++) { for (int j = i; j &lt;= N; j += i) { aux[j].add(i); } }}public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); } Arrays.sort(a); int[] c = new int[N + 1]; long[] f = new long[N + 1]; for (int i = 0; i &lt; n; i++) { for (int x : aux[a[i]]) { f[x] += (long) c[x] * (n - i - 1); c[x]++; } } long ans = 0L; for (int i = N; i &gt;= 1; i--) { for (int j = i + i; j &lt;= N; j += i) { f[i] -= f[j]; } ans += f[i] * i; } io.println(ans);} Transitive Graph似乎是和强连通分量相关的题目，有空可以补一下。","link":"/2023/11/27/Codeforces%20Round%20911%20(Div.%202)/"},{"title":"第 374 场力扣周赛","text":"需要添加的硬币的最小数量题目 输入长度为 \\(n\\) 的数组 \\(a\\) 和整数 \\(k\\)，输出需要向数组插入多少个数，使得数组的子序列能够表示 \\([1,k]\\) 范围内的所有整数。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq k\\leq 10^{5}\\)。 思路 从小到大遍历数组，假设当前能够表示的区间为 \\([0,s]\\)，此时遍历到数组中的数 \\(a_{i}\\)，我们可以表示区间 \\([a_{i},s+a_{i}]\\)。 如果 \\(a_{i}\\leq s+1\\)，那么就可以合并两个区间，得到 \\([0,s+a_{i}]\\)，然后继续遍历 \\(a_{i+1}\\)。 否则，需要向数组插入数 \\(s+1\\) 来保证区间连续，得到 \\([0,2s+1]\\)，然后再次遍历 \\(a_{i}\\)。 不断重复上述过程直到能够表示区间 \\([1,k]\\)。 排序数组的时间复杂度为 \\(O(n\\log{n})\\)，插入操作最多执行 \\(O(\\log{k})\\) 次。 统计完全子字符串题目 输入长度为 \\(n\\) 的由小写英文字母组成的字符串 \\(s\\) 和整数 \\(k\\)，输出满足以下两个条件的子字符串的个数。 每个字符恰好出现 \\(k\\) 次。 相邻字符在字母表中的距离小于等于 \\(2\\)。 数据范围：\\(1\\leq k\\leq n\\leq 10^{5}\\)。 思路 距离大于 \\(2\\) 的相邻字符可以将字符串分割成若干子串，对于每个子串 \\(t\\) 考虑满足条件一的子串 \\(t_{i}\\) 个数即可。我们可以枚举 \\(t_{i}\\) 包含多少个不同的字符（设为 \\(x\\)），对于每个 \\(x\\) 使用滑动窗口可以得到 \\(t\\) 中满足条件一的长度为 \\(kx\\) 的子串个数。时间复杂度为 \\(O(|\\Sigma| n)\\)，外层循环执行 \\(O(|\\Sigma|)\\) 次，内层循环滑窗执行 \\(O(n)\\) 次，滑窗的同时使用计数数组统计有多少个字符恰好出现 \\(k\\) 次，判断的时间复杂度为 \\(O(1)\\)。 统计感冒序列的数目题目 输入整数 \\(n\\) 和长度为 \\(m\\) 的按照升序排列的数组 \\(a\\)，数组 \\(a\\) 存储下标 \\([0,n-1]\\) 的子序列，输出所有不在数组 \\(a\\) 中的下标被选择的方案数，答案对 \\(10^{9}+7\\) 取余。下标 \\(i\\) 可以被选择，当且仅当下标 \\(i-1\\) 或者 \\(i+1\\) 被选择，数组 \\(a\\) 中的下标可以看作是被选择的。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq m\\leq n-1\\)，\\(0\\leq a_{i}\\leq n-1\\)。 思路 数组 \\(a\\) 中的下标将 \\([0,n-1]\\) 划分为多个子数组，首先考虑每个子数组内部的方案数：最左和最右的子数组只存在一种选择方案，其他子数组存在 \\(2^{x_{i}-1}\\) 种选择方案，\\(x_{i}\\) 为该子数组的长度。然后考虑子数组之间的方案数，最初我们有 \\(n-m\\) 个位置可以放置下标，假设各个子数组的长度分别为 \\(x_{0},x_{1},\\dots,x_{k}\\)，那么总共有 \\(\\prod_{i=0}^{k}{C(n-m-\\sum_{j=0}^{i-1}{x_{j}},x_{i})}=\\frac{(n-m)!}{\\prod_{i=0}^{k}{x_{i}!}}\\) 种放置方案。将两者相乘即可得到答案，计算过程需要使用逆元和快速幂。","link":"/2023/12/05/%E7%AC%AC%20374%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 119 场力扣夜喵双周赛","text":"消除相邻近似相等字符题目 输入长度为 \\(n\\) 的字符串 \\(s\\)，输出所需的最少操作次数，使得字符串 \\(s\\) 中的相邻字符在字母表中的距离大于 \\(1\\)。每次操作可以将字符串 \\(s\\) 中的某个字符修改为任意字符。 数据范围：\\(1\\leq n\\leq 100\\)。 思路 思路一：距离大于 \\(1\\) 的相邻字符可以将字符串 \\(s\\) 分割为若干子串，每个子串所需的最少操作次数为 \\(\\lfloor\\frac{l}{2}\\rfloor\\)，其中 \\(l\\) 表示子串的长度。 思路二：如果相邻字符距离小于等于 \\(1\\)，那么贪心的修改右边的字符即可。 两种思路原理是一样的，只是实现时略有不同。 关闭分部的可行集合数目题目 输入整数 \\(n\\) 表示有 \\(n\\) 个节点，长度为 \\(m\\) 表示无向边的数组 \\(e\\)（包含重边），以及整数 \\(d\\)。输出删除节点的方案数，使得剩余节点两两之间的最短路不超过 \\(d\\)。 数据范围：\\(1\\leq n\\leq 10\\)，\\(0\\leq m\\leq 1000\\)。其他数据不会影响时间复杂度，所以不列出。 思路 题目要求满足条件的方案数，首先想到枚举所有方案，总共有 \\(2^{n}\\) 个方案，然后对每个方案求删除节点后的多源最短路（Floyd 算法），如果剩余节点两两之间的最短路都不超过 \\(d\\)，那么答案就加一，总时间复杂度为 \\(O(m+2^{n}n^{3})\\)。因为是求最短路，所以重边可以只保留最小的那条边。","link":"/2023/12/10/%E7%AC%AC%20119%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 375 场力扣周赛","text":"统计最大元素出现至少 K 次的子数组题目 输入长度为 \\(n\\) 的数组 \\(a\\) 和整数 \\(k\\)，输出满足 \\(\\max(a)\\) 至少出现 \\(k\\) 次的子数组的数目。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq k\\leq 10^{5}\\)。 思路 首先计算出最大值，然后将所有最大值的下标放入列表 \\(l\\) 中，最后枚举右端点即可。假设列表的长度为 \\(m\\)，当前枚举到 \\(i\\)，当 \\(i&lt;m-1\\) 时，区间 \\([l[i],l[i+1]-1]\\) 范围内的右端点都对应 \\(l[i-k+1]+1\\) 数量的左端点，将它们相乘加入答案。特别的，当 \\(i=m-1\\) 时，取区间 \\([l[i],n-1]\\)。PS：也可以滑动窗口，使窗口内只包含 \\(k-1\\) 个最大值，这样计算答案的空间复杂度为 \\(O(1)\\)。 统计好分割方案的数目题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出将数组分割为若干不相交子数组的方案数。不相交表示子数组之间没有相同的元素，答案对 \\(10^{9}+7\\) 取余。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路 因为要求子数组之间没有相同元素，那么相同元素必定只会出现在一个子数组中，首先统计每个元素的最小和最大下标，这两个下标构成的区间是不可分割的。然后将所有不可分割的区间进行合并，最后剩余的区间数假设为 \\(m\\)，那么就会有 \\(2^{m-1}\\) 种分割方案（因为 \\(m\\) 个区间有 \\(m-1\\) 个分割位置，每个分割位置有分割或者不分割两种状态）。PS：① 可以边计数边做乘法，不使用快速幂；② 可以只统计最大下标，然后遍历数组时维护最大下标的最大值，如果当前下标等于该值，那么就可以做一次分割。（代码）","link":"/2023/12/10/%E7%AC%AC%20375%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 915 (Div. 2)","text":"Begginer’s Zelda题目输入一颗树，输出执行的最少操作次数，使得该树只有一个节点。每次操作可以选择树中的两个节点，将它们之间的路径压缩为一个节点，所有连接路径上节点的边都会连向新节点。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq u_{i},v_{i}\\leq n\\)，\\(u_{i}\\neq v_{i}\\)。 思路每次操作贪心的选择两个叶子节点（度数为 \\(1\\) 的节点都看作叶子），根据叶子节点的数量 \\(x\\) 的奇偶性分类讨论： 如果 \\(x\\) 为奇数，\\(x=1\\) 需要 \\(0\\) 次操作，\\(x=3\\) 需要 \\(2\\) 次操作，之后每增加两个叶子，都会使操作次数加 \\(1\\)，由于数据范围限制初始时叶子至少有 \\(2\\) 个，所以操作次数为 \\(\\frac{x+1}{2}\\)。 如果 \\(x\\) 为偶数，\\(x=2\\) 需要 \\(1\\) 次操作，\\(x=4\\) 需要 \\(2\\) 次操作，之后每增加两个叶子，都会使操作次数加 \\(1\\)，所以操作次数为 \\(\\frac{x}{2}\\)。 最后，可以将两种情况的公式合并为 \\(\\lfloor\\frac{x+1}{2}\\rfloor\\)。 Largest Subsequence题目输入长度为 \\(n\\) 的字符串 \\(s\\)，输出执行的最少操作次数，使得字符串有序。每次操作可以将字符串中字典序最大的子序列循环右移一位。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)。 思路首先使用单调栈求出字典序最大的子序列（非严格单调递减），然后通过观察可以发现，执行多次操作最终会将该子序列反转。相当于求最少右移次数，使得子序列反转，该次数等于子序列长度减去子序列中最大字符的数量。其次，还需要判断子序列反转之后，字符串是否有序。 Cyclic MEX题目输入一个包含 \\({0,1,2,\\dots,n-1}\\) 的排列 \\(p\\)，输出排列 \\(p\\) 的所有循环移动的最大代价。对于数组 \\(a\\)，它的代价为 \\(\\sum_{i=1}^{n}{\\operatorname{mex}([a_{1},a_{2},\\dots,a_{i}])}\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路观察每循环左移一次，代价是如何变化的： 排列 \\(2,3,6,7,0,1,4,5\\) 对应的代价为 \\(0,0,0,0,1,4,5,8\\)； 排列 \\(3,6,7,0,1,4,5,2\\) 对应的代价为 \\(0,0,0,1,2,2,2,8\\)； 排列 \\(6,7,0,1,4,5,2,3\\) 对应的代价为 \\(0,0,1,2,2,2,3,8\\)。 可以发现每当将数 \\(x\\) 移动到排列末尾，所有大于 \\(x\\) 的 \\(\\operatorname{mex}\\) 值都会变为 \\(x\\)，然后 \\(x\\) 位置对应的 \\(\\operatorname{mex}\\) 值为 \\(n\\)。 我们可以首先将排列移动为 \\(1,4,5,2,3,6,7,0\\) 形式，对应的代价为 \\(0,0,0,0,0,0,0,8\\)。然后使用单调递增栈维护左移的数构成的递增序列，栈中存储数的下标，模拟上述过程并维护最大代价。","link":"/2023/12/18/Codeforces%20Round%20915%20(Div.%202)/"},{"title":"第 376 场力扣周赛","text":"使数组成为等数数组的最小代价题目输入长度为 \\(n\\) 的整数数组 \\(a\\)，输出执行任意次操作后使得数组中的数全部相等并且是回文数的最小代价（要求该回文数小于 \\(10^{9}\\)）。每次操作可以将数组中的某个数（假设为 \\(a_{i}\\)）修改为任意正整数（假设为 \\(x\\)），对应的代价为 \\(|a_{i}-x|\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq10^{9}\\)。 思路如果没有限制是回文数，那么将数组排序之后按如下方式修改，代价是最小的（假设有序数组中的元素为 \\(a_{0},a_{1},\\dots,a_{n-1}\\)）： 当 \\(n\\) 为奇数时，将所有数修改为中位数 \\(a_{\\lfloor\\frac{n}{2}\\rfloor}\\)。 当 \\(n\\) 为偶数时，将所有数修改为区间 \\([a_{\\lfloor\\frac{n-1}{2}\\rfloor},a_{\\lfloor\\frac{n}{2}\\rfloor}]\\) 内的某个数。 首先使用反证法证明，最小代价可以通过将所有数修改为数组中的某个数取到。 假设将所有数修改为 \\(x\\)，\\(x\\) 在区间 \\((a_{i},a_{i+1})\\) 范围内，其中 \\(a_{i}\\) 和 \\(a_{i+1}\\) 表示数组中相邻的两个数。此时 \\(x\\) 左边有 \\(i+1\\) 个元素，右边有 \\(n-i\\) 个元素。将 \\(x\\) 修改为 \\(a_{i+1}\\) 会使代价增加 \\((i+1)\\times (a_{i+1}-x)\\)，并且使代价减少 \\((n-i)\\times(a_{i+1}-x)\\)。将 \\(x\\) 修改为 \\(a_{i}\\) 会使代价减少 \\((i+1)\\times (x-a_{i})\\)，并且使代价增加 \\((n-i)\\times(x-a_{i})\\)。 当 \\(i+1&lt;n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i+1}\\) 会使代价减少；当 \\(i+1&gt;n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i}\\) 会使代价减少；当 \\(i+1=n-i\\) 时，将 \\(x\\) 修改为 \\(a_{i}\\) 或者 \\(a_{i+1}\\) 代价不变。 特别的，\\(x\\) 在区间 \\([1,a_{0})\\) 或者 \\((a_{n-1},+\\infty]\\) 范围内时，同理。 然后再使用反证法证明上述结论： 假设将数组中的数都修改为 \\(a_{i}\\) 时，代价最小，\\(a_{i}\\) 不满足上述条件。 当 \\(n\\) 为奇数时，由于 \\(a_{i}\\) 不是中位数： 当 \\(i&lt;\\lfloor\\frac{n}{2}\\rfloor\\) 时，有 \\(i+1&lt;n-1-i\\)，此时 \\(i\\) 每向中位数移动一位，代价都会减少 \\((n-1-i)-(i+1)&gt;0\\)。 反之亦然。 当 \\(n\\) 为偶数时，同理。 综上，得出按照上述方式修改代价最少，即 \\(x\\) 越靠近中位数代价越小。所以，如果需要将所有数修改为某个回文数，那么该回文数一定是最靠近中位数的回文数。PS：还是灵神的证明更简单。 该题有两种方法可以找到距离 \\(x\\) 的最近回文数： 方法一：将 \\(x\\) 的前半部分作为回文根，对称之后得到回文数 \\(y\\)。如果 \\(y&lt;x\\)，则将回文根加一再做对称得到回文数 \\(z\\)，然后取 \\(y\\) 和 \\(z\\) 中距离最近者；如果 \\(y&gt;x\\)，则将回文根减一再做对称得到回文数 \\(z\\)，然后取 \\(y\\) 和 \\(z\\) 中距离最近者；否则，\\(x\\) 本身就是回文数。注意，排除大于等于 \\(10^{9}\\) 的回文数，以及做加减法时可能会遇到回文根为 \\(100\\dots0\\) 或 \\(99\\dots9\\) 的特殊情况，此时做对称会得到错误答案，我们应该直接根据长度构造回文数。（这个代码还挺好看，把所有情况都直接循环枚举，就可以不用写那么多判断语句） 方法二：枚举出 \\([1,10^{9}]\\) 范围内的所有回文数，然后二分找到距离 \\(x\\) 最近的回文数。 执行操作使频率分数最大题目输入长度为 \\(n\\) 的整数数组 \\(a\\) 和一个整数 \\(k\\)，输出经过至多 \\(k\\) 次操作之后，数组中众数的最大频率。每次操作可以选择数组中的某个数 \\(a_{i}\\)，将其增加或者减少 \\(1\\)。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)，\\(0\\leq k\\leq 10^{14}\\)。 思路排序 + 前缀和 + 滑动窗口。要使众数尽可能多，可以首先对数组排序，假设最终众数有 \\(x\\) 个，那么这 \\(x\\) 个数一定是在某个子数组中。使用滑动窗口，将尽可能多的数包含在窗口内，同时满足操作次数小于等于 \\(k\\)，如果大于 \\(k\\) 则将左端点右移。类似上一题，将窗口内的所有数都修改为窗口的中位数，所需的操作次数最少。窗口的操作次数可以使用前缀和 \\(O(1)\\) 的计算出来，假设窗口的左右端点的下标分别为 \\(i\\) 和 \\(j\\)，中位数的下标为 \\(k\\)，则窗口的操作次数为：\\((a_{k}\\times (k-i)-(s[k]-s[i]))+((s[j+1]-s[k+1])-a_{k}\\times (j-k))\\)。","link":"/2023/12/18/%E7%AC%AC%20376%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Educational Codeforces Round 160 (Rated for Div. 2)","text":"Swap and Delete题目输入长度为 \\(n\\) 的二进制字符串，输出执行操作需要的最小成本，使得对于操作之后得到的字符串 \\(t\\) 的每个字符 \\(t_{i}\\)，都有 \\(t_{i}\\neq s_{i}\\)，其中 \\(1\\leq i\\leq |t|\\)。有两种操作： 从字符串 \\(s\\) 中删除一个字符，操作的成本为 \\(1\\)。 交换字符串 \\(s\\) 中的两个字符，操作的成本为 \\(0\\)。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)。 思路由于只有删除操作会导致成本增加，所以我们只需要让字符串 \\(t\\) 尽可能长就好。首先对字符串 \\(s\\) 中的 \\(0\\) 和 \\(1\\) 计数，然后贪心的构造字符串 \\(t\\)，如果 \\(s_{i}=0\\)，则 \\(t_{i}=1\\)，反之亦然，直到不能增加长度为止。最后最小成本就是 \\(n-|t|\\)。 Game with Multiset题目输入一个整数 \\(m\\) 表示查询的次数，以及 \\(m\\) 行查询，每行包含两个整数 \\(t_{i}\\) 和 \\(v_{i}\\)。初始时你有一个空的多重集合（multiset）： 如果 \\(t_{i}=1\\)，将元素 \\(2^{v}\\) 加入集合。（\\(0\\leq v_{i}\\leq 29\\)） 如果 \\(t_{i}=2\\)，询问 \\(v_{i}\\) 是否可以表示为当前集合的某个子集之和，并输出 YES 或 NO。（\\(0\\leq v_{i}\\leq 10^{9}\\)） 数据范围：\\(1\\leq m\\leq 10^{5}\\)。 思路 方法一：使用数组对 \\(t_{i}=1\\) 的 \\(v_{i}\\) 计数，对于每个询问，从低到高遍历 \\(v_{i}\\) 的二进制 \\(1\\)。假设当前遍历到 \\(2^{k}\\)，如果集合中存在 \\(2^{k}\\) 则当前位可以被表示（假设集合中有 \\(c_{k}\\) 个 \\(2^{k}\\)），并且集合中剩余的 \\(2^{k}\\) 可以合并为 \\(\\frac{c_{k}-1}{2}\\) 个 \\(2^{k+1}\\)，然后遍历下一位，这样最终可以判断 \\(v_{i}\\) 是否能被集合表示。 方法二：使用数组对 \\(t_{i}=1\\) 的 \\(v_{i}\\) 计数，对于每个询问，从高到低遍历 \\(v_{i}\\) 的二进制 \\(1\\)。假设当前遍历到 \\(2^{k}\\)，则执行 \\(v_{i}=v_{i}-(\\min{(v_{i}&gt;&gt;k,c_{k})}&lt;&lt;k)\\) 操作（假设集合中有 \\(c_{k}\\) 个 \\(2^{k}\\)），表示将集合中的元素尽可能填补到 \\(v_{i}\\) 中，最终 \\(v_{i}\\) 还需要多少值，如果最终 \\(v_{i}=0\\) 则它可以被集合表示。 Array Collapse题目输入长度为 \\(n\\) 的数组 \\(p\\)，其中的元素互不相同。输出执行任意次操作能够得到的不同数组个数，结果对 \\(998244353\\) 取余。每次操作可以选择 \\(p\\) 的一个子数组（假设为 \\([i,j]\\)），将子数组中除最小值之外的所有数删除。 数据范围：\\(1\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq p_{i}\\leq 10^{9}\\)。 思路 方法一：使用分治 + 线段树的时间复杂度为 \\(O(n\\log{n})\\) 的思路，比赛时大概就是这个思路，不过想岔了一点。对于区间 \\([i,j]\\)，使用线段树找到区间最小值的下标，然后左右分治求不同数组的个数，最后将两者相乘。这个方法还有一些特殊情况需要维护，具体看代码。 方法二：参考灵神视频单调栈优化 DP，将 \\(f[i]\\) 定义为以 \\(p[i]\\) 结尾的子序列个数，然后利用动态规划转移，最后将所有 \\(f[i]\\) 求和得到答案。单调栈这个规律有点难想，具体看视频吧。","link":"/2023/12/21/Educational%20Codeforces%20Round%20160%20(Rated%20for%20Div.%202)/"},{"title":"Codeforces Round 916 (Div. 3)","text":"Three Activities题目输入长度为 \\(n\\) 的数组 \\(a,b,c\\)，输出 \\(a_{i}+b_{j}+c_{k}\\) 的最大值，要求 \\(i,j,k\\) 互不相同。 数据范围：\\(3\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i},b_{i},c_{i}\\leq 10^{8}\\)。 思路 方法一：可以发现答案只和数组 \\(a,b,c\\) 中最大的三个元素有关，首先建立三个数组对应的下标数组，对其降序排序。然后使用三重循环暴力枚举前三个元素的组合，要求 \\(i,j,k\\) 互不相同，最后取组合的最大值作为答案。 方法二：状压 DP，定义 \\(dp[i][j]\\) 表示 \\([0,i]\\) 范围内从 \\(j\\)（\\(0\\leq j\\leq 7\\)）所对应数组中各取一个元素，能够得到的元素和的最大值。例如，当 \\(j=3\\) 时，表示从 \\(a\\) 和 \\(b\\) 中取元素。可以使用倒序枚举的方式优化空间。 Game with Marbles (Hard Version)题目输入长度为 \\(n\\) 的数组 \\(a,b\\)，输出游戏结束时的得分 \\(s\\)。游戏内容为：玩家 \\(A,B\\) 每次可以选一个下标 \\(i\\)，如果当前轮到玩家 \\(A\\)，则进行 \\(s=s+(a_{i}-1)\\) 操作，否则进行 \\(s=s-(b_{i}-1)\\) 操作，不能重复选择同一个下标。游戏从玩家 \\(A\\) 开始，并且假设 \\(A,B\\) 双方都以最优的方式进行游戏。 数据范围：\\(2\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq a_{i},b_{i}\\leq 10^{9}\\)。 思路假设当前轮到玩家 \\(A\\)，选择下标 \\(i\\)，则答案会增加 \\(a_{i}-1\\)，并且 \\(b_{i}\\) 将会无效化。相当于每次选择对答案的贡献为 \\(a_{i}+b_{i}\\)，建立一个下标数组，按照该方式对数组降序排序。然后让玩家 \\(A,B\\) 依次选择数组中的下标，该游戏方式是最优的。","link":"/2023/12/21/Codeforces%20Round%20916%20(Div.%203)/"},{"title":"第 120 场力扣夜喵双周赛","text":"统计移除递增子数组的数目 II题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出子数组的数目，使得移除该子数组之后剩余的数是严格递增的，空数组也被认为是递增的。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 首先找到第一个满足 \\(a_{i}&gt;=a_{i+1}\\) 的下标 \\(i\\)。如果 \\(i=n-1\\)，则表示可以移除任意子数组，直接返回 \\(\\frac{n(n-1)}{2}\\)。否则，我们需要移除一个子数组使得剩余前缀和后缀分别递增，并且前缀的右端点小于后缀的左端点。可以使用双指针，一个指针枚举后缀的左端点 \\(j\\)，另一个指针从 \\(i\\) 开始左移，寻找满足条件的前缀的右端点 \\(i\\)，然后将 \\(i+2\\) 添加到答案中，重复此过程直到 \\(a_{j}&gt;=a_{j+1}\\)。","link":"/2023/12/26/%E7%AC%AC%20120%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B/"},{"title":"第 377 场力扣周赛","text":"移除栅栏得到的正方形田地的最大面积题目 输入整数 \\(m\\) 和 \\(n\\)，表示宽为 \\(m\\) 长为 \\(n\\) 的矩形，左上角为 \\((1,1)\\)，右下角为 \\((m,n)\\)。输入长度分别为 \\(p\\) 和 \\(q\\) 的数组 \\(a\\) 和 \\(b\\)，数组 \\(a\\) 中的数对矩形水平分割，数组 \\(b\\) 中的数对矩形垂直分割。输出从数组 \\(a\\) 和 \\(b\\) 中移除任意个数，所能够形成的最大正方形面积，结果对 \\(10^{9}+7\\) 取余。 数据范围：\\(3\\leq m,n\\leq 10^{9}\\)，\\(1\\leq p,q\\leq 600\\)，\\(1&lt;a_{i}&lt;m\\)，\\(1&lt;b_{i}&lt;n\\)。 思路 首先考虑对于宽来说，能够表示的长度是多少。显然，可以通过二重循环枚举出所有可能的长度。将宽能够表示的长度放入哈希表，然后同样使用二重循环枚举长能够表示的长度（假设当前枚举到长度 \\(x\\)），如果该长度在哈希表中，则说明可以形成长度为 \\(x\\) 的正方形。最后输出最大值即可。 转换字符串的最小成本 II题目 输入长度为 \\(n\\) 的字符串 \\(source\\) 和 \\(target\\)，以及长度为 \\(m\\) 的字符串数组 \\(original\\)、\\(changed\\) 和 \\(cost\\)。其中 \\(cost[i]\\) 表示将字符串 \\(original[i]\\) 替换为 \\(changed[i]\\) 的成本。输出将 \\(source\\) 转换为 \\(target\\) 所需的最小成本，如果无法转换则输出 \\(-1\\)。任意两个替换操作所替换的区间要么相同，要么不相交。 数据范围：\\(1\\leq n\\leq 1000\\)，\\(1\\leq m\\leq 100\\)，\\(1\\leq \\operatorname{len}(original[i])=\\operatorname{len}(changed[i])\\leq n\\)。 思路 首先使用哈希表将 \\(original\\) 和 \\(changed\\) 数组中的字符串映射为数字，每个数字都作为图中的一个顶点。对于每个下标 \\(i\\)，建立一条从顶点 \\(original[i]\\) 到顶点 \\(changed[i]\\) 的边，然后使用 Floyd 算法求出多源最短路径。最后使用动态规划，定义 \\(dp[i+1]\\) 为对 \\(source\\) 的前缀 \\([0,i]\\) 做替换使其和 \\(target\\) 的前缀 \\([0,i]\\) 相等，所需的最小代价。注意，外层循环枚举前缀的右端点 \\(i\\)，内层循环枚举 \\(original\\) 数组，总时间复杂度为 \\(O(m^{3}+n^{2}m)\\)。使用字典树会更快，参考灵神题解。","link":"/2023/12/26/%E7%AC%AC%20377%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Codeforces Round 917 (Div. 2)","text":"Least Product题目 输入长度为 \\(n\\) 的数组 \\(a\\)，输出能够使 \\(\\prod_{i=1}^{n}{a_{i}}\\) 最小的最小操作次数。每次操作可以选择数组中的任意元素 \\(a_{i}\\)，如果 \\(a_{i}&lt;0\\)，则可以将其改为 \\([a_{i},0]\\) 中的任意整数，否则可以将其改为 \\([0,a_{i}]\\) 中的任意整数。 数据范围：\\(1\\leq n\\leq 100\\)，\\(-10^{9}\\leq a_{i}\\leq 10^{9}\\)。 思路 由于操作只会让所有元素乘积的绝对值变小，所以如果乘积是非正数，则不需要进行操作，否则只需进行一次操作，将任意一个元素改为 \\(0\\)。 Erase First or Second Letter题目 输入长度为 \\(n\\) 的字符串 \\(s\\)，输出进行任意次操作能够得到的不同非空字符串的个数。每次操作可以删除字符串的第一个字符或者第二个字符。 数据范围：\\(1\\leq n\\leq 10^{5}\\)。 思路 方法一：枚举剩余字符串的第一个字符下标 \\(i\\)，对于每个 \\(i\\) 都可以通过不断删除第二个字符得到 \\(n-i\\) 个不同的字符串。然后思考什么时候会出现相同的字符串，假设两次枚举的第一个字符分别为 \\(i\\) 和 \\(j\\)（\\(i&lt;j\\)），只有当 \\(s_{i}=s_{j}\\) 时才有可能出现相同字符串，进一步观察可以发现，对 \\(i\\) 操作得到的 \\(n-i\\) 个不同的字符串总是包含对 \\(j\\) 操作得到的 \\(n-j\\) 个不同的字符串。所以，假设字符串 \\(s\\) 中有 \\(m\\) 个不同的字符，每个字符第一次出现的位置分别为 \\(k_{0},k_{1},\\dots,k_{m-1}\\)，则答案为 \\(\\sum_{i=0}^{m-1}(n-k_{i})\\)。 方法二：枚举剩余字符串的第二个字符下标 \\(i\\)，对于每个 \\(i\\) 它的贡献为 \\([0,i-1]\\) 中不同字符的个数。 Watering an Array题目 输入长度为 \\(n\\) 的整数数组 \\(a\\)，长度为 \\(k\\) 的整数数组 \\(v\\)，以及整数 \\(d\\)。输出执行 \\(d\\) 次操作能够得到的最大分数。有两种类型的操作： 假设当前执行第 \\(i\\) 次操作，则将数组 \\(a\\) 的前缀 \\([a_{1},a_{b_{i}}]\\) 都加 \\(1\\)。其中 \\(b_{i}=v_{((i-1)\\bmod k)+1}\\)。 将 \\(a_{j}=j\\) 的元素个数加到分数中，然后将数组中的所有元素都置为 \\(0\\)。（下标从 \\(1\\) 开始） 数据范围：\\(1\\leq n\\leq 2000\\)，\\(1\\leq k\\leq 10^{5}\\)，\\(k\\leq d\\leq 10^{9}\\)，\\(0\\leq a_{i}\\leq n\\)，\\(1\\leq v_{i}\\leq n\\)。 思路 如果数组 \\(a\\) 中的元素都为 \\(0\\)，显然最大分数为 \\(\\lfloor\\frac{d}{2}\\rfloor\\)，对应的方案为交替执行两种操作。也就是说，解决问题的关键是确定何时第一次将数组 \\(a\\) 重置。这可以通过枚举实现，但是由于 \\(d\\) 很大，肯定不能直接枚举范围 \\([1,d]\\)。进一步观察可以发现，对前缀进行 \\(2n\\) 次加法，再重置最多得到 \\(n\\) 分，而先重置再交替执行操作，能够得到的分数大于等于 \\(n\\)，所以只需要枚举范围 \\([1,2n]\\)。 Yet Another Inversions Problem题目 输入长度为 \\(n\\) 的数组 \\(p\\)，表示 \\([1,2n-1]\\) 中所有奇数的一个排列。输入长度为 \\(k\\) 的数组 \\(q\\)，表示 \\([0,k-1]\\) 中所有整数的一个排列。定义长度为 \\(nk\\) 的数组 \\(a\\)，对于 \\(0\\leq i&lt;n\\) 和 \\(0\\leq j&lt;k\\)，有 \\(a_{i\\cdot k+j}=p_{i}\\cdot 2^{q_{j}}\\)。输出数组 \\(a\\) 的逆序数，结果对 \\(998244353\\) 取余。 数据范围：\\(1\\leq n,k\\leq 2\\cdot 10^{5}\\)，\\(1\\leq p_{i}\\leq 2n-1\\)，\\(0\\leq q_{i}&lt;k\\)。 思路 可以将数组看作 \\(n\\times k\\) 的矩阵，逆序数可以分为行内和行间。所有行的行内逆序数都是数组 \\(q\\) 的逆序数，使用归并排序或者树状数组即可求解，所以难点在如何快速求出行间的逆序数。首先尝试两两枚举所有行，然后观察对于确定的两个行，它们的逆序数有什么特点。由此可以发现，两行之间的逆序数大概是一个等差数列之和，项数和其他边界条件是由 \\(p_{i}\\) 和 \\(p_{j}\\) 的大小关系确定的。具体来说，假设 \\(p_{i}&lt;p_{j}\\)，等差数列是由满足 \\(p_{i}\\cdot 2^{z}&lt;p_{j}\\) 条件的最大的 \\(z\\) 确定的，确定 \\(z\\) 需要花费 \\(O(\\log{n})\\) 的时间。从而可以得到时间复杂度为 \\(O(n^{2}\\log{n}+k\\log{k})\\) 的朴素解法。（总是假设 \\(i&lt;j\\)） 下面解释等差数列是如何得到的，假设 \\(p_{i}\\cdot 2^{z}&lt;p_{j}\\)（\\(z\\geq0\\)），将对应的两行合并之后可以得到如下序列： $$ p_{i}\\cdot 2^{0},p_{i}\\cdot 2^{1},\\dots,p_{i}\\cdot 2^{z},p_{j}\\cdot 2^{0},p_{i}\\cdot 2^{z+1},p_{j}\\cdot 2^{1},\\dots,p_{i}\\cdot 2^{k-1},p_{j}\\cdot 2^{k-z-1},\\dots,p_{j}\\cdot 2^{k-1} $$ 要求逆序数，可以通过对每个 \\(p_{i}\\) 项前面有多少个 \\(p_{j}\\) 项计数，然后求和得到。可以发现，\\(p_{i}\\cdot 2^{z+1}\\) 前面有 \\(1\\) 个 \\(p_{j}\\) 项，\\(p_{i}\\cdot 2^{z+2}\\) 前面有 \\(2\\) 个 \\(p_{j}\\) 项，\\(p_{i}\\cdot 2^{k-1}\\) 前面有 \\(k-1-z\\) 个 \\(p_{j}\\) 项。得到逆序数为 \\(\\frac{(k-z)(k-1-z)}{2}\\)。 同理，假设 \\(p_{j}\\cdot 2^{z}&lt;p_{i}\\)（\\(z\\geq0\\)），将对应的两行合并之后可以得到如下序列： $$ p_{j}\\cdot 2^{0},p_{j}\\cdot 2^{1},\\dots,p_{j}\\cdot 2^{z},p_{i}\\cdot 2^{0},p_{j}\\cdot 2^{z+1},p_{i}\\cdot 2^{1},\\dots,p_{j}\\cdot 2^{k-1},p_{i}\\cdot 2^{k-z-1},\\dots,p_{i}\\cdot 2^{k-1} $$ 可以发现，\\(p_{i}\\cdot 2^{k-z-1}\\) 到 \\(p_{i}\\cdot 2^{k-1}\\) 的逆序数都为 \\(k\\)，总和为 \\(k(z+1)\\)。剩余部分的逆序数构成首项为 \\(z+1\\)，尾项为 \\(k-1\\)，公差为 \\(1\\) 的等差数列，总和为 \\(\\frac{(k+z)(k-1-z)}{2}\\)。得到逆序数为 \\(\\frac{(k+z)(k-1-z)}{2}+k(z+1)\\)。 如何降低时间复杂度？通过上述分析，可以知道对于任意 \\(p_{i}\\) 和 \\(p_{j}\\)，它们之间的逆序数是由 \\(z\\) 决定的。也就是说，如果给定 \\(p_{i}\\) 和 \\(z\\)（\\(z\\) 为任意整数），对于任意满足 \\(p_{i}\\cdot 2^{z}&lt;p_{j}&lt;p_{i}\\cdot 2^{z+1}\\) 条件的 \\(p_{j}\\) 来说，\\(p_{i}\\) 和 \\(p_{j}\\) 之间的逆序数都是相同的。注意，当 \\(z&lt;0\\) 时，对不等式变形得到 \\(p_{i}\\cdot 2^{-1}&lt;p_{j}\\cdot 2^{-z-1}&lt;p_{i}\\)，此时的 \\(z\\) 和上面逆序数公式中的 \\(z\\) 不同，并且需要处理整数除法的舍入问题（存在一些边界情况）。 要快速求出区间中 \\(p_{j}\\) 的个数，可以使用树状数组/线段树，从而可以得到 \\(O(n\\log{\\min(\\log{n},k)}+k\\log{k})\\) 的解决方案。外层循环枚举 \\(p_{i}\\)（倒序遍历数组 \\(p\\)，因为之前的讨论都基于 \\(i&lt;j\\) 的假设），内层循环枚举 \\(z\\)（大小由 \\(n\\) 和 \\(k\\) 限制），然后使用树状数组求区间和，之后可以 \\(O(1)\\) 时间内计算出该区间的 \\(p_{j}\\) 和当前枚举的 \\(p_{i}\\) 之间的逆序数。 PS：还有另一种写法，只需要对树状数组的前缀求和，而不是区间求和，写起来好像更简单，但是没看懂。好难，溜了。","link":"/2023/12/26/Codeforces%20Round%20917%20(Div.%202)/"},{"title":"数据复制","text":"复制指在多个节点上存储相同的数据，以降低访问延迟（数据分布在多个地理位置），提高容错性和吞吐量。如果复制的数据一成不变，那么只需要简单地将数据复制到每个节点。然而复制的挑战在于如何处理不断变化的数据（如何保证数据的一致性），下面讨论三种流行的应对复制数据变化的方法：主从复制、多主复制和无主复制。 主从复制 工作原理 主从复制也被称为单主复制，客户端必须将写请求发送给主节点，主节点首先将更改应用到本地，然后再将更改发送给所有从节点。客户端可以将读请求发送给主节点或者从节点。 同步和异步复制 同步复制 优点：如果主节点发生故障，则可以在从节点访问到最新数据。 缺点：如果从节点发生故障，则主节点会被阻塞直到从节点复制完成。 异步复制 优点：主节点不会被阻塞，系统的吞吐量更大。 缺点：如果主节点发生不可恢复的故障，则所有未被复制到从节点的更改都会丢失。 实践中，通常只将一个从节点设置为同步模式，其他从节点设置为异步模式。如果主节点发生故障，则可以在同步的从节点访问到最新数据；如果同步的从节点发生故障，则可以将另一个异步的从节点升级为同步模式。这种配置方式被称为半同步。 配置新的从节点 当需要提高系统的容错性或者替换失效的从节点时，就需要增加新的从节点。此时如何保证新的从节点和主节点的数据一致？简单地将数据从主节点复制到从节点是不行的，因为数据在不断变化，这样可能会丢失更改。或者可以对数据库加写锁，但是这会违反高可用的设计目标。 实际上，可以在不中断数据库服务的情况下完成新的从节点的配置。步骤如下：对主节点的数据创建一个一致性快照，将此快照复制到从节点，然后从节点向主节点请求快照之后的更改日志（根据快照中的 LSN 确定），获得日志之后重做日志的更改（这个步骤称为追赶）。 处理节点失效 从节点失效：追赶式恢复 如果从节点发生故障，然后顺利重启，或者主从节点之间的网络发生中断，则从节点可以通过向主节点请求故障期间的日志，并且将日志应用到本地来追赶主节点，从而恢复正常状态。 主节点失效：节点切换 如果主节点发生故障，选择某个从节点将其升级为主节点，同时更新客户端的主节点的信息。切换可以手动进行，也可以自动进行。 自动切换的步骤如下： 确认主节点失效（心跳检测）。 选举新的主节点（共识算法）。 重新配置系统使新主节点生效（修改客户端配置以及原主节点上线之后降级为从节点）。 切换过程存在的问题： 如果使用了异步复制，并且新的主节点并未和原主节点同步，则原主节点上线之后可能会尝试将未完成复制的更改发送到新的主节点，从而产生冲突。常见的解决方案是将未完成复制的更改丢弃，这会违背持久化的承诺。 如果有外部系统依赖于数据库的内容，丢弃数据的方案会产生很严重的问题（可能会导致数据泄露）。 在某些故障下，会发生两个节点同时都认为自己是主节点的情况（称为脑裂），这可能会导致数据丢失或者破坏。 如何设置合适的超时时间来检测主节点失效。 复制日志的实现 原书中描述的是基于语句的复制，基于预写日志的复制，基于行的逻辑日志的复制等。下面将预写日志改为物理日志，将语句和行归为逻辑日志。之所以这样，是因为根据我所看过的一些资料（包括 CMU-15445）都将语句归为逻辑日志，而基于行的复制根据书上的说法，它和存储引擎解耦，同时书上也称其为基于行的逻辑日志的复制，所以我将两者都归为逻辑日志。而把预写日志改为物理日志，是因为书上说预写日志描述的是数据的字节级更改，按照这个说法，明显是预写日志的物理日志模式（CMU-15445 中描述了预写日志的三个日志模式：物理日志，逻辑日志，混合日志）。 基于物理日志的复制 解释：主节点将物理日志发送给从节点。 缺点：由于物理日志描述的是数据的字节级更改，这种复制方案和存储引擎紧密耦合，此时主从节点必须使用相同版本的存储引擎。所以在进行数据库升级时，只能首先将主从节点停机，再进行升级。如果复制方案允许从节点的版本比主节点更高，则可以首先将从节点升级，然后将从节点作为新的主节点，从而实现不停机升级。 基于逻辑日志的复制 解释：分为基于语句的复制和基于行的复制，主节点将逻辑日志（和物理存储引擎解耦的日志格式）发送给从节点。 缺点：如果使用基于语句的复制，则某些语句可能在不同节点产生不同的执行结果。例如：语句使用非确定性函数（NOW，RAND），语句依赖于数据库现有数据，有副作用的语句（触发器、存储过程、用户定义的函数）。 优点：主从节点可以运行不同版本的存储引擎，甚至是不同的存储引擎。对于外部应用程序，逻辑日志格式也更容易解析。 基于触发器的复制 解释：之前的复制都是由 DBMS 实现的，但在某些情况下可能需要更高的灵活性，这时需要将复制交给应用程序实现。一种方法是让应用程序读取数据库日志从而获取数据更改，另一种方法是使用触发器和存储过程，当发生数据更改时自动执行存储过程，将数据更改记录到单独的表中，应用程序通过访问该表来获取数据更改。 分析：此复制方式开销更高，也更容易出错或者暴露一些限制，但是具有更高的灵活性。 复制滞后问题 如果使用异步复制，则会出现主节点和从节点的数据不一致的情况，这种不一致只是暂时的状态。如果停止写数据库，则从节点最终会追赶上主节点，这被称为最终一致性。虽然主从节点最终会保持一致，但是暂时的不一致会引发各种问题，下面将讨论相关问题和解决方案。 写后读 问题：用户写入数据之后立即读取这些数据，如果读请求被发送给滞后的从节点，则用户看不到刚才写入的数据。 解决：此时，我们需要保证写后读一致性（也称为读写一致性），该一致性要求用户能够立即看到自己最近写入的数据，但是不保证其他用户能够立即看到这些数据。系统可以通过跟踪用户最近写入的时间戳，来保证将读请求发送给包含对应数据的节点。 单调读 问题：用户执行两次相同的查询，对应的读请求分别被路由两个不同的从节点，并且第二次查询访问的从节点比第一次查询访问的从节点更滞后。这会导致用户首先看到新数据，然后看到旧数据，就好像数据被回滚一样。 解决：此时，我们需要保证单调读一致性，该一致性要求用户进行多次读取时，不会先读到新数据再读到旧数据，即读取的数据对应的时间戳是单调递增的。系统可以总是将同一用户的读请求路由到同一个节点来保证单调读。 前缀读 问题：存在因果关系的数据被划分到不同的分区，用户在读取数据时可能会先看到果后看到因。 解决：此时，我们需要保证前缀读一致性，该一致性要求按照写入数据的顺序读取数据。对于未分区的单主数据库而言，数据总是按照因果关系的顺序写入数据库[1]，在读取数据时也总是按照因果关系的顺序读取，因此不会发生该异常。但是，如果数据被划分到不同分区，不同分区独立运行，无法保证分区之间的从节点按照因果关系的顺序写入数据[2]，此时将会发生异常。简单的想法是在复制日志中记录时间戳，但是由于存在时钟偏差问题，该方法不可行。一种解决方案是将具有因果关系的写入都交给一个分区完成，但是这样做的效率很低。另一种解决方案是使用版本向量技术跟踪因果关系，这将在无主复制的检测并发写中进行讨论。PS：这部分是按照我的理解描述的，可能存在错误。 多主复制 工作原理 系统中包含多个主节点，每个主节点都可以接收写请求，并且需要将更改发送给其他主节点和自己的从节点。 使用场景 多数据中心：为了容忍数据中心级别的故障或者使数据库更接近用户，可以把数据库的副本存储在多个数据中心。如果使用主从复制，主节点只能存在于某个数据中心，所有写请求都必须经过该数据中心。如果使用多主复制，则可以为每个数据中心设置一个主节点，在数据中心内部使用主从复制，主节点之间通常使用异步复制进行同步。 多主复制相比主从复制在多数据中心场景下的优势：写入延迟更低，对网络性能的依赖更低，能够容忍数据中心失效。缺点是，如果使用异步复制，多个主节点同时更改相同的数据时会产生写冲突。 处理写冲突 冲突检测 如果使用异步复制，那么多个主节点可以同时更改相同的数据，并且只能在稍后的复制过程中检测到冲突。 如果使用同步复制，每次只能进行一个写请求，无法发挥多个主节点的优势，那还不如直接使用主从复制。 冲突避免 可以在应用层保证对相同数据的写请求路由到相同的数据中心，但是在某些时候需要改变事先指定的数据中心，例如在数据中心故障或者用户移动到其他位置导致离某个数据中心更近时，写请求将会被路由到其他数据中心。 冲突解决 可能的解决方式如下： 为每个写请求分配唯一的 ID（时间戳、随机数、UUID、哈希值），然后按照某种规则选择特定的写请求。 为每个节点分配唯一的 ID，然后按照某种规则确定优先级。 将多个写入的值合并。 保存冲突信息，然后在应用层解决冲突。 在应用层解决冲突是最合理的方式，可以在写入时调用用户定义的冲突处理程序解决，还可以保留多个写入值，然后在读取时调用程序或者通知用户解决。还有一些自动解决冲突的方法，包括使用无冲突的复制数据类型（CRDT）、可合并的持久数据结构、操作转换算法。 拓扑结构 复制的拓扑结构描述了写日志从一个节点传播到其他节点的通信路径，包括全部至全部型拓扑（完全图）、环形拓扑、星形拓扑等。在环形和星形拓扑中，写日志需要经过多个节点才能传播到所有节点，为了避免循环复制（自己的写日志被传播给自己，然后又进行一轮传播），在复制日志中都会记录已传播节点的标识符。 星形和环形拓扑的问题是单点故障会影响写日志的传播，这可以通过在故障时重新配置拓扑结构解决。而全部至全部型拓扑的问题是在传播时写日志的因果顺序无法保证（参考复制滞后问题中的前缀读）。 无主复制 工作原理 客户端并行地将写请求发送给多个节点，如果得到多数节点的确认，则认为写入成功。读取时也是并行地从多个节点上读取数据，此时可能得到多个不同的值（由于复制滞后），系统会使用某种机制确定新值以及更新旧值。 读修复和反熵 当节点失效之后重新上线，可以使用以下两种机制进行追赶。 读修复 解释：客户端并行读取多个节点，获取的数据中包含版本号，以判断数据的新旧，同时会更新包含旧数据的节点。 分析：该方法适合读密集的场景，不然包含旧数据的节点得不到更新。 反熵 解释：使用后台进程检测节点之间数据的差异，然后将新数据复制到包含旧数据的节点。 分析：和基于主节点的复制不同，此过程不保证按照特定的顺序复制数据，并且会引入明显的滞后。 读写仲裁（quorum） 如果有 \\(n\\) 个节点参与仲裁，写入时需要得到 \\(w\\) 个节点的确认，读取时至少查询 \\(r\\) 个节点，则只要 \\(w+r&gt;n\\)，读取的节点中就一定会包含最新值。满足该条件的读/写操作被称为仲裁读/写（或者法定票数读/写），可以将 \\(w\\) 和 \\(r\\) 看作是确认读/写操作是否有效的最低票数。 通常会将 \\(n\\) 设置为奇数，将 \\(w\\) 和 \\(r\\) 设置为 \\(\\frac{n+1}{2}\\)。当然也可以根据实际情况做调整，例如对于读多写少的负载，设置 \\(w=n\\) 和 \\(r=1\\) 比较合适，这样读取速度很快，但是只要有一个节点失效就会导致仲裁写失败。 通常读/写请求总是并行发送给所有节点，参数 \\(w\\) 和 \\(r\\) 只是决定要等待的节点数。如果可用的节点数小于 \\(w\\) 或 \\(r\\)，则读/写操作就会返回错误。 也可以将 \\(w\\) 和 \\(r\\) 设置为较小的值，使得 \\(w+r\\leq n\\)，不满足仲裁条件。此时可能读取到的值都是旧值，但是可用获得更低的延迟和更高的可用性。即使在 \\(w+r&gt;n\\) 的情况下，也可能存在只读取到旧值的边界条件。 如果需要更高的容错性，可用使用宽松的读写仲裁：写入和读取仍需要 \\(w\\) 和 \\(r\\) 个节点确认，但是可以利用 \\(n\\) 个节点之外的其它节点（参与仲裁的节点数量为 \\(n\\)，集群中的节点数量大于 \\(n\\)）。例如，当 \\(n\\) 个节点中的多数节点失效时，客户端会向额外的节点发送读/写请求，当失效节点重新上线时，将额外节点中的新值复制到这些滞后的节点。 检测并发写 和多主复制类似，无主复制同样存在写冲突。在多主复制的处理写冲突中介绍过，可以为每个写请求分配一个时间戳，然后选择保留时间戳最大的写请求，这被称为最后写入者获胜（last write wins，LWW）。LWW 可以实现最终一致性，代价是牺牲数据的持久性，因为小于最大时间戳的并发写入都会被覆盖，由于时钟偏差，该算法甚至可能覆盖非并发写入。是否使用该算法依据实际场景而定，例如在缓存系统中覆盖是可以接受的，则可以使用该算法。 我们可以使用版本向量技术来判断两个写操作是否并发。如果一个写操作发生在另一个写操作之前（依赖关系/因果关系），则后面的写操作可以覆盖前面的写操作。如果是并发的，就需要处理写冲突问题。算法的工作流程见书上，本质上就是通过在写之前读，来获取数据的当前值以及版本向量（该数据在所有节点上的版本号的集合），之后的写操作只会覆盖服务器中低版本的数据，从而并发写（高版本）的数据得到保留。PS：书上只是简单提了一下，还有很多细节没说。 首先因被写入数据库，然后因被读取，从而产生果，之后果才被写入数据库。 ↩︎ 参考注 1，分区之间的主节点总是按照因果关系的顺序写入数据，但是分区之间的从节点就无法保证写入顺序。 ↩︎","link":"/2023/12/27/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/"},{"title":"数据分区","text":"分区/分片（动词）就是将数据拆分为多个子集，一个子集被称为一个分区[1]（名词）。使用数据分区的目的是提高可扩展性，不同分区可以存储在不同节点上，查询负载也随之分散到多个节点。在面对海量数据集或者非常高的查询压力，使用数据复制还不够，这时就需要使用数据分区。当分区和复制结合使用时（假设为主从复制），每个分区都会有自己的主节点和从节点，这种情况下单个节点也会存储多个分区的数据（作为某个分区的主节点和其他分区的从节点）。 分区方式 最好的情况是将数据和查询负载均匀分布到所有节点。如果分区不均匀，就会出现负载的倾斜，这会导致分区的效率下降。极端情况下，所有负载都集中在单个节点上，其他节点都处于空闲状态，此时这个节点被称为系统的热点。避免热点的最简单的方法是将记录随机分配给所有节点，但是由于不知道数据的分布情况，在查询时需要访问所有节点。下面将会介绍对键值数据和二级索引进行分区的方式。 这节的内容看得有点懵。按我的理解，键（key）也被称为关键字（keyword），它是一列或多列属性的集合，可以是唯一的或者不唯一的。但是按照书中的描述以及我在网上看到的定义来说，在“键值数据”这样的词中，似乎要求键必须是唯一的。书中在介绍完键值数据之后，又紧接着介绍二级索引，然后说二级索引在分区时的复杂性在于索引键的不唯一。但是书中接下来的讨论让我感觉，二级索引在分区时的复杂性在于如何创建二级索引，即是创建本地索引还是全局索引。 键值数据 基于区间的分区 解释：可以为每个分区分配一个关键字区间，区间可以由管理员手动选择，或者由数据库自动选择。 优点：分区内的数据可以按照关键字排序存储，从而支持区间查询。 缺点：如果查询集中访问某个范围内的数据，则会导致热点问题，解决方案是使用额外的内容作为关键字的第一列。 基于哈希的分区 解释：可以为每个分区分配一个哈希值区间，关键字根据哈希值进行分区，用于分区的哈希函数不需要很强的加密性。 分析：可以将关键字均匀的分配到多个分区，但是不能很好地支持关键字上的区间查询（查询时需要将请求发送给所有分区）。如果使用的是联合关键字，则可以只将关键字的第一列用于哈希分区，然后将其他列用作联合索引来对分区内的数据排序，从而可以在关键字的其他列上实现区间查询。 问答：为什么要将哈希值拆分为区间，而不直接使用取模操作？因为如果添加/删除节点，取模会导致大量的数据迁移。 负载倾斜与热点 虽然哈希分区可以减轻热点，但是无法完全避免。极端情况下，所有读/写操作都是针对一个关键字，则最终所有请求都会被路由到同一个分区。例如，发生热点事件时，会产生大量对相同关键字的读/写操作，此时哈希分区起不到作用。大多数系统至今仍无法自动消除这种高度倾斜的负载，而只能通过应用层来减轻倾斜程度。例如，如果某个关键字被认为是热点，则可以通过在关键字的开头或结尾添加随机数（有点像密码学中的盐值），从而将请求路由到不同分区。但是，此时读操作必须将多个分区中的数据合并，开销较大。 二级索引 基于文档的分区 解释：每个分区独自创建和维护二级索引，创建的是本地索引，而非全局索引。 缺点：如果要使用索引查询满足某个条件的数据，则需要将查询请求发送给所有分区，然后合并返回的结果。 基于词条的分区 解释：对所有数据创建全局索引，然后对索引进行分区，可以使用区间或哈希分区。 优点：进行单关键字查询时，只需要读取单个分区，因为相同的索引键都会被分配到相同的节点。 缺点：即使更新的是单个节点上的数据，可能也需要更新多个节点上的索引。如果选择同步更新，那么需要分布式事务的支持，写请求会被阻塞；如果选择异步更新，就意味着更新的滞后。 分区再平衡 在某些情况下，可能需要为数据库添加/删除节点，我们希望在添加/删除节点的过程中平衡所有节点的负载，这个迁移负载的过程被称为再平衡或者动态平衡。 再平衡的策略 固定数量的分区 解释：创建远超实际节点数的固定数量的分区，然后为每个节点分配多个分区。如果添加节点，则从每个现有节点中移动几个分区到新节点；如果删除节点，则将其中的分区均匀分配给剩余节点。也可以将硬件配置考虑进来，为性能更强的节点分配更多的分区。 分析：如果数据的规模不确定，就很难确定合适的分区数量。每个分区包含的数据量的上限是固定的，实际大小应该和集群中的数据总量成正比。如果分区数量太大，则每个分区包含的数据量太小，徒增管理开销；如果分区数量太小，则每个分区包含的数据量太大，再平衡和故障恢复的开销就更大（不是很懂为什么）。 动态分区 解释：为每个分区设置阈值，如果分区中的数据量太大或太小，就会进行分裂或合并（类似 B+ 树）。每个节点可以包含多个分区，当某个分区分裂时，可以将其中一半的数据转移到其他节点，以平衡负载。 分析：优点是分区的数量可以通过分裂和合并自动适配数据总量。对于空的数据库来说，需要进行预分裂，从而避免开始时只存在一个分区，导致负载不均衡的情况。 按节点比例分区 解释：为每个节点分配固定数量的分区。如果添加节点，则随机选择固定数量的现有分区进行分裂。 分析：随机选择可能会带来不公平的分裂，但是当每个节点包含的分区数量较大时，可以减少不公平的概率。 疑问：为什么书上说随机选择分区边界的前提是使用哈希分区，以及为什么说该方法符合一致性哈希。 请求路由 我们已经知道如何将数据分区，以及如何平衡节点上的分区，现在还有一个问题是，如何将请求路由到对应分区所在的节点。如果发生分区再平衡，分区和节点的对应关系还会随之变化，我们需要能够跟踪这些变化。有如下三种处理策略： 客户端将请求发送给任意节点，如果当前节点没有对应的分区，则将请求转发给其他节点，直到找到对应节点。 客户端将请求发送给路由层（负载均衡器），路由层负责将请求转发给对应节点。 客户端跟踪分区和节点之间的关系，直接将请求发送给对应节点。 不管使用哪种方法，核心问题是：作出路由决策的组件（节点、路由器、客户端）如何跟踪分区和节点的对应关系。有的分布式系统依靠独立的协调服务（例如 ZooKeeper）跟踪对应关系，有的使用 gossip 协议在节点之间同步对应关系，等等。 PS：数据分区这章看得有点痛苦，感觉书上的表述很乱，包括多个同义词混用，以及前后表述不一致。一些部分也讲得很模糊，没有一个实际的例子，单是看某句话感觉会有歧义，不知道实际上想表达的是什么。先这样吧，总感觉笔记上有很多问题。 这里讨论的数据分区和网络分区问题（一种节点间的网络故障）中的分区是不同的概念。 ↩︎","link":"/2023/12/29/%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/"},{"title":"Good Bye 2023","text":"Two Divisors 题目 输入两个整数 \\(a\\) 和 \\(b\\)，它们是 \\(x\\) 的最大除数，满足 \\(1\\leq a\\leq b&lt;x\\)。输出 \\(x\\) 的值。 数据范围：\\(1\\leq a\\leq b&lt;x\\leq 10^{9}\\)。 思路 首先 \\(b\\) 肯定等于 \\(x\\) 除以最小的质因数，然后 \\(a\\) 可能等于 \\(x\\) 除以两次最小的质因数，或者等于 \\(x\\) 除以次小的质因数。这可以根据 \\(b\\bmod a\\) 是否等于 \\(0\\) 来确定，如果是则 \\(x=b\\times\\frac{b}{a}\\)，否则 \\(x=b\\times\\frac{a}{\\gcd(a,b)}\\)。 Mathematical Problem 题目 输入奇数 \\(n\\)，输出 \\(n\\) 个不同的数，它们都是整数的平方，并且 \\(n\\) 个数的数位构成的多重集合都相同。 数据范围：\\(1\\leq n\\leq 99\\)。 思路 只需要在 \\(169,196,961\\) 的基础上添加 \\(0\\) 就可以构造出满足条件的 \\(n\\) 个数，方法直接看题解或者代码吧，反正 \\(169\\) 和 \\(961\\) 这两个数比较特殊，真不知道大家怎么做出来的。","link":"/2023/12/31/Good%20Bye%202023/"},{"title":"第 378 场力扣周赛","text":"找出出现至少三次的最长特殊子字符串 II 题目 输入长度为 \\(n\\) 的由小写字母组成的字符串 \\(s\\)。如果一个字符串仅由单一字符组成，则它被称为特殊字符串。输出在 \\(s\\) 中出现至少三次的最长特殊非空子字符串的长度，如果不存在则输出 \\(-1\\)。 数据范围：\\(3\\leq n\\leq 5\\times 10^{5}\\)。 思路 可以直接想到二分答案，时间复杂度为 \\(O(n\\log{n})\\)。不过该题有 \\(O(n)\\) 的做法，其实就是分类讨论。首先遍历一边数组，将数组按照字母分段，把对应的长度存到桶中。假设字符串 \\(s\\) 的最长特殊子字符串的长度为 \\(m\\)，则答案必定在 \\([m-2,m]\\) 范围内，枚举答案然后判断是否满足条件即可。当然还可以像灵神一样讨论得更细，但是不好理解。 回文串重新排列查询 题目 输入长度为偶数 \\(n\\) 的字符串 \\(s\\)，以及长度为 \\(m\\) 的二维数组 \\(q\\)，其中 \\(q_{i}=[a_{i},b_{i},c_{i},d_{i}]\\)。对于每个查询 \\(i\\)，可以将区间 \\([a_{i},b_{i}]\\) 和 \\([c_{i},d_{i}]\\) 中的字符重新排列，输出是否能让字符串 \\(s\\) 变为回文串。每个查询是独立的。 数据范围：\\(2\\leq n\\leq 10^{5}\\)，\\(1\\leq m\\leq 10^{5}\\)，\\(0\\leq a_{i}\\leq b_{i}&lt;\\frac{n}{2}\\)，\\(\\frac{n}{2}\\leq c_{i}\\leq d_{i}&lt;n\\)。 思路 比赛时基本的思路是有的，就是没有实现出来。首先可以将后半段字符串反转，将原串当成两个字符串，这就将问题转化为判断操作之后两个字符串能否相等，从而简化实现。然后就是预处理前缀的字符计数（类似前缀和），最后对每个查询分类讨论，两个区间是相离、相交还是包含关系。个人觉得稍微复杂点的就是相交关系该如何判断，具体可以看题解区。","link":"/2023/12/31/%E7%AC%AC%20378%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"再见 2023","text":"时间过得好快！今年大概有 5 个月的时间都在搞算法，然后其他时间基本上每周都会打比赛，虽然对面试来说不应该花费这么多时间，但是我喜欢算法给我带来的反馈，以及比赛时能够高度集中注意力的状态。特别是绞尽脑汁然后 AC 的感觉，真的很棒。即使不会做，赛后也可以通过题解来学习。 力扣基本上可以稳定三题，上 2300 分之后就有点没状态，排名波动有点大。在打 CF 之前就听说，力扣分减 700 大概就是 CF 分，结果还真是这样。CF 思维题较多，前四题基本上不会使用很复杂的数据结构，如果能稳定四题就能到 1900 分吧。AtCoder 题目有点水，对我来说，基本上从 D 题开始才算正式进入比赛，但是经常简单题也没做出来。令人印象深刻的是，获得两次群主发的进步奖。 5 月份阅读完《OSTEP》，9、11 月份学习完课程 CMU 15-445，并且做完四个相关的项目，感觉还不错。12 月份阅读《DDIA》25%，然后摸鱼。6-8 月份，高数、线代、Linux、Java 虚拟机、Spring、设计模式雨露均沾，基本上没有特别深入的，当时有点急躁。总的来说，确实有做不少事，但是效率不高，目的不明确，缺乏实践，要做的事还有很多。","link":"/2023/12/31/%E5%86%8D%E8%A7%81%202023/"},{"title":"UNICODE 双向算法","text":"前段时间看到群友聊天，使用特殊的昵称能够让文字的顺序发生变化。我把昵称复制到 IDEA 里面，发现包含一个显示为 RLI 的字符。在网上查询之后，发现是 Unicode 为显示双向文本提供的一个特殊字符，功能是将之后的文本视为独立的从右到左的顺序。还有其他特殊的格式化字符，以及用于解析这些字符并正确显示文本顺序的 Unicode 双向算法。 1print(&quot;⁧;(&quot; 上面的文本在浏览器中会显示为 print(&quot;&quot;);，因为在第一个引号之后有一个 RLI 字符。如果在之后添加文字： 1print(&quot;⁧;(&quot;Hello World! 则会显示为 print(&quot;!Hello World&quot;);，具体的显示方式和双向算法的实现有关。介绍 Unicode 双向算法的两个网站：UNICODE BIDIRECTIONAL ALGORITHM，Unicode Bidirectional Algorithm basics。","link":"/2024/01/01/UNICODE%20%E5%8F%8C%E5%90%91%E7%AE%97%E6%B3%95/"},{"title":"MapReduce: Simplified Data Processing on Large Clusters","text":"阅读论文 MapReduce，做个总结，部分内容参考课程的笔记。 概念 MapReduce 是一个编程模型，用于处理和生成大型数据集。它将并行、容错、数据分布和负载均衡的复杂性隐藏在库中，使得没有任何并行和分布式系统经验的程序员可以轻松利用大型分布式系统的资源。 MapReduce 将计算（computation）抽象为 \\(Map\\) 和 \\(Reduce\\) 函数。通常，\\(Map\\) 函数处理一个键值对，生成一组中间键值对。然后 MapReduce 库将具有相同中间键的值存储在一个列表中，以迭代器的方式提供给 \\(Reduce\\) 函数，避免因为数据量太大从而溢出到磁盘。\\(Reduce\\) 函数处理一个中间键以及该键的值列表，然后将列表中的值合并。 以下是可以被抽象为 MapReduce 计算的问题：统计文档中单词的出现次数，Grep（模式匹配），倒排索引，排序等。 实现 MapReduce 的实现方式取决于使用场景，Google 的常见计算场景是通过交换式以太网连接的大型计算机集群，使用 GFS 管理存储在各个机器的磁盘上的数据。用户将作业（job）提交给调度系统，每个作业由多个任务（task）组成，通过调度系统映射到可用的机器上。有关场景的详细信息见论文，下面介绍基于该场景的 MapReduce 实现。 概述 用户程序在调用 \\(MapReduce\\) 函数之后，用户程序中的 MapReduce 库首先将输入文件划分为 \\(M\\) 块，通常每块 16-64 MB。然后将用户程序复制到集群的多个机器上运行，由一个 master 和多个 worker 组成，master 会将一个 map 任务或 reduce 任务分配给空闲的 worker。 GFS 将所有文件划分为 64 MB 的块，并且将每个块的多个副本存储在不同的机器上。MapReduce 的 master 将 map 任务分配给包含输入文件的机器，从而可以避免通过网络传输输入数据（节省网络带宽）。 map worker 从 GFS 中读取文件，解析键值对并将其传递给用户的 \\(Map\\) 函数。\\(Map\\) 函数生成的中间键值对会被分区函数划分为 \\(R\\) 个文件（每个 reduce 任务一个文件），存储在机器的本地磁盘。\\(R\\) 个中间文件的位置和大小信息会被发送给 master，然后 master 负责将这些信息发送给 reduce worker。 reduce worker 收到文件的位置和大小信息之后，使用远程过程调用（RPC）从 map worker 的磁盘读取文件。当 reduce worker 读取完 \\(M\\) 个中间文件时，它会将数据按照中间键排序，以使相同键的键值对彼此相邻。reduce worker 迭代已排序的数据，它将唯一键以及该键对应的值列表传递给用户的 \\(Reduce\\) 函数。\\(Reduce\\) 函数合并数据，将结果写入 GFS 中的一个文件（每个 reduce 任务一个文件）。PS：GFS 会将输出文件以多个副本块的形式存储在多个机器上。 当所有 map 和 reduce 任务完成之后，master 唤醒用户程序。此时，在用户程序中的 \\(MapReduce\\) 函数调用返回至用户代码。通常，用户不需要将这些文件合并，而是将这些文件作为另一个 MapReduce 作业的输入。 细节 Master 数据结构 对于每个 map 和 reduce 任务，master 会记录任务的状态（idle，in-progress，completed），以及非 idle 任务所在的 worker 的标识。对于每个 map 任务，master 会记录 \\(R\\) 个中间文件的位置和大小信息，总共记录 \\(M\\times R\\) 个信息。 容错 worker 失效 master 定期对每个 worker 执行 ping 操作，如果超时未响应则将其标记为失效。失效 worker 已完成的任何 map 任务、正在执行的 map 和 reduce 任务都会被重置为 idle 状态，从而可以分配给其他 worker。 已完成的 map 任务在 map worker 发生故障时需要重新执行，因为它们的输出存储在失效机器的本地磁盘上，无法被访问。而已完成的 reduce 任务将输出存储在 GFS 中，所以在发生故障时不需要重新执行。 当失效的 map worker A 被 map worker B 替代时，将会通知所有 reduce worker 重新执行，任何没有从 A 读取数据的 reduce 任务将会从 B 读取数据。PS：已从 A 读取数据的 reduce 任务该如何处理，论文没有说明。我的想法是，如果已读取完，则不会有问题。如果读取到一半，那么直接丢弃即可。 master 失效 定期持久化 master 数据结构的检查点（checkpoint），如果 master 失效，则可以从上一个检查点状态重新开始。论文中表示单个 master 失效的可能性不大，所以发生故障时会中止 MapReduce 计算。 PS：检查点和失效点之间的状态会丢失，有可能已完成的 map 任务没有被 master 持久记录已完成。如果持久状态是 idle，则会导致重新分配 map 任务。如果持久状态是 in-progress，则需要等待 worker 发送完成信息，但 worker 如何知道需要重新发送完成信息，这需要额外的机制。 任务粒度 一个 map 任务处理一个文件，生成 \\(R\\) 个中间文件，分别由 \\(R\\) 个 reduce 任务处理。理论上，\\(M\\) 和 \\(R\\) 的大小应该远大于 worker 的数量，从而分配更多的任务给较快的机器，以均衡负载。如果 worker 发生故障，还可以通过将任务分散到多个 worker 上来提升故障恢复的速度。 备份任务 由于 MapReduce 操作需要等待所有任务完成才能够继续推进，所以少数缓慢的机器（straggler）会拖慢整个操作。当 MapReduce 操作接近完成时，master 可以冗余执行剩余的任务，以缩短 MapReduce 的执行时间。 问题 Q：如果网络延迟导致 master 将 worker 标记为失效，master 如何处理旧 map worker 发送的中间文件信息？GFS 如何处理重复 reduce 任务的输出？ A：对于 map 任务，论文提到 master 会忽略 map 任务的重复完成消息，但是它是否会接收旧 worker 的消息，毕竟已经分配新 worker 重新执行该 map 任务。不论如何，只要保证 reduce 任务只从其中一个中间文件读取数据，就没有问题。对于 reduce 任务，输出首先被写入临时文件，当任务完成时再重命名为最终文件，GFS 提供原子重命名（使用锁），从而相同 reduce 任务只会有一个输出文件。 总结 论文在介绍完实现之后，还提出对实现的改进、测试实现在 Grep 和 Sort 场景的性能等。MapReduce 的成功主要在于，隐藏各种细节使得 MapReduce 易于使用，很多问题都可以表示为 MapReduce 计算，而且作者开发的 MapReduce 实现可以有效利用大型计算机集群的资源。从中可以学到：限制编程模型可以使并行和分布式计算更容易，使计算具有容错性；网络带宽是稀缺资源，使用局部性优化可以节省网络带宽；冗余执行可以减少缓慢机器的影响。","link":"/2024/01/06/MapReduce%20Simplified%20Data%20Processing%20on%20Large%20Clusters/"},{"title":"AtCoder Beginner Contest 335","text":"Non-Decreasing Colorful Path 题目 输入有 \\(n\\) 个顶点和 \\(m\\) 条边的连通的无向图（没有重边和自环），每个顶点上有一个整数 \\(A_{i}\\)，输出所有从顶点 \\(1\\) 到 \\(N\\) 的简单路径的最高得分。如果路径中顶点上的整数构成的序列非递减，那么该路径的得分为序列中不同整数的个数，否则得分为 \\(0\\)。 数据范围：\\(2\\leq n\\leq 2 \\times 10^{5}\\)，\\(1\\leq A_{i}\\leq 2\\times 10^{5}\\)。 思路 虽然是无向图，但是序列需要非递减才能有得分。进一步观察可以发现，对于一条非递减路径，所有包含相同整数的顶点只会贡献 \\(1\\) 个得分，我们可以将这些顶点缩为一个顶点。所以，只需要建立满足递增条件的有向边，如果边的两个顶点包含相同的整数，则使用并查集将它们连接（缩点）。然后问题就变为求 DAG 中两个顶点之间的最长路径，不过和一般的使用拓扑排序 + 动态规划来求解的方式不同，因为缩点的缘故，该题不是很好使用拓扑排序。由于 \\(A_{i}\\) 的范围比较小，从小到大枚举顶点整数，然后扩展以该整数为起点的边，结合动态规划可以比较方便的求出答案。实现时，需要注意起点和终点同样可能被缩点，使用时将其替换为并查集中所在连通块的根节点。","link":"/2024/01/07/AtCoder%20Beginner%20Contest%20335/"},{"title":"Hello 2024","text":"Grouping Increases 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，将数组 \\(a\\) 分割为两个子序列（可能为空），输出两个子序列中满足 \\(b_{i}&lt;b_{i+1}\\) 的下标 \\(i\\) 的数量之和的最小值。 数据范围：\\(1\\leq n\\leq 2\\times 10^{5}\\)，\\(1\\leq a_{i}\\leq n\\)。 思路 贪心。假设将数组 \\(a\\) 分割为数组 \\(b\\) 和 \\(c\\)，从空数组开始，将 \\(a\\) 中的元素添加到 \\(b\\) 或 \\(c\\)。假设 \\(b\\) 和 \\(c\\) 的最后一个元素分别为 \\(x\\) 和 \\(y\\)（\\(x\\leq y\\)），如果 \\(a_{i}\\leq x\\) 或 \\(a_{i}&gt;y\\)，则将 \\(a_{i}\\) 添加到 \\(b\\)，否则添加到 \\(c\\)。","link":"/2024/01/07/Hello%202024/"},{"title":"第 379 场力扣周赛","text":"移除后集合的最多元素数 题目 输入长度为偶数 \\(n\\) 的数组 \\(a\\) 和 \\(b\\)，输出从 \\(a\\) 和 \\(b\\) 中分别选择一半元素构成的集合的最大大小。 数据范围：\\(1\\leq n\\leq 2\\times 10^{4}\\)。 思路 要使集合尽可能大，肯定优先选择除 \\(a\\) 和 \\(b\\) 交集以外的元素，假设分别为 \\(x\\) 和 \\(y\\)，则可以选择 \\(s=\\min(x,\\frac{n}{2})+\\min(y,\\frac{n}{2})\\) 个不同元素。此时还有 \\(n-s\\) 个元素待选，假设交集的大小为 \\(z\\)，则答案为 \\(s+\\min(n-s,z)\\)。 执行操作后的最大分割数量 题目 输入长度为 \\(n\\) 的字符串 \\(s\\) 和一个整数 \\(k\\)，输出至多改变一个字符时，执行操作能够得到的最大分割数。每次操作可以分割 \\(s\\) 的最多包含 \\(k\\) 个不同字符的最长前缀。 数据范围：\\(1\\leq n\\leq 10^{4}\\)，\\(1\\leq k\\leq 26\\)。 思路 首先，很容易想到暴力做法，枚举每个位置的所有改变情况，然后通过遍历求分割数，时间复杂度为 \\(O(n^{2}|\\Sigma|\\log{|\\Sigma|})\\)。显然，可以优化的部分就是最后遍历求分割数的 \\(O(n\\log{|\\Sigma|})\\)。然后观察修改字符相比不修改字符会产生什么变化，可以发现修改字符所在的分割段的长度可能发生变化，而前缀的分割数是固定的。可以想到预处理原字符串每个位置 \\(i\\) 的后缀分割数，问题就剩下如何快速求得修改字符所在段的右端点。由于字符数随着长度的增加而增加，所以可以通过二分求得该段的右端点，这还需要花费 \\(O(n|\\Sigma|)\\) 的时间提前预处理出字符数的前缀和。最后，分割数为前缀 + 中间 + 后缀的段数。代码实现时，还有很多其他细节需要注意，强烈建议自己实现一下。","link":"/2024/01/07/%E7%AC%AC%20379%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"Threads and RPC","text":"参考 Go FAQ，crawler.go，kv.go，note。 Exercise: Web Crawler 串行爬虫 就是 DFS。 1234567891011121314func Serial(url string, fetcher Fetcher, fetched map[string]bool) { if fetched[url] { return } fetched[url] = true urls, err := fetcher.Fetch(url) if err != nil { return } for _, u := range urls { Serial(u, fetcher, fetched) } return} 并行爬虫 共享 + 锁 在 DFS 的基础上，同时启动多个线程来爬取网页，通过使用锁保护共享变量，使用计数器等待所有线程执行完成。如果网页很多，可能会创建非常多的线程，可以通过使用线程池限制线程的数量。 123456789101112131415161718192021222324252627282930313233343536type fetchState struct { mu sync.Mutex fetched map[string]bool}func (fs *fetchState) testAndSet(url string) bool { fs.mu.Lock() defer fs.mu.Unlock() r := fs.fetched[url] fs.fetched[url] = true return r}func ConcurrentMutex(url string, fetcher Fetcher, fs *fetchState) { if fs.testAndSet(url) { return } urls, err := fetcher.Fetch(url) if err != nil { return } var done sync.WaitGroup for _, u := range urls { done.Add(1) go func(u string) { defer done.Done() ConcurrentMutex(u, fetcher, fs) }(u) } done.Wait() return}func makeState() *fetchState { return &amp;fetchState{fetched: make(map[string]bool)}} 通道（channel） 使用 channel 实现同步，不需要 DFS，没有任何共享变量，自然也不需要使用锁（尽管 channel 内部会使用锁）。代码的组织方式有点像 MapReduce。 12345678910111213141516171819202122232425262728293031323334func worker(url string, ch chan []string, fetcher Fetcher) { urls, err := fetcher.Fetch(url) if err != nil { ch &lt;- []string{} } else { ch &lt;- urls }}func coordinator(ch chan []string, fetcher Fetcher) { n := 1 fetched := make(map[string]bool) for urls := range ch { for _, u := range urls { if fetched[u] == false { fetched[u] = true n += 1 go worker(u, ch, fetcher) } } n -= 1 if n == 0 { break } }}func ConcurrentChannel(url string, fetcher Fetcher) { ch := make(chan []string) go func() { ch &lt;- []string{url} }() coordinator(ch, fetcher)} Go RPC 远程过程调用（Remote procedure call，RPC），指程序调用的过程在远程计算机执行。通常表现为客户端向服务器发送请求，服务器向客户端返回响应。数据在通过网络传输时需要进行序列化和反序列化，序列化是将数据转换为可以存储或传输的格式的过程，反序列化是序列化的逆过程。远程过程调用和本地过程调用的区别在于，如何处理失败的情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//// Client//func connect() *rpc.Client { client, err := rpc.Dial(&quot;tcp&quot;, &quot;:1234&quot;) if err != nil { log.Fatal(&quot;dialing:&quot;, err) } return client}func get(key string) string { client := connect() args := GetArgs{&quot;subject&quot;} reply := GetReply{} err := client.Call(&quot;KV.Get&quot;, &amp;args, &amp;reply) if err != nil { log.Fatal(&quot;error:&quot;, err) } client.Close() return reply.Value}func put(key string, val string) { client := connect() args := PutArgs{&quot;subject&quot;, &quot;6.824&quot;} reply := PutReply{} err := client.Call(&quot;KV.Put&quot;, &amp;args, &amp;reply) if err != nil { log.Fatal(&quot;error:&quot;, err) } client.Close()}//// Server//type KV struct { mu sync.Mutex data map[string]string}func server() { kv := &amp;KV{data: map[string]string{}} rpcs := rpc.NewServer() rpcs.Register(kv) l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;) if e != nil { log.Fatal(&quot;listen error:&quot;, e) } go func() { for { conn, err := l.Accept() if err == nil { go rpcs.ServeConn(conn) } else { break } } l.Close() }()}func (kv *KV) Get(args *GetArgs, reply *GetReply) error { kv.mu.Lock() defer kv.mu.Unlock() reply.Value = kv.data[args.Key] return nil}func (kv *KV) Put(args *PutArgs, reply *PutReply) error { kv.mu.Lock() defer kv.mu.Unlock() kv.data[args.Key] = args.Value return nil} 其他问题 Q：为什么闭包函数可以使用外部函数的变量？ A：闭包函数引用的外部变量存储在堆中，所以当外部函数返回时，变量依旧存在，垃圾收集器会根据引用计数判断是否回收该变量。注意，如果需要引用循环中的变量，需要通过参数传递（值传递），因为外部变量会随循环变化。 Q：假设有两个线程，线程 A 使用条件变量等待某个条件，线程 B 在达到条件时通知线程 A。如果线程 B 在解锁之前通知线程 A 会有问题吗？ A：如果在解锁之前唤醒线程 A，假设线程 A 在 B 解锁之前被调度，那么线程 A 在获取锁时会被阻塞。之后的某个时刻，操作系统会调度线程 B 解锁，此时线程 A 可以重新被调度。注意，条件变量和锁的阻塞队列是独立的，所以不需要再次通知线程 A。","link":"/2024/01/10/Threads%20and%20RPC/"},{"title":"The Google File System","text":"阅读论文 GFS，参考 FAQ，note。 概念 GFS 是一个分布式文件系统，用于大型分布式数据密集型应用程序，例如 MapReduce。系统的设计基于以下场景： 系统由许多机器组成，所以会频繁发生故障。 GB 级别的文件很多，普通文件系统会将文件划分为很多块，不便管理。 读负载由大量顺序读和少量随机读组成，写负载由大量追加写和少量随机写组成。 高持续带宽比低延迟更重要，应用程序需要快速进行批处理，而对响应时间没有严格要求。 实现 GFS 集群由单个 master 和多个 chunkserver 组成，由多个客户端访问。文件被划分为 64 MB 的块（chunk），每个块都是 chunkserver 中的一个文件。在分配空间时使用懒分配策略，避免产生内部碎片从而浪费空间。master 在创建块时，会为其分配一个不可变且全局唯一的 64 位块句柄（chunk handle）。每个块都会被复制到多个 chunkserver 上（默认三个），以保证系统的可靠性。 master 主要负责维护系统的元数据、存储日志和检查点、租约管理以及控制垃圾收集、重新复制、负载均衡和快照创建。元数据包括命名空间、访问控制信息、从文件名到块句柄数组的映射，以及为每个块维护版本号和副本所在 chunkserver 的列表。master 通过心跳消息定期与 chunkserver 通信，向其发出指令和收集其状态。chunkserver 主要负责存储文件数据、版本号和校验和，64 MB 的 chunk 被划分为 64 KB 的 block，每个 block 都有一个 32 位的校验和。 链接到应用程序的 GFS 客户端代码实现文件系统 API，通过与 master 和 chunkserver 通信来代表应用程序读写数据。客户端从 master 获取元数据，从 chunkserver 获取文件数据。客户端不需要缓存文件数据（但会缓存元数据），因为负载通常是顺序读和追加写。客户端没有实现 POSIX API，因此不需要挂钩到 Linux vnode 层。PS：我没有查到 Linux vnode 相关的资料，vnode 似乎是 BSD 中的概念，和 VFS 有关。 块大小 Linux 文件系统的默认块大小为 4 KB，GFS 使用 64 MB 的块大小是基于其 GB 级文件场景而设计的，优势如下： 由于应用程序通常是顺序读写文件数据，所以 64 MB 的块大小可以减少客户端和 master 的交互次数。 许多操作会发生在同一个块中，使得客户端和 chunkserver 保持长 TCP 连接，有利于减少网络开销。 master 中的元数据更少，从而可以全部放入内存，避免磁盘 I/O。 同时，论文提到小文件可能只有一个块，面对多个应用程序的访问，存储该块的 chunkserver 有可能成为热点。GFS 的解决方案是使用更高的复制因子存储小文件，同时使批处理队列系统错开应用程序访问小文件的时间。潜在的解决方案是允许客户端在该情况下从其他客户端读取数据。 元数据 命名空间和映射会以操作日志（operation log）的形式持久化到 master 的本地磁盘和复制到远程机器，保证 master 能够在崩溃之后恢复。为保证一致性，只有在本地和远程将相应的日志刷新到磁盘之后，master 才会响应客户端的操作。可以对刷新和复制批处理，从而减少开销。当日志超过一定大小时，会创建检查点（使用 B 树），从而避免崩溃恢复时重放所有日志。由于创建检查点比较耗时，master 会切换到新的日志文件，并在单独的线程中创建检查点，以避免在创建检查点时停止执行（写）操作。检查点同样也会被复制到远程机器。 master 不会持久化块的位置列表，而是在启动时以及 chunkserver 加入集群时，向 chunkserver 询问其包含的块。因为块是否存在于某个 chunkserver 是由该 chunkserver 决定的，所以在 master 中持久化该信息没有任何意义，反而会面临同步问题。PS：说明 master 内存中的位置列表可能因为 chunkserver 故障，从而产生不一致。 命名空间其实就是一个将目录名和文件名作为节点的树，通过使用读写锁保证写操作的正确性。具体来说，读/写操作会获取路径上所有祖先节点的读锁，以及目标节点的读/写锁。锁在层级间按照自顶向下的顺序获取，在层级内按照字典序获取，从而避免死锁。PS：这让我想到 B+ 树的蟹行协议只锁定会被修改的节点，大概是因为 B+ 树的数据和路径不像文件和路径那样具有很强的关联性。 读操作 客户端使用固定的块大小，将应用程序指定的文件名和字节偏移量转换为文件内的块索引。然后，它向 master 发送包含文件名和块索引的请求，master 回复相应的块句柄（handle）、副本的位置列表，客户端使用文件名和块索引作为键来缓存该信息（会有过期时间）。 然后，客户端选择其中一个副本发送请求（很可能是距离最近的副本），该请求指定块句柄和块内字节范围。在缓存信息过期或重新打开文件之前，客户端不需要和 master 进行交互。客户端可以在向 master 发送的一个请求中请求多个块，master 也可以在回复中包含请求块之后的多个块信息（利用空间局部性），从而减少客户端和 master 交互的次数。 写操作 在发生写操作时，需要保证多个副本之间的一致性。GFS 使用租约（lease）实现一致性（租约是按块授予的），持有租约的 chunkserver 被称为 primary，其他包含副本的 chunkserver 被称为 secondary。租约的超时时间为 60 秒，primary 可以根据需要续约，续约请求包含在定期的心跳消息中发送给 master，master 也可以在租约到期之前撤销租约（用于快照创建）。如果 master 和 primary 发生网络分区故障，master 可以在旧租约到期之后向另一个副本授予租约，从而避免脑裂。 写操作的流程如下： 客户端首先向 master 询问 primary 和 secondary 的位置并将其缓存。如果 primary 不存在，则 master 任选一个包含副本的 chunkserver 授予租约。客户端会缓存位置信息，当 primary 不可达或者回复其租约过期时，客户端会重新联系 master。然后，客户端以流水线的方式将数据发送到 primary 和 secondary（存储在缓冲区中），并且等待它们的确认响应。 客户端收到所有副本的确认之后，向 primary 发送写请求，该请求会使用之前发送的数据。primary 为其收到的来自多个客户端的请求分配序列号（单个客户端的请求肯定是同步的，在收到响应之前不会发送第二个请求，因为 GFS 没法保证客户端请求的 FIFO 顺序），只有当 primary 本地执行成功之后，才会转发给所有 secondary，请求在所有副本上都按照序列号的顺序执行。当 primary 收到所有 secondary 的完成响应时，primary 回复客户端完成。 论文提到，副本的任何错误都会被报告给客户端，客户端会首先从步骤三开始重试几次，然后从步骤一开始重试。论文有一个前后矛盾的点，首先提到 primary 分配序列号然后应用到本地，之后又说如果在 primary 执行失败就不会分配序列号和转发。不过无关紧要。 一致性模型 GFS 具有宽松的一致性模型，数据突变之后文件区域的状态，取决于突变的类型（随机写和追加写）以及是否存在并发，如下图所示。如果无论客户端从哪个副本读取，始终看到相同的数据，则文件区域是一致的。如果文件区域一致，且客户端将会看到整个突变的内容，则文件区域是定义的。PS：这里的一致并不是严格一致性（可线性化）。 随机写：顺序突变成功状态是定义的和一致的；并发突变成功状态是一致的但是未定义，因为 GFS 使用租约保证突变以相同的顺序应用到所有副本（一致的），但是突变没有对文件区域加锁（未定义）。 追加写：不论是顺序还是并发突变成功，状态都是定义的，因为追加是原子操作且按照指定顺序应用到所有副本。只要有一个副本追加失败，客户端会重试整个追加操作，使得在未失败的机器上多次追加相同的数据，在失败的机器上填充无效的数据（因为追加会指定偏移量），从而产生不一致。特别的，追加的偏移量由 primary 指定，而不是单纯的追加到文件末尾，这可以保证多个副本在成功执行追加的偏移位置的数据是一致的，即使之前发生过失败。也就是说，中间区域不一致，最后区域一致。 此外，失败的突变总是会导致不一致。即使突变成功，数据最终一致，客户端仍可能观察到不一致，因为数据可以从任何包含副本的 chunkserver 读取。假设突变由客户端 A 发起，首先应用到 primary，再发送到 secondary。客户端 B 和 C 在突变过程中分别读取 primary 和 secondary，可以观察到不一致的情况。如果突变很慢，由于网络延迟或故障重试，单个客户端也可以观察到不一致。应用程序需要自行适应 GFS 的宽松一致性模型。 版本检测 如果 chunkserver 发生故障，从而错过突变，其上的块副本将会过时。master 和 chunkserver 会为块维护一个版本号，以此来区分新副本和旧副本。当 master 授予某个块租约时，它会递增该块的版本号，同时和 chunkserver 通信来递增最新副本的版本号。任何包含旧副本的 chunkserver 都不会返回给客户端，master 会在心跳检测中检查副本的版本，然后 master 会指示 chunkserver 对旧副本垃圾收集。作为额外的保护措施，master 会在回复客户端请求或指示 chunkserver 复制时包含版本号，客户端和 chunkserver 会在执行操作时进行验证。 故障处理 master 故障 当 master 发生故障时，GFS 的外部监控基础设施会使用检查点和日志快速恢复，即使磁盘发生故障也可以在其他机器上使用检查点和日志的副本进行恢复。客户端仅使用 DNS 别名访问 master（CNAME），其映射可以随时更改，以适应 master 机器的变更。此外，GFS 使用 shadow master 在 master 故障时提供对文件系统的只读访问，shadow master 略微滞后于 master。由于它存储的是元数据，文件数据存储在 chunkserver 中，所以客户端实际上不会读取到旧数据。 PS：论文提到 shadow master 会按顺序执行操作日志的副本，似乎 master 和 shadow master 的关系就是主从复制，但是为什么 shadow master 只提供只读访问，即使在 master 故障之后。它和 master 应该是最终一致的，为什么论文没有说 shadow master 在执行完所有日志之后会被提升为 master，虽然可以肯定需要人工操作，以避免原 master 只是网络分区故障，从而导致脑裂。 chunkserver 故障 master 使用心跳消息判断 chunkserver 是否存活，如果 master 判断 chunkserver 故障，它会指示其他 chunkserver 对不满足复制因子的数据块重新复制。当故障的 chunkserver 上线时，master 也会删除多余的副本，以及因错过突变而过时的副本。 其他功能 使用写时复制实现快照功能；跨机架的块放置策略；根据服务器的负载进行块放置和块迁移；根据优先级重新复制块以恢复冗余；延迟删除和垃圾收集；使用校验和检测数据块是否损坏；生成诊断日志（包含 chunkserver 的启动/关闭，RPC 的请求/回复记录，不包括文件数据）。 问题 Q：租约具体是如何工作的，master 和 chunkserver 如何判断租约是否过期？如何撤销租约？ A：论文没有说明，我猜测：master 首先发送授予租约的请求，chunkserver 收到请求之后开始计时，同时发送响应给 master，master 收到响应之后开始计时。这样 chunkserver 和 master 都可以判断租约是否到期，以及 master 的计时总是晚于 chunkserver，可以保证避免脑裂。撤销租约只修改 master 本地元数据肯定是不行的，因为客户端可能正在和持有租约的 chunkserver 通信，master 必须直接向 primary 发送撤销请求。 Q：根据上述猜测，如果授予租约的响应丢失，master 该如何处理？是否需要考虑时钟同步问题？ A：如果 master 没有收到响应，它就不会把该 chunkserver 记作 primary 返回给客户端，那么该租约实际上是一个无效租约，master 可以重试或者另选一个包含副本的 chunkserver。计算超时使用的是单调时钟，不需要同步。也可以使用时间戳判断租约是否到期，但是使用的是墙上时钟，需要服务器之间时钟同步。 总结 GFS 使用复制进行容错，从而引入多个副本间的一致性问题。但是仅保证宽松的一致性，而将问题交由应用程序处理，该设计基于其特殊的使用场景，顺序读写以及用于批处理，似乎强一致性显得不是很重要。可以查看课程的笔记和问答加深对论文的理解，笔记结尾的优缺点总结还是很不错的，有一个全局的视角，我有点过于关注一致性了。更多关于 GFS 的讨论，可以阅读 GFS: Evolution on Fast-forward。","link":"/2024/01/19/The%20Google%20File%20System/"},{"title":"The Design of a Practical System for Fault-Tolerant Virtual Machines","text":"阅读论文 Fault-Tolerant Virtual Machines，参考 FAQ，note。 概述 论文使用虚拟机、机器级别的主从复制（一主一从）和共享磁盘的方式设计容错系统，目前只支持单处理器的虚拟机。 有两种复制方式，状态转移复制和状态机复制。状态转移复制是将主节点的所有状态复制到从节点；而状态机复制要求节点是一个确定性状态机，不同节点从同一个状态以相同的顺序执行操作，可以得到相同的结果。 比较有意思的是，不像我所了解的常规数据复制，论文实现的系统使用机器级别的复制，状态包含 CPU、内存和 I/O 设备的状态，操作是 x86 指令。在机器级别上，状态转移复制的缺点是会将所有状态的更改通过网络进行传输，发送状态需要很多带宽；状态机复制使用更少的网络带宽，但是需要特殊处理非确定性操作（例如：获取时间、定时中断）来保证主从一致，这在物理服务器上很难实现，特别是当处理器频率增加时。 PS：时间是非确定的很好理解，但是定时中断为什么是非确定的，我的想法是虽然主从的状态是一致的（如果没有中断），但是执行速度也不是完全一致，所以中断的时机可能不同。 论文设计的系统使用状态机复制，利用虚拟机（VM）由虚拟机管理程序完全控制的特性，当主虚拟机执行非确定性操作时，虚拟机管理程序可以捕获必要的信息发送给从虚拟机，将非确定性操作转化为确定性操作，从而保证主从一致。只支持单处理器虚拟机，因为多处理器产生的并发操作是非确定性的，存在显著的性能问题。 主从虚拟机运行在不同的服务器上，从虚拟机和主虚拟机以相同的方式运行，并且总是有较小的延迟（小于 100 毫秒），课程讲义提到至少滞后一个日志项。只有主虚拟机在网络上发布其存在，输入（例如：网络、磁盘、键盘、鼠标）只会发送给主虚拟机，主虚拟机通过网络连接（称为日志通道，logging channel）将其转发给从虚拟机。同时，只有主虚拟机会产生输出，从虚拟机的输出将被虚拟机管理程序丢弃。 确定性重放 VMware FT 使用确定性重放，使从虚拟机能够通过重放日志达到和主虚拟机相同的状态。具体来说，主虚拟机的输入和非确定性操作都会被虚拟机管理程序捕获，然后生成日志（不会写入磁盘），发送给从虚拟机。对于非确定性操作，日志会记录必要的信息，保证主从一致。例如，对于中断操作，日志会记录操作发生时所完成的指令数量。论文提到该技术的实现有使用硬件性能计数器（HPC）。 特别注意，日志仅包含输入和非确定性操作相关的信息，确定性操作在从虚拟机的本地执行。具体来说，主虚拟机和从虚拟机都是状态机，会自动执行操作（由 VM 中的 Linux 和 App 发起，这也说明了为什么主从虚拟机的初始状态必须相同），只不过输入只会发送给主虚拟机，以及存在非确定性操作，所以输入和非确定性操作需要以日志的形式包含额外信息发送给从虚拟机。 容错协议 但是仅使用确定性重放还不够，需要额外的机制保证系统的容错性。如果主虚拟机在执行输出操作之后发生故障，而日志没有发送给从虚拟机，那么从虚拟机接管之后，在其输出之前的非确定性操作（未收到日志的）可能会得到不同的输出结果，从而产生不一致（不一致主要是针对客户端的感知而言）。 解决方案是在主虚拟机发送输出之前，向从虚拟机发送输出操作的日志并等待其确认，当从虚拟机接收到该输出操作及之前的所有日志之后，从虚拟机回复一个确认，然后主虚拟机可以向外部发送输出。注意，主虚拟机只是延迟发送输出，但是没有停止执行（即在等待输出的同时会继续执行其他操作，就像在某个线程等待磁盘 I/O 时会切换到其他线程一样）。该机制在主虚拟机发生故障时，可能会产生两次相同的输出，因为从虚拟机无法得知主虚拟机是否发送输出，但是论文随后提到 TCP 可以保证网络数据包的去重（我的理解是 TCP 是根据序列号去重的，由于主从虚拟机状态相同，所以会产生相同的序列号）。 故障检测和恢复 系统通过监控节点的心跳（使用 UDP），以及日志通道上的流量来判断节点是否发生故障（使用定时中断，保证流量不会停止）。 从虚拟机故障：主虚拟机继续执行，但是停止发送日志。 主虚拟机故障：从虚拟机重放日志以追赶主虚拟机，然后将从虚拟机提升为主虚拟机。VMware FT 会在网络上发布新的主虚拟机的 MAC 地址，以便交换机知道其位于哪个服务器上。 网络分区故障：主虚拟机可能由于网络问题和从虚拟机中断连接，如果此时将从虚拟机提升为主虚拟机，将会导致脑裂。为避免该问题，容错协议要求在检测到故障时，主从虚拟机需要在共享磁盘上执行 test-and-set 原子操作。操作成功的虚拟机作为主虚拟机存活，操作失败的虚拟机会自行中止。 不论是启动系统时，还是故障恢复时，都需要保证存在一个从虚拟机。VMware FT 使用 FT VMotion 功能，将虚拟机复制到集群中的某个服务器上（根据资源使用情况和其他约束条件选择）。该功能会建立从源虚拟机到目标虚拟机的日志通道，并且将源虚拟机设置为主虚拟机（记录日志模式），目标虚拟机设置为从虚拟机（重放日志模式）。该功能仅会中断源虚拟机小于 1 秒的时间，在复制的过程中源虚拟机仍会正常执行，日志会被存放在缓冲区中。 总结 论文介绍容错虚拟机的实现，还提到磁盘 I/O 和网络问题及其解决方案，不同设计的决策以及对各个负载的性能测试，详情参见论文。PS：课程讲义很不错，可以加深对论文内容的理解，我的理解还是太浅。","link":"/2024/01/23/The%20Design%20of%20a%20Practical%20System%20for%20Fault-Tolerant%20Virtual%20Machines/"},{"title":"第 382 场力扣周赛","text":"给定操作次数内使剩余元素的或值最小 题目 输入长度为 \\(n\\) 的整数数组 \\(nums\\) 和整数 \\(k\\)，输出执行至多 \\(k\\) 次操作之后，将数组中所有剩余元素按位或的最小值。每次操作可以选择一个下标 \\(i\\)，满足 \\(0\\leq i&lt;n\\)，将 \\(nums[i]\\) 和 \\(nums[i+1]\\) 替换为它们按位与的结果。注意，是两个数替换为一个数。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(0\\leq nums[i]&lt;2^{30}\\)，\\(0\\leq k&lt; n\\)。 思路 要使按位或的结果最小，肯定是从高位到低位消除。但是高位消除的方式会影响低位消除的方式，它们是相关的，不能单独计算每一位的操作次数。如果暴力枚举所有位的组合，会有 \\(2^{30}\\) 种情况，肯定会超时。如何计算？其实，只需要考虑从高位到低位的组合方式。从高位开始，能够消除的位总是应该被消除，然后判断加上更低的一位是否能被消除（保留相关性），如果不能，则该低位就永远不会被消除，以此类推。那么如何判断某个位的组合是否能被消除？从前往后遍历数组，贪心的将数组分割为若干按位与结果为 0 的子数组（假设为 \\(m\\)），则当前组合消除所需的操作次数为 \\(n-m\\)。具体可以看下灵茶山的题解和小羊的题解。","link":"/2024/01/28/%E7%AC%AC%20382%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"In Search of an Understandable Consensus Algorithm (Extended Version)","text":"阅读论文 Raft，参考 FAQ1，note1，FAQ2，note2。 概述 MapReduce 的 master、GFS 的 master 和 VM FT 的共享磁盘都存在单点故障（即使 GFS 的 master 存在副本，其依然是单点故障，因为故障时系统会停止），从而可以很简单的避免脑裂。脑裂会发生的根本原因在于，无法区分机器故障和网络分区故障。共识算法使用多数原则（仲裁协议，quorum），可以在复制的同时避免脑裂。如果集群中有 \\(2f+1\\) 个服务器，则共识算法可以容忍 \\(f\\) 个服务器故障。共识算法通常使用状态机复制，以复制日志的方式实现。客户端、服务器以及共识算法和状态机的关系见下图。 Raft 的主要设计目标是可理解性，通过分解问题和减少状态来实现。问题被分解为多个子集，例如：领导者选举、日志复制、安全性和成员变更。使用随机化超时时间、限制选举保证日志单向流动等方式，来减少状态。 实现 基础知识 服务器有三种状态：leader、follower、candidate，服务器初始时都是 follower。正常情况下，只有一个 leader 和多个 follower。只有 leader 会处理客户端的请求，如果客户端将请求发送给 follower，该 follower 会将其重定向到 leader。服务器之间使用远程过程调用（RPC）进行通信，基本的 Raft 算法使用两种 RPC，candidate 在选举时会发起 RequestVote RPC，leader 在复制日志和发送心跳时会发起 AppendEntries RPC（心跳消息是没有日志条目的 AppendEntries RPC）。Raft 保证 RPC 是幂等的。 时间被划分为任期（term），使用单调递增的连续整数表示。每个服务器都会持久存储当前任期，不同服务器的任期可能不同（由于故障）。服务器之间进行通信时会交换任期，处于旧任期的服务器会更新其任期。如果 leader 或 candidate 发现自己包含旧任期，它会成为 follower。如果服务器收到具有旧任期的请求，它会拒绝该请求。 领导者选举 如果一个 follower 在超时时间（该时间被称为选举超时，election timeout）内没有收到来自 leader 或 candidate 的有效 RPC（何为有效，参考图 2），它将递增其任期成为 candidate，开始选举新的 leader。它为自己投票，然后向集群中的其它服务器发送 RequestVote RPC。 如果 candidate 收到大多数服务器的投票，它会成为新的 leader，同时向其他服务器发送心跳消息，以建立其权威防止新的选举。每个服务器在给定的任期内，只能投票给一个 candidate。服务器是否投票给某个 candidate 存在限制，将在安全性中讨论。 如果在等待投票时，candidate 收到 leader 的 AppendEntries RPC，且 leader 的任期大于等于 candidate 的任期，那么 candidate 会成为 follower。如果 leader 的任期更小，则 candidate 会拒绝该 RPC。或者收到其他 candidate 的 RequestVote RPC，且其任期大于当前 candidate 的任期，当前 candidate 同样会成为 follower。 如果存在多个 candidate 使选票分裂，使得没有 candidate 可以得到大多数服务器的投票，则每个 candidate 都会超时，继续递增任期，重新开始选举。Raft 使用随机 election timeout 来确保选票分裂很少发生（避免同时超时），election timeout 是从一个固定间隔中随机选择的（例如 [150, 300] 毫秒），每个候选人在开始选举时会重新随机化 election timeout。 如果 follower 在执行完成 AppendEntries RPC 之后，回复之前发生崩溃，则 leader 会重试 RPC。如果 follower 重新上线，它会忽略重复请求中的日志条目。如果 candidate 在发送 RequestVote RPC 之后崩溃，重启之后它会重新发送 RPC，follower 会持久存储其投票的 candidate，避免在同一任期内多次投票。 为了保证系统的可用性，election timeout 存在如下要求： $$ broadcastTime\\ll electionTimeout\\ll MTBF $$ 其中 \\(broadcastTime\\) 是发送 RPC 的平均往返时间，\\(electionTimeout\\) 是 follower 的超时时间，\\(MTBF\\) 是单个服务器的平均故障间隔时间。broadcast time 应该比 election timeout 小一个数量级，防止 follower 开始不必要的选举。election timeout 应该比 MTBF 小几个数量级，这样在 leader 真正发生故障时客户端不会等待太久。 日志复制 客户端会向 leader 发送请求，请求包含由复制状态机执行的命令，leader 会将当前任期和命令作为一个条目（entry）追加到日志中（只读命令可以不记录日志，但有额外的限制，在可线性化中描述），由日志索引标识其位置。然后 leader 向其他服务器并行发送 AppendEntries RPC 以复制该条目，当大多数服务器确认复制该条目时，leader 将条目应用到其状态机（即状态机执行条目中的命令），并将执行结果返回给客户端，之后 leader 通过不断地失败重试保证剩余服务器会复制该条目。 只要创建日志条目的 leader 将其复制到大多数服务器上，该日志条目就是已提交的（committed）。注意，是创建日志条目的 leader，而不是之后的 leader，这将在安全性中讨论。Raft 保证已提交的条目是持久的，并且最终会被所有可用的状态机执行。leader 提交其创建的日志条目时，也会提交 leader 日志中在该日志条目之前的所有日志条目，包含由之前 leader 创建的条目（会在安全性中解释原因）。leader 会跟踪其已提交日志条目的最高索引，并且在之后的 AppendEntries RPC 中包含该索引，以通知 follower 哪些日志条目已提交，之后 follower 会应用已提交的日志条目到本地状态机（按照日志顺序）。 Raft 的日志匹配（Log Matching）属性保证不同服务器之间日志的一致性：如果两个日志在同一索引位置的条目具有相同任期，则两个日志中所有小于等于该索引位置的条目都相同。如何实现该属性？leader 在给定任期只会对自己的日志进行追加，而不会覆盖。当 leader 向 follower 发送 AppendEntries RPC 时，会进行一致性检查。请求中会包含上一个条目的索引和任期，如果 follower 中对应索引的任期不同，则 follower 会拒绝该请求，回复 leader 匹配失败。如果系统正常运行，那么所有服务器上的日志都会相同。 但是当发生故障时，服务器之间的日志会产生不一致。如何处理不一致？leader 会为每个 follower 维护一个 nextIndex，表示 leader 下次向 follower 发送该索引位置的日志条目，如果 follower 拒绝 leader 的 AppendEntries RPC，则 leader 会将该 follower 对应的 nextIndex 递减，然后重试 RPC 直到 follower 和 leader 的日志完全相同（冲突条目将被删除）。整个过程表现为，递减 follower 的 nextIndex 到和 leader 日志最长相等前缀之后的一个位置，然后追加条目到 follower 直到其 nextIndex 和 leader 日志的尾后索引相等。 可以对上述算法进行优化，不是将 nextIndex 每次递减 1，而是递减整个任期，这通过在 follower 回复的信息中包含冲突条目的任期以及该任期在其日志中的第一个索引位置来实现。从而，每个冲突的任期都需要一个 AppendEntries RPC，而不是每个冲突的条目一个 RPC。为什么直接返回第一个索引位置，论文并没有描述之后该如何处理。我的理解是，其实并不是从该索引位置开始重传日志条目，因为这样可能会导致不必要的重传已提交的日志条目。在 leader 接收到冲突的任期和第一个索引之后，应该会递增该索引直到任期不同为止（之所以可以这样，是因为日志匹配属性），然后再传递该位置的日志条目。这样关于课程中提出的问题，为什么需要返回任期，而不是只返回第一个索引，也可以得到解答。 安全性 选举限制 即使日志一致，两个状态机也可能执行不同的命令序列。例如，leader 提交日志时，某个 follower 可能发生故障，如果它成为 leader，它将覆盖旧 leader 中的条目，而这些条目可能已经应用于旧 leader 的状态机上。为此 Raft 的领导者完整性（Leader Completeness）属性保证在某个任期被提交的日志条目必定会出现在更高任期的 leader 日志中，从而可以保证所有状态机执行相同的命令序列。 如何实现该属性？candidate 在发送 RequestVote RPC 时，会包含其日志信息，如果投票者的日志比 candidate 的日志更（读第四声）新，则投票者会拒绝投票。更新的定义如下：如果两个日志的最后一个条目具有不同任期，则更大任期的日志更新；否则，更长的日志更新。上述限制使得，只有包含所有已提交日志条目的 candidate 才有可能当选 leader，日志只会从 leader 流向 follower。 提交之前任期的条目 在日志复制中提到，创建日志条目的 leader 将其复制到大多数服务器上，则该日志条目就是已提交的。之所这样定义，是因为即使 leader 将之前任期的条目（不是由当前 leader 创建）复制到大多数服务器上，依然可能会被之后的 leader 覆盖（根据之前描述的日志匹配属性）。如果将其视为已提交，则会违反领导者完整性属性，导致状态机不一致。那么之前任期的条目何时视为已提交？当前任期的一个日志条目被提交时，由于日志匹配属性，之前任期的条目将会间接提交。 日志压缩 日志可能会变得很大，导致崩溃恢复需要花费很多时间重放所有日志，以及日志占用大量空间，Raft 通过使用快照来压缩日志。每个服务器会定期创建快照（通常是当日志达到固定大小时），快照中包含状态机的状态、状态对应的最后一个日志条目的索引和任期（以支持 AppendEntries PRC 的一致性检查）、当时的配置信息（用于集群成员变更）。当服务器将快照持久化之后，可以删除该快照之前的日志和之前的快照（剩余日志的索引并不会重置为从 1 开始，或许会新开一个数组从 1 开始存储，但是对外来说索引总是会加上某个偏移量）。 如果有一个严重滞后或新加入集群的 follower，它需要的日志可能已经被 leader 删除，此时 leader 需要使用 InstallSnapshot RPC 向滞后的 follower 发送快照。通常快照会比 follower 的日志更新，follower 会丢弃整个日志，使用快照替代。但是，由于重传或错误，follower 可能会收到描述其日志前缀的快照，此时仅会删除快照覆盖的日志，快照之后的日志将被保留。 为了避免在创建快照时停止操作，可以使用写时复制技术。状态机可以通过实现某种数据结构支持写时复制，或者使用操作系统的写时复制支持（例如，Linux 的 fork）来创建状态机的内存快照（作者使用该实现方式）。具体来说，Linux 的 fork 创建的子进程会共享和父进程相同的内存页面，如果父进程更新页面，则操作系统会对该页面执行写时复制。 可线性化 什么是可线性化？每个操作似乎在其调用和响应之间的某个时刻以原子的方式执行。Raft 如何实现可线性化语义？如果 leader 在执行命令之后回复客户端之前崩溃，然后客户端在新的 leader 重试请求，将会多次执行同一个命令。如果客户端向新 leader 发送读请求，由于旧 leader 在回复客户端之后发送下一个 AppendEntries RPC 之前崩溃，新 leader 可能并没有将某些已提交的命令应用到状态机，此时客户端可能会从新 leader 读取到旧数据。如果出现网络分区故障，旧 leader 可能不知道它已经被新 leader 取代，此时客户端可能从旧 leader 读取到旧数据。 首先，客户端需要为每个命令分配唯一的序列号，状态机会跟踪为每个客户端处理的最后的序列号以及相关响应。如果状态机收到已被执行的命令，它不会执行该命令而是直接返回响应。注意，日志中依然包含重复命令的日志条目。其次，每个 leader 在任期开始时会提交一个无操作日志条目，从而确定哪些日志条目已被提交并将其应用到状态机。能否通过心跳消息确定哪些日志条目已提交，个人认为不能，就是之前提到的旧任期日志条目不能通过计数判断是否已提交。最后，leader 在回复读请求之前，需要和集群中的大多数交换心跳消息，以确保它仍然是 leader（或者可以使用租约，论文中没有详细介绍，不过课程笔记中有提到具体方式）。 问题 Q：Raft 集群是部署在一个数据中心，还是多个数据中心？ A：通常是一个数据中心，这样可以避免 leader 跨数据中心向多个 follower 发送 RPC（网络延迟）。 Q：客户端如何知道谁是新的 leader？ A：客户端包含所有 server 的地址，它可以随机发送请求，follower 会将请求重定向到它认为的 leader。 Q：为什么日志的索引从 1 开始？ A：可以将其视为从 0 开始，索引 0 包含任期为 0 的空日志条目，以方便 AppendEntries RPC 在初始时的一致性检查。个人认为，类似于求数组的前缀和时从索引 1 开始。 Q：Raft 何时将其状态（currentTerm、votedFor、log）持久化到磁盘？ A：在内存中修改状态的同时刷盘，只有持久化之后 leader 才能向 follower 发送 RPC，follower 才能回复 leader，leader 才能将命令应用到状态机。否则，如果服务器发生崩溃，Raft 的各种属性将无法得到保证。 Q：图 2 中的 lastApplied 为何不需要持久化？如果发生崩溃，服务器如何知道日志条目是否应用于状态机？ A：论文作者在会话中对该问题以及下一个问题进行了解释（推荐阅读）。实际上 lastApplied 是否被持久化取决于状态机是否被持久化。如果状态机不被持久化，那么崩溃恢复之后需要重放所有日志，所以 lastApplied 会被初始化为 0。否则，只需重放 lastApplied 之后的日志。按我的理解，由于快照的存在，以及更新状态机的同时持久化产生的随机 I/O 开销较大，所以状态机一般不会实时持久化。如果存在快照，lastApplied 会被赋值为快照中包含的索引。 Q：图 2 中的 matchIndex 有什么作用？ A：matchIndex 表示 follower 和 leader 匹配的最高日志条目的索引（可能会小于实际值），只要大多数 follower 的 matchIndex 超过 leader 的 commitIndex，并且 log[matchIndex] 条目的任期是当前 leader 的任期（参见提交的定义），则 leader 可以增加 commitIndex。 Q：图 7 的 leader 崩溃之后，谁有可能成为新的 leader？ A：服务器 acd 都有可能成为新的 leader。首先日志 9 是最后一个提交的日志条目，根据领导者完整性属性，只能从 acd 中选择 leader。同时，acd 都有可能得到大多数服务器的投票，对于 a 来说是 abef，对于 c 来说是 abcef，对于 d 来说是 abcdef。有一点需要注意，服务器最后一个日志条目的任期可能并不是其当前任期。 总结 Raft 共识算法实现可线性化一致性模型，核心内容包括领导者选举、日志复制和安全性。论文中还提到 Raft 的集群成员变更机制，我并没有做介绍。然后日志压缩可以看作是 Raft 的额外补充。如课程中所述，论文中也有很多细节没有介绍，单个机制可以有多种不同的实现方式。课程视频、问答和笔记是对论文很好的补充，其中还提到一篇文章 Raft does not Guarantee Liveness in the face of Network Faults，讲述 Raft 在特定情况下无法建立稳定的领导者，除非使用 PreVote 和 CheckQuorum 技术。可见这篇论文介绍的仅仅是 Raft 的基本实现，现实中面临各种复杂场景，或许需要添加很多额外的机制。 附录","link":"/2024/01/29/In%20Search%20of%20an%20Understandable%20Consensus%20Algorithm%20(Extended%20Version)/"},{"title":"ZooKeeper: Wait-free coordination for Internet-scale systems","text":"阅读论文 ZooKeeper，参考 FAQ，note，官方文档，另一个课程的 note。 概述 ZooKeeper 是一个协调服务，用于协调分布式应用程序。它没有实现特定的协调原语（例如：配置、选举、锁），而是提供 API 供应用程序开发者使用，让开发者根据实际需要实现协调原语。ZooKeeper API 具有无等待特性，提供事件驱动机制。ZooKeeper 使用流水线（pipeline）架构处理请求，流水线自动支持客户端请求的 FIFO 执行顺序，从而允许客户端异步发送请求。ZooKeeper 没有实现可线性化一致性模型，它仅保证写操作的异步可线性化，以及读操作的写后读和单调读一致性（术语取自 DDIA），适合读多写少的工作负载。 会话 客户端在连接到服务器时建立一个会话（session），同时获得一个会话 ID。只要会话 ID 有效，应用程序就可以通过客户端调用 ZooKeeper API。客户端会定期向服务器发送心跳，如果服务器在超时时间内没有收到心跳，则服务器会结束会话。如果客户端当前连接的服务器故障，则客户端在会话 ID 过期之前自动尝试连接到另一台服务器。 PS：创建会话类似写操作，需要经过多数服务器同意，会话的状态也会使用日志持久化，它是一个全局会话。这也可以解释，为什么客户端可以使用同一个会话 ID 透明地切换到另一台服务器。由于开销较大，ZooKeeper 在之后的版本添加了本地会话功能，本地会话只能执行全局会话操作的子集，状态只在本地服务器维护。 数据模型和监视 ZooKeeper 以类似文件系统的树形结构在内存中存储协调数据（应用程序元数据），树中的数据节点被称为 znode，由路径名唯一标识。不同的应用程序在各自的子树中组织数据，存储在节点中的数据以原子的方式被读写。节点会维护一个统计结构，包含版本号、时间戳和事务 ID（zxid）等元数据。节点分为常规（Regular）和临时（Ephemeral）两种类型，客户端可以显示创建和删除节点。特别的，临时节点如果没有被显示删除，则在创建它们的会话终止时被自动删除，以及临时节点不能有子节点。 创建节点时，客户端可以设置顺序（sequential）标志，从而将一个计数值附加到该节点的路径末尾，同一父节点的子节点的计数值根据创建顺序单调递增。客户端可以为节点设置一次性监视（watch）标志，该标志在客户端连接的服务器本地维护。当监视触发时，服务器会向客户端发送一个监视事件，同时取消监视。有两种监视类型，监视数据和监视子节点。有四种监视事件，创建、删除、数据变化、子节点变化（不包含子节点的数据变化）。监视和会话相关，当会话结束时，监视也会被取消。ZooKeeper 保证设置监视的客户端在看到变化之前，会收到服务器的通知。会话事件也会触发监视，以便客户端知道监视事件可能延迟。 原语示例 客户端可以使用 ZooKeeper API 实现更强的原语，示例如下。更多示例（双重屏障、2PC、选举）可以查看官方文档。 配置管理 ZooKeeper 可用于分布式应用程序的配置管理，可以将配置存储在 znode 中。客户端从 znode 读取配置，同时设置监视标志。如果配置被更新，则客户端会收到通知，然后再次从该 znode 读取配置和设置监视标志。 群组成员 客户端可以创建一个 znode 表示一个群组，当进程以该群组的成员身份启动时，它会在该 znode 下创建一个临时子 znode。如果每个进程有一个唯一的名称，则将该标识作为子 znode 的名称，否则可以使用顺序标志，使其获得唯一的名称。进程可以将其元数据存储在该子 znode 中，例如地址和端口。如果进程终止，则临时节点会被自动删除。可以通过在 znode 上设置监视标志，从而监视群组成员的变化。 简单锁 可以将一个指定路径的 znode 作为锁，客户端可以创建临时 znode 来获取锁，其他客户端通过判断 znode 是否存在来判断是否能够获取锁，同时设置监视标志。当临时 znode 被显示或自动删除，则表示锁被释放。此时，等待锁的客户端将收到通知。但是该实现存在羊群效应（herd effect）：在锁被释放时，许多客户端会争抢同一个锁。 无羊群效应的简单锁 直觉上来说，将获取锁的请求按照 FIFO 的顺序排队处理，那么就可以避免羊群效应。可以使用顺序标志在指定父 znode 下创建临时子 znode，客户端通过判断其创建的临时 znode 是否是序号最小的，来判断它是否已获取锁。当客户端需要释放锁时，只需删除其创建的临时 znode。个人认为，有无羊群效应的简单锁，有点像是 notify_all 和 notify_one 的区别。 特别的，在代码实现时有一个陷阱，ZooKeeper 没有提供监视来通知当前 znode 的序号是否最小。在创建 znode 之后， 我们首先需要获取子 znode 列表，判断当前是否是最小的。如果不是，则可以在前一个节点上设置监视。但是，该监视触发并不意味着当前客户端已获取锁，因为有可能只是前一个客户端提前结束会话，此时仍存在更小的序号。 读写锁 实现细节 ZooKeeper 使用复制提供容错，使用原子广播协议（ZAB）保证多个副本之间的一致性。客户端仅连接到一个服务器发送请求，写请求会被转发给领导者，读请求读取本地数据库而不需要通过领导者。本地处理读请求使得读取性能可以随着服务器的数量增加而增加，而不会受限于单个领导者。复制数据库是一个内存数据库，当日志持久化到磁盘时，才会将日志应用到内存数据库，同时会定期为数据库生成快照。PS：类似 Raft，内存数据库实际上就是一个状态机。 ZooKeeper 使用 ZAB 保证写操作的可线性化，同时保证异步请求按照客户端 FIFO 的顺序执行，从而实现写操作的异步可线性化（A-linearizability）。当领导者收到写请求时，如果请求包含的版本号和目标 znode 的未来版本号匹配，就会将请求转换为事务。之所以要和未来版本号匹配，是因为可能存在尚未应用到数据库的事务。如果事务未提交（复制到大多数），则无法应用到数据库。ZooKeeper 保证事务是幂等的，〈transactionType, path, value, new-version〉。 ZooKeeper 使用的是模糊快照（fuzzy snapshot），因为允许在创建快照的过程中更改状态机，而且也不像 Raft 使用写时复制，所以快照不对应某个时刻的状态，故称为模糊快照。不过，由于事务的幂等性，重放相同的日志也没有关系。从日志的角度看，模糊快照并不对应一个连续的日志范围，可能是断断续续的。 客户端向服务器发送读写请求和心跳消息，得到的响应中会包含服务器的 zxid。如果客户端连接到新服务器，会检查客户端的 zxid 和新服务器的 zxid，确保新服务器满足客户端的单调读一致性。如果新服务器的视图更旧，客户端可以连接另一台服务器。 问题 Q：无等待（wait-free）是什么意思？ A：论文 Wait-Free Synchronization 进行了介绍，并发数据对象的无等待实现可以保证，任何进程都能在有限步中完成任何操作，而不论其他进程的执行速度如何。个人认为这个定义有点抽象，无等待还有一个层次结构和共识数。类似的术语还有无锁、无障碍、无阻塞。FAQ 提供了一个简单的解释，为什么 ZooKeeper 是无等待的，因为客户端调用 API 不会被其他客户端阻塞，ZooKeeper 没有使用锁来阻塞调用。 Q：为何流水线自动支持客户端请求的 FIFO 执行顺序？异步请求为何能提高性能？ A：我的理解是 TCP 可以保证客户端请求的 FIFO 到达顺序。流水线将一个处理过程分解为多个组件，能够充分利用系统的资源。但流水线依然是一个顺序的处理过程，一般就是按照到达顺序处理的，所以能够自动支持 FIFO 执行顺序。异步请求能提高性能是流水线的特性，如果同步发送请求，流水线中的很多组件会处于空闲状态。 FAQ 中有问到 ZooKeeper 如何实现异步请求的 FIFO 执行顺序，按照论文的逻辑，这个问题就不对。论文首先说流水线支持 FIFO 执行顺序，然后推出客户端可以发送异步请求。从而我觉得，FAQ 的答案也不对。FAQ 对流水线的解释也有问题，他把流水线解释为批处理。 Q：如何实现读操作的写后读和单调读一致性？ A：写后读一致性可以由客户端的 FIFO 执行顺序保证，而单调读一致性通过检查客户端和服务器的 zxid 保证。 Q：ZooKeeper 如何实现监视（watch）？ A：FAQ 有解释，客户端通常会注册一个回调函数，该函数在监视触发时调用。Go 使用通道（channel）来实现，当监视触发时，服务器会向通道发送一个事件，然后应用程序可以从通道中获取该事件。但是有个疑问，Go 的通道能跨网络传输数据么。 Q：为什么请求不幂等，而事务幂等？ A：假设有一个带顺序标志的创建节点的请求，那么多次发送请求会创建不同的节点。事务是请求的幂等形式，论文中提到形如 〈transactionType, path, value, new-version〉。 Q：ZooKeeper 服务器、客户端和应用程序的关系？ A：个人理解，服务器提供低级原语，客户端使用 API 实现更高级的原语，应用程序使用客户端提供的高级原语。 Q：ZooKeeper 中的 zxid 和版本号有什么关系？ A：ZooKeeper 的每次状态更改（写操作）都会递增 zxid，而版本号则是 znode 的属性。个人认为，zxid 是 ZAB 层面的，版本号是数据库（状态机）层面的。 Q：可线性化和可串行化的区别？ A：可以看下 Linearizability versus Serializability，很清晰。 总结 刚开始看这篇论文，涉及很多没见过的术语，看着比较折磨。如果深入细节的话，会花费很多时间。我确实一开始没有抓住重点，陷入如何在代码层面使用 ZooKeeper，无等待和通用对象是什么意思之类的。但是，如果从更高的层面来看，ZooKeeper 可以理解为 ZAB + 数据库（状态机），就是使用数据树结构提供一个通用的 API。 在查找资料的过程中发现很多不一致的地方，例如：API 文档中描述异步请求会排队等待发送，但按照论文的描述应该不是这样的，不然怎么提高性能；一致性保证中提到单一系统映像，定义首先说保证看到相同的视图，然后又说不会看到旧视图，但这完全不是一个意思；FAQ 中对异步请求如何实现客户端 FIFO 执行顺序的讨论，我认为论文和另一份笔记都证明 FAQ 的错误。 在阅读论文和资料的过程中，经常会看到某个描述，感觉模糊不清，只能凭自己的猜测去理解。实际上确实有很多模糊的地方，没有描述具体的实现方式，但有些问题其实论文中也给出了回答。所以，在读论文的过程中还是要仔细一点，遇到不懂的不要随便猜测，先记下问题，因为很可能是一个错误的猜测，还会干扰之后的理解。总之，论文只是提供一个简要的说明，深入理解还需要实际使用 ZooKeeper，以及阅读源码。","link":"/2024/02/05/ZooKeeper%20Wait-free%20coordination%20for%20Internet-scale%20systems/"},{"title":"Chain Replication for Supporting High Throughput and Availability","text":"阅读论文 Chain Replication，参考 note。 概述 链式复制是一种容错复制方式，可以保证高性能、高可用和强一致性（可线性化）。客户端的请求都以原子的方式执行，查询请求直接发送到 tail，更新请求发送到 head，然后沿着链传递到 tail。在没有故障的情况下，可线性化保证源于以下两点：只有 tail 会响应客户端的请求，以及更新操作只会在 head 计算一次，从而可以避免冗余计算和非确定性操作带来的一致性问题。 实现 基本概念 对象由 \\(objID\\) 唯一标识，\\(Hist_{objID}\\) 表示该对象上已执行的请求，\\(Pending_{objID}\\) 表示该对象上待执行的请求。对于链式复制来说，客户端视图中的 \\(Hist_{objID}\\) 被定义为 tail 存储的 \\(Hist_{objID}\\)，\\(Pending_{objID}\\) 被定义为任何服务器接收到的、没有被 tail 执行的客户端请求。注意，这两个状态都是对象的客户端视图，而不是实际存储在服务器中的数据。此外，论文只是为方便论证才将对象状态描述为 \\(Hist_{objID}\\)，实际的状态应该是对象的当前值。 故障检测和恢复 链式复制使用额外的服务来检测故障，重新配置链，通知客户端链头和链尾对应的服务器。论文称该服务为 master，使用复制进行容错，使用 Paxos 维持多个 master 副本之间的一致性。可以将其视为类似 ZooKeeper 的协调服务。虽然论文没有提及，不过检测故障通常是使用定时心跳。 链头故障 master 直接将 head 的下一个节点作为新的 head，然后通知客户端。所有旧 head 接收而未转发给后继的请求最终都会超时，然后客户端会重试。该过程相当于执行 T2 转移。 链尾故障 master 直接将 tail 的上一个节点作为新的 tail，然后通知客户端。因为更新是从前往后传播的，所以上一个节点的视图至少和旧 tail 的视图一样新，不会影响一致性。该过程相当于执行 T3 转移。 中间故障 master 会修改故障节点的前驱和后继的指针，从而将故障节点从链中删除。但是，如果前驱转发更新请求到故障节点，而故障节点没有将其转发至后继，那么前驱需要一种机制识别这部分请求，然后重新将其转发至后继。 每个服务器维护一个更新请求的已转发列表 \\(Sent\\)，当服务器将请求转发到后继时，会将该请求添加到列表中。当更新请求 \\(r\\) 转发到尾节点，并被尾节点处理时，尾节点会向前驱发送确认信息 \\(ack( r)\\)。收到 \\(ack( r)\\) 的服务器会将 \\(r\\) 从 \\(Sent\\) 列表中删除，同时将 \\(ack( r)\\) 转发到前驱。 当中间节点 \\(S\\) 故障，master 向后继 \\(S^{+}\\) 发送其新的前驱 \\(S^{-}\\)，\\(S^{+}\\) 会响应 master 确认消息，其中包含 \\(S^{+}\\) 收到的最后一个更新请求的序列号。然后 master 向前驱 \\(S^{-}\\) 发送其新的后继 \\(S^{+}\\) 和序列号，\\(S^{-}\\) 会将在 \\(Sent_{S^{-}}\\) 中且在序列号之后的请求转发到 \\(S+\\)，这部分请求就是故障节点 \\(S\\) 未转发至 \\(S^{+}\\) 的请求。该机制的关键在于保留已发送请求的列表，\\(ack\\) 的作用只是回收空间。 恢复冗余 发生故障的服务器会从链中删除，需要恢复冗余以保证容错。理论上，可以将新服务器添加到链中的任意位置。实践中，添加到链尾比较简单。master 会要求当前链尾 \\(T\\) 转发对象已执行的请求队列 \\(Hist_{objID}^{T}\\) 到新的链尾 \\(T^{+}\\)，在转发完成之前，依然是当前链尾 \\(T\\) 执行查询请求和前驱传来的更新请求，以及响应客户端。该过程中执行的更新请求同时会被添加到 \\(Sent_{T}\\)，该操作与 \\(Sent_{T}\\) 的定义不一致，之后会处理。当 \\(Hist_{objID}^{T}=Hist_{objID}^{T^{+}}\\oplus Sent_{T}\\) 成立时，也就是转发开始时的 \\(Hist_{objID}^{T}\\) 都转发到 \\(T^{+}\\) 时，\\(T^{+}\\) 可以成为链尾。 过程如下：如果 master 收到上述不变式成立的通知，master 会通知 \\(T\\) 其不是链尾，之后 \\(T\\) 会将收到的查询请求转发到 \\(T^{+}\\)。然后 \\(Sent_{T}\\) 中的更新请求也会被转发到 \\(T^{+}\\)，转发完成之后，就符合 \\(Sent_{T}\\) 的定义，\\(T\\) 会通知 master 将 \\(T^{+}\\) 作为新的链尾。然后，master 会通知客户端新的链尾。PS：注意，此时 \\(Sent^{T}\\) 中的请求已经响应客户端。 对比主从复制 链式复制可以视为特殊的主从复制，头节点和尾节点共同充当主节点，其他节点作为从节点。相比传统的主从复制（指的是强一致性的主从复制）： 链式复制的查询，由链尾的服务器处理，不会被链中其他服务器的活动延迟。而主从复制的查询，主节点需要等待之前的更新被从节点确认，才能执行查询。PS：个人理解，指的应该是多客户端之间的更新和查询，单客户端是同步的，只有接收到上一个请求的响应才会发送下一个请求，否则链式复制是无法保证客户端的 FIFO 执行顺序。 链式复制串行传播更新，主从复制并行传播更新，所以链式复制的更新延迟更高，而且和链的长度成正比。 测试 根据论文中的模拟实验可以发现，链式复制比主从复制具有更高的读取性能，但是强一致性保证使得读写性能不能随着机器的数量线性扩展，不像 ZooKeeper。比较令人惊讶的是，在更新请求至少占总请求数的 15% 时，弱一致性保证的读取方案反而会降低系统的总吞吐量，因为在头节点的查询和更新会产生竞争。主从复制的吞吐量不会受复制因子的影响，而链式复制的更新是串行传播的，似乎吞吐量会随着链的长度增加而减少。但是，只要有足够多的更新请求，那么通过一个预热时间启动流水线，吞吐量可以恢复正常水平。 问题 Q：更新请求不是幂等的，如果响应丢失，客户端重试更新请求怎么办？ A：目前讨论的系统：GFS 的 primary chunkserver 重试会导致重复追加，我猜客户端重试大致也是如此；VM-FT 请求是否幂等取决于虚拟机中的应用程序；Raft 要求请求包含唯一标识，在状态机层去重；尽管 ZooKeeper 的事务是幂等的，但是请求不是幂等的，没有讨论如何处理；链式复制论文提到可以在重试之前，进行查询判断更新是否已经执行。总的来说，是否要求幂等是根据系统的实际使用场景而定的，课程中也提到，ZooKeeper 和链式复制也可以使用和 Raft 类似的方法去重，从而实现幂等。 Q：更新请求的延迟和链的长度成正比，那么超时时间会更长，如果请求丢失似乎需要更多等待？ Q：如果链头 \\(S\\) 和 master 发生网络分区故障，那么 \\(S^{+}\\) 会成为新链头，而此时 \\(S^{+}\\) 依然会收到旧链头 \\(S\\) 的转发。节点必然需要一种机制判断是否应该忽略请求，这可以通过简单的判断请求的来源是否是其前驱来实现。 Q：客户端在连接到服务器时，以及链头或链尾被改变时，master 需要通知客户端，如果客户端很多会有什么问题？ 总结 课程提到，复制状态机有两种主要的实现方式，一种是使用共识算法复制所有操作，另一种是使用配置服务 + 主从复制，配置服务中的共识算法仅复制元数据，其他操作不需要使用共识算法复制。链式复制使用的是第二种方式，它需要利用额外的配置服务进行故障恢复，同时避免脑裂。链式复制概念简单，只有中间故障和恢复冗余稍微复杂一点。和共识算法不同，只要有一个服务器故障，就可能会导致读请求或写请求的短暂中断。论文在模拟实验中提到多链和对象放置策略，我认为论文的描述很模糊，所以没介绍。","link":"/2024/02/10/Chain%20Replication%20for%20Supporting%20High%20Throughput%20and%20Availability/"},{"title":"Codeforces Round 924 (Div. 2)","text":"Rectangle Cutting 题目 输入两个整数 \\(a\\) 和 \\(b\\)，表示矩形 \\(a\\times b\\)，判断是否能将矩形切割一次再拼接得到不同的矩形，切割线要求平行于某条边且得到的矩形边长为整数。 数据范围：\\(1\\leq a,b\\leq 10^{9}\\)。 思路 以下讨论总是假设 \\(a\\leq b\\)： 首先我们总是应该对半切，如果不对半切，并且想要拼接得到矩形，那么只能切割更长的边 \\(b\\)，得到 \\(a\\times a\\) 和 \\(a\\times(b-a)\\)，但是不论怎么拼接都和原矩形相同。 如果 \\(a\\) 是偶数，可以总是对半切 \\(a\\)，然后拼接得到不同的矩形 \\(\\frac{a}{2}\\times 2b\\)。 如果 \\(a\\) 是奇数，\\(b\\) 必须是偶数，否则无法对半切。此时只能对半切 \\(b\\)，拼接得到矩形 \\(2a\\times\\frac{b}{2}\\)，当 \\(a\\neq\\frac{b}{2}\\) 时，得到的矩形和原矩形不同。 代码 12345678910111213public static void solve() { int a = io.nextInt(), b = io.nextInt(); if (a &gt; b) { int t = a; a = b; b = t; } if (a % 2 == 0 || b % 2 == 0 &amp;&amp; b != 2 * a) { io.println(&quot;Yes&quot;); } else { io.println(&quot;No&quot;); }} Equalize 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，可以选择一个 \\([1,n]\\) 的任意排列 \\(p\\)，执行 \\(a_{i}=a_{i}+p_{i}\\) 操作。输出执行操作之后，能够得到的数组 \\(a\\) 中相同元素最大出现次数的最大值。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 将数组加上任意排列，肯定是更小的数对应更大的数，才能使相同元素的最大出现次数最大化。我们可以将数组 \\(a\\) 排序同时去重，之所以去重是因为相同元素加上排列之后必定不相同，然后将排列看作固定的递减数组。只要数组 \\(a\\) 中的两个数的差值小于 \\(n\\)，那么这两个数之间的元素必定可以在操作之后变成相同的元素。问题就转化为求区间的最大长度，同时最大值和最小值的差值小于 \\(n\\)，可以使用滑动窗口求解。 代码 12345678910111213141516171819202122public static void solve() { int n = io.nextInt(); TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) { set.add(io.nextInt()); } int m = set.size(), idx = 0; int[] a = new int[m]; for (var x : set) { a[idx++] = x; } int ans = 1; for (int i = 0, j = 1; j &lt; m; j++) { while (a[j] - a[i] &gt;= n) { i++; } ans = Math.max(ans, j - i + 1); } io.println(ans);} Physical Education Lesson 题目 输入两个整数 \\(n\\) 和 \\(x\\)，求 \\(k\\) 的个数，使得对于编号为 \\(1\\) 到 \\(k\\) 的位置，满足第 \\(n\\) 个位置的编号为 \\(x\\)。第 \\(n\\) 个位置是按往返来计算的，例如 \\(1,2,\\dots,k-1,k,k-1,\\dots,2,1\\)，第 \\(1\\) 和 \\(1+2k-2\\) 个位置的编号都为 \\(1\\)。当 \\(k&gt;1\\) 时，编号循环的周期就是 \\(2k-2\\)。题目限制 \\(k&gt;1\\)。 数据范围：\\(1\\leq x&lt;n\\leq 10^{9}\\)。 思路 \\(k\\) 必须满足 \\(k\\geq x\\)，同时 \\((2k-2)\\cdot t+x=n\\) 或 \\((2k-2)\\cdot t+k+k-x=n\\)，变形得到 \\(n-x=2\\cdot(k-1)\\cdot t\\) 或 \\(n+x-2=2\\cdot(k-1)\\cdot(t+1)\\)。求 \\(k\\) 的个数，可以首先求出 \\(\\frac{n-x}{2}\\) 和 \\(\\frac{n+x-2}{2}\\) 的约数，约数加一就是满足等式的 \\(k\\) 值，最后限制 \\(k\\geq x\\)，得到答案。其实也可以不使用集合去重，只需要特判 \\(x=1\\) 和 \\(k=x\\) 的情况。 代码 123456789101112131415161718192021222324public static void solve() { int n = io.nextInt(), x = io.nextInt(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); calc(n - x, x, set); calc(n + x - 2, x, set); io.println(set.size());}private static void calc(int x, int y, Set&lt;Integer&gt; set) { if (x % 2 != 0) { return; } x /= 2; for (int i = 1; i &lt;= x / i; i++) { if (x % i == 0) { if (i + 1 &gt;= y) { set.add(i + 1); } if (x / i != i &amp;&amp; x / i + 1 &gt;= y) { set.add(x / i + 1); } } }} Lonely Mountain Dungeons 题目 输入三个整数 \\(n,b,x\\)，以及长度为 \\(n\\) 的数组 \\(c\\)。有 \\(n\\) 种生物，每种生物的数量为 \\(c_{i}\\)。你需要将所有生物分为 \\(k\\) 组，位于不同组的每对同种生物会使总分增加 \\(b\\)，同时总分会减少 \\((k-1)\\cdot x\\)。输出能够得到的最大分数。 数据范围：\\(1\\leq n\\leq 2\\cdot 10^{5}\\)，\\(1\\leq b\\leq 10^{6}\\)，\\(0\\leq x\\leq 10^{9}\\)，\\(1\\leq c_{i}\\leq 2\\cdot 10^{5}\\)，\\(\\sum_{i=1}^{n}c_{i}\\leq 2\\cdot 10^{5}\\)。 思路 首先需要知道，对于某种生物 \\(i\\) 和固定的 \\(k\\)，将 \\(c_{i}\\) 尽量平均分配是最优的，不过我也不知道该怎么证明。当 \\(k&gt;c_{i}\\) 时，得分总是为 \\(C_{c_{i}}^{2}\\cdot y^{2}\\)。当 \\(k\\leq c_{i}\\) 时，就需要将 \\(c_{i}\\) 分为，\\(c_{i}\\bmod k\\) 组包含 \\(y=\\lceil\\frac{c_{i}}{k}\\rceil\\) 个该种生物，\\(k-c_{i}\\bmod k\\) 组包含 \\(y^{\\prime}=\\lfloor\\frac{c_{i}}{k}\\rfloor\\) 个该种生物。得分为： $$ C_{k-c_{i}\\bmod k}^{2}\\cdot y^{2}+C_{c_{i}\\bmod k}^{2}\\cdot y^{\\prime 2}+(k-c_{i}\\bmod k)\\cdot(c_{i}\\bmod k)\\cdot y\\cdot y^{\\prime} $$ 根据以上讨论，很容想到暴力枚举组数 \\(k\\)，然后内层循环计算该组数下的最大得分，总时间复杂度为 \\(O(\\max(c_{i})\\cdot n)\\)。由于题目限制 \\(\\sum_{i=1}^{n}c_{i}\\leq 2\\cdot 10^{5}\\)，我们可以预处理得到所有 \\(c_{i}\\) 在组数为 \\([1,c_{i}]\\) 下的最大得分之和，从而可以将暴力枚举的内循环优化为 \\(O(1)\\) 时间复杂度。 代码 12345678910111213141516171819202122232425262728293031323334public static void solve() { int n = io.nextInt(), b = io.nextInt(), x = io.nextInt(); int m = 0; int[] c = new int[n]; for (int i = 0; i &lt; n; i++) { c[i] = io.nextInt(); m = Math.max(m, c[i]); } long[] f = new long[m + 1]; long[] g = new long[m + 1]; for (int i = 0; i &lt; n; i++) { for (int j = 1; j &lt;= c[i]; j++) { f[j] += calc(c[i], j); } g[c[i]] += calc(c[i], c[i]); } long ans = 0L; for (int i = 1; i &lt;= m; i++) { ans = Math.max(ans, (f[i] + g[i - 1]) * b - (long) (i - 1) * x); g[i] += g[i - 1]; } io.println(ans);}private static long calc(int n, int k) { int a = n / k, b = n % k; long res = (long) (k - b) * (k - b - 1) / 2 * a * a; res += (long) b * (b - 1) / 2 * (a + 1) * (a + 1); res += (long) (k - b) * b * a * (a + 1); return res;}","link":"/2024/02/12/Codeforces%20Round%20924%20(Div.%202)/"},{"title":"Frangipani: A Scalable Distributed File System","text":"阅读论文 Frangipani，参考 FAQ，note。 概述 Frangipani 是一个分布式文件系统，由 Petal 分布式存储服务和多个 Frangipani 服务器组成，Frangipani 服务器共享 Petal 提供的单个虚拟磁盘抽象，同时使用分布式锁保证缓存一致性。 实现 预写日志 每个 Frangipani 服务器都会使用预写日志记录系统元数据的变化（不记录文件数据），只有当日志持久化到 Petal 之后，才能修改系统的元数据。日志首先会按顺序存放在服务器内存的循环缓冲区中，然后定期刷新到 Petal。使用日志记录元数据的变化，可以避免服务器故障时元数据的部分更新导致文件系统结构被破坏（产生不一致），从而可以避免运行 fsck 一致性检查程序，实现快速恢复。 日志由若干大小为 512 字节的日志块组成，每个日志块都有一个单调递增的序列号。论文表示序列号作用是在故障恢复时检测日志的末尾，即使磁盘乱序写入数据。元数据由若干大小为 512 字节的元数据块组成，每个元数据块都有一个单调递增的版本号。日志块也会包含其所修改元数据块的版本号，只有日志块中的版本号大于元数据块的版本号时，才能应用日志。从而可以避免服务器故障恢复时，旧日志覆盖新版本的元数据，以及重复应用已经应用的日志。512 字节的日志块和元数据块实际上对应一个扇区，扇区的读写保证是原子的。 PS：论文提到元数据块被释放然后重用于文件数据导致版本号消失的问题，然后说明限制释放的元数据块仅被新的元数据块重用可以解决该问题。此处所说的元数据块应该是指扇区，所有才会释放和重用，也就是说版本号实际上是和元数据块所在的扇区绑定，而和元数据是什么无关。而且，之所以版本号消失会有问题，是因为日志块记录的是所修改元数据块的扇区位置。这种设计有点奇怪，日志块以及版本号不和修改的元数据关联，而是和扇区关联。 分布式锁 锁服务使用 Paxos 进行容错，为文件系统提供读写锁。当锁服务检测到冲突的锁请求时，会要求当前锁的持有者释放或降级锁，以消除冲突。读写锁允许 Frangipani 服务器从磁盘获取数据并将其缓存。在释放读写锁前，服务器会使缓存无效，从而保证缓存一致性。在释放或降级写锁前，服务器必须将脏数据写入磁盘（包括文件数据）。磁盘被划分为若干逻辑段，每个段都有一个锁，每个日志、文件、目录和符号链接都是一个段。每个文件使用一个锁，适合很少并发写的工作负载，其他负载可能需要使用更细粒度的锁。 锁具有粘性，也就是说 Frangipani 服务器获取锁之后不会主动释放，除非锁服务要求其释放。当挂载 Frangipani 文件系统时，Frangipani 服务器会调用 clerk 模块，该模块会连接到锁服务，获取租约并且在本地打开一个锁表。当文件系统被卸载时，clerk 会关闭锁表。clerk 和锁服务使用异步消息进行通信，有四种消息类型：request、grant、revoke 和 release。 故障处理 当 Frangipani 服务器的租约由于没有续约而过期时，锁服务会认为该服务器故障，此时需要一种机制来释放故障服务器持有的锁。锁服务会在另一个 Frangipani 服务器上启动恢复进程，新服务器会获取租约和故障服务器日志的锁，然后按顺序应用未执行的日志，最后释放（release）所有锁以及释放（free）日志。如果是由于网络分区故障而没有续约，租约过期的 Frangipani 服务器会主动丢弃其所有锁和缓存数据。如果缓存中存在脏数据，则服务器会向用户程序报告错误，将问题交给用户处理。 如果租约在服务器向 Petal 发送写入请求之后到达之前过期，则会产生问题，因为此时锁可能已经被授予故障恢复服务器。论文提到可以为每个写入请求添加过期时间戳，如果请求到达 Petal 的时间戳大于请求中的时间戳，则拒绝该请求。或者将锁服务和 Petal 集成，服务器为写入请求添加租约标识符，然后 Petal 可以判断租约是否过期。 问题 Q：日志序列号的作用有点奇怪，为什么磁盘要乱序写入数据？ Q：日志只会记录元数据，那么有可能只执行元数据更改，而丢失文件数据？ A：该语义符合标准的本地 Unix 文件系统，崩溃之前的写入可能会丢失。应用程序可以使用 fsync 系统调用，强制将数据立即刷新到磁盘。 总结 预写日志存储在 Petal 提供的共享虚拟磁盘上，使得任何服务器都可以使用故障服务器的日志进行恢复。多个日志使得恢复过程变得复杂，需要使用版本号机制避免异常。分布式锁保证服务器之间的缓存一致性。Frangipani 服务器运行在用户侧，负责和共享磁盘通信，该设计要求用户是可信的。该系统使用粗粒度的锁定，一个文件对应一个锁，所以不适用于经常并发写入相同文件的负载。论文的性能测试我没有太多时间看，总结时也忽略了一些我认为不是很重要的细节。","link":"/2024/02/15/Frangipani%20A%20Scalable%20Distributed%20File%20System/"},{"title":"Codeforces Round 925 (Div. 3)","text":"ABC 都是简单模拟题。D 题很经典，利用哈希表求同余的下标对数。E 题需要观察到答案只和元素的位数有关。F 题给出元素的偏序，判断是否存在全序，可以将顺序建模成有向图，然后使用拓扑排序判断是否存在环。G 题需要观察到如下性质，1 和 2 的数量不能相差超过一，3 和 4 放置的方案数相互独立，计算组合数的方式类似将 m 个球放入 n 个可以为空的盒子，公式为 \\(C_{n+m-1}^{n-1}=C_{n+m-1}^{m}\\)，可以看看灵神的视频。","link":"/2024/02/15/Codeforces%20Round%20925%20(Div.%203)/"},{"title":"Codeforces Round 926 (Div. 2)","text":"Sasha and the Drawing 题目 输入整数 \\(n\\) 表示 \\(n\\times n\\) 的正方形网格，网格总共有 \\(4n-2\\) 条对角线，输出最小的着色单元格数量，使得至少有 \\(k\\) 个对角线上存在着色的单元格。 数据范围：\\(2\\leq n\\leq 10^{8}\\)，\\(1\\leq k\\leq 4n-2\\)。 思路 最好情况下，对 \\(1\\) 个单元格着色，可以贡献 \\(2\\) 个对角线，最多有 \\(2n-2\\) 个单元格满足该条件，例如选择着色第一行的 \\(n\\) 个单元格和最后一行的中间 \\(n-2\\) 个单元格。剩下 \\(2\\) 个单元格，每着色 \\(1\\) 个可以贡献 \\(1\\) 个对角线。 代码 12345678public static void solve() { int n = io.nextInt(), k = io.nextInt(); if (k &lt;= 4 * n - 4) { io.println((k + 1) / 2); } else { io.println(2 * n - 2 + (k - (4 * n - 4))); }} Sasha and the Casino 题目 输入三个整数 \\(k,x,a\\)，表示有一个游戏每次可以选择下注 \\(y\\) 个硬币（\\(y\\leq a\\)），如果赢了将获得 \\(y\\cdot k\\) 个硬币，输了不会获得任何硬币，游戏最多连续输 \\(x\\) 次。输出初始有 \\(a\\) 个硬币时，是否存在某个方案能够获取无限数量的硬币。 数据范围：\\(2\\leq k\\leq 30\\)，\\(1\\leq x\\leq 100\\)，\\(1\\leq a\\leq 10^{9}\\)。 思路 首先，前 \\(x\\) 次游戏都下注 \\(1\\) 个硬币，最后下注 \\(a-x\\) 个硬币不是最优策略，因为可能会提前赢，如果赢的时候增量为负，将会输得很惨。所以对于第 \\(i\\) 次下注（\\(1\\leq i\\leq x+1\\)），下注大小 \\(y_{i}\\) 需要满足赢得游戏时 \\(y_{i}\\times (k-1)&gt;\\sum_{j=1}^{i-1}y_{j}\\)。 代码 12345678public static void solve() { int k = io.nextInt(), x = io.nextInt(), a = io.nextInt(); int sum = 0; for (int i = 0; i &lt;= x &amp;&amp; sum &lt;= a; i++) { sum += sum / (k - 1) + 1; } io.println(sum &lt;= a ? &quot;YES&quot; : &quot;NO&quot;);} Sasha and a Walk in the City 题目 输入一棵树，包含 \\(n\\) 个节点和 \\(n-1\\) 条边，输出存在多少个集合，使得任意简单路径都不会包含超过两个在集合中的节点，答案对 \\(998244353\\) 取模。 数据范围：\\(2\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq u_{i},v_{i}\\leq n\\)，\\(u_{i}\\neq v_{i}\\)。 思路 假设节点 \\(1\\) 是树的根节点，定义 \\(dp_{v}\\) 表示以 \\(v\\) 为根的子树的非空集合个数，集合满足不存在一对节点，其中一个是另一个的祖先。假设节点 \\(u_{1},u_{2},\\dots,u_{k}\\) 是节点 \\(v\\) 的子节点，则有 \\(dp_{v}=\\prod_{i=1}^{k}(dp_{u_{i}}+1)\\)，当所有子树的集合为空时，表示只选择节点 \\(v\\)。最后答案为 \\(\\sum_{i=1}^{n}dp_{i}+1\\)，可以通过以下分类讨论得到： 不存在祖先关系的集合个数为 \\(dp_{1}+1\\)，其中 \\(dp_{1}\\) 表示不存在祖先关系的非空集合个数，\\(1\\) 表示集合为空的情况。 存在祖先关系的集合个数为 \\(\\sum_{i=2}^{n}dp_{i}\\)，因为对于每个节点 \\(v\\) 作为祖先，有 \\(\\sum_{i=1}^{k}dp_{u_{i}}\\) 个集合存在祖先关系。 代码 12345678910111213141516171819202122232425262728293031private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(); List&lt;Integer&gt;[] g = new List[n]; Arrays.setAll(g, k -&gt; new ArrayList&lt;&gt;()); for (int i = 0; i &lt; n - 1; i++) { int u = io.nextInt() - 1, v = io.nextInt() - 1; g[u].add(v); g[v].add(u); } long[] dp = new long[n]; dfs(0, -1, g, dp); long ans = 1L; for (long x : dp) { ans = (ans + x) % MOD; } io.println(ans);}private static void dfs(int x, int fa, List&lt;Integer&gt;[] g, long[] dp) { dp[x] = 1; for (int y : g[x]) { if (y != fa) { dfs(y, x, g, dp); dp[x] = dp[x] * (dp[y] + 1) % MOD; } }} Sasha and the Wedding Binary Search Tree 题目 输入两个整数 \\(n\\) 和 \\(c\\)，表示一颗二叉搜索树，以及节点值的取值范围为 \\([1,c]\\)。然后输入 \\(n\\) 行 \\(l_{i},r_{i},v_{i}\\) 值，表示节点 \\(i\\) 的左右子节点和该节点的值。如果 \\(l_{i}&lt;0\\) 或 \\(r_{i}&lt;0\\)，则表示没有对应的子节点。如果 \\(val_{i}&lt;0\\)，则表示不知道该节点的值是多少。输出可能的二叉搜索树个数，答案对 \\(998244353\\) 取模。 数据范围：\\(2\\leq n\\leq 5\\cdot 10^{5}\\)，\\(1\\leq c\\leq 10^{9}\\)。 思路 首先进行中序遍历，将所有值添加到一个列表，那么可以求出每段连续负数值的方案数，将所有段的方案数相乘就是答案。对于每一段可以知道其上下限，假设段的长度为 \\(m\\)，取值范围为 \\([lo,hi]\\)，则可能的取值数量为 \\(k=hi-lo+1\\)。那么方案数就是将 \\(m\\) 个球放入 \\(k\\) 个盒子的方案数，盒子可以为空，公式为 \\(C_{m+k-1}^{k-1}=C_{m+k-1}^{m}\\)，可以参考上一场比赛的最后一题。 需要注意的是，\\(k\\) 的取值范围很大，我们使用等号右边的公式计算方案数，可以只循环 \\(m\\) 次。由于答案需要取模，循环中取模之后的值可能无法被整除，所以必须计算模乘法逆元。以及下面的代码会栈溢出，但是改写为 C++ 就不会，只能说 Java 占用的栈空间比较大么，但是也有其他人使用 Java 通过测试，真不知道为什么我的就不行。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static final int MOD = 998244353;public static void solve() { int n = io.nextInt(), c = io.nextInt(); int[] val = new int[n]; int[][] g = new int[n][2]; for (int i = 0; i &lt; n; i++) { int l = io.nextInt() - 1, r = io.nextInt() - 1; val[i] = io.nextInt(); g[i][0] = l; g[i][1] = r; } List&lt;Integer&gt; aux = new ArrayList&lt;&gt;(); dfs(0, g, val, aux); aux.add(c); long ans = 1L; int lo = 1, cnt = 0; for (int x : aux) { if (x &lt; 0) { cnt++; continue; } if (cnt &gt; 0) { ans = ans * calc(lo, x, cnt) % MOD; cnt = 0; } lo = x; } io.println(ans);}private static void dfs(int x, int[][] g, int[] val, List&lt;Integer&gt; aux) { if (x &lt; 0) { return; } dfs(g[x][0], g, val, aux); aux.add(val[x]); dfs(g[x][1], g, val, aux);}private static long calc(int lo, int hi, int cnt) { long res = 1L; int len = hi - lo + 1; for (int i = cnt + len - 1, j = 1; j &lt;= cnt; i--, j++) { res = res * i % MOD * pow(j, MOD - 2) % MOD; } return res;}private static long pow(long x, long n) { long res = 1L; for (; n != 0; x = x * x % MOD, n &gt;&gt;= 1) { if ((n &amp; 1) == 1) { res = res * x % MOD; } } return res;}","link":"/2024/02/16/Codeforces%20Round%20926%20(Div.%202)/"},{"title":"think-cell Round 1","text":"Permutation Printing 题目 输入一个整数 \\(n\\)，输出长度为 \\(n\\) 的排列，满足不存在两个不同的索引 \\(1\\leq i,j&lt; n\\)，使得 \\(p_{i}\\) 整除 \\(p_{j}\\) 且 \\(p_{i+1}\\) 整除 \\(p_{j+1}\\)。 数据范围：\\(3\\leq n\\leq 10^{5}\\)。 思路 可以构造排列 \\(1,n,2,n-1,\\dots,\\lceil\\frac{n+1}{2}\\rceil\\)。如果 \\(i&lt;j\\)，则有 \\(p_{i+1}&gt;p_{j+1}\\)，必定不能整除，反之亦然。 代码 123456789101112public static void solve() { int n = io.nextInt(); int l = 1, r = n; for (int i = 0; i &lt; n; i++) { if (i % 2 == 0) { io.print(l++ + &quot; &quot;); } else { io.print(r-- + &quot; &quot;); } } io.println();} Lexicographically Largest 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，初始时有一个空集 \\(S\\)，执行以下三步操作恰好 \\(n\\) 次： 选择一个索引 \\(i\\)，\\(1\\leq i\\leq |a|\\)。 将 \\(a_{i}+i\\) 插入集合 \\(S\\)。 从 \\(a\\) 中删除 \\(a_{i}\\)，\\(a_{i}\\) 之后的所有元素的索引将减少 \\(1\\)。 将得到的集合 \\(S\\) 中的元素按照递减顺序排列，输出能够得到的字典序最大的排列。 数据范围：\\(1\\leq n\\leq 3\\cdot 10^{5}\\)，\\(1\\leq a_{i}\\leq 10^{9}\\)。 思路 可以发现字典序最大的排列总是包含 \\(n\\) 个元素。暴力的想法是，可以首先将所有 \\(a_{i}+i\\) 从小到大排序，我们总是优先选择最大的元素，如果有多个元素最大，就优先选择其中索引 \\(i\\) 最小的元素，从而可以保证得到字典序最大的排列。通过观察可以发现，如果从小到大排列 \\(a_{i}+i\\)，然后倒序遍历数组，我们可以得到的最大元素为 \\(\\min(a[i],a[i+1]-1)\\)，对所有 \\(1\\leq i&lt; n\\) 都成立。比赛时没发现，使用的是更复杂的方法，其实不难。 12345678910111213141516public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt(); a[i] += i + 1; } Arrays.sort(a); for (int i = n - 2; i &gt;= 0; i--) { a[i] = Math.min(a[i], a[i + 1] - 1); } for (int i = n - 1; i &gt;= 0; i--) { io.print(a[i] + &quot; &quot;); } io.println();} Sum over all Substrings (Hard Version) 题目 输入长度为 \\(n\\) 的二进制字符串 \\(s\\)，输出 \\(\\sum_{i=1}^{n}\\sum_{j=i}^{n}f(s_{i}s_{i+1}\\cdots s_{j})\\)。对于某个二进制模式串 \\(p\\)，\\(f(p)\\) 表示满足以下条件的二进制字符串 \\(q\\)，其中 \\(1\\) 的最小可能数量：假设 \\(p\\) 和 \\(q\\) 的长度均为 \\(m\\)，对于所有 \\(1\\leq i\\leq m\\)，存在 \\(l\\) 和 \\(r\\)（\\(1\\leq l\\leq i\\leq r\\leq m\\)），使得 \\(p_{i}\\) 在 \\(q_{l}q_{l+1}\\cdots q_{r}\\) 中的出现次数至少为 \\(\\lceil \\frac{m}{2}\\rceil\\)。 数据范围：\\(1\\leq n\\leq 10^{6}\\)。 思路 暴力的想法是枚举所有子串，然后对于每个子串计算 \\(f\\) 值。现在思考对于给定的 \\(p\\)，如何计算 \\(f\\) 值。正序遍历子串，基本算法如下：如果 \\(p_{i}=0\\)，则直接在 \\(q_{i}\\) 放置 \\(0\\)；如果 \\(p_{i}=1\\)，则可以在 \\(q_{i+1}\\) 放置 \\(1\\)，\\(q_{i}\\) 和 \\(q_{i+2}\\) 放置 \\(0\\)，从而不论 \\(p_{i+1}\\) 和 \\(p_{i+2}\\) 是什么，都存在满足条件的 \\(l\\) 和 \\(r\\)（在区间 \\([i,i+2]\\) 范围内）。时间复杂度为 \\(O(n^{3})\\)，如果在遍历的同时计算子串，则时间复杂度为 \\(O(n^{2})\\)。可以使用动态规划将时间复杂度降低为 \\(O(n)\\)，定义 \\(dp_{i}\\) 表示 \\(\\sum_{j=i}^{n}f(s_{i}s_{i+1}\\cdots s_{j})\\)，转移方程见代码。 代码 12345678910111213141516public static void solve() { int n = io.nextInt(); char[] s = io.next().toCharArray(); long ans = 0L; long[] dp = new long[n + 3]; for (int i = n - 1; i &gt;= 0; i--) { if (s[i] == '1') { dp[i] = dp[i + 3] + n - i; } else { dp[i] = dp[i + 1]; } ans += dp[i]; } io.println(ans);}","link":"/2024/02/21/think-cell%20Round%201/"},{"title":"分布式系统的挑战","text":"不可靠的网络 网络分区故障，指网络的一部分由于网络故障而与其他部分断开，其实可以直接称为网络故障。作者推荐，可以通过故意触发网络问题，来测试系统的反应。 在分布式系统中，需要设置响应的超时时间，从而判断节点是否失效。如果时间设置得太长，则需要等待更长的时间。如果时间设置得太短，可能节点只是负载过高而响应缓慢，此时判断节点失效并将负载转移到其他节点会进一步增加系统负载，从而可能导致失效扩散（还可能会导致其他异常）。比较好的做法是，持续测量响应时间及其变化，然后根据测量结果自动调整超时时间。 从广义上讲，网络延迟的波动可以视为资源动态分配的结果。传统的电话网络（非 VoIP）使用电路交换技术，为每个通话分配一条固定带宽的通信链路，网络的延迟是确定的；而互联网使用分组交换技术，所有用户共享网络带宽，用户之间的数据存在排队的情况，该方法可以增加带宽的利用率，但是理论上的延迟是无限大的。 不可靠的时钟 网络上的每台机器都有独立的时钟硬件设备，通常是石英晶体振荡器，用于维护机器的本地时间，该时间可能与其他机器上的时间不同。通常使用网络时间协议（Network Time Protocol，NTP）来同步机器之间的时间，该协议根据一组专门的时间服务器来调整本地时间（调整石英的振动频率），时间服务器则从精确度更高的时间源（例如 GPS 接收器）获取高精度时间。 墙上时钟和单调时钟 现代计算机内部至少有两种时钟：墙上时钟和单调时钟。 墙上时钟 墙上时钟根据某个日期返回当前的日期与时间，例如 Linux 的 clock_gettime(CLOCK_REALTIME) 和 Java 的 System.currentTimeMillis() 会返回自 1970 年 1月 1 日（UTC）以来的秒数和毫秒数，不含润秒。有些系统则使用其他日期作为参考点。 墙上时钟需要使用 NTP 进行同步，但是存在很多问题。特别是，如果本地时钟远远快于 NTP 服务器，则同步之后会发生时间倒退的现象，以及墙上时钟经常忽略润秒，导致其不太适合用于测量时间间隔。 单调时钟 单调时钟不需要和 NTP 服务器时钟进行同步，适合测量时间间隔。例如 Linux 的 clock_gettime(CLOCK_MONOTONIC) 和 Java 中的 System.nanoTime() 返回的都是单调时钟。单调时钟的单个值没有任何意义，它可能是电脑启动后经过的纳秒数或者其他含义，不同节点上的单调时钟没有相同的基准，不能相互比较。 时钟同步和准确性 硬件时钟和 NTP 服务器可能会出现各种问题，例如：计算机中的石英钟存在漂移现象（运行速度会加快或减慢，取决于机器的温度）；如果本地时钟和 NTP 服务器时钟相差太大，应用程序可能会看到时间倒退或跳跃的现象；同步的准确性受限于网络延迟，以及 NTP 服务器是否正常工作；各种其他情况，包括下面提到的润秒。 润秒（Leap second）就是对协调世界时（Coordinated Universal Time，UTC）增加或减少 1 秒，以使协调世界时和世界时（UT，通常指 UT1）之间的差异不超过 0.9 秒。2022 年 11 月，国际计量大会决定在 2035 年之前取消润秒。润秒曾经使许多大型系统崩溃，根本原因是许多系统没有正确适配润秒，软件存在 BUG 从而引发各种问题。可以看下 The Inside Story of the Extra Second That Crashed the Web 这篇文章，讲述了现实中发生过的问题。Google 处理润秒方式是，在一天内逐步调整时间，而不是在一天结束时直接改变 1 秒。PS：一个显示各个时钟目前时间的网站。 如果投入大量资源，可以达到非常高的时钟精度，例如交易系统的时钟就要求很小的时钟误差。高精度的时钟可以使用 GPS 接收器，精确时间协议（PTP）并辅以细致的部署和监测来实现。 依赖同步的时钟 如果应用需要精确同步的时钟，最好仔细监控所有节点上的时钟偏差。如果某个节点的时钟漂移超出上限，则将其视为失效节点并从集群中移除。这样监控的目的是确保在造成重大影响（例如隐式的数据丢失）之前尽早发现并处理问题。 时间戳和事件顺序 在无主复制的检测并发写中提到过，最后写入者获胜（LWW）冲突解决策略由于时钟偏差，可能会覆盖非并发写入。 在上述例子中，时钟同步机制稳定工作，节点 1 和节点 3 之间的时钟偏差小于 3ms，但是时间戳却不能正确排序事件，从而导致客户端 B 的增量操作被覆盖。解决方案就是之前提到过的，使用版本向量技术跟踪因果关系。PS：因果关系其实就是非并发写操作的前后关系，版本向量不仅可以跟踪因果关系，还可以判断写操作是否并发。 时钟的置信区间 或许墙上时钟会返回微秒甚至纳秒级别的信息，但是这种精度的测量值其实并不可信，因为存在石英漂移和网络延迟等不确定性因素。所以，我们不应该将时钟读数视为一个精确的时间点，而应该视为带有置信区间的时间范围。例如，系统可能有 95% 的置信度认为目前时间介于 10.3~10.5 秒之间。 可以根据具体的时间源来推算出时钟误差的上限。如果节点上直接装有 GPS 接收器或原子（铯）时钟，那它的误差范围通常可查询制造商的手册。如果节点是从服务器获取时间，则不确定性取决于上次同步以来的石英漂移范围，加上 NTP 服务器的不确定性，再加上节点和服务器之间的往返时间。 但是，大多数系统并不提供这种误差查询接口，通常只会返回某个确定的时间，而没有任何误差信息。Google Spanner 中的 TrueTime API 提供误差查询，它会返回时间的上下界。 全局快照的同步时钟 该节主要是讲如何在分布式场景下，生成全局单调递增的事务 ID，有点不明白这个标题是什么意思。如果是单节点数据库，使用一个计数器就可以实现正确的事务 ID。但是，如果是多节点数据库，则更加复杂并且开销更大。 Twitter 使用雪花（Snowflake）算法来生成近似单调递增的唯一 ID。如果节点之间的墙上时钟完全同步，则也可以将其作为事务 ID，但是实际上是不可能的。Google Spanner 使用 TrueTime API 返回的时钟置信区间作为事务 ID，如果两个置信区间没有重叠，则可以知道两个事务的先后顺序。 进程暂停 在使用主从复制的数据库中，只有主节点可以接受写入，如果主节点失效则需要将某个从节点提升为主节点。判断节点是否失效可以使用租约来实现：如果某个节点持有租约，那么它就是主节点；如果租约过期，则该节点失效。我们可以使用单调时钟来判断租约是否过期，但是可能由于垃圾收集、上下文切换或磁盘 I/O 等原因导致进程暂停，从而使得暂停之前判断租约没有过期，暂停之后发送请求时租约已经过期。 上图是 HBase 曾经遇到的问题，不正确的分布式锁实现，导致未持有锁的客户端修改数据。解决方案是，锁服务为每个锁维护一个单调递增的 fencing 令牌（实际上就是版本号），在锁服务授予客户端租约和客户端向存储服务发送写请求时会包含该令牌，存储服务也会维护数据最后一次修改对应的令牌。如果存储服务收到的写请求包含旧令牌，则会拒绝该请求。如果使用 ZooKeeper 作为锁服务，则事务标识 zxid 或节点版本 cversion 可以充当 fencing 令牌。","link":"/2024/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/"},{"title":"AtCoder Beginner Contest 344","text":"String Bags 题目 输入字符串 \\(T\\) 和整数 \\(N\\)，表示有 \\(N\\) 个袋子。然后对每个袋子，输入其包含的字符串个数 \\(A_{i}\\)，以及 \\(A_{i}\\) 个字符串 \\(S_{i,1},S_{i,2},\\dots,S_{i,A_{i}}\\)。对于每个袋子，我们只能从中选择一个字符串或者不选。输出选择袋子的最少个数，使得按照袋子的编号顺序拼接字符串，能够得到字符串 \\(T\\)。如果无法得到字符串 \\(T\\)，则输出 \\(-1\\)。 数据范围：\\(1\\leq \\operatorname{len}(T)\\leq 100\\)，\\(1\\leq N\\leq 100\\)，\\(1\\leq A_{i}\\leq 10\\)，\\(1\\leq \\operatorname{len}(S_{i,j})\\leq 10\\)。 思路 定义 \\(dp[i][j]\\) 表示从袋子 \\([1,i]\\) 中选择袋子的最少个数，使得拼接得到的字符串和 \\(T\\) 的前缀 \\([1,j]\\) 相同（下标从 \\(1\\) 开始）。初始状态和转移方程见代码，算是基本的动态规划，太久没做题加上原题表述有歧义，竟然没做出来。 代码 1234567891011121314151617181920212223242526public static void solve() { String t = io.next(); int n = io.nextInt(); int m = t.length(); int[] dp = new int[m + 1]; Arrays.fill(dp, m + 1); dp[0] = 0; for (int i = 0; i &lt; n; i++) { int z = io.nextInt(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int j = 0; j &lt; z; j++) { set.add(io.next()); } for (int j = m - 1; j &gt;= 0; j--) { for (int k = 1; k &lt;= 10 &amp;&amp; k &lt;= j + 1; k++) { if (set.contains(t.substring(j - k + 1, j + 1))) { dp[j + 1] = Math.min(dp[j + 1], dp[j + 1 - k] + 1); } } } } io.println(dp[m] == m + 1 ? -1 : dp[m]);}","link":"/2024/03/10/AtCoder%20Beginner%20Contest%20344/"},{"title":"第 388 场力扣周赛","text":"K 个不相交子数组的最大能量值 题目 输入长度为 \\(n\\) 的整数数组 \\(nums\\) 和正奇数 \\(k\\)，输出从数组中选择 \\(k\\) 个不相交的子数组，能够得到的最大得分。\\(k\\) 个子数组的得分为 \\(\\sum_{i=1}^{k}(-1)^{i+1}\\times sum[i]\\times (k-i+1)\\)，其中 \\(sum[i]\\) 表示第 \\(i\\) 个子数组中元素之和。 数据范围：\\(1\\leq n\\leq 10^{4}\\)，\\(-10^{9}\\leq nums[i]\\leq 10^{9}\\)，\\(1\\leq k\\leq n\\)，\\(1\\leq n\\times k\\leq 10^{6}\\)。 思路 定义 \\(dp[i][r]\\) 表示从区间 \\([0,r-1]\\) 选择 \\(i\\) 个不相交子数组，能够得到的最大得分。对于元素 \\(nums[r-1]\\)，我们有选或者不选两种情况，状态转移方程如下： $$ dp[i][r]=\\max(dp[i][r-1],\\max_{l=i-1}^{r-1}(dp[i-1][l]+(sum[r]-sum[l])\\times (-1)^{i+1}\\times (k-i+1))) $$ 初始时，对于所有 \\(0\\leq i\\leq n\\)，有 \\(dp[0][i]=0\\)，其他值初始化为负无穷。使用上述转移方程，时间复杂度为 \\(O(kn^{2})\\)。可以对其变形，将时间复杂度优化为 \\(O(kn)\\)，详细参见灵神的题解。小羊的题解使用的是另一种做法，似乎更简洁，但是看不太懂啊。 代码 123456789101112131415161718192021222324class Solution { public long maximumStrength(int[] nums, int k) { int n = nums.length; long[] sum = new long[n + 1]; for (int i = 0; i &lt; n; i++) { sum[i + 1] = sum[i] + nums[i]; } long[][] dp = new long[k + 1][n + 1]; for (int i = 1; i &lt;= k; i++) { Arrays.fill(dp[i], Long.MIN_VALUE); } for (int i = 0; i &lt; k; i++) { long max = Long.MIN_VALUE; int w = (2 * (i &amp; 1) - 1) * -1 * (k - i); for (int r = i; r &lt; n - (k - i - 1); r++) { max = Math.max(max, dp[i][r] - sum[r] * w); dp[i + 1][r + 1] = Math.max(dp[i + 1][r], sum[r + 1] * w + max); } } return dp[k][n]; }}","link":"/2024/03/10/%E7%AC%AC%20388%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 394 场力扣周赛","text":"使矩阵满足条件的最少操作次数 题目 输入 \\(m\\times n\\) 的矩阵 \\(grid\\)，输出需要的最少操作次数，使得每列的值相等，且相邻两列的值不相等。每次操作可以将任意单元格的值修改为任意非负整数。 数据范围：\\(1\\leq n,m\\leq 1000\\)，\\(0\\leq grid[i][j]\\leq 9\\)。 思路 首先，每列的值肯定是修改为 \\([0,9]\\) 之间更优，因为操作次数可能更少。我们可以从前往后枚举每列修改为什么值，可以发现存在重叠子问题。定义 \\(dp[i][j]\\) 表示将第 \\(i\\) 列修改为 \\(j\\)，使得 \\([0,i]\\) 列满足条件所需的最少操作次数。有状态转移方程 \\(dp[i][j]=\\min{(dp[i-1][k])}+cnt_{i,j}\\)，其中 \\(0\\leq k\\leq 9\\) 且 \\(k\\neq j\\)，\\(cnt_{i,j}\\) 表示将第 \\(i\\) 列修改为 \\(j\\) 所需的操作次数。时间复杂度为 \\(O(mn+nU^{2})\\)，空间复杂度为 \\(O(nU)\\)，其中 \\(U\\) 表示 \\(grid[i][j]\\) 的值域大小。灵神题解提到一个优化方式，状态转移只会从前面所有列操作的最优值或者次优值转移过来，利用这个特性可以降低时间和空间复杂度。 代码 1234567891011121314151617181920212223242526272829303132class Solution { public int minimumOperations(int[][] grid) { int m = grid.length, n = grid[0].length; int[][] cnt = new int[n][10]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { cnt[j][grid[i][j]]++; } } int[][] dp = new int[n + 1][10]; for (int i = 1; i &lt;= n; i++) { Arrays.fill(dp[i], Integer.MAX_VALUE); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (k != j) { dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][k] + (m - cnt[i][j])); } } } } int ans = Integer.MAX_VALUE; for (int i = 0; i &lt; 10; i++) { ans = Math.min(ans, dp[n][i]); } return ans; }} 最短路径中的边 题目 输入整数 \\(n\\) 和长度为 \\(m\\) 的数组 \\(edges\\)，表示包含 \\(n\\) 个节点和 \\(m\\) 条边的无向带权图（无重边和自环）。输出长度为 \\(m\\) 的布尔数组 \\(ans\\)，如果从节点 \\(0\\) 到节点 \\(n-1\\) 的所有最短路中包含 \\(edges[i]\\)，则 \\(ans[i]=true\\)。 数据范围：\\(2\\leq n\\leq 5\\times 10^{4}\\)，\\(1\\leq m\\leq\\min{(5\\times 10^{4},\\frac{n(n-1)}{2})}\\)，\\(1\\leq w_{i}\\leq 10^{5}\\)。 思路 首先使用 Dijkstra 算法求出从节点 \\(0\\) 到所有其他节点的最短路，然后暴力的想法是以节点 \\(0\\) 为起点使用 DFS 回溯来遍历图，遍历的同时存储路径上的边，当到达节点 \\(n-1\\) 的路径长度等于最短路时，则将该路径上的边都置为 \\(true\\)。回溯理论上最坏情况下的时间复杂度为 \\(O(n\\times n!)\\)，但是可以通过力扣的测试，因为可以利用最短路的限制进行剪枝，至于能否构造出 Hack 回溯的测试用例，我不太清楚。 正确的解法是使用两次 Dijkstra 算法，分别求出从节点 \\(0\\) 到所有其他节点的最短路，和从节点 \\(n-1\\) 到所有其他节点的最短路。然后枚举每一条边，判断路径长度 \\(d_{0,u}+w_{u,v}+d_{v,n-1}\\) 或者 \\(d_{0,v}+w_{u,v}+d_{u,n-1}\\) 是否等于最短路，从而可以得出该边是否在某个最短路中。 另一种做法是只对起点使用一次 Dijkstra 算法，然后从终点反向 DFS，经过的边如果满足 \\(d_{0,v}+w_{u,v}=d_{0,u}\\)，则说明该边在某个最短路上。","link":"/2024/05/13/%E7%AC%AC%20394%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"AtCoder Beginner Contest 350","text":"Sort 题目 输入长度为 \\(n\\) 的数组 \\(a\\)，表示从 \\(1\\) 到 \\(n\\) 的排列。输出操作的次数和过程，使得排列有序。每次操作可以交换 \\(a_{i}\\) 和 \\(a_{j}\\)，其中 \\(1\\leq i&lt;j\\leq n\\)。 数据范围：\\(2\\leq n\\leq 2\\times 10^{5}\\)。 思路 如果 \\(a_{i}=i\\)，则说明 \\(a_{i}\\) 在正确的位置上。否则，\\(a_{i}\\) 应该移动到位置 \\(a_{i}\\) 上，即交换下标 \\(i\\) 和 \\(a_{i}\\) 的值。这样每次交换都至少使得一个数在正确的位置上，最多交换 \\(n-1\\) 次，时间复杂度为 \\(O(n)\\)。PS：太久没做题，竟然没有做出来。比赛时多此一举，使用的是下标数组 + 排序做的，其实也没问题，就是最后没有按照大小顺序输出。 代码 1234567891011121314151617181920public static void solve() { int n = io.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = io.nextInt() - 1; } List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { while (a[i] != i) { ans.add(new int[]{Math.min(i, a[i]), Math.max(i, a[i])}); int t = a[a[i]]; a[a[i]] = a[i]; a[i] = t; } } io.println(ans.size()); for (var t : ans) { io.println((t[0] + 1) + &quot; &quot; + (t[1] + 1)); }}","link":"/2024/05/13/AtCoder%20Beginner%20Contest%20350/"},{"title":"第 397 场力扣周赛","text":"矩阵中的最大得分 题目 输入一个 \\(m\\times n\\) 的矩阵 \\(grid\\)，输出选择任意单元格作为起点，至少移动一次能够得到的最大得分。每次移动只能向正右方和正下方的单元格移动，不必相邻。假设从单元格 \\((x_{1},y_{1})\\) 移动到 \\((x_{2},y_{2})\\)，则本次移动的得分为 \\(grid[x_{2}][y_{2}]-grid[x_{1}][y_{1}]\\)。 数据范围：\\(2\\leq m,n\\leq 1000\\)，\\(4\\leq m\\times n\\leq 10^{5}\\)，\\(1\\leq grid[i][j]\\le 10^{5}\\)。 思路 比赛时想到计算过程存在重叠子问题，可以使用记忆化搜索。定义 \\(f[i][j]\\) 表示以 \\((i,j)\\) 为起点能够得到的最大得分，初始化 \\(f[i][j]\\) 为负无穷。当 \\(i&lt;m-1\\) 且 \\(j&lt;n-1\\) 时，状态转移方程为 \\(f[i][j]=\\max{(f[i+1][j]+grid[i+1][j]-grid[i][j],f[i][j+1])+grid[i][j+1]-grid[i][j]}\\)。也可以将记忆化搜索转化为自底向上的形式，或者定义 \\(f[i][j]\\) 表示以 \\((i,j)\\) 为终点能够得到的最大得分。 通过观察可以发现，对于某个移动路径，得分只和起点和终点有关，中间的值都被抵消了。也就是说，某个起点能够得到的最大得分，是其右下角的最大值减去起点的值，反之亦然。所以也可以定义 \\(f[i][j]\\) 表示 \\((i,j)\\) 右下角的最大值或者左上角的最小值，然后进行递推。 时间复杂度为 \\(O(mn)\\)，空间复杂度为 \\(O(mn)\\)。灵神题解有个空间复杂度为 \\(O(n)\\) 的做法，思路是维护每列的最小值。 代码 123456789101112131415161718192021222324252627282930313233class Solution { public int maxScore(List&lt;List&lt;Integer&gt;&gt; grid) { int m = grid.size(), n = grid.get(0).size(); int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) { Arrays.fill(dp[i], Integer.MIN_VALUE); } dfs(0, 0, grid, dp); int ans = Integer.MIN_VALUE; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { ans = Math.max(ans, dp[i][j]); } } return ans; } private int dfs(int x, int y, List&lt;List&lt;Integer&gt;&gt; grid, int[][] dp) { int m = grid.size(), n = grid.get(0).size(); if (dp[x][y] == Integer.MIN_VALUE) { if (x + 1 &lt; m) { int diff = grid.get(x + 1).get(y) - grid.get(x).get(y); dp[x][y] = Math.max(dp[x][y], diff + dfs(x + 1, y, grid, dp)); } if (y + 1 &lt; n) { int diff = grid.get(x).get(y + 1) - grid.get(x).get(y); dp[x][y] = Math.max(dp[x][y], diff + dfs(x, y + 1, grid, dp)); } } return Math.max(0, dp[x][y]); }} 找出分数最低的排列 题目 输入从 \\(0\\) 到 \\(n-1\\) 的一个排列 \\(nums\\)，输出从 \\(0\\) 到 \\(n-1\\) 的排列 \\(perm\\)，使得 \\(score(perm)=\\sum_{i=0}^{n-1}{|perm[i]-nums[perm[(i+1)\\bmod n|}\\) 的值最小。如果有多个满足条件的排列，则返回字典序最小的那个。 数据范围：\\(2\\leq n\\leq 14\\)。 思路 通过观察可以发现，对于一个给定的排列 \\(perm\\)，将其循环移动不会改变 \\(score(perm)\\) 的值。要使满足条件的 \\(perm\\) 字典序最小，那么必然有 \\(perm[0]=0\\)。暴力的想法是枚举所有排列，但是时间复杂度为 \\(n!\\times n\\)。由于枚举过程中，存在重复子问题，可以使用记忆化搜索来降低时间复杂度到 \\(O(2^{n}n^{2})\\)。定义 \\(f[mask][pre]\\) 表示已经选择集合 \\(mask\\) 中的数，上一个选择的数是 \\(pre\\)，剩余的数排列能够得到的最小分数。同理，定义 \\(g[mask][pre]\\) 表示下一个选择什么数能够使得分数最小，以及相同分数的排列字典序最小。可以看下灵神题解，不使用记忆化搜索，自底向上的解法也是非常经典的。 代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int[] findPermutation(int[] nums) { int n = nums.length; int[][] f = new int[1 &lt;&lt; n][n]; int[][] g = new int[1 &lt;&lt; n][n]; for (int i = 0; i &lt; (1 &lt;&lt; n) - 1; i++) { Arrays.fill(f[i], -1); } for (int i = 0; i &lt; n; i++) { f[(1 &lt;&lt; n) - 1][i] = Math.abs(i - nums[0]); } dfs(1, 0, nums, f, g); int[] ans = new int[n]; for (int i = 0, mask = 0, cur = 0; i &lt; n; i++) { ans[i] = cur; mask |= 1 &lt;&lt; cur; cur = g[mask][cur]; } return ans; } private int dfs(int mask, int pre, int[] nums, int[][] f, int[][] g) { int n = nums.length; if (mask == (1 &lt;&lt; n) - 1 || f[mask][pre] != -1) { return f[mask][pre]; } int res = Integer.MAX_VALUE; for (int i = 1; i &lt; n; i++) { if ((mask &gt;&gt; i &amp; 1) == 0) { int cur = dfs(mask | 1 &lt;&lt; i, i, nums, f, g) + Math.abs(pre - nums[i]); if (cur &lt; res) { res = cur; g[mask][pre] = i; } } } return f[mask][pre] = res; }}","link":"/2024/05/13/%E7%AC%AC%20397%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"},{"title":"第 130 场力扣夜喵双周赛（VP）","text":"正方形中的最多点数 题目 输入长度为 \\(n\\) 的二维数组 \\(points\\) 和字符串 \\(s\\)，\\(points[i]\\) 表示第 \\(i\\) 个点的坐标，\\(s[i]\\) 表示第 \\(i\\) 个点的标签。如果以 \\((0,0)\\) 为中心且边平行于坐标轴的正方形内（包括边上的点，且边长可以为 \\(0\\)），不包含标签相同的两个点，则该正方形是合法的。输出合法正方形可以包含的最多点数。其中 \\(points\\) 中的点互不相同，\\(s\\) 只包含小写英文字母。 数据范围：\\(1\\leq n\\leq 10^{5}\\)，\\(-10^{9}\\leq points[i][0],points[i][1]\\leq 10^{9}\\)。 思路 首先可以想到，正方形的边长越长，包含的点就越多，越可能不合法。具有单调性，可以使用二分求解。在二分的过程中，判断正方形是否合法，如果合法则更新答案。时间复杂度为 \\(O(n\\log{U})\\)，其中 \\(U=\\max_{i=0}^{n-1}(|x_{i}|,|y_{i}|)\\)。更好的做法是观察到，如果正方形包含某个点 \\((x,y)\\)，则正方形的边长 \\(len\\) 必须满足 \\(len\\geq 2\\times\\max(|x|,|y|)\\)。其中，\\(\\max(|x|,|y|)\\) 是点 \\((x,y)\\) 到点 \\((0,0)\\) 的切比雪夫距离。实际上，我们只需要维护每种标签点的最小切比雪夫距离 \\(min_{i}\\)，以及除此之外所有点的最小切比雪夫距离 \\(k\\)。因为，如果正方形包含某个标签 \\(i\\)，必定是包含具有该标签的切比雪夫距离最小的那个点，而这个点需要满足 \\(min_{i}&lt;k\\)。详情见代码，时间复杂度为 \\(O(n)\\)。优化思路参考灵神题解。 代码 1234567891011121314151617181920212223242526272829class Solution { public int maxPointsInsideSquare(int[][] points, String s) { int n = points.length; int[] min = new int[26]; Arrays.fill(min, Integer.MAX_VALUE); int k = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { int x = points[i][0]; int y = points[i][1]; int z = Math.max(Math.abs(x), Math.abs(y)); int c = s.charAt(i) - 'a'; if (z &lt; min[c]) { k = Math.min(k, min[c]); min[c] = z; } else { k = Math.min(k, z); } } int ans = 0; for (int x : min) { if (x &lt; k) { ans++; } } return ans; }} 分割字符频率相等的最少子字符串 题目 输入长度为 \\(n\\) 的字符串 \\(s\\)（只包含小写英文字母），输出 \\(s\\) 最少能被分割为多少个平衡子字符串。平衡字符串就是字符串中不同字符出现频次都相同的字符串。 数据范围：\\(1\\leq n\\leq 1000\\)。 思路 定义 \\(dp[i+1]\\) 表示字符串 \\([0,i]\\) 最少能被分割的平衡子字符串数目，则转移方程为 \\(dp[i+1]=\\min(dp[j]+1)\\)，其中 \\(0\\leq j\\leq i\\) 且字符串 \\([j,i]\\) 必须是平衡字符串。 代码 12345678910111213141516171819class Solution { public int minimumSubstringsInPartition(String s) { int n = s.length(); int[] dp = new int[n + 1]; for (int i = 0; i &lt; n; i++) { dp[i + 1] = i + 1; int k = 0, max = 0; int[] cnt = new int[26]; for (int j = i; j &gt;= 0; j--) { k += cnt[s.charAt(j) - 'a'] == 0 ? 1 : 0; max = Math.max(max, ++cnt[s.charAt(j) - 'a']); if (i - j + 1 == k * max) { dp[i + 1] = Math.min(dp[i + 1], dp[j] + 1); } } } return dp[n]; }} 大数组元素的乘积 不会。","link":"/2024/05/14/%E7%AC%AC%20130%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B%EF%BC%88VP%EF%BC%89/"},{"title":"南京大学 计算机系统基础 课程实验 2022","text":"实验网站，2020 南京大学计算机系统基础习题课。 PA0 - 世界诞生的前夜: 开发环境配置 使用 vimtutor 命令启动 vim 教程。 教程：GNU/Linux，Makefile，GDB，tmux，Git，Linux C编程一站式学习。 课程：The Missing Semester of Your CS Education。 其他：Visualizing Git Concepts with D3。 使用 apt-get install 经常遇到 “The following packages have unmet dependencies” 错误，原因是因为依赖的包和现有的包版本冲突，之前我都是手动 apt-get remove，但是经常遇到该问题。STFW 之后，这里推荐的 aptitude 工具比较方便，发生冲突时会询问是否降级。（apt-get，aptitude，apt 的区别，是否有必要使用 aptitude？讨论。） 使用 make 经常遇到 “No such file or directory” 之类缺失头文件的错误，目前是遇到两种情况。一种是缺失对应的包，直接 apt-get install 即可解决；另一种是有对应的包，但是当前项目中 .mk 文件配置的程序名称和现有名称不一致（例如，配置的是 llvm-config，而现有的是 llvm-config-11），修改 .mk 文件即可解决。 PA1 - 开天辟地的篇章: 最简单的计算机 手册：riscv-isa-manual，riscv-elf-psabi-doc，etc，NEMU ISA API。 可以在目标命令之前添加 time 命令，从而计算目标命令的执行时间。使用 make 命令的 -j 选项，可以启用多线程编译。make -j4 表示创建 4 个线程并行编译，具体创建多少个线程，可以根据 lscpu 命令查询得到的系统中的 CPU 数量来确定。使用 ccache 工具可以缓存目标文件，从而加速执行 make clean 之后，再次执行 make 的速度。 如何实现宏 IFDEF 和 MUXDEF。其中 IFDEF 表示，如果定义了 CONFIG_DEVICE 宏，才会调用 init_device() 函数。而 MUXDEF 表示，如果定义了 CONFIG_TRACE 宏，则预处理结果为 ON，否则预处理结果为 OFF。 12IFDEF(CONFIG_DEVICE, init_device());MUXDEF(CONFIG_TRACE, &quot;ON&quot;, &quot;OFF&quot;) 在 nemu/include/macro.h 文件中有如下定义： 1234567891011121314151617181920212223// macro concatenation#define concat_temp(x, y) x ## y#define concat(x, y) concat_temp(x, y)// macro testing// See https://stackoverflow.com/questions/26099745/test-if-preprocessor-symbol-is-defined-inside-macro#define CHOOSE2nd(a, b, ...) b#define MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)// define placeholders for some property#define __P_DEF_0 X,#define __P_DEF_1 X,// define some selection functions based on the properties of BOOLEAN macro#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)// simplification for conditional compilation#define __IGNORE(...)#define __KEEP(...) __VA_ARGS__// keep the code if a boolean macro is defined#define IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__) 我们可以使用如下代码进行测试，同时给出宏展开的步骤。需要注意的是，只有当 CONFIG_DEVICE 被定义为 0 或 1 时，才会执行函数调用。 123456789101112#include &lt;stdio.h&gt;#define CONFIG_DEVICE 1void init_device() { printf(&quot;Hello, Linux World!\\n&quot;);}int main(void) { IFDEF(CONFIG_DEVICE, init_device()); return 0;} 12345678910IFDEF(CONFIG_DEVICE, init_device());IFDEF(1, init_device());MUXDEF(1, __KEEP, __IGNORE)(init_device());MUX_MACRO_PROPERTY(__P_DEF_, 1, __KEEP, __IGNORE)(init_device());MUX_WITH_COMMA(concat(__P_DEF_, 1), __KEEP, __IGNORE)(init_device());MUX_WITH_COMMA(__P_DEF_1, __KEEP, __IGNORE)(init_device());MUX_WITH_COMMA(X,, __KEEP, __IGNORE)(init_device());CHOOSE2nd(X, __KEEP, __IGNORE)(init_device());__KEEP(init_device());init_device();","link":"/2024/08/12/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%20%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C%202022/"},{"title":"南京大学 操作系统 课程总结 2022","text":"课程网站，课程视频，OSTEP，CSAPP。 Part 1 资料：The Feynman Lectures on Physics，ENIAC Simulator and Related Material。 思考 Why - What - How，为什么 - 是什么 - 怎么做。 Operating System: A body of software, in fact, that is responsible for making it easy to run programs (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP) 关键问题：操作系统如何发展成现在这样的？（硬件、软件） 工具：gdb，strace。（tldr，xxd） 资料：Vim help files，logisim.c，seven-seg.py，minimal.S。 以下代码是 logisim.c 的简化版，实现数字逻辑电路的模拟器。我们可以在 vim 中使用 !gcc % &amp;&amp; ./a.out 命令，运行如下代码。代码中使用 X macro 技巧，我们可以使用 !gcc -E % 命令输出宏展开之后的代码。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define REGS_FOREACH(_) _(X) _(Y)#define RUN_LOGIC X1 = !X &amp;&amp; Y; \\ Y1 = !X &amp;&amp; !Y;#define DEFINE(X) static int X, X##1;#define UPDATE(X) X = X##1;#define PRINT(X) printf(#X &quot; = %d; &quot;, X);int main() { REGS_FOREACH(DEFINE); while (1) { // clock RUN_LOGIC; REGS_FOREACH(PRINT); REGS_FOREACH(UPDATE); putchar('\\n'); sleep(1); }} 123456789int main() { static int X, X1; static int Y, Y1;; while (1) { X1 = !X &amp;&amp; Y; Y1 = !X &amp;&amp; !Y;; printf(&quot;X&quot; &quot; = %d; &quot;, X); printf(&quot;Y&quot; &quot; = %d; &quot;, Y);; X = X1; Y = Y1;; putchar('\\n'); sleep(1); } } 程序 seven-seg.py 使用 ANSI escape code 来控制字符的颜色。\\033[37m 和 \\033[31m 分别表示，将当前和之后的字符设置为白色、红色，而 \\033[0m 表示重置设置。\\033[2J 表示清空屏幕同时将光标移至左上角，\\033[1;1f 表示将光标移至第 1 行和第 1 列（应该是这样，HVP 和 CUP 的区别没看懂）。最后，我们可以使用管道，将 logisim.c 的输出作为 seven-seg.py 的输入，从而模拟数码管的显示（执行 ./a.out | python3 seven-seg.py 命令）。 彩蛋：telnet towel.blinkenlights.nl（命令行电影），ssh sshtron.zachlatta.com（网络游戏）。（使用 ANSI escape code 实现） 关键概念：程序是状态机。可以从以下两个视角，抽象的理解。 源代码视角：状态 = 栈帧列表（每个栈帧都有 PC）+ 全局变量。 二进制视角：状态 = 寄存器 + 内存，程序 = 计算指令 + syscall 指令。 问题：如何构造一个最小的 “Hello, World” 程序？（RTFM，man syscall） 1234567891011121314151617#include &lt;sys/syscall.h&gt;.globl _start_start: movq $SYS_write, %rax // write( movq $1, %rdi // fd=1, movq $st, %rsi // buf=st, movq $(ed - st), %rdx // count=ed-st syscall // ); movq $SYS_exit, %rax // exit( movq $1, %rdi // status=1 syscall // );st: .ascii &quot;\\033[01;31mHello, OS World\\033[0m\\n&quot;ed:","link":"/2024/08/14/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%202022/"},{"title":"UCB CS61A 课程总结","text":"课程网站，Composing Programs，Python Tutor，Karel the Robot。","link":"/2024/08/16/UCB%20CS61A%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"设计模式","text":"refactoringguru，sourcemaking。 创建型模式 单例模式 提前创建单例：适用于频繁使用，或者单例占用资源较少的情况。最简单创建单例的方式是使用枚举类。 延迟创建单例：存在多线程问题，可以直接使用 synchronized 对整个方法进行同步。但实际上只有在第一次调用时才需要同步，所以更优的实现是使用双重检查加锁以及 volatile 关键字。 当使用多个类加载器、反射和序列化/反序列化时，要注意避免创建多个单例实例。 1234567891011121314151617181920public final class Singleton { private volatile static Singleton instance; public String value; private Singleton(String value) { this.value = value; } public static Singleton getInstance(String value) { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(value); } } } return instance; }} 结构型模式 代理模式 Java 在 java.lang.reflect 包中有自己的代理支持，利用该包可以动态地创建代理类，所以该技术被称为动态代理。 实现 InvocationHandler 接口。 以指定的对象和 InvocationHandler 实现类为参数，调用 Proxy.newProxyInstance 方法，创建代理对象。 将代理对象强制类型转换为指定的对象所实现的某个接口类型，然后调用方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Person { void foo();}class PersonImpl implements Person { @Override public void foo() { System.out.println(this.getClass().getName()); }}class MyInvocationHandler implements InvocationHandler { private Person person; public MyInvocationHandler(Person person) { this.person = person; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 逻辑处理 System.out.println(this.getClass().getName()); return method.invoke(person, args); }}class ProxyFactory { public static Person getProxyInstance(Person person) { return (Person) Proxy.newProxyInstance( person.getClass().getClassLoader(), person.getClass().getInterfaces(), new MyInvocationHandler(person)); }}public class DynamicProxy { public static Person getProxyInstance(Person person) { return (Person) Proxy.newProxyInstance( person.getClass().getClassLoader(), person.getClass().getInterfaces(), new MyInvocationHandler(person)); } public static void main(String[] args) { Person person = new PersonImpl(); Person proxyInstance = getProxyInstance(person); proxyInstance.foo(); }}","link":"/2024/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"CSAPP 第 1 &amp; 2 章","text":"系统概述 编译系统 系统硬件 系统抽象 信息存储 基本概念 大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。 每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 \\(w\\) 位的机器而言，虚拟地址的范围为 0 ~ \\(2^{w}\\)-1，程序最多访问 \\(2^{w}\\) 个字节。 我们将程序称为“32 位程序”或“64 位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。 字节顺序 对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。 在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为 int 的变量 × 的地址为 0x100，也就是说，地址表达式 &amp;× 的值为 0x100。那么，（假设数据类型 int 为 32 位表示）x 的 4 个字节将被存储在内存的 0x100、0x101、0x102 和 0x103 位置。 在内存中按照从最低有效字节到最高有效字节的顺序存储对象的方式，称为小端法（little endian）。按照从最高有效字节到最低有效字节的顺序存储对象的方式，称为大端法（big endian）。假设变量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围 0x100 ~ 0x103 的字节顺序依赖于机器的类型： 整数表示 编码方式 对向量 \\(\\vec{x}=[x_{w-1},x_{w-2},\\cdots,x_{0}]\\)，各编码方式的定义如下： 编码方式 定义 无符号数 \\(B2U_{w}(\\vec{x})\\dot =\\sum_{i=0}^{w-1}x_{i}2^{i}\\) 补码 \\(B2T_{w}(\\vec{x})\\dot =-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_{i}2^{i}\\) 反码 \\(B2O_{w}(\\vec{x})\\dot =-x_{w-1}(2^{w-1}-1)+\\sum_{i=0}^{w-2}x_{i}2^{i}\\) 原码 \\(B2S_{w}(\\vec{x})\\dot =(-1)^{x_{w-1}}\\cdot(\\sum_{i=0}^{w-2}x_{i}2^{i})\\) 转换规则 对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。转换关系如下： 补码转换为无符号数，\\(T2U_{w}(x)=x+x_{w-1}2^{w}\\)。 无符号数转换为补码，\\(U2T_{w}(u)=u-u_{w-1}2^{w}\\)。 当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。 扩展规则 要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0，这种运算被称为零扩展（zero extension）。要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展（sign extension），在表示中添加最高有效位的值。对于扩展大小和转换符号的顺序，C 语言标准要求，先扩展大小，再转换符号。 运算规则 检测无符号数加法中的溢出：对满足 \\(0\\leq x,y\\leq UMax_{w}\\) 的 \\(x\\) 和 \\(y\\)，令 \\(s\\dot=x+_{w}^{u}y\\)。当且仅当 \\(s&lt;x\\)（或者等价地 \\(s&lt;y\\)）时，计算 \\(s\\) 发生溢出。 检测补码数字加法中的溢出：对满足 \\(TMin_{w}\\leq x,y\\leq TMax_{w}\\) 的 \\(x\\) 和 \\(y\\)，令 \\(s\\dot=x+_{w}^{t}y\\)。当且仅当 \\(x&gt;0\\)，\\(y&gt;0\\)，但 \\(s\\leq 0\\) 时，计算 \\(s\\) 发生正溢出。当且仅当 \\(x&lt;0\\)，\\(y&lt;0\\)，但 \\(s\\geq 0\\) 时，计算 \\(s\\) 发生负溢出。 计算一个位级表示的值的在补码加法下的逆元：第一种方法是对每一位取反，再对结果加 1，即 -x == ~x + 1；第二种方法是将最低位的 1 左侧的所有位取反。 无符号乘法和补码乘法在截断之后的位级表示是相同的，该结论可以通过公式推导得出。 整数乘法运算指令比其他整数运算（例如加法、减法、移位）更慢，因此编译器会尝试使用移位和加减法的组合来代替乘以常数因子的乘法。是否实际替换，取决于两种方案的相对速度。 整数除法总是向零取整，即对于正数向下取整，对于负数向上取整。当使用移位运算替换除以 2 的幂的除法时，需要注意补码移位是向下取整。也就是说，对于负数需要添加“偏置（biasing）”值，从而使得其向零取整。如下所示： 1x / (1 &lt;&lt; k) == (x &lt; 0 ? x + (1 &lt;&lt; k) - 1 : x) &gt;&gt; k 浮点标准 IEEE 浮点标准用 \\(V=(-1)^{s}\\times M\\times 2^{E}\\) 的形式来表示一个数： 符号（sign） \\(s\\) 决定这数是负数（\\(s=1\\)）还是正数（\\(s=0\\)），而对于数值 0 的符号位解释作为特殊情况处理。 尾数（significand） \\(M\\) 是一个二进制小数，它的范围是1 ~ \\(2-\\varepsilon\\)，或者是 0 ~ \\(1-\\varepsilon\\)。 阶码（exponent） \\(E\\) 的作用是对浮点数加权，这个权重是 2 的 \\(E\\) 次幂（可能是负数）。 将浮点数的位表示划分为三个字段，分别对这些值进行编码： 一个单独的符号位 \\(s\\) 直接编码符号 \\(s\\)。 \\(k\\) 位的阶码字段 \\(exp=e_{k-1}\\cdots e_{1}e_{0}\\) 编码阶码 \\(E\\)。 \\(n\\) 位小数字段 \\(frac=f_{n-1}\\cdots f_{1}f_{0}\\)，编码尾数 \\(M\\)，但是编码出来的值也依赖于阶码字段的值是否等于 0。 图 2-32 给出了将这三个字段装进字中两种最常见的格式。在单精度浮点格式中，s、exp 和 frac 字段分别为 1 位、k = 8 位和 n = 23 位，得到一个 32 位的表示。在双精度浮点格式中，s、exp 和 frac 字段分别为 1 位、k = 11 位和 n = 52 位，得到一个 64 位的表示。 给定位表示，根据 exp 的值，被编码的值可以分成三种不同的情况。 分类 阶码 尾数 规格化的值 \\(E=e-Bias\\)，\\(Bias=2^{k-1}-1\\) \\(M=1+f\\) 非规格化的值 \\(E=1-Bias\\) \\(M=f\\) 这种表示具有一个有趣的属性，假如我们将图 2-35 中的值的位表达式解释为无符号整数，它们就是按升序排列的，就像它们表示的浮点数一样。IEEE 格式如此设计就是为了浮点数能够使用整数排序函数来进行排序。当处理负数时，有一个小的难点，因为它们有开头的 1，并且它们是按照降序出现的，但是不需要浮点运算来进行比较也能解决这个问题。 IEEE 浮点格式定义了四种不同的舍入方式：向偶数舍入（默认），向零舍入，向下舍入，向上舍入。向偶数舍入指的是，将正中间的值向偶数舍入。IEEE 标准中的浮点加法和乘法是可交换的，具有单调性，但是不可结合，不具有分配性。","link":"/2024/08/16/CSAPP%20%E7%AC%AC%201%20&%202%20%E7%AB%A0/"},{"title":"CSAPP 第 8 &amp; 9 章 + OSTEP 虚拟化","text":"异常控制流 + CPU 虚拟化 从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列 \\(a_{0},a_{1},\\cdots,a_{n-1}\\) 其中，每个 \\(a_{k}\\) 是某个相应的指令 \\(I_{k}\\) 的地址。每次从 \\(a_{k}\\) 到 \\(a_{k+1}\\) 的过渡称为控制转移（control transfer）。这样的控制转移序列叫做处理器的控制流（flow of control，control flow）。 最简单的一种控制流是一个“平滑的”序列，其中每个 \\(I_{k}\\) 和 \\(I_{k+1}\\) 在内存中都是相邻的。这种平滑流的突变（也就是 \\(I_{k+1}\\) 与 \\(I_{k}\\) 不相邻）通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。 但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。 现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。 异常 异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。 异常（exception）就是控制流中的突变，用来响应处理器状态中的某些变化。图 8-1 展示了基本的思想。在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 \\(I_{curr}\\)。在处理器中，状态被编码为不同的位和信号。状态变化称为事件（event）。事件可能和当前指令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表（exception table）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的异常处理程序（exception handler）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种： 处理程序将控制返回给当前指令 \\(I_{curr}\\)，即当事件发生时正在执行的指令。 处理程序将控制返回给 \\(I_{next}\\)，如果没有发生异常将会执行的下一条指令。 处理程序终止被中断的程序。 异常处理 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号（exception number）。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。 在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为异常表的跳转表，使得表目 k 包含异常 k 的处理程序的地址。图 8-2 展示了异常表的格式。在运行时（当系统在执行某个程序时），处理器检测到发生了一个事件，并且确定了相应的异常号。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k，转到相应的处理程序。图 8-3 展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器（exception table base register）的特殊 CPU 寄存器里。 异常分类 中断 中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序（interrupt handler）。 陷阱 陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。 故障 故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。例如：缺页异常。 终止 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。 进程 进程就是运行中的程序。最简单的方式是一次只运行一个进程，等到它运行完成之后再运行下一个。但是，通常人们希望同时运行多个进程。解决方案是，使用时分共享 CPU 技术，并发地运行多个进程。要高效、可控的实现时分共享，需要使用操作系统来对进程进行管理，而操作系统进行管理的基础就是需要始终保留对 CPU 的控制权。如果没有控制权，进程可以无限制的使用 CPU，访问任意地址。使用异常机制结合用户/内核模式，使得 CPU 的控制权总会在特定的情况从进程转移给操作系统，从而能够高效、可控的实现时分共享。 创建进程 要运行可执行目标文件 prog，我们可以在 Linux shell 的命令行中输入它的名字 ./prog。因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件，shell 进程会生成一个子进程，它是父进程的一个复制。子进程通过 execve 系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的内容。 最后，加载器跳转到程序的入口点，也就是 _start 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。 除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制，直到 CPU 引用一个被映射的虚拟页时才会进行复制。此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。在 Linux x86-64 系统中，代码段总是从地址 0×400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址（\\(2^{48}-1\\)）开始，向较小内存地址增长。栈上的区域，从地址 \\(2^{48}\\) 开始，是为内核（kernel）中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。 上图只是简化图。实际上，由于.data 段有对齐要求，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR）。虽然每次程序运行时这些区域的地址都会改变，但它们的相对位置是不变的。 用户模式和内核模式 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。 处理器通常是用某个控制寄存器中的一个模式位（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。 没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令（privileged instruction），比如停止处理器、改变模式位，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。 运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。 上下文切换 内核为每个进程维持一个上下文（context），上下文就是内核重新启动一个被抢占的进程所需的状态。包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。 操作系统内核使用一种称为上下文切换（context switch）的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在较低层异常机制之上的。在进程执行的某些时刻，内核可以决定抢占当前进程，并使用上下文切换来将控制转移到新的进程。这种决策就叫做调度（scheduling），是由内核中称为调度器（scheduler）的代码处理的。上下文切换的步骤：① 保存当前进程的上下文，② 恢复某个先前被抢占的进程被保存的上下文，③ 将控制传递给这个新恢复的进程。 图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。在这个例子中，进程 A 初始运行在用户模式中，直到它通过执行系统调用 read 陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。 调度策略 调度指标： 周转时间：\\(T_{周转时间}=T_{完成时间}-T_{到达时间}\\)。（性能指标） 响应时间：\\(T_{响应时间}=T_{首次运行}-T_{到达时间}\\)。（公平指标） 护航效应（convoy effect），一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后，使得平均周转时间增大。 如果你愿意不公平，你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。 先进先出（FIFO） 最短任务优先（SJF） 最短完成时间优先（STCF） 时间片轮转（RR） 时间片越短响应时间越好，但是时间片太短会导致频繁的上下文切换，从而影响系统的整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。 请注意，上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在 CPU 高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本。 多级反馈队列（MLFQ） 关键问题：没有工作长度的先验（priori）知识，如何设计一个能同时减少响应时间和周转时间的调度程序？ MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作（即在较高级队列中的工作）。当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情沉下，我们就对这些工作采用轮转调度。 因此，MLFQ 调度策略的关键在于如何设置优先级。MLFQ 没有为每个工作指定不变的优先顺序，而是根据观察到的行为调整它的优先级。例如，如果一个工作不断放弃 CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。相反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级。通过这种方式，MLFQ 在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 规则 3：工作进入系统时，放在最高优先级（最上层队列）。 规则 4：一旦工作用完其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 规则 5：经过一段时间 \\(S\\)，就将系统中所有工作重新加入最高优先级队列。 关于 MLFQ 调度算法还有一些问题，其中一个大问题是如何配置一个调度程序。例如：配置多少队列？每一层队列的时间片配置多大？为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。 虚拟内存 + 内存虚拟化 从内存层面来说，实现时分共享最简单的方式是，进程独占内存的使用，切换时将其保存到磁盘中，然后加载另一个进程。为了提高效率，我们让多个进程同时使用内存，但是如何实现进程内存之间的隔离呢？所以引入虚拟内存的概念，让操作系统管理内存实现虚拟化。 虚拟寻址 计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address，PA）。使用虚拟寻址时，CPU 通过生成一个虚拟地址（Virtual Address，VA）来访问主存。之后 CPU 上被称为内存管理单元（Memory Management Unit，MMU）的专用硬件，利用存放在主存中的查询表来动态的将虚拟地址翻译为物理地址，该表的内容由操作系统管理。 页面缓存 概念上而言，虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。VM 系统通过将虚拟内存分割为固定大小的虚拟页（Virtual Page，VP），每个虚拟页的大小为 \\(P=2^{p}\\) 字节。类似地，物理内存被分割为物理页（Physical Page，PP），大小也为 \\(P\\) 字节。 虚拟页面的集合被分为三个不相交的子集： 未分配的：VM 系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。 已缓存的：已缓存在物理内存中的已分配页。 未缓存的：未缓存在物理内存中的已分配页。 图 9-3 的示例展示了一个有 8 个虚拟页的小虚拟内存。虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。页 2、5 和 7 已被分配，但是当前并未缓存在主存中。 页表 同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。 这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和存放在物理内存中被称为页表（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。 图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。目前，我们将假设每个 PTE 是由一个有效位（valid bit）和一个 n 位地址字段组成的。有效位表明该虚拟页当前是否被缓存在 DRAM 中。如果设置了有效位，那么地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个 null 地址表示这个虚拟页还未被分配，否则这个地址就指向该虚拟页在磁盘上的起始位置（即已分配但未缓存）。 缺页 在虚拟内存的习惯说法中，DRAM 缓存不命中称为缺页（page fault）。图 9-6 展示了在缺页之前我们的示例页表的状态。CPU 引用了 VP3 中的一个字，VP3 并未缓存在 DRAM 中。地址翻译硬件将虚拟地址作为索引来定位 PTE3，并从内存中读取它。从有效位推断出 VP3 未被缓存，从而触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在 PP3 中的 VP4。如果 VP4 已被修改，那么内核会将它复制回磁盘。无论哪种情况，内核都会修改 VP4 的页表条目，反映出 VP4 不再缓存在主存中这一事实。 之后，内核从磁盘复制 VP3 到内存中的 PP3，更新 PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3 已被缓存在主存中，那么页命中也能由地址翻译硬件正常处理。图 9-7 展示了在缺页之后我们的示例页表的状态。 内存管理 到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。图 9-9 展示了基本思想。注意，多个虚拟页面可以映射到同一个物理页面上（页面共享）。 内存保护 任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。不应该允许一个用户进程修改它的只读代码段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写其他进程的私有内存，并且不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做（通过调用明确的进程间通信系统调用）。 每次 CPU 生成一个虚拟地址时，地址翻译硬件都会读一个 PTE，所以可以在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问。图 9-10 展示了基本思想。在这个示例中，每个 PTE 中添加了三个许可位。SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。READ 位和 WRITE 位控制对页面的读写访问。如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为“段错误（segmentation fault）”。 地址翻译 CPU 中的一个控制寄存器，页表基址寄存器（Page Table Base Register，PTBR）指向当前页表。\\(n\\) 位的虚拟地址包含两个部分：一个 \\(p\\) 位的虚拟页面偏移（Virtual Page Offset，VPO）和一个 \\((n - p)\\) 位的虚拟页号（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。将页表条目中物理页号（Physical Page Number，PPN）和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。 快表 每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。然而，许多系统都试图消除即使是这样的开销，它们在 MMU 中包括了一个关于 PTE 的小缓存，称为快表（Translation Lookaside Buffer，TLB）。 多级页表 到目前为止，我们一直假设系统只用一个单独的页表来进行地址翻译。但是如果我们有一个 32 位的地址空间、4KB 的页面和一个 4 字节的 PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。对于地址空间为 64 位的系统来说，问题将变得更复杂。使用多级页表，时间换空间。","link":"/2024/08/16/CSAPP%20%E7%AC%AC%208%20&%209%20%E7%AB%A0%20+%20OSTEP%20%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"title":"CSAPP 第 6 章 + OSTEP 持久性","text":"存储技术 随机访问存储器 随机访问存储器（Random-Access Memory，RAM）分为两类：静态的和动态的。静态 RAM（SRAM）比动态 RAM（DRAM）更快，但也更贵。SRAM 通常用来作为高速缓存存储器，DRAM 通常用来作为主存以及图形系统的帧缓冲区。 静态 RAM SRAM 将每个位存储在一个双稳态的（bistable）存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压配置（configuration）或状态（state）之一。由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除时，电路就会恢复到稳定值。 动态 RAM DRAM 将每个位存储为对一个电容的充电。这个电容非常小，通常只有大约 \\(30\\times 10^{-15}\\) 法拉（femtofarad）。DRAM 存储器单元对干扰非常敏感，当电容的电压被扰乱之后，它永远都不会恢复。内存系统必须周期性地通过读出，然后重写来刷新内存每一位。有些系统也使用纠错码，其中计算机的字会被多编码几位（例如 64 位的字可能用 72 位来编码），这样一来，电路可以发现并纠正一个字中任何单个的错误位。 非易失性存储器 如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是易失的（volatile）。另一方面，非易失性存储器（nonvolatile memory）即使是在关电后，仍然保存着它们的信息。现在有很多种非易失性存储器。由于历史原因，虽然 ROM 中有的类型既可以读也可以写，但是它们整体上都被称为只读存储器（Read-Only Memory，ROM）。ROM 是以它们能够被重编程（写）的次数和对它们进行重编程所用的机制来区分的。 存储在 ROM 设备中的程序通常被称为固件（firmware）。当一个计算机系统通电以后，它会运行存储在 ROM 中的固件。一些系统在固件中提供了少量基本的输入和输出函数，例如 PC 的 BIOS（基本输入/输出系统）例程。复杂的设备，像图形卡和磁盘驱动控制器，也依赖固件翻译来自 CPU 的 I/O（输入/输出）请求。 总线事务 数据流通过称为总线（bus）的共享电子电路在处理器和 DRAM 主存之间来来回回。每次 CPU 和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务（bus transaction）。读事务（read transaction）从主存传送数据到 CPU。写事务（write transaction）从 CPU 传送数据到主存。 总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。例如，当前事务是到主存还是到诸如磁盘控制器这样的其他 I/O 设备，事务是读还是写，总线上的信息是地址还是数据项。 图 6-6 展示了一个示例计算机系统的配置。主要部件是 CPU 芯片、我们将称为 I/O 桥接器（I/O bridge）的芯片组（其中包括内存控制器），以及组成主存的 DRAM 内存模块。这些部件由一对总线连接起来，其中一条总线是系统总线（system bus），它连接 CPU 和 I/O 桥接器，另一条总线是内存总线（memory bus），它连接 I/O 桥接器和主存。I/O 桥接器将系统总线的电子信号翻译成内存总线的电子信号。I/O 桥也将系统总线和内存总线连接到 I/O 总线，像磁盘和图形卡这样的 I/O 设备共享 I/O 总线。 磁盘存储 磁盘构造 磁盘是由盘片（platter）构成的。每个盘片有两面或者称为表面（surface），表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴（spindle），它使得盘片以固定的旋转速率（rotational rate）旋转，通常是 5400 ~ 15000 转每分钟（Revolution Per Minute，RPM）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。 图 6-9a 展示了一个典型的磁盘表面的结构。每个表面是由一组称为磁道（track）的同心圆组成的。每个磁道被划分为一组扇区（sector）。每个扇区包含相等数量的数据位（通常是 512 字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙（gap）分隔开，这些间隙中不存储数据位。间隙存储用来标识扇区的格式化位。 磁盘是由一个或多个叠放在一起的盘片组成的，它们被封装在一个密封的包装里，如图 6-9b 所示。整个装置通常被称为磁盘驱动器（disk drive），我们通常简称为磁盘（disk）。有时，我们会称磁盘为旋转磁盘（rotating disk），以使之区别于基于闪存的固态硬盘（SSD），SSD 是没有移动部分的。 磁盘制造商通常用术语柱面（cylinder）来描述多个盘片驱动器的构造，这里，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。例如，如果一个驱动器有三个盘片和六个面，每个表面上的磁道的编号都是一致的，那么柱面 k 就是 6 个磁道 k 的集合。 磁盘操作 磁盘用读/写头（read/write head）来读写存储在磁性表面的位，而读写头连接到一个传动臂（actuator arm）一端，如图 6-10a 所示。通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为寻道（seek）。一旦读/写头定位到了期望的磁道上，那么当磁道上的每个位通过它的下面时，读/写头可以感知到这个位的值（读该位），也可以修改这个位的值（写该位）。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头，如图 6-10b 所示。读/写头垂直排列，一致行动。在任何时刻，所有的读/写头都位于同一个柱面上。 磁盘以扇区大小的块来读写数据。对扇区的访问时间（access time）有三个主要的部分：寻道时间（seek time）、旋转时间（rotational latency）和传送时间（transfer time）。 逻辑磁盘块 正如我们看到的那样，现代磁盘构造复杂，有多个盘面，这些盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，现代磁盘将它们的构造呈现为一个简单的视图，一个 B 个扇区大小的逻辑块的序列。磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际（物理）磁盘扇区之间的映射关系。当操作系统想要执行一个 I/O 操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个（盘面，磁道，扇区）的三元组，这个三元组唯一地标识了对应的物理扇区。控制器上的硬件会解释这个三元组，将读/写头移动到适当的柱面，等待扇区移动到读/写头下，将读/写头感知到的位放到控制器上的一个小缓冲区中，然后将它们复制到主存中。 局部性原理 局部性通常有两种不同的形式：时间局部性（temporal locality）和空间局部性（spatial locality）。在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。 存储器层次结构 存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k + 1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。数据总是以块大小为传送单元（transfer unit）在第 k 层和第 k + 1 层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。 高速缓存存储器 早期计算机系统的存储器层次结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入 SRAM 高速缓存存储器。 缓存不命中的种类：强制性不命中/冷不命中、冲突不命中和容量不命中。 高速缓存的种类：直接映射高速缓存、组相联高速缓存和全相联高速缓存。 写的策略：直写 + 非写分配、后写 + 写分配。 组织结构 考虑一个计算机系统，其中每个存储器地址有 \\(m\\) 位，形成 \\(M=2^{m}\\) 个不同的地址。如图 6-25a 所示，这样一个机器的高速缓存被组织成一个有 \\(S=2^{s}\\) 个高速缓存组（cache set）的数组。每个组包含 \\(E\\) 个高速缓存行（cache line）。每个行是由一个 \\(B=2^{b}\\) 字节的数据块（block）组成的，一个有效位（valid bit）指明这个行是否包含有意义的信息，还有 \\(t=m-(b+s)\\) 个标记位（tag bit）（是当前块的内存地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。","link":"/2024/08/16/CSAPP%20%E7%AC%AC%206%20%E7%AB%A0%20+%20OSTEP%20%E6%8C%81%E4%B9%85%E6%80%A7/"},{"title":"南京大学 软件分析 课程总结","text":"课程网站，在线评测，课程视频，silverbullettt。 知难而进，贵在坚持。省察体悟，贵于改过。 Course Introduction 概念 程序设计语言（Programming Languages，PL），静态程序分析（Static Program Analysis），莱斯定理（Rice’s Theorem），可靠性（Soundness）和完备性（Completeness）。 莱斯定理说明，不存在完美的静态分析，满足 Sound（Overapproximate）和 Complete（Underapproximate）。Sound 允许误报（false positives），但不允许漏报（false negatives），Complete 相反。 静态分析可以使用两个词概括：Abstraction + Safe-approximation（Transfer functions，Control flows）。首先对数据做抽象，然后对数据流做近似。近似涉及到 Transfer functions 如何设计和 Control flows 如何合并。Safe-approximation 的含义取决于使用场景，在大多数场景 Sound 就是 Safe-approximation，而小部分场景 Complete 才是。 问题 Q：关于静态分析，思考 What、Why、How？ Q：如何使用一句话概括静态分析？什么是有用的静态分析？ A：在确保 Safe-approximation 的前提下，在精度（precision）和速度（speed）之间权衡。 参考 Intermediate Representation 概念 编译器（Compiler），中间表示（Intermediate Representation，IR），三地址码（Three-Address Code，3AC），控制流图（Control Flow Graph，CFG），基本块（Basic Block，BB）。 问题 Q：如何基于 3AC 构建 BB？如何基于 BB 构建 CFG？ 参考 Data Flow Analysis - Applications 概念 数据流分析的种类：may analysis（over-approximation），must analysis（under-approximation）。 数据流分析的应用：Reaching Definitions Analysis，Live Variables Analysis，Available Expressions Analysis。 问题 Q：为什么 Reaching Definitions Analysis 的算法最终会停止？ A：所有的 OUT 对应的 Bit Vector，它包含的 1 的数量都是单调递增的，最后必定会到达一个上界。 Q：为什么 Live Variables Analysis 使用 Backward Analysis，而不是 Forward Analysis？（算法设计更方便） 参考 Data Flow Analysis - Foundations 概念 不动点（Fixed point），偏序集（Partially ordered set），上确界和下确界（LUB and GLB，Join and meet），格（Lattice），不动点定理（Knaster–Tarski theorem），抽象解释（Abstract interpretation）。 Data Flow Analysis Domain Direction May/Must Constant Propagation Analysis Set of pairs (variable, value) Forwards Must 问题 Q：什么是 Meet-Over-All-Paths Solution（MOP）？MOP 和 Iterative Algorithm 的精度有什么关系？ Q：为什么 Constant Propagation Analysis 的 Transfer function 是不可分配的（Non-distributivity）？ Q：如何理解可能存在多个不动点，以及 Iterative Algorithm 求到的是最小/最大不动点？为什么在 Constant Propagation Analysis 中，MOP 的精度大于 Iterative Algorithm 的精度？MOP 是否满足不动点定理？ A：对于函数 \\(F\\) 而言，可能有多个 \\(x\\) 使得 \\(F(x)=x\\)，所以可能存在多个不动点。由于 Iterative Algorithm 满足不动点定理，对于特定的函数 \\(F\\)，如果存在多个不动点，我们求到的必然是最小/最大不动点。MOP 和 Iterative Algorithm 的函数 \\(F\\) 不同，所以 MOP 的精度可以更大，不会违背不动点定理。MOP 应该是满足不动点定理的，因为 Transfer function 和 Join/Meet function 相比 Iterative Algorithm 没有变化，只是它们组成的函数 \\(F\\) 有变化。 参考 Interprocedural Analysis 问题 Q：什么是 CHA？如何基于 CHA 构建 Call Graph？ Q：如何实现 Interprocedural Constant Propagation Analysis？ 参考 Pointer Analysis 问题 Q：Pointer Analysis 和 Alias Analysis 的区别？ A：Pointer Analysis 回答一个指针能指向哪些对象，Alias Analysis 回答两个指针是否能指向同一个对象。 Q：各个 Factor 的方案该如何选择，精度和速度的权衡？ A：课程选择 Allocation-site，Context-sensitive，Flow-insensitive，Whole-program。 参考 Pointer Analysis - Foundations 问题 Q：什么是 Pointer Flow Graph（PFG）？如何构建 PFG？ Q：为什么构建 PFG 和在 PFG 上传播指向信息，两个过程相互依赖？以及构建 PFG 和构建 Call Graph 相互依赖？ A：首先需要有 PFG，才能在 PFG 上传播指向信息。而 PFG 节点获得指向信息之后，可能会在 PFG 中添加边。主要原因是 PFG 使用抽象对象的字段 \\(o_{i}.f\\) 来表示实例字段 \\(x.f\\)，其中 \\(o_{i}\\in pt(x)\\)，它是动态变化的。为什么不直接使用 \\(x.f\\) 作为节点，在最开始将所有边建好？个人理解，如果 \\(x\\) 和 \\(y\\) 的指向信息存在交集，当更新 \\(x.f\\) 时需要部分更新 \\(y.f\\)，这样很难使用图上的算法来实现 Pointer Analysis，所以需要做更细粒度的划分。构建 PFG 和构建 Call Graph 相互依赖，也是取决于 Call Rule 的设计，从而在构建 Call Graph 的过程中会在 PFG 中添加边。 参考 Pointer Analysis - Context Sensitivity 问题 Q：为什么 Instance fields 不需要限定上下文？ A：明确限定上下文的作用是什么，区分对同一个方法的多次调用，也就是区分多次调用中的变量和对象。而对于 Instance fileds 不需要区分什么，它从属于某个对象，该对象已经被上下文限定。 参考 Static Analysis for Security 参考 实验作业 如何减少和检查代码的错误？ ① 编写代码前：可以先使用注释梳理逻辑，确定算法步骤。重要！如果遗漏某种情况，之后找错会花费更多时间。遇到不清楚的地方要及时（使用 TODO）标出来，不要想当然。② 编写代码时：不要过早优化。在必要的地方添加断言。当找不到想要的 API 时可以查看继承关系，目标 API 可能在子类中。每完成一个功能，就编写相应的测试用例，尽早发现问题。③ 代码出错时：首先检查逻辑是否有误/遗漏，以及边界条件的处理是否有误/遗漏。然后检查 API 是否存在误用，例如对 API 的功能理解有误，或者误用其他类的相同名称的 API。最后检查文档表述是否存在歧义，或者不清楚的地方，从而在实现细节的理解上存在偏差。④ 找不到错时：如果可以的话，找到正确代码，然后对拍测试。休息一下，或许之后能找到。真的找不到，重写一遍，或许能够发现遗漏的地方。真的真的找不到，寄。 Java 的 ArrayDeque 不能存储 null，而 LinkedList 可以。Deque 的文档有说明： While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any Deque implementations that do allow null elements are strongly encouraged not to take advantage of the ability to insert nulls. This is so because null is used as a special return value by various methods to indicate that the deque is empty.","link":"/2024/08/17/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%20%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"GAMES101 课程总结","text":"课程网站，课程视频，讨论，作业。","link":"/2024/08/20/GAMES101%20%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"简单看下 Tai-e 源码","text":"官方文档，代码仓库，ISSTA 2023 论文，静态程序分析框架“太阿”的设计之道。 已完成全部作业，简单看下 Tai-e 科研版是如何实现作业的，以及作业涉及的部分接口和类的源码。 在分析的实现中，Stream 使用的比较多，然后就是某些比较好用的 API 在作业中没有注意到，代码中也有使用高版本 Java 的某些新特性。基本上每个包都有 package-info.java 文件，描述当前包的关键信息，还是很不错的。我没怎么看和作业关系不大的源码，它涉及到的东西比较多，需要额外的理论知识。 IR FieldRef 特点：私有构造函数和静态工厂方法；Record Classes；缓存实例对象；向方法传递 Runnable 类型的对象来实现回调。 12345678910111213141516171819202122public class FieldRef extends MemberRef { private static final ConcurrentMap&lt;Key, FieldRef&gt; map = Maps.newConcurrentMap(4096); static { World.registerResetCallback(map::clear); } public static FieldRef get( JClass declaringClass, String name, Type type, boolean isStatic) { Key key = new Key(declaringClass, name, type); return map.computeIfAbsent(key, k -&gt; new FieldRef(k, isStatic)); } private FieldRef(Key key, boolean isStatic) { ... } private record Key(JClass declaringClass, String name, Type type) { }} Var 特点：使用内部类存储和当前 Var 相关的语句，而不是直接包含在当前类中；使用 transient、writeObject 和 readObject 显示控制序列化，避免反序列化创建多个单例对象；使用 Collections.unmodifiableList 方法返回不可修改的列表。 123456789101112131415161718192021222324252627282930313233public class Var implements LValue, RValue, Indexable { private transient RelevantStmts relevantStmts = RelevantStmts.EMPTY; @Serial private void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); if (relevantStmts == RelevantStmts.EMPTY) { s.writeObject(null); } else { s.writeObject(relevantStmts); } } @Serial private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); relevantStmts = (RelevantStmts) s.readObject(); if (relevantStmts == null) { relevantStmts = RelevantStmts.EMPTY; } } private static class RelevantStmts implements Serializable { private static final RelevantStmts EMPTY = new RelevantStmts(); private static &lt;T&gt; List&lt;T&gt; unmodifiable(List&lt;T&gt; list) { return list.isEmpty() ? list : Collections.unmodifiableList(list); } }} Stmt 特点：Stmt 包含以 StmtVisitor 类型作为参数的 accept 泛型方法，可以用于实现访问者模式。 1234public interface Stmt extends Indexable, Serializable { &lt;T&gt; T accept(StmtVisitor&lt;T&gt; visitor);} 1234567891011public interface StmtVisitor&lt;T&gt; { default T visit(New stmt) { return visitDefault(stmt); } default T visitDefault(Stmt stmt) { return null; }} DefinitionStmt 特点：使用 &lt;L extends LValue, R extends RValue&gt; 泛型，对表达式进行限定，所有具体的子类都会使用具体的类型替换限定的类型。 12DefinitionStmt&lt;L extends LValue, R extends RValue&gt;Invoke extends DefinitionStmt&lt;Var, InvokeExp&gt; Analysis 特点：LiveVariable 的实现，删除变量使用 ifPresent + lambda 处理，代码比较简洁。ConstantPropagation 的 newBoundaryFact 使用 Stream 来实现，而我是使用普通的方式实现的。Evaluator 类中的 evaluate 方法，使用了扩展的 Switch Expressions，可以省略 break。InterConstantPropagation 实现 Alias-Aware 时，使用访问者模式处理 Load 和 Store 语句。指针分析和作业时区别比较大，没有细看。 核心组成","link":"/2024/08/30/%E7%AE%80%E5%8D%95%E7%9C%8B%E4%B8%8B%20Tai-e%20%E6%BA%90%E7%A0%81/"},{"title":"Lab 1: MapReduce","text":"课程网站，实验网站，实验指南。 准备工作：复习 Lecture 1 &amp; 2 的内容，主要是 MapReduce 的论文、Go 教程和 RPC 包的使用。 交互逻辑 首先需要明白，Coordinator 和 Worker 的关系，以及 Map/Reduce Task 和 Map/Reduce 函数的关系。MapReduce 由一个 Coordinator 和多个 Worker 组成，Coordinator 负责将 Task 分配给空闲的 Worker，可以是 Map Task 或 Reduce Task。Map/Reduce Task 负责调用应用程序提供的 Map/Reduce 函数，对数据进行处理。 最开始我以为是由 Coordinator 管理所有 Worker，主动分配任务。结果代码的结构是由 Worker 向 Coordinator 发送 RPC 请求，Coordinator 被动的接收请求，然后根据当前的情况分配任务。仔细想想，确实应该这样，Worker 是可以随意增减的，它并不由 Coordinator 管理。 Coordinator 不仅是接收分配任务的请求，在一个 Map Task 完成时，它也会收到该 Task 生成的中间文件的信息。而且 Reduce Task 完成时，也应该通知 Coordinator，从而 Coordinator 可以确认所有是否已完成所有 Reduce Task。 数据结构 明白整体的交互逻辑之后，需要思考一下 Coordinator 存储什么数据，使用什么数据结构。根据论文 3.2 节的描述，需要存储每个 Map/Reduce Task 的状态（包括 idle、in-progress 和 completed），以及非 idle 状态的 Task 所在的 Worker 标识，还有 Map Task 生成的中间文件的位置和大小。在我们的实现中，就只需要 Map/Reduce Task 的状态和文件路径。当然，中间文件是根据哈希函数划分给 Reduce Task 的，那么存储时也应该能够知道，某个文件由哪个 Map Task 生成，又应该交给哪个 Reduce Task 处理。 而且论文提到，中间文件是以增量的方式发送给对应 Reduce Task 的，这也是为什么需要记录非 idle 状态的 Task 所在的 Worker 标识。但是，这样实现起来比较复杂，所以我们不会记录 Worker 标识，也不会去增量的发送 Reduce Task 所需的文件，而是等待所有 Map Task 完成之后，再分配 Reduce Task 给 Worker。 然后考虑并发访问数据结构的问题，我们可以先使用一个粗粒度的锁来实现 MapReduce，测试结果正确之后，再尝试使用更细粒度的锁，这样可以避免并发时发生非并发错误，从而难以调试。 更多细节 考虑一下分配 Task 的细节，分配的先后顺序已经确定是优先分配 Map Task，所有 Map Task 的状态为 completed 之后，再分配 Reduce Task。那么如何实现呢？首先，我们会分配状态为 idle 的 Map Task 给 Worker，如果没有则等待所有 Map Task 完成。如何等待，根据实验网站的提示，我们可以使用 time.Sleep() 或者 sync.Cond。那么之后呢，等待之后该做什么？如果依然没有完成，我们应该继续等待吗？显然不行，如果某个 Map Worker 崩溃，也就是该实验中预定的超时 10 秒钟，此时如果剩余的 Worker 都在等待，那么 Task 将永远都无法推进。所以，我们应该重新考虑是否需要分配 Map Task，判断 Reduce Task 是否全部完成也是类似的逻辑。 根据上面的讨论，我们又可以问，如何确认 Task 是否完成，是使用 for 循环遍历吗？如果是，那么当 Map Task 全部完成时，如何避免重复的遍历？使用一个标志位或许可以解决，那么应该在哪里遍历呢，似乎可以有两种策略，一种是在分配 Reduce Task 之前遍历，另一种是在 Worker 的 Map Task 完成时遍历。如果不使用 for 循环，能否使用计数器记录 Map Task 完成的数量？如果判断为“崩溃”的 Map Worker 其实没有崩溃，是否会导致额外的计数？这都取决于具体的实现方式。 考虑到代码的可读性，如何表示 Task 的状态和类型？我首先想到的是使用枚举类，但是 Go 中实现枚举的方式比较特别，参考Go 实现枚举。以上基本上是讨论 Coordinator 如何处理 Worker 的请求，那么 Worker 的实现其实是比较简单的，不需要考虑太多。只要根据请求的返回数据，判断是执行 Map Task 还是 Reduce Task 即可。当然，根据实验网站的提示，我们可以添加一个 pseudo-task 来表示所有 Task 已完成，从而使 Worker 退出请求 Task 的循环。 实验小结 准备工作很重要，很久之前看的 MapReduce 论文，对各种概念的定义不是很清楚，直接看代码就很懵。然后，我个人的经验就是不要提前优化，以及先使用粗粒度锁排除非并发问题，然后再使用更细粒度的锁。测试时只遇到两个小问题，一个是导出字段没有使用大写字母开头，另一个是中间文件名的保存位置搞错。根本就没遇到并发问题啊，有点出乎意料。代码编写时我感觉脑子有点乱，就是会想很多问题，一定记住先实现基本的逻辑，再处理额外的逻辑。","link":"/2024/09/02/Lab%201%20MapReduce/"},{"title":"Debugging","text":"Lab guidance，Debugging，Debugging by Pretty Printing。 If you’re spending hours debugging and don’t get anywhere, that means you should try a different approach!","link":"/2024/09/02/Debugging/"},{"title":"Lab 2: Key&#x2F;Value Server","text":"课程网站，实验网站，实验指南。 很简单的实验，但还是经常踩坑。① 使用 Go 经常忘记初始化 map。② 对于重复的请求忘记处理返回值，即使服务器不处理请求，还是需要返回对应的返回值。③ 对于重复的 Append，不能简单的获取子字符串作为返回值，因为有多个客户端。④ 打错变量名，定位错误有点慢。最开始我是观察到打印的 ID 不对，没有发现请求 ID 和客户端 ID 相同，以为是使用 nrand 的方式不对，结果不是。⑤ 测试有点弱，有些很明显的错误没有检测到。","link":"/2024/09/03/Lab%202%20Key%20Value%20Server/"},{"title":"Lab 3: Raft","text":"课程网站，实验网站，实验指南。 规则 在此列出比较通用且重要的规则：① 发送心跳 RPC 每秒不会超过 10 次。② 如果多数服务器之间可以通信的话，应该在旧领导者失效之后的 5 秒内选出新的领导者。③ election timeout 的范围应该比论文中提到的 \\([150,300]\\) 毫秒更大，因为实验要求的心跳消息的发送频率比论文中的更低。当然也不能太大，否则无法满足第 ② 点要求。④ 在循环中使用 rf.killed 函数，避免被测试程序 kill 的 peer 持续运行。 ⑤ 每个 RPC 应该在单独的线程中发送和处理响应，因此它们不会相互阻塞，也不会阻塞当前函数，例如心跳和选举。而 RPC 的参数应该在启动线程时复制，因为 peer 的状态随时都可能变化，我们要保证 RPC 是以当前状态发送的。⑥ 发送 RPC 的是 labrpc.go 中的 Call 函数，如果返回 false，则表示没有收到响应。此时，只需要重试复制日志相关的 RPC，而不需要重试心跳和投票相关的 RPC。不重试时，记得直接退出函数，不要继续处理默认的“响应”。 ⑦ 在收到 RPC 请求或响应时，比较任期大小，来确定是否需要将当前 peer 的 state 转变为 follower。⑧ 处理响应时，要首先检查所有假设，也就是此时 peer 的某些状态是否和发送请求时相同。如果不一致，则说明响应已经不适用。特别的，应该总是执行第 ⑦ 点。此处需要仔细思考，应该比较哪些状态。 Part 3A: leader election 实现 实现领导者选举和心跳检测。首先按照论文的图 2 在 Raft 结构体中添加状态，然后在 Make 函数中初始化。特别的，我们需要添加额外的状态信息，包括当前 peer 的 state（follower，candidate，leader），以及最近收到的有效 RPC 的时间戳，该时间戳用于判断 follower 是否需要转变为 candidate。有效是指，收到当前 leader 发送的 AppendEntries RPC，或者收到某个 candidate 的 RequestVote RPC 且决定投票给它。当前 leader 的含义需要搞清楚，不仅是任期不旧，而且日志前缀要匹配，也就是返回 success = true 才行。 实现 AppendEntries RPC 和 RequestVote RPC 处理程序，除了按照论文图 2 描述的步骤编写代码以及满足第 ⑦ 点之外，有几个需要注意的细节。如果 RPC 有效，则更新时间戳。理解 up-to-date 的含义，在论文 5.4.1 节的结尾有描述。特别的，对于 AppendEntries RPC，如果当前 peer 的 state 是 candidate，则在当前任期和 RPC 的任期相等时，仍然需要将 state 转变为 follower。 此外，论文图 2 对 RequestVote RPC 实现的描述有遗漏，即使 votedFor 不是 null 或 candidateId，只要 term &gt; currentTerm，在满足 up-to-date 的前提下，候选者也可以获得选票。因为，voteFor 的作用只是限制，一个 peer 在一个任期内只能投一次票，如果任期都不相同，当然就不需要做任何限制。 实现心跳检测的函数，首先使用 for 循环 + rf.killed 函数。心跳是周期性的，我们需要等待某个时间，满足第 ① 点。该等待的过程应该放在循环的最后，因为当 candidate 转变成 leader 时，需要立即发送心跳 RPC，防止其他 peer 发起新的选举。在循环开始时，我们需要检测当前 peer 是否仍是 leader，因为它可能转变为 follower。在发送 AppendEntries RPC 和处理响应时，需要满足第 ⑤⑥⑦⑧ 点。 实现超时选举的函数，也就是 ticker 函数，首先依然使用 for 循环 + rf.killed 函数。然后，等待随机化的 election timeout，满足第 ③ 点。应该将等待的代码发在循环的开头，因为初始时所有 peer 都是 follower，放在开头有助于避免选票分裂。然后思考谁会发起选举，显然只有 follower 和 candidate 会。那么它们发起选举的条件分别是什么？在 election timeout 内，如果 follower 没有收到有效 RPC，或者 candidate 没有成为 leader。如果满足条件，则将当前 peer 的 state 转变为 candidate，然后执行论文图 2 中指定的操作。 在发送 RequestVote RPC 和处理响应时，需要满足第 ⑤⑥⑦⑧ 点。如何处理投票的结果？比较自然的想法是使用通道，因为整个过程有点类似生产者消费者模型。更简单的方法是，在 Raft 结构体中记录获取的选票数，这样就可以在发送 RPC 的线程中处理响应。不过，要记得在发起选举时，初始化该字段。当 candidate 转变为 leader 时，记得初始化和 leader 相关的字段，包括 nextIndex 和 matchIndex。 测试 如何执行多次测试，只保留失败测试的输出？不知道。 使用命令 time go test -race -run 3A -count 1 -failfast -timeout 0 | tee log 开始测试： ① 报错 race: limit on 8128 simultaneously alive goroutines is exceeded, dying。不使用 -race，第二个测试一直停不下来，查看日志发现某个 peer 一直不响应。检查代码发现，在退出某个函数时，忘记释放锁，使得该 peer 无法执行任何操作。② 报错 config.go:443: term 2 has 2 (&gt;1) leaders。日志表明，peer 没有获取多数选票仍然当选 Leader。检查代码发现两处错误，某个判断条件写反，以及发送 RPC 没有排除自身，导致自己给自己多投一票。③ 报错 config.go:454: expected one leader, got none。应该是 election timeout 设置太大，没有在规定时间内选举出 Leader。 Part 3B: log 实现 实现日志复制，以及将已提交日志应用到状态机。首先谈谈 AppendEntries RPC 的更多细节，一定要认真读论文图 2 描述的步骤。特别注意，只会删除冲突的日志，不冲突的日志会保留。以及不要搞错更新 commitIndex 的方式，注意是和 “index of last new entry” 取最小值，也就是 args.PrevLogIndex + len(args.Entries)。 实现将已提交日志应用到状态机的过程，我们在 Make 函数中单独创建一个线程来处理此过程。我们需要添加一个状态 applyIndex，表示最后应用到状态机的索引位置，初始化为零。然后依然使用 for 循环 + rf.killed 函数，循环执行该过程。什么时候应用到状态机？显然是当前 peer 的 commitIndex 推进时，可以使用 sync.Cond 或者 time.Sleep 来实现等待操作。接下来就很简单，只需按照顺序将已提交日志对应的 ApplyMsg 发送到通道。 实现日志复制，首先实现 Start 函数。逻辑上比较简单，如果当前 peer 是 leader，则将命令包装成日志，将其添加到自身的 log 中。然后，向其他 peer 发送 AppendEntries RPC，需要满足第 ⑤⑥⑦⑧ 点。注意看论文图 2 的描述，发送 RPC 有个前提条件 lastLogIndex &gt;= nextIndex，以及发送的是 nextIndex 对应的日志，该日志不一定是当前命令的日志。简单起见，发送从 nextIndex 开始，之后的所有日志，这样也可以提升 peer 之间同步的速度，测试的运行时间会更短。参数中不要直接使用切片，而要使用切片的副本，否则可能会产生竞态条件。 处理 AppendEntries RPC 的响应，按照论文图 2 的规则编写代码就行，但是有更多细节需要注意。如果返回 success = true，该如何更新 nextIndex 和 matchIndex？直接将 nextIndex 更新为 args.PrevLogIndex + 1 + len(args.Entries) 是错误的，因为 Start 函数会不断地接收客户端的命令并发送 RPC，会同时存在多个发送给同一个 peer 的 RPC，而且它们都可以返回 success = true，然后 nextIndex 就会被不断地设置为最后一个响应的值。但是，并发 RPC 的顺序会有交错，之后响应的 RPC 的 args.PrevLogIndex + 1 + len(args.Entries) 值可能更小，所以更新时取 max(rf.nextIndex[i], args.PrevLogIndex + 1 + len(args.Entries))。如果返回 success = false，记得重试 RPC。 最后，比较有疑问的点就是 leader 如何推进 commitIndex，论文图 2 说的很明白，但是如何使用代码去实现呢？可以二分 \\(N\\) 的值，或者对 matchIndex 降序排序，取第 n / 2 + 1 个元素判断是否满足推进的条件，更优的做法是使用快速选择算法。那么应该何时检查条件，尝试推进？我的想法是，在处理 AppendEntries RPC 的响应时，如果某个 peer 的 matchIndex 增加，则做一次检查。特别注意，对 leader 的 matchIndex 做特殊判断。 测试 使用命令 time go test -race -run 3B -count 1 -failfast -timeout 0 | tee log 开始测试： ① 报错 panic: runtime error: index out of range [-1]。代码已经在选出 leader 时，将 nextIndex 正确初始化。说明索引是在递减之后越界，也就是说 AppendEntries RPC 的响应可能有误，检查之后发现在 RPC 处理程序中忘记执行赋值 reply.Success = true。② 报错 config.go:594: one(100) failed to reach agreement。检查日志是正常的，只能在测试代码中添加打印语句，然后发现误将 ApplyMsg 的 Command 字段设置成日志项，而不是日志项中的命令。③ 依然报错 config.go:594: one(100) failed to reach agreement。查看日志发现，日志提交到多数 peer，但是 leader 没有推进 commitIndex。明显是在统计个数时出现问题，查看代码发现原因是没有对 leader 的 matchIndex 做特殊处理。 ④ 报错 config.go:601: one(106) failed to reach agreement。定位错误有点慢，主要是一直傻傻看日志，明明只要再多打印一条信息更详细的日志，就会很容易发现问题。处理 AppendEntries RPC 时，在 Success = false 的情况下，忘记重试 RPC。论文图 2 有说到，“decrement nextIndex and retry”。注意，重试前要根据当前状态重新设置参数的值。⑤ 日志很奇怪，出现没有被执行的操作，报错也找不到错。定位错误很慢，错误的原因是忘记在循环中判断当前 peer 是否被 kill。其实可以想到的，日志混乱就是被 kill 的 peer 执行打印语句造成的，而报错也是因为被 kill 的 peer 仍在执行某个操作。 ⑥ 报错 apply error: commit index=2 server=4 1000 != server=2 30。Start 函数并发发送 RPC，顺序交错，没有正确更新 nextIndex。就是在上面提到的，需要取两者的最大值。⑦ 报错 testing.go:1152: race detected during execution of test。查错发现，切片是引用类型，作为参数传递到各个位置，引发竞态条件。在最开始，Go 竞争检测器报告的堆栈信息显示，是由 log.Printf 触发的竞争，我还以为是包有问题。之后，某次测试报出和切片相关的竞争，才发现应该是参数的问题。关于切片的线程安全问题，可以查看Reddit 中的讨论。 Part 3C: persistence 实现 实现 nextIndex 递减策略的优化，以及持久化必要的状态。比较简单，没有任何问题，测试报错基本上是因为之前的代码有问题。 测试 使用命令 time go test -race -run 3C -count 1 -failfast -timeout 0 | tee log 开始测试： ① 报错：race: limit on 8128 simultaneously alive goroutines is exceeded, dying。定位错误很慢，之前也遇到过该错误，不过是通过其他方式解决的。该错误其实就是因为创建太多线程，检查代码发现原因是，我会在日志 RPC 超时的时候进行重试，而每个 RPC 都在单独的线程中发送，所以无法通信的 peer 会累积很多重试线程。解决方案就是，不在 RPC 失败时重试，而使用定时重试。定时重试的代码和心跳检测基本上是一致的，区别只有是否包含日志项，所以实现时放一起很合理，并且这也可以额外满足只在空闲时发送心跳消息的规则（刚想起这个规则）。 ② 报错 config.go:601: one(5634) failed to reach agreement。日志很清晰，问题出在 leader 变更之后，没有调用 Start 函数，使得日志没有同步。此时，定时重试起不到作用，因为 nextIndex 被初始化为 lastLogIndex + 1，而重试的前提是 lastLogIndex &gt;= nextIndex。最开始想到的解决方案是，在当选 leader 时执行一次 AppendEntries RPC，包含索引位置为 nextIndex - 1 的日志项。但是有更好的做法，之所以会报错可以理解为心跳 RPC 没有在冲突时递减 nextIndex，因为我以为不需要处理心跳返回的 success 值，如果按正常流程处理其响应，那么就不会出现这个错误。 Part 3D: log compaction 实现 使用快照实现日志压缩，首先需要明白整体的流程，阅读 Diagram of Raft interactions 会很有帮助。如何创建快照？快照是由状态机/应用层创建的，然后对每个 peer 调用 Snapshot 函数来传递快照，此时 peer 可以丢弃快照包含的日志。而且 peer 也会负责快照的持久化，我们可以修改 persist 函数来实现。值的注意的是，peer 并不负责读取快照，状态机/应用层会读取 peer 持久化的快照。 实现 Snapshot 函数，需要在 Raft 结构体中添加两个状态，日志偏移量和快照。如果快照包含直到 log[Index] 的日志信息，我们会丢弃 Index 之前的所有日志，但是不会丢弃 Index 位置的日志，以便 AppendEntries RPC 对日志做一致性检查。在丢弃日志时需要注意，不要使用切片引用，而是复制切片，否则日志无法进行垃圾回收。Java 中 substring 函数就是因为使用引用可能会保留太多无效数据，而无法进行垃圾回收，所以改为复制的实现方式。 以上两个状态都需要持久化，而且我们需要修改必要的代码，以支持日志偏移量。首先修改 applyIndex 的初始值为日志偏移量，然后修改所有和 log 的索引访问以及长度有关的代码。修改代码感觉侵入性很强，很多地方都需要加减日志偏移量，可读性差并且易错。我想到的解决方案是，将获取日志长度和日志项的代码包装在单独的函数内，其他地方只需要调用对应的函数，从而不会导致混乱。注意，有些代码可能需要特殊处理。 当 leader 不包含 nextIndex - 1 位置的日志时，会调用该 InstallSnapshot RPC 而不是 AppendEntries RPC。特别注意，即使有以上限制，依然需要修改 AppendEntries RPC 处理程序，使其能够正确处理发送的日志项已经被 follower 压缩为快照的情况，因为 RPC 是并发的并且有可能滞后。简单的处理方式是，如果日志项被包含在快照中，则返回 success = true。修改代码时要非常小心，不要执行不必要的操作，从而导致索引越界，或者其他不正确的行为。 实现 InstallSnapshot RPC 处理程序，需要满足第 ⑤⑥⑦⑧ 点。处理程序的框架可以参考 AppendEntries RPC 的实现，实现可以参考论文图 2 描述的步骤。当 follower 收到有效的快照时，需要向 applyCh 通道发送消息。在发送消息之前，需要修改 applyIndex = max(rf.applyIndex, rf.logOffset)，之所以取 max 是因为有可能收到描述当前日志前缀的快照。最后，如果 RPC 返回响应且满足第 ⑧ 点，需要取最大值来更新 nextIndex。 测试 使用命令 time go test -race -run 3D -count 1 -failfast -timeout 0 | tee log 开始测试： ① 测试无法停止或者卡住，日志表明 leader 在向 applyCh 发送消息时阻塞。我之前就想过 applyCh 有可能会阻塞，但是测试通过就以为它不会阻塞，但是果然通道还是会阻塞。一定记住，不要假设任何不存在的前提条件。② 报错 snapshot decode error。定位错误有点慢，添加打印语句发现参数的快照字段，在发送 RPC 之前有值，但在接收 RPC 时没有值。很明显是字段首字母没有大写，从而没有将字段导出。 ③ 报错 apply error: server 0 apply out of order, expected index 1, got 10。很明显是应用层没有读取到快照，在我的代码中，该错误的触发条件是连续两次崩溃重启。原因是 peer 重启时没有读取快照，那么在之后的 persist 就会将已有的快照覆盖为 nil，然后第二次重启应用层没有读取到快照，从而产生错误。④ 索引越界，当 AppendEntries RPC 响应 success = false 时，有可能 reply.XIndex 位置的日志已经被丢弃，需要特判。 问题 在调试时发现，如果 leader 转变为 follower 之后，对应的 election timeout 正好结束，那么由于该 follower 没有设置最近收到的有效 RPC 的时间戳，所以会直接转变为 candidate，发起选举。我的想法是，可以在 leader 转变为 follower 时，重置超时时间。但是，要允许重置就需要在 Raft 结构体中额外添加状态。 在处理 RPC 响应之前，到底应该检查什么假设，一般会检查任期是否和发送时一致。但是，如何判断其他状态是否需要做一致性检查？处理 AppendEntries RPC 响应之前，如果 nextIndex 改变，只要任期没变，也依然可以处理该响应，因为这是正确的。为什么任期改变，就不能继续处理响应？因为当前 peer 可能已经不是 leader，或者虽然是 leader，但是 nextIndex 已经重新初始化，继续处理该响应会造成错误。 处理 RequestVote RPC 响应之前，如果 len(rf.log) 改变且任期没变，是否可以处理该响应？len(rf.log) 改变，说明当前 peer 收到有效的 AppendEntries RPC，它已经和 leader 取得联系转变为 follower，所以不需要处理该响应。类似的问题还可以提出很多，总之确定应该检查什么状态，来维持程序的正确性，需要仔细思考。 疑问：有可能收到当前快照的前缀快照吗？发送快照消息给 applyCh 时，解锁是否有可能产生错误？更新 nextIndex 时，由于 RPC 的并发性，总是需要取最大值来更新？之前处理 AppendEntries RPC 的响应时，并发返回 success = false，是否有可能不正确的递减 nextIndex，甚至使其为负数？ 总结 实验有很多细节点，有时以为自己知道该怎么做，但在编写代码却没有完全按照准则说的做，往往会遗漏某个前提条件或者某个操作，以及理解错某个概念。在做每一步之前，最好问一下自己，是否应该这样做，有什么特殊情况。日志对调试的帮助很大，我还是第一次打印这么大量且详细的日志，来调试并发程序。代码中同时存在多个错误真的很难搞，有时修复一个错误之后仍然报错，那么有可能是修复时引入的错误，或者之前代码中遗留的错误。在测试的后半部分，有种面向测试查错的感觉，个人感觉不是很好，最好还是能自己顺着逻辑找出错误。如果隐藏测试代码，估计得花费更长时间查错。 创建 go-test-many.sh 脚本，使用命令 bash ./go-test-many.sh 1000 8 开始并行测试。测试 Test (3C): Figure 8 (unreliable) ... 失败一次，报错 config.go:601: one(9042) failed to reach agreement。日志表明，follower 没有在限定时间内和 leader 同步。由于我的代码在某些情况下，只会传递 nextIndex 位置的日志，而不是之后的所有日志，此时会有同步过慢的问题，简单修改一下就可以解决。","link":"/2024/09/07/Lab%203%20Raft/"},{"title":"Lab 4: Fault-tolerant Key&#x2F;Value Service","text":"课程网站，实验网站，实验指南。 单个客户端只会串行发送 RPC，但服务器会收到多个客户端的 RPC。 Part A: Key/value service without snapshots 实现 实现 Clerk 的 Get 和 PutAppend 方法。如果不知道谁是 leader，则迭代地向每个服务器发送 RPC。直到某个服务器回复操作成功，此时记录该服务器为 leader，以免每次发送 RPC 都需要重新确定 leader。如果标记为 leader 的服务器回复操作失败或者超时未回复，依然需要迭代所有服务器。因为 leader 随时可能变化，甚至是在迭代的过程中，所以需要在迭代的外层添加一个无限循环。 实现 KVServer 的 Get、Put 和 Append 方法。基本的结构是，首先调用 rf.Start 方法，如果不是 leader 则响应 ErrWrongLeader。否则，在正常情况下，我们等待通道中出现对应的命令，将命令应用到状态机，然后返回响应。由于 rf.Start 方法不保证会提交指定的命令，我们需要一种能够检测当前服务器已经不是 leader 的方法，从而避免客户端阻塞在非 leader 服务器上。方式如下，可以定时调用 rf.GetState 检查当前服务器的任期是否和之前调用 Start 得到的任期不一致，或者在通道中出现和请求不匹配的消息。 对于每个服务器，我们应该使用一个线程来读取 ApplyMsg，不断地将已提交的命令应用到状态机。我们不能等待 RPC 去读取对应的 ApplyMsg，因为只有 leader 会收到 Clerk 的 RPC，此时其他服务器需要自动同步。需要注意，不是所有提交的命令都会应用到状态机，因为会存在重复的请求。例如，当前 leader 在提交日志之后崩溃，客户端没有收到响应，然后向新的 leader 发送重复的请求，如果此时命令没有被应用到状态机，依然会调用 rf.Start 方法，重复的请求会出现在日志中。 我们需要为每个客户端记录其最后应用到状态机的命令对应请求的标识，来过滤重复的请求。特别的，Get 请求不会对状态机产生影响，并且将 Get 请求放入日志只是为保证单个客户端视图的单调性，所以我们不需要过滤重复的 Get 请求，也就不需要保存上次 Get 请求的结果，而总是应该返回最新的结果。对于每个 Clerk，只缓存上次请求的 RequestId 是否有可能产生错误？例如，某个很早之前发送的 RPC 到达 KVServer，而对应的 RequestId 已经被覆盖。不会发生该情况，TCP 会保证发送顺序和到达顺序一致。 测试 使用命令 time go test -race -run 4A -count 1 -failfast -timeout 0 开始测试： ① 测试无法停止，查看日志发现，客户端请求阻塞在非 leader 服务器上。通过定时检查服务器的任期，可以解决该问题。 Part B: Key/value service with snapshots 实现 什么时候检查大小？可以定时检查。如果超过大小，该执行什么操作？调用 rf.Snapshot。什么时候读取快照？在服务器启动时，以及从通道中。特别的，如果 maxraftstate = -1，则不需要快照。通道中的快照是否有可能比服务器的当前状态更小？ 测试 使用命令 time go test -race -run 4B -count 1 -failfast -timeout 0 开始测试： ① 报错 panic: runtime error: slice bounds out of range [-190:]。Raft 发送快照给服务器，而服务器也发送快照给 Raft，状态交叠从而产生错误。要解决该问题，第一个想法是在 Raft 向服务器发送快照时不释放锁，但是有可能产生死锁。第二个想法是，在服务器从通道接收快照消息之后，再更新 Raft 的状态。但是还是不行，如果服务器读取快照消息却没有应该到状态机，然后服务器在 Raft 更新状态之前，调用 persister.RaftStateSize 检查大小，此时 Raft 更新状态，之后服务器调用 rf.Snapshot 方法传递一个更小的快照，必然会产生索引越界。或者，服务器调用 rf.Snapshot 方法传递一个更大的快照，然后 Raft 更新状态，也会索引越界。而且，在之后更新状态必须重新检查假设，很麻烦。简单起见，依然在解锁之前更新状态，同时在 rf.Snapshot 中过滤更小的快照。 ② 测试 TestSnapshotRecover4B，报错 test_test.go:148: duplicate element x 0 333 y in Append result。定位错误很慢，日志太长不好看，看半天看不出问题。原因是服务器从通道读取快照之后，通道中有快照已经包含的命令消息，所以会重复应用命令。在应用消息到状态机之前，需要限制消息的日志索引必须大于最后应用到状态机的日志索引。其实只要查看修改状态机的关键代码，应该是可以很快找到错误的。 ③ 测试 TestSnapshotRecoverManyClients4B，报错 test_test.go:293: get wrong value, key 19。错误的信息表明状态缺失，定位错误很慢，主要日志太多，打印的信息也不全，经常需要添加打印信息然后重新测试，果然应该在最开始就打印所有信息。错误的原因在 Raft 代码，没有限制快照消息在日志消息之前发送，服务器会提前收到快照之后的命令，使得服务器在收到快照时会丢弃快照，因为最后应用的命令索引大于快照的最后索引。解决方案很简单，只需要做一下限制就行。 总结 每次做实验都会遇到两个难点，一个是功能实现，一个是定位错误。 关于功能实现：例如，如何实现将 ApplyMsg 应用到状态机？最开始，我是想让每个 RPC 去读取消息，然后将其应用到状态机。但是，思考之后，会发现不可行，然后又去想其他方案。实现方式的设计依赖于对整个交互逻辑的正确理解，难点在于处理异常情况，像是 leader 变更、服务器崩溃。 关于定位错误：总是应该在日志中包含所有信息，避免需要添加信息然后重新测试的情况，会非常痛苦。定位错误不要只看日志，一定要先思考可能是哪个部分有问题，比如说状态机的状态有问题，那么在什么情况下会修改状态？找到修改状态的代码，然后思考这段代码在什么情况下会有问题。如果代码没有问题，那么想一想是不是外界的输入有问题，什么样的输入会产生该错误？然后，我们就可以找到外部依赖的代码，确定是否有可能产生该输入序列。","link":"/2024/09/12/Lab%204%20Fault-tolerant%20Key%20Value%20Service/"},{"title":"Lab 5: Sharded Key&#x2F;Value Service","text":"课程网站，实验网站，实验指南。 Part A: The Controller and Static Sharding 实现 基本上就是复制 lab4 的代码，实现平衡分片到服务器的代码会花点时间，像在做算法题。 测试 使用命令 time go test -race -run 5A -count 1 -failfast -timeout 0 开始测试： ① 测试 TestMulti，报错 test_test.go:61: Shards wrong。日志显示，不同状态机的 Shards 数组包含相同的元素，但是顺序不同。可以想到，错误原因在于改变状态机的代码是非确定性的，由于提示中有说 map 遍历顺序的不确定性，所以我们可以很快定位错误。要使遍历顺序具有确定性，只好将 map 中的键放在数组中，排序之后遍历。 Part B: Shard Movement 实现 假设副本组 G1 负责的分片 S1 需要移动到副本组 G2。在 G1 发送分片之后，以及 G2 接收分片之前，都不应该处理和该分片相关的客户端请求，不论是新收到的请求还是已经在 applyCh 中的请求。G1 应该返回 ErrWrongGroup，G2 应该使用条件变量等待分片的到达。和 lab4 相同，如果服务器发现其已经不是 leader，则不应该继续等待。而且，G2 必须将接收的分片使用 Raft 应用到状态机之后，才能返回响应。为了方便的发送和删除分片，服务器应该按分片来存储数据。如果服务器需要发送多个分片，可以简单地串行发送，更好的做法是，并发地向不同副本组发送分片，在单个 RPC 中包含所有需要发向该副本组的分片。 如果在 G2 更新配置之前，G1 发送的分片到达 G2，该如何处理？在请求中应该包含配置编号，如果 G2 发现更大的配置编号，则使用条件变量等待配置更新，再处理该请求。如果 G1 发生故障，G2 可能会收到重复的分片，在将分片应用到状态机之前，应该限制该分片所属的配置编号和当前配置相同，并且使用副本组编号和配置编号的组合来去重。如果分片的配置编号小于当前配置编号，则直接响应 OK。 对于客户端请求，必须实现跨副本组的重复检测。例如，副本组 G1 已执行客户端的请求但未响应，然后 G1 向 G2 发送分片，最终客户端会向 G2 发送重复的请求。简单的解决方案是，G1 不仅发送分片，还发送用于重复检测的数据，所以重复检测的数据最好也是按照分片来存储。 服务器需要定期检查配置是否变更，在一个副本组中，只有 leader 会检查，还是所有副本都会检查？应该是只有 leader 检查配置变更，然后使用 Raft 将变更复制到其他副本中。因为不同副本检查配置变更的时机不同，服务器拒绝 applyCh 中相关请求的时机也就不同，从而状态机会不一致。在将配置变更应用到状态机之后，才开始发送分片，从而确保不同副本都会发送相同的分片。 在检查配置变更时，需要根据配置编号获取下一个配置，而不能直接获取最新配置，因为在未检查期间配置可能变更多次。如果 Raft 选举出新的 leader，它会检查下一个配置变更将其添加到日志，若此时通道中已经存在旧 leader 提交的一个/多个配置变更的日志，有可能会导致不正确的覆盖。所以，在将变更应用到状态机之前，应该总是限制配置编号是单调递增的。 配置必须线性地变更，如果配置变更多次，之后的变更必须等待之前的变更完成。可以将等待发送和接收的分片记录到状态中，然后使用条件变量检查状态来确定之前的配置是否完成。特别的，如果配置的编号为 1，则不需要记录状态。如果 leader 在变更配置的过程中崩溃，新的 leader 需要知道当前配置是否变更完成，所以上述状态应该使用 Raft 复制到副本中。同时，创建一个线程定期检查（或者使用条件变量），如果当前服务器是 leader，则发送状态中记录的待发送分片，发送完成之后删除对应分片。 测试 使用命令 time go test -race -run 5B -count 1 -failfast -timeout 0 开始测试： ① 在将配置应用到状态机之后，没有拒绝 applyCh 中的相关请求。 ② 在处理发送分片的 RPC 的响应时，忘记检查假设，需要确保当前配置编号和发送 RPC 时相同。 ③ 读取快照的语句放在初始化之前，导致错误的状态。 ④ Op 中的 map 会和 Raft 的 e.Encode(rf.log) 竞争，所以总是使用 map 的副本。 ⑤ 在修改状态时，没有唤醒条件变量。 ⑥ 有些状态只有 leader 会修改，所以 follower 需要特殊处理。 ⑦ 如果 leader 接收分片，使用 Raft 复制到多数副本，在返回响应之后所有副本都崩溃。重启之后，由于 Raft 对提交之前任期的日志条目存在限制，该日志无法提交。此时，客户端请求该分片的数据将会阻塞直到日志应用，而日志无法提交除非在当前任期提交一个日志。解决方案就是，在重启之后总是添加一个空日志条目，来推进 commitIndex。之前测试有发生过低概率的报错，我当时就怀疑是 Raft 的实现有问题。 总结 Part B 有点折磨，有些很蠢的错误，花费很长时间才定位到。例如 ⑥，主要是太相信某个部分不会出错，结果就是那个地方有问题。例如 ①，以为已经实现某个功能，实际上存在遗漏，在定位错误时就不会往那个方面想。原因在于，没有在完成部分功能时做相关的测试，从而将发现错误的时间延后，此时代码已经有很多其他逻辑，定位错误会更加困难。错误 ②③④⑤ 是细节上的遗漏，因为功能实现并不是线性的过程，添加某个功能会修改已经实现的部分，逻辑交互在一起难免会有遗漏，特别是在代码组织很糟糕的情况下。整体来说，程序的并发运行会产生意想不到的交错，特别是存在网络或者机器故障的情况下，真的很难在最开始就写出正确的代码。","link":"/2024/09/19/Lab%205%20Sharded%20Key%20Value%20Service/"},{"title":"Coroutines for Go（草稿）","text":"参考 Coroutines for Go，Coroutine Wiki。 什么是协程（coroutine）？通常使用的函数（function）也被称为子例程（subroutine），一系列调用会形成一个调用栈（call stack），调用者（caller）和被调用者（callee）是父子关系。而协程不同，协程之间是对等关系，每个协程都有一个调用栈。协程有非对称和对称两种实现，非对称协程使用 resume 和 yield 关键字，调用者使用 resume 恢复某个协程，被调用者使用 yield 暂停当前协程，然后控制会转移到调用者。对称协程只使用 yield 关键字，但是需要指定将控制转移给哪个协程。经典的例子，比较两个二叉树是否包含相同的序列（中序遍历），代码。 协程的控制转移是主动的（非抢占式），不需要操作系统支持，也不需要使用锁和信号量等同步原语。线程的控制转移是被动的（抢占式），由操作系统调度，上下文切换更加昂贵，需要使用同步原语保护共享变量。协程只提供并发性，而线程可以利用多核 CPU 实现并行。切换的速度，协程最多 10 纳秒，线程几微秒，Goroutines 和 Virtual Threads（Java 21） 几百纳秒。 网络上各种术语的解释很混乱，根据多线程模型，我倾向于使用用户线程和内核线程的对应关系，来描述不同的实现。简单描述一下我的理解：平常使用的是一对一模型，Goroutines 和 Virtual Threads 使用的是多对多模型。协程不能简单的看作多对一模型，协程是非抢占式的用户线程，描述的是多个用户线程之间的协作关系，实际上可以在各个模型上实现协程。 关于 Goroutines 的实现，可以看 Dmitry Vyukov 的演讲 Go scheduler: Implementing language with lightweight concurrency。其他资源：Scalable Go Scheduler Design Doc，The Go scheduler，HACKING。 简单的设计，使用一对一模型 + 线程池，缺点是线程的内存占用较大，Goroutine 阻塞会导致线程阻塞，没有“无限数量”的栈。所以，使用多对多模型，Goroutine 占用内存更小，可以被 Go runtime 完全控制。如果 Goroutine 因为锁/通道/网络 IO/计时器而阻塞，Goroutine 将会进入阻塞队列，运行此 Goroutine 的内核线程不会阻塞，Go runtime 可以从 Run Queue 中调度 Runnable 的 Goroutine 到该内核线程上（复用，Multiplex）。 但是，当 Goroutine 进行系统调用，控制将从 Goroutine 转移到系统调用处理程序，Go runtime 是无法感知该处理流程的，直到系统调用返回，所以此时运行 Goroutine 的内核线程是无法被复用的。有可能所有内核线程都阻塞在系统调用上，而该系统调用所需的资源被某个 Runnable 的 Goroutine 持有，从而发生死锁。所以在系统调用发生时总是会创建/唤醒一个内核线程，执行 Run Queue 中的 Goroutine。当内核线程从系统调用返回，Go runtime 将内核线程上的 Goroutine 放入 Run Queue，使该内核线程空闲从而保证指定的并行度（由 GOMAXPROCS 指定）。 关于 GOMAXPROCS，runtime 文档的描述如下：The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. 该实现的瓶颈在全局的互斥锁（MUTEX），内核线程创建 Goroutine 以及获取 Goroutine 都需要操作共享的 Run Queue。解决方案很容易想到，就是为每个内核线程创建本地变量，从而避免频繁访问全局的共享变量。该方案会增加获取下一个 Goroutine 的复杂性，Go 调度器实现的获取顺序是， Local Run Queue、Global Run Queue、Network Poller、Work Stealing。 由于发生系统调用时会创建/唤醒内核线程，也就是说内核线程的数量会多于 CPU 的核心数量。新的调度器为每个内核线程分配本地资源，但是实际上执行 Go 代码的内核线程的数量是固定的（由 GOMAXPROCS 指定），所以空闲线程不应该持有资源，会造成资源浪费以及降低 Work Stealing 的效率。所以，设计上引入一个新的实体，也就是处理器（Processor），从而调度模型从 GM 变为 GMP。Go runtime 不会为每个内核线程分配资源，而是为 Processor 分配资源，Processor 的数量就是 CPU 的核心数量。在新的模型中，当 Goroutine 发生系统调用时，Goroutine 会创建/唤醒新的内核线程，然后将 Processor 对象交给新的内核线程。 目前，调度器已经足够好，不过可以更好。公平性（Fairness）和性能的权衡：设计者想要以最小的性能开销获得最小的公平性。FIFO 队列可以一定程度上保证公平性，但是如果当前 Goroutine 陷入无限循环，队列中的 Goroutine 将会饥饿，所以设计者使用 10 ms 的时间片轮转调度（时分共享，抢占式）。另一方面，FIFO 队列缺少局部性（影响性能），最后进入队列的 Goroutine 会在最后运行。常见的场景，当前 Goroutine 创建另一个 Goroutine，然后自身被阻塞等待另一个 Goroutine 执行。缺少局部性的 FIFO 会产生很大延迟，所以设计者在 Local Run Queue 的尾部添加一个单元素的 LIFO 缓冲区，每次获取 Goroutine 都会首先从缓冲区中获取（Direct Switch）。 该设计引入额外两个问题，一个是其他内核线程从当前内核线程 Work Stealing 时，将 LIFO 中的 Goroutine 窃取，影响 Direct Switch 的执行。解决方案是只有 Goroutine 被放入 LIFO 超过 3 μs 才能被窃取。另一个问题是，不断创建 Goroutine 会导致 LIFO 缓冲区总是有元素，从而 FIFO 队列中的 Goroutine 会饥饿，解决方案是当前 Goroutine 和 LIFO 中的 Goroutine 共享同一个 10 ms 的时间片。 如果 Local Run Queue 一直不为空，Global Run Queue 会饥饿。所以，假设当前是第 schedTick 次获取，设计者设置当 schedTick % 61 == 0 时，优先从 Global Run Queue 获取 Goroutine。为什么使用 61，因为 61 不大不小，太大会饥饿，太小会因为 Global Run Queue 的 MUTEX 限制性能，并且参考哈希表的设计，使用质数而不是 2 的幂会更随机/公平。 最后，Network Poller 可能会饥饿，解决方案是使用后台线程从中定期获取 Goroutine。之所以不像处理 Global Run Queue 饥饿一样在当前线程中获取，是因为从 Network Poller 获取 Goroutine 涉及到 epoll_wait() 系统调用（很慢）。","link":"/2024/10/03/Coroutines%20for%20Go/"},{"title":"快速傅里叶变换（FFT）","text":"参考 Reducible。 问题 如何求两个 \\(n\\) 次多项式 \\(A(x)\\) 和 \\(B(x)\\) 的乘积 \\(C(x)\\)？最简单的方式是使用乘法分配律对每个系数做乘积，时间复杂度为 \\(O(n^{2})\\)。 $$ A(x)=a_{0}+a_{1}x^{1}+\\cdots+a_{n-1}x^{n} \\\\ B(x)=b_{0}+b_{1}x^{1}+\\cdots+b_{n-1}x^{n} \\\\ C(x)=c_{0}+c_{1}x^{1}+\\cdots+c_{2n}x^{2n} $$ 另一种想法是：① 在多项式 \\(A(x)\\) 和 \\(B(x)\\) 上取 \\(2n+1\\) 个点 \\(x_{i}\\)，其中 \\(i=0,1,\\cdots,2n\\)，求出对应的函数值。② 根据 \\(C({x_{i}})=A(x_{i})\\cdot B(x_{i})\\)，可以得到 \\(C(x)\\) 上的 \\(2n+1\\) 个点。③ 使用拉格朗日插值，化简得到 \\(C(x)\\) 的表达式。总时间复杂度为 \\(O(n^{2})\\)，如果能够将 ① 和 ③ 的时间复杂度优化为 \\(O(n\\log{n})\\)，那么就能够降低总时间复杂度。 优化步骤 ① 可以发现，对于偶函数 \\(f(x)=f(-x)\\)，对于奇函数 \\(f(x)=-f(-x)\\)。如果将多项式分解为偶函数和奇函数两部分，则可以可以利用对称性快速求点值。不妨设 \\(n\\) 为偶数，将 \\(n-1\\) 次多项式 \\(P(x)\\) 划分为偶函数和奇函数两部分。 $$ \\begin{align}P(x)&=p_{0}+p_{1}x^{1}+\\cdots+p_{n-1}x^{n-1} \\\\&=(p_{0}+p_{2}x^{2}+\\cdots+p_{n-2}x^{n-2})+(p_{1}+p_{3}x^{3}+\\cdots+p_{n-1}x^{n-1}) \\\\&=(p_{0}+p_{2}x^{2}+\\cdots+p_{n-2}x^{n-2})+x(p_{1}+p_{3}x^{2}+\\cdots+p_{n-1}x^{n-2})\\end{align} $$ 设 \\(P_{e}(x)=p_{0}+p_{2}x^{1}+\\cdots+p_{n-2}x^{\\frac{n}{2}-2}\\)，\\(P_{o}(x)=p_{1}+p_{3}x^{2}+\\cdots+p_{n-1}x^{\\frac{n}{2}-2}\\)，则 \\(P(x)=P_{e}(x^{2})+xP_{o}(x^{2})\\)。此时，如果取 \\(n\\) 个点 \\(\\pm x_{0},\\pm x_{1},\\cdots,\\pm x_{\\frac{n}{2}-1}\\)，则只需要计算 \\(P_{e}(x_{i}^{2})\\) 和 \\(P_{o}(x_{i}^{2})\\)，就能够通过以下方式得到两个函数值。 $$ P(x_{i})=P_{e}(x_{i}^{2})+x_{i}P_{o}(x_{i}^{2}) \\\\ P(-x_{i})=P_{e}(x_{i}^{2})-x_{i}P_{o}(x_{i}^{2}) $$ 所以，要求 \\(P(x)\\) 上的 \\(n\\) 个点值，等价于求 \\(P_{e}(x^{2})\\) 和 \\(P_{o}(x^{2})\\) 上的 \\(\\frac{n}{2}\\) 个点值，即点 \\(x_{0},x_{1},\\cdots,x_{\\frac{n}{2}-1}\\) 的值。此时，原问题被分解为两个相同的子问题，并且子问题的大小只有原问题的一半，如果子问题能够按照原问题的方式继续分解，则可以得到时间复杂度为 \\(O(n\\log{n})\\) 的算法。 但是，\\(P_{e}(x^{2})\\) 和 \\(P_{o}(x^{2})\\) 不能继续分解，因为定义域 \\(x^{2}\\geq 0\\)，点 \\(x_{0}^{2},x_{1}^{2},\\cdots,x_{\\frac{n}{2}-1}^{2}\\) 不构成正负对，也就不能利用对称性求点值。如果能够取到一组构成正负对的点，在子问题中所有正点依然构成正负对，那么就可以继续递推。此时，需要引入复数，例如，取点 \\(\\pm 1,\\pm i\\) 构成正负对，子问题中 \\(1^{2},i^{2}\\) 等价于 \\(1,-1\\) 依然构成正负对。 那么对于 \\(n-1\\) 次多项式，如何取满足条件的 \\(n\\) 个点？假设取某个点 \\(z\\)，那么必然要取 \\(-z\\)，在子问题中 \\(z\\) 变为 \\(z^{2}\\)，那么必然要取 \\(-z^{2}\\)，以此类推，假设 \\(n\\) 为 \\(2\\) 的幂（总是可以通过对高次项补系数 \\(0\\) 取到），则最终得到 \\(z^{n}\\)。也就是说，所有取值的 \\(n\\) 次方都相等，不妨设 \\(z^{n}=1\\)，求解方程可以得到 \\(n\\) 个单位根，即为满足条件的 \\(n\\) 个点。 设复数 \\(z=a+bi\\)，则极坐标表示为 \\(z=r(cos(\\varphi)+isin(\\varphi))\\)，根据欧拉公式，有 \\(z=re^{\\varphi i}\\)。要求 \\(z^{n}=1\\)，即求 \\(r^{n}e^{\\varphi ni}=e^{2k\\pi i}\\)，得出 \\(r=1,\\varphi =\\frac{2k\\pi}{n}\\)，所以 \\(z=e^{\\frac{2k\\pi}{n}i}\\)，其中 \\(k=0,1,\\cdots,n-1\\)。设 \\(w_{n}=e^{\\frac{2\\pi}{n}i}\\)，则 \\(n\\) 个单位根分别为 \\(w_{n}^{0},w_{n}^{1},\\cdots,w_{n}^{n-1}\\)，它们将复平面中的单位圆 \\(n\\) 等分。 观察单位根的性质，有 \\(w_{n}^{k}=-w_{n}^{k+\\frac{n}{2}}\\)，\\(w_{n}^{k}=w_{\\frac{n}{2}}^{\\frac{k}2}\\)，所以 \\(w_{n}^{0},w_{n}^{1},\\cdots,w_{n}^{\\frac{n}{2}-1}\\) 和 \\(w_{n}^{\\frac{n}{2}},w_{n}^{\\frac{n}{2}+1},\\cdots,w_{n}^{n-1}\\) 构成正负对。在子问题中，\\(w_{n}^{0},w_{n}^{1},\\cdots,w_{n}^{\\frac{n}{2}-1}\\) 变为 \\(w_{n}^{0},w_{n}^{2},\\cdots,w_{n}^{n-2}\\)，等价于 \\(w_{\\frac{n}{2}}^{0},w_{\\frac{n}{2}}^{1},\\cdots,w_{\\frac{n}{2}}^{\\frac{n}{2}-1}\\)，前半和后半依然构成正负对，以此类推。从复平面的角度思考，更容易理解。 根据上述讨论，单位根的正负对性质，在所有子问题中都成立，所以求 \\(n-1\\) 次多项式 \\(P(x)\\) 的 \\(n\\) 个点值，可以使用递归分治的方式求解。当 \\(n=1\\) 时，多项式是常数，\\(P(w_{1}^{0})\\) 就是该常数值。当 \\(n&gt;1\\) 时，如果已知 \\(P_{e}(x^{2})\\) 和 \\(P_{o}(x^{2})\\) 在 \\(w_{n}^{k}\\) 的点值，其中 \\(k&lt;\\frac{n}{2}\\)，则利用之前推出的 \\(P(x)=P_{e}(x^{2})+xP_{o}(x^{2})\\) 公式可以得到以下两个函数值。 $$ P(w_{n}^{k}) =P_{e}(w_{n}^{2k})+w_{n}^{k}P_{o}(w_{n}^{2k}) \\\\ P(-w_{n}^{k}) =P(w_{n}^{k+\\frac{n}{2}}) =P_{e}(w_{n}^{2k+n})+w_{n}^{k+\\frac{n}{2}}P_{o}(w_{n}^{2k+n}) =P_{e}(w_{n}^{2k})-w_{n}^{k}P_{o}(w_{n}^{2k}) $$ 优化步骤 ③ 步骤 ① 是已知系数，求 \\(n-1\\) 次多项式 \\(P(x)\\) 在 \\(n\\) 个 \\(n\\) 次单位根位置的值，可以看作矩阵相乘的形式。 $$ \\left[\\begin{matrix}P(w_{n}^{0}) \\\\P(w_{n}^{1}) \\\\P(w_{n}^{2}) \\\\\\vdots \\\\P(w_{n}^{n-1})\\end{matrix}\\right]=\\left[\\begin{matrix}w_{n}^{0} & w_{n}^{0} & w_{n}^{0} & \\cdots & w_{n}^{0} \\\\w_{n}^{0} & w_{n}^{1} & w_{n}^{2} & \\cdots & w_{n}^{n-1} \\\\w_{n}^{0} & w_{n}^{2} & w_{n}^{4} & \\cdots & w_{n}^{2(n-1)} \\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\w_{n}^{0} & w_{n}^{n-1} & w_{n}^{2(n-1)} & \\cdots & w_{n}^{(n-1)(n-1)}\\end{matrix}\\right]\\left[\\begin{matrix}p_{0} \\\\p_{1} \\\\p_{2} \\\\\\vdots \\\\p_{n-1}\\end{matrix}\\right] $$ 步骤 ③ 是已知 \\(n\\) 个点值，求多项式的系数，可以看作上述变换的逆变换。 $$ \\left[\\begin{matrix}p_{0} \\\\p_{1} \\\\p_{2} \\\\\\vdots \\\\p_{n-1}\\end{matrix}\\right]=\\left[\\begin{matrix}w_{n}^{0} & w_{n}^{0} & w_{n}^{0} & \\cdots & w_{n}^{0} \\\\w_{n}^{0} & w_{n}^{1} & w_{n}^{2} & \\cdots & w_{n}^{n-1} \\\\w_{n}^{0} & w_{n}^{2} & w_{n}^{4} & \\cdots & w_{n}^{2(n-1)} \\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\w_{n}^{0} & w_{n}^{n-1} & w_{n}^{2(n-1)} & \\cdots & w_{n}^{(n-1)(n-1)}\\end{matrix}\\right]^{-1}\\left[\\begin{matrix}P(w_{n}^{0}) \\\\P(w_{n}^{1}) \\\\P(w_{n}^{2}) \\\\\\vdots \\\\P(w_{n}^{n-1})\\end{matrix}\\right] $$ $$ \\left[\\begin{matrix}w_{n}^{0} & w_{n}^{0} & w_{n}^{0} & \\cdots & w_{n}^{0} \\\\w_{n}^{0} & w_{n}^{1} & w_{n}^{2} & \\cdots & w_{n}^{n-1} \\\\w_{n}^{0} & w_{n}^{2} & w_{n}^{4} & \\cdots & w_{n}^{2(n-1)} \\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\w_{n}^{0} & w_{n}^{n-1} & w_{n}^{2(n-1)} & \\cdots & w_{n}^{(n-1)(n-1)}\\end{matrix}\\right]^{-1}=\\frac{1}{n}\\left[\\begin{matrix}w_{n}^{0} & w_{n}^{0} & w_{n}^{0} & \\cdots & w_{n}^{0} \\\\w_{n}^{0} & w_{n}^{-1} & w_{n}^{-2} & \\cdots & w_{n}^{-(n-1)} \\\\w_{n}^{0} & w_{n}^{-2} & w_{n}^{-4} & \\cdots & w_{n}^{-2(n-1)} \\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\w_{n}^{0} & w_{n}^{-(n-1)} & w_{n}^{-2(n-1)} & \\cdots & w_{n}^{-(n-1)(n-1)}\\end{matrix}\\right] $$ 如果将步骤 ① 表示为 \\(FFT(w_{n},p_{0},p_{1},\\cdots,p_{n-1})\\)，则步骤 ③ 为 \\(IFFT(w_{n},P(w_{n}^{0}),P(w_{n}^{1}),\\cdots,P(w_{n}^{n-1}))=\\frac{1}{n}FFT(w_{n}^{-1},P(w_{n}^{0}),P(w_{n}^{1}),\\cdots,P(w_{n}^{n-1}))\\)。","link":"/2025/01/03/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89/"},{"title":"Reflections on Trusting Trust","text":"参考 Reflections on Trusting Trust，Running the “Reflections on Trusting Trust” Compiler。 The moral is obvious. You can’t trust code that you did not totally create yourself. (Especially code from companies that employ people like me.) No amount of source-level verification or scrutiny will protect you from using untrusted code. 步骤一 如何编写一个自我复制程序（Quine）？使用 Java 编写的代码如下，还是有点难的。最开始想直接打印，但是打印语句需要包含完整的程序，而完整的程序又包含打印语句，是一个循环依赖的过程。要把循环解开，就只能在字符串中包含基本的行，经过特殊处理得到正确的输出，最简单的方式是使用占位符。似乎不能使用转义字符，因为反斜杠在字符串中也需要转义，所以根本没办法打印出相同的行。更短的示例可以参考 Quine Programs。 1234567891011121314151617public class Main { public static void main(String[] args) { char n = 10; String t = new String(new char[]{'&quot;', '&quot;', '&quot;'}); String s = &quot;&quot;&quot;public class Main { public static void main(String[] args) { char n = 10; String t = new String(new char[]{'&quot;', '&quot;', '&quot;'}); String s = %s; System.out.printf(s, t + n + s + t); }}&quot;&quot;&quot;; System.out.printf(s, t + n + s + t); }} 步骤二 如何构建一个自编译的编译器（即由要编译的语言编写的编译器），是一个先有鸡还是先有蛋的问题，解决方案是引导（Bootstrapping）。简单来说，首先使用机器支持的语言编写编译器 A 的源代码，编译器 A 可以编译目标语言的子集。然后使用目标语言的子集编写编译器 B 的源代码，经过编译器 A 编译得到编译器 B 的二进制文件。之后就可以不断重复，得到支持完整目标语言的编译器。 12if (c == 'v') return 11; // 旧编译器可以识别if (c == 'v') return '\\v'; // 新编译器才能识别 论文提到的例子是，在目标语言中添加 \\v 符号，表示垂直制表符。由于旧编译器不识别该符号，所以使用垂直制表符的 ASCII 码 11 扩展旧编译器的源代码，旧编译器编译扩展后的源代码得到新编译器，新编译器就能够识别 \\v 符号。 步骤三 修改编译器，以匹配指定模式，如果匹配则错误地编译源代码，这是特洛伊木马（Trojan horse）。可以在编译器中插入指定的匹配模式（后门，backdoor），使其匹配 login 命令的源代码。如果用户使用该编译器编译 login 命令，则命令会被错误编译，从而可以使用指定的密码登录系统的任意用户。 最关键的是，如果再添加一个针对编译器自身的匹配模式，在识别到当前正在编译编译器时，将特洛伊木马插入到新编译器中，则可以实现类似步骤二中的“学习”过程。也就是说，即使编译器 B 的源代码是正确的，使用包含以上两个匹配模式的编译器 A 编译，得到的编译器 B 的二进制文件依然包含两个特洛伊木马。最终，编译器 B 仍会错误地编译 login 命令，而编译器 B 的源代码却是正确的。 论文提到，将特洛伊木马插入到新编译器中，使用的是步骤一的自我复制程序。我看半天才理解这句话，可以这么想，特洛伊木马需要获取自身的代码，然后插入到新编译器的特定位置，类似自我复制需要输出自身的代码。","link":"/2025/01/15/Reflections%20on%20Trusting%20Trust/"},{"title":"Volatile &amp; 内存一致性模型","text":"参考 What Volatile Means in Java，Memory Models，Consistency model。另外，stack overflow 的讨论或许有用。 Java 中的 volatile 可以保证可见性、有序性。可见性：线程 A 写入 volatile 变量，线程 B 读取该 volatile 变量可以读到最新值，并且在线程 A 写入 volatile 变量之前对 A 可见的变量值，在线程 B 读取该 volatile 变量之后对 B 也可见。有序性：禁止（编译器/CPU）对 volatile 变量相关的指令进行重排优化。虽然 Java 并发编程实战中提到 volatile 不能保证原子性，但是对 long/double 类型的 volatile 变量的简单赋值操作是原子的，我所说的简单赋值是指不依赖变量当前值的赋值操作。 问题 在《深入理解 Java 虚拟机》第 12 章中有提到 volatile 相关的汇编代码，简单的示例如下。书中提到 lock addl 相当于一个内存屏障，阻止跨内存屏障的指令重排，同时还会将当前处理器的缓存写入内存，以及使其他处理器的缓存失效，从而禁止指令重排。 1234567private static boolean a;private volatile static boolean b;public static void foo() { a = true; b = true;} 123450x000002271ed4378c: movabs $0x711dec880,%r10 ; {oop(a 'java/lang/Class'{0x0000000711dec880} = 'Test')}0x000002271ed43796: movb $0x1,0x70(%r10)0x000002271ed4379b: movb $0x1,0x71(%r10)0x000002271ed437a0: lock addl $0x0,-0x40(%rsp) ;*putstatic b {reexecute=0 rethrow=0 return_oop=0}; - Test::foo@5 (line 8) 最初，我有个疑问，就是赋值语句之后的内存屏障无法禁止屏障之前的指令重排，例如此处的两个赋值语句 a=true 和 b=true 是否可能重排。询问 Jeremy（JSR-133 的作者之一）之后，他告诉我： It is possible for processors to do that in general, but x86 doesn’t, so you don’t need a barrier there. Search for “total store order” if you’re curious. 然后，我查找和 TSO 相关的内容时，又一次找到 Russ Cox 的博客，以下内容部分来自该博客。 概念 顺序一致性（Sequential Consistency）：单个处理器按照程序顺序执行（不重排指令），多个处理器按照某种顺序交错执行，这样的多处理器就是顺序一致的。 大多数指令集架构不提供顺序一致的内存模型，因为更强的一致性通常意味着更少的优化（更低的性能）。x86 使用 Total Store Order（TSO）内存模型：所有处理器都连接到单个共享内存，但是每个处理器有一个本地的写入队列，写入操作排队写入共享内存，读取操作会优先读取本地写入队列中的值（如果有的话）。ARM/POWER 的内存模型更加宽松：每个处理器从自己的内存完整副本中读取和写入，读取可以延迟到写入之后，并且每个写入都独立地传播到其他处理器，在写入传播时允许重新排序。 测试 Litmus Test（石蕊测试）：初始时 x=0,y=0（共享变量），rn 表示私有存储（例如，寄存器或者局部变量），不考虑编译器重排指令。 以下程序是否可以看到 r1=1,r2=0？顺序一致性和 x86 中不可以，ARM/POWER 中可以。 123456// Thread1x = 1y = 1// Thread2r1 = yr2 = x 以下程序是否可以看到 r1=0,r2=0？顺序一致性中不可以，x86 和 ARM/POWER 中可以。 123456// Thread1x = 1r1 = y// Thread2y = 1r2 = x 其他 区分 consistency 和 coherency：consistency 表示多个处理器对所有内存位置的操作的总顺序达成一致，coherency 表示多个处理器对相同内存位置的操作的总顺序达成一致。 JMM 为程序中所有操作定义了一个偏序关系，称为 Happens-Before。操作 A Happens-Before 操作 B 的含义是：如果操作 A 先于操作 B 发生，那么执行操作 B 的线程能够看到操作 A 的结果。如果两个操作没有 Happens-Before 关系，那么 JVM/CPU 可以对它们任意地重新排序。","link":"/2025/01/26/Volatile%20&%20%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"title":"Lockfree Algorithms","text":"参考 Lockfree Algorithms，Is Parallel Programming Hard, And, If So, What Can You Do About It?（中文版名称《深入理解并行编程》）。 最近在看《实战 Java 高并发程序设计》，遇到一些问题，所以简单记录一下。上面两个参考资料都非常不错，由于时间有限，并没有全部看完，有些地方也不能完全看懂。第二个参考资料偏 C++，如果要看 Java 相关的书，或许可以看看《The Art of Multiprocessor Programming》。 阻塞算法（Blocking Algorithms）：被阻塞/中断/终止的线程可能会无限期的阻止整个系统向前推进。使用锁的算法都是阻塞算法，因为当持有锁的线程被阻塞/中断/终止时，其他线程无法向前推进。以及存在死锁问题。 非阻塞算法：被阻塞/中断/终止的线程不会阻止当前线程向前推进，包括无障碍（Obstruction-freedom）、无锁（Lock-freedom）和无等待（Wait-freedom）。无障碍：线程只有在没有遇到其他线程竞争时，才能向前推进，也就是说存在活锁。无锁：必然有一个线程可以向前推进。无等待：所有线程都可以向前推进。 概念比较抽象，可以想下经典的例子，对于无锁来说典型的就是 CAS + 循环。那么为什么说这样是无锁的？对于多个并行执行的线程，必然会有一个线程 CAS 成功（当然其他线程都会 CAS 失败，并且会存在饥饿现象，即某个线程可能会一直自旋），所以说这样是无锁的。 常见的误区是认为，无锁算法一定比基于互斥锁的算法更快。实际上，以上术语只是关于系统向前推进的保证，和性能无关。参考资料中有一句话，我不太理解，但还是先放这里： So blocking is at least as fast as lockfree, while it can be faster (when it happened so that the fastest known algorithm is at least partially blocking). 这也是《实战 Java 高并发程序设计》中犯的错误，书中提到以下代码使用 AtomicInteger 比锁有更好的性能。给出的例子是，使用单个 AtomicInteger 变量作为多个线程共享的计数器。简单的代码如下： 123456789101112131415161718192021222324252627public class AtomicIntegerDemo { private static final AtomicInteger i = new AtomicInteger(); public static class AddThread implements Runnable { public void run() { for (int k = 0; k &lt; 10000000; k++) { i.incrementAndGet(); } } } public static void main(String[] args) throws InterruptedException { Thread[] ts = new Thread[10]; for (int k = 0; k &lt; 10; k++) { ts[k] = new Thread(new AddThread()); } long s = System.nanoTime(); for (int k = 0; k &lt; 10; k++) { ts[k].start(); } for (int k = 0; k &lt; 10; k++) { ts[k].join(); } long e = System.nanoTime(); System.out.println((e - s) / 1000000.); }} 在我的机器上测试，以上程序执行时间在 1900 ms 左右。如果使用锁呢？以下程序执行时间只有十几毫秒，性能相差 100 倍。为什么无锁反而更慢呢？因为使用 AtomicInteger 会在循环中多次执行 CAS 操作，而使用锁只会执行很少的加锁/解锁操作。并且，CAS 竞争单个变量，在多处理器的情况下，会频繁地使缓存失效（由于缓存一致性），所以在多处理器上执行反而会更慢，毫无扩展性。 1234567891011121314151617181920212223242526272829public class AtomicIntegerDemo { private static int i = 0; public static class AddThread implements Runnable { public void run() { synchronized (AtomicIntegerDemo.class) { for (int k = 0; k &lt; 10000000; k++) { i++; } } } } public static void main(String[] args) throws InterruptedException { Thread[] ts = new Thread[10]; for (int k = 0; k &lt; 10; k++) { ts[k] = new Thread(new AddThread()); } long s = System.nanoTime(); for (int k = 0; k &lt; 10; k++) { ts[k].start(); } for (int k = 0; k &lt; 10; k++) { ts[k].join(); } long e = System.nanoTime(); System.out.println((e - s) / 1000000.); }} 我们使用 start /affinity 1 java geym.conc.ch4.atomic.AtomicIntegerDemo 命令设置程序的 CPU 亲和性，测试 AtomicInteger 代码在单核上的耗时，得到大约 500 ms 的输出，毕竟使用的是同一个 CPU 缓存，性能更高在意料之中。那么，如果设置使用锁的代码亲和单个 CPU，得到的结果依然是十几毫秒，毕竟加锁就是严格串行的，无法利用多核 CPU 的资源，即使在单核上执行也不会影响多少性能。 那么，如果要使用无锁算法，更好的做法是什么？使用 LongAdder，时间大概在 200 多毫秒，因为该类会将累加操作拆分到多个变量中，然后合并得到累加结果，所以比 AtomicInteger 更快。将单个变量拆分为数组时，需要注意伪共享（False sharing）问题，数组元素类型在源代码中声明为如下形式： 1@jdk.internal.vm.annotation.Contended static final class Cell 使用 @Contended 注解，JVM 会在字段周围进行填充，从而使数组元素位于不同的缓存行中。可以看看这篇文章，对使用/不使用 @Contended 的程序做了基准测试，并且使用 Linux 的 perf 命令进行性能监控，查看两者缓存命中次数的差别，还是非常不错的。","link":"/2025/02/08/Lockfree%20Algorithms/"},{"title":"Java 基础","text":"基本类型 整数类型 整数进行除法运算，商向零取整。 整数被 0 除将会产生一个异常，而浮点数被 0 除将会得到无穷大或 NaN。 思考：进行取模运算时，数值的正负对结果有什么影响？ 取模的定义：(a / b) * b + a % b = a。根据定义算就行，或者记住取模的结果和左边的数（被除数）符号相同，但是结果本质上依赖于除法的舍入规则，所以最好还是按定义算。 12345int a = 3 % 2; // 1int b = -3 % 2; // -1int c = 3 % -2; // 1int d = -3 % -2; // -1System.out.printf(&quot;%d %d %d %d&quot;,a, b, c, d); 浮点类型 思考：double 类型的取值范围和精度是多少？（float 类型同理） double 类型的表示使用 IEEE 754 标准，以 \\(V=(-1)^{s}\\times M\\times 2^{E}\\) 的形式来表示浮点数。其中，\\(s,M,E\\) 分别表示符号、尾数和阶码，分别使用 1、11 和 52 位进行编码。根据标准定义，能够表示的最大/最小规格化值是 \\(\\pm (1+1-2^{-52})\\times2^{(2^{11}-2-1023)}\\approx\\pm 1.79769313486231570e+308\\)。 通常，会说 double 的精度是 15，计算方式为 \\(\\log{2^{-52}}\\) 或者 \\(\\log{2^{-53}}\\)（由于隐含的 \\(1\\)）。但是，这里所说的精度都是仅从尾数层面计算的，而没有涉及阶码（或者部分涉及）。在十进制表示中，由于阶码的影响（以及科学记数法表示），说精度是 15 没有什么意义。而在二进制表示中，直接说精度是 52 比较合理。 思考：为什么浮点运算可能产生误差？是否所有浮点运算都会产生误差？BigDecimal 是如何避免误差的？ 声明：这里所讨论的误差是指运算过程中的舍入误差，不包括由于不能准确表示而产生的舍入误差，例如浮点数 0.1 只是实数 0.1 的近似，也不包括输出产生的舍入误差，例如虽然浮点数能够精确表示 Double.MAX_VALUE，但是输出会得到近似值 1.7976931348623157E308。 （1）发生误差的根本原因是，IEEE 754 标准不能准确表示所有小数（由于范围和精度限制），所以浮点运算只能近似地表示实数运算。标准定义了四种不同的舍入（rounding）方式，默认是将计算结果向偶数舍入（round-to-even）。向偶数舍入是指，将非中间值向最接近的数舍入，将中间值向偶数舍入。 为什么选择向偶数舍入？如果计算一组数的平均数：向上/下舍入会使结果偏大/小；向零舍入在统计数据都是正/负数时，会使结果偏小/大；而向偶数舍入大概率可以避免这种统计偏差，因为此时向上和向下舍入的概率各占一半。 （2）并非所有浮点运算都会产生误差。首先，0.5 + 0.25 不会产生误差。 12345// 0 01111111110 0000000000000000000000000000000000000000000000000000System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.5)));// 0 01111111101 0000000000000000000000000000000000000000000000000000System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.25)));System.out.println(0.5 + 0.25 == 0.75); // true 那么，是否可以猜测，能够被 IEEE 754 标准精确表示的数，浮点运算就不会产生误差？然而不是，只要运算结果超出浮点数能够表示的范围或者精度，那么运算就会产生误差。例如： 12345// 0 01111111111 0000000000000000000000000000000000000000000000000000System.out.println(Long.toBinaryString(Double.doubleToLongBits(1.0)));// 0 10000110100 0000000000000000000000000000000000000000000000000000System.out.println(Long.toBinaryString(Double.doubleToLongBits(9007199254740992.0)));System.out.println(1.0 + 9007199254740992.0); // 9.007199254740992E15 那么，不能被 IEEE 754 标准精确表示的数，浮点运算是否总会产生误差？也不是，例如 0.1 + 0.1 就没有误差，而 0.1 + 0.2 就会有误差，可以使用这个网站查看计算过程。 12345678// 0 01111111011 1001100110011001100110011001100110011001100110011010System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.1)));// 0 01111111100 1001100110011001100110011001100110011001100110011010System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.2)));// 0 01111111101 0011001100110011001100110011001100110011001100110011System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.3)));System.out.println(0.1 + 0.1 == 0.2); // trueSystem.out.println(0.1 + 0.2 == 0.3); // false （3）BigDecimal 表示不可变的任意精度的小数，可以将其视为由任意精度的未缩放值 \\(x\\)，以及 32 位的缩放值 \\(k\\) 组成，最终表示的数就是 \\(x\\times 10^{-k}\\)。如果未缩放值 \\(x\\) 非常大，则会使用 BigInteger 来表示。BigInteger 表示不可变的任意精度的整数，内部使用 int 类型的数组存储整数的补码表示的各个部分。例如，\\(9\\times 10^{9}\\) 会被存储为 \\([2,410065408]\\)，对应补码表示 \\(01000011000011100010001101000000000\\) 的 \\(010\\) 和 \\(00011000011100010001101000000000\\) 两部分。 思考：double 类型不能准确表示的最小正整数是多少？（CSAPP 练习题 2.49） 假设阶码位数足够大，对于有 \\(n\\) 位尾数的浮点数，不能准确表示的最小正整数是 \\(2^{n+1}+1\\)。所以，double 类型不能准确表示的最小正整数是 \\(2^{53}+1=9007199254740993\\)。示例如下，最低位的 1 被舍掉。 1System.out.println(9007199254740993.); // 9.007199254740992E15 需要注意，不能根据上述结论推断出，能够准确表示的最大正整数是 \\(2^{n+1}\\)。反例是，\\(2^{n+1}+2\\) 可以被准确表示，更简单的反例是 \\(2^{n+2}\\)。总的来说，能转换为 \\((-1)^{s}\\times M\\times 2^{E}\\) 形式的数都可以被准确表示。 思考：将三个 int 类型的整数转换为 double 类型（假设为 \\(x,y,z\\)），问 \\((xy)z=x(yz)\\) 是否总是成立？如果不是，反例是什么？（CSAPP 2.89 D） 反例如下，简单来说乘法可能存在舍入误差，不同的结合方式可能会有不同的舍入形式。 123456double x = (1 &lt;&lt; 30) + 1;double y = (1 &lt;&lt; 23) + 1;double z = (1 &lt;&lt; 24) + 1;System.out.println((x * y) * z == x * (y * z)); // falsez = (1 &lt;&lt; 24);System.out.println((x * y) * z == x * (y * z)); // true 可以根据乘法结果能否转换为标准定义的浮点形式，来判断是否存在舍入误差。首先 \\((2^{30}+1)\\times(2^{23}+1)=(1+2^{-23}+2^{-30}+2^{-53})\\times 2^{53}\\)，由于尾数能表示的最小值是 \\(2^{-52}\\)，所以最后 \\(1\\) 位会被舍掉，得到 \\(xy=(1+2^{-23}+2^{-30})\\times 2^{53}\\)。然后 \\((1+2^{-23}+2^{-30})\\times 2^{53}\\times(2^{24}+1)=(1+2^{-23}+2^{-30}+2^{-24}+2^{-47}+2^{-54})\\times 2^{77}\\)，所以最后 \\(2\\) 位会被舍掉，得到 \\((xy)z=(1+2^{-23}+2^{-30}+2^{-24}+2^{-47})\\times 2^{77}=151115754614164973158400\\)。 字符类型 Java 的 char 类型占用两个字节，使用 Unicode 字符集，并且采用 UTF-16 编码方式。 一个 Unicode 字符在 UTF-16 编码中由 1 ~ 2 个代码单元组成，一个 char 值表示 UTF-16 编码中的一个代码单元。 char 类型可以使用转义序列 \\u 表示，例如 \\u0061 表示字符 a。\\u 转义序列与其他转义序列不同，它可以出现在加引号的字符常量或字符串之外。如下所示，第一行代码中的 \\u005B 和 \\u005D 分别是 [ 和 ] 的编码。 1public static void main(String\\u005B\\u005D args) 值得注意的是 Unicode 转义序列会在解析代码前进行处理。例如，下面的代码看上去是没有问题，但是有两个语法错误，因为 \\u000A 会被替换为一个换行符，而 \\user 会被视为非法的 Unicode 转义，因为 \\u 后面没有跟着 4 个十六进制数。 123// \\u000A is a newline// look inside c:\\userString s = &quot;\\u0022+\\u0022&quot;; // 表示一个空串 思考：能否使用 Character.isDigit 方法判断字符是 0~9？能否使用 Character.isLetter 方法判断字符是 a~z 或 A~Z？ 在 Unicode 字符集中，数字和字母的范围更大。例如，\\u0669 表示 Arabic-Indic 数字中的 9，但是不能将其和字符 9 等同，字符 9 的 Unicode 表示为 \\u0039。同理，\\u03c0 表示希腊字母 π，Character.isLetter 也会返回 true。 12345char c = '\\u0669';System.out.println(c); // ٩System.out.println(Character.getNumericValue(c)); // 9System.out.println(Character.isDigit(c)); // trueSystem.out.println(c == '9'); // false 类型转换 思考：自动类型转换是否可能损失精度？什么情况下需要强制类型转换？ （1）自动类型转换可能损失精度，例如之前提到 double 不能准确表示的最小正整数是 9007199254740993。支持的自动类型转换如下（图片参考《Java 核心技术 卷一》），损失精度一般都涉及到浮点数。 （2）简单来说，将大范围类型转换为小范围类型，需要强制类型转换，反之则不需要。或者按照书中的表述，可能损失信息的转换，需要强制类型转换。 思考：以下代码会发生几次类型转换？ 1long x = 1; double y = 1; x += y; 使用 javap -v 反编译字节码，部分输出如下： 12345678910110: lconst_11: lstore_12: dconst_13: dstore_34: lload_15: l2d6: dload_37: dadd8: d2l9: lstore_110: return 可以发现，字面量 1 直接使用 lconst_1 和 dconst_1 获取，不会发生类型转换。而 x += y 相当于 x = (long) (x + y)，所以发生两次类型转换。 类与接口 包 通常使用逆序的因特网域名作为包名，然后对不同工程使用不同的子包，以防止相同名字的类产生冲突。可以使用完全限定名访问其他包中的类，也可以使用 import 语句（位于 package 语句的后面）导入其他包中的类，然后就可以直接使用类名。当导入的包存在命名冲突时，仍然需要使用完全限定名。编译器将 java 文件编译为 class 文件后，class 文件中的字节码使用的都是完全限定名。 使用星号可以导入其他包中的所有类，但是不能使用星号导入多个包，例如 import java.* 或 import java.*.* 是不允许的。嵌套的包之间没有任何关系，每一个包都是独立的类集合。用星号导入某个包中的所有类后，使用其子包仍然需要显示导入。使用 import static 可以导入静态方法/静态字段。 访问修饰符 常规类（非内部类）可以被 public 修饰或者无修饰符，字段和方法可以被所有修饰符修饰或者无修饰符。不同修饰符的访问级别如下（图片源自 Controlling Access to Members of a Class）。 public：被修饰的类/字段/方法可以被任意类访问。特别的，一个源文件只能有一个 public 类，并且文件名必须和该类名相同。 protected：被修饰的字段/方法可以被所有子类和相同包中的类访问。需要注意，在不同包中，子类可以访问的是自身继承的 protected 字段/方法，而不能访问父类对象的（或者其他子类继承的） protected 字段/方法。（避免滥用保护机制，不能通过派生子类来访问父类对象的 protected 字段/方法） no modifier：无修饰符，类/字段/方法可以被相同包中的类访问。 private：被修饰的字段/方法可以被所属的类访问。 思考：private 字段一定不会被其他类访问到吗？（不使用反射） 虽然 private 字段不能通过 obj.field 形式访问，但是如果 private 字段从某个方法暴露出去，则会被其他类访问到。 对象与对象变量 以下代码使用 new 关键字构造 Date 类型的对象，然后将该对象的引用（地址）赋值给 deadline，这个 deadline 就是对象变量（可以看作指针）。 1Date deadline = new Date(); 字段的初始化顺序 静态字段：在类加载时，按照类中出现的顺序执行显式初始化和静态初始化块。 实例字段：首先执行默认初始化，然后按照类中出现的顺序执行显式初始化和初始化块，最后执行构造器代码。 父类字段：父类静态字段的初始化在子类静态字段之前，父类实例字段的初始化在子类实例字段之前。 方法的重载和重写 重载方法是指在相同类中，方法名相同但参数类型不同的方法（返回值类型不重要）。方法名 + 参数类型被称为方法的签名。在进行方法调用时，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个匹配的方法，编译器就会报错。 重写方法是指子类重写（覆盖）父类的方法，重写方法通常会加上 @Override 注解。方法重写遵循以下规则： 重写方法的可见性不能低于原方法。 重写方法的返回值类型可以改为原返回类型的子类型。 重写方法声明的异常不能比原方法声明的异常更通用。 父类的 static 方法不能被子类重写，但是可以被子类中相同签名的 static 方法隐藏。 参数数量可变的形参换成数组类型构成重写。 如果重写方法的返回值类型是原返回类型的子类型，此时编译器会在子类中生成一个桥方法，该桥方法的返回值类型和原方法相同，并且桥方法会调用重写的方法。 思考：方法参数是值传递还是引用传递？ 方法参数总是值传递，即方法得到的是参数的副本。对于基本类型，肯定是值传递。对于引用类型，只要明白对象和对象变量的区别，就可以知道引用类型也是值传递，因为对象变量（指针）的值就是对象的引用（地址）。 继承和多态（向上转型） 在 Java 中，类之间只支持单继承，而接口之间支持多继承。在子类的构造器中，可以使用 super 语句调用父类的构造器，该语句必须是子类构造器的第一条语句。如果子类的构造器没有显式地调用父类的构造器，将自动地调用父类的无参数构造器。如果父类没有无参数构造器，并且在子类的构造器中又没有显式地调用父类的其他构造器，Java 编译器就会报错。 一个对象变量可以指示多种实际类型的现象称为多态，在运行时能够自动地选择适当的方法，称为动态绑定。在将父类强制类型转换成子类之前，应该使用 instanceof 进行检查。否则，如果类型不符，将会产生类型转换异常。 思考：方法调用的原理？解析和分派？字段没有多态性？（详细分析见《深入理解 Java 虚拟机》第 8 章） 所有方法调用的目标方法在 Class 文件中都是一个常量池中的符号引用。在类加载的解析阶段就可以将符号引用解析为直接引用的方法被称为非虚方法，包括静态方法、私有方法、实例构造器、父类方法以及 final 方法。这类方法的调用被称为解析。 虚方法是指除非虚方法以外的方法，需要通过分派确定调用目标。重载方法是静态分派（重载解析）的，依据对象的外观类型（Apparent Type）来选择调用的方法。重写方法是动态分派的，依据对象的运行时类型（Runtime Type）来选择调用的方法。 字段没有多态性，访问字段依据的是当前方法所属的类或者外观类型。 接口 方法默认被 public abstract 修饰，字段默认且必须被 public static final 修饰。 可以使用 default 修饰符声明默认方法（必须是非静态的）。 在 Java 8 中，可以声明静态方法，静态方法只能通过接口调用，不能通过实现类及其对象调用。 在 Java 9 中，可以声明私有方法（用作其他方法的辅助方法），私有方法可以是静态方法或实例方法。 在继承关系中，接口的默认方法有时会和其他类/接口的方法冲突，解决规则如下： 父类与接口冲突，父类优先。 如果父类的方法和接口的默认方法有相同签名，则接口中的默认方法会被忽略。 接口与接口冲突，覆盖方法。 如果两个接口有相同签名的方法，并且其中一个接口的方法是默认方法，则必须覆盖这个方法来解决冲突。 如果想要在实现类中显示调用接口中的默认方法，可以使用 interfaceName.super.methodName(xxx)。 常用关键字 this 每个实例方法都会有一个隐含的参数 this，表示当前对象的引用。在字节码中，实例方法的 args_size 至少是 1，就是因为 this 作为隐含的参数。 可以使用 this 调用当前对象的构造器、字段/方法。特别的，可以在内部类中使用 OuterClass.this 表示外部类的引用；在 lambda 表达式中，this 表示创建这个表达式的对象的引用（类似事实最终变量）。 super 调用父类的构造器/方法，获取父类的字段。 调用接口的默认方法，interfaceName.super.xxx()。 与 this 不同，super 不是对象的引用，不能将 super 赋给另一个对象变量。 final 修饰类时，类不能被继承。 修饰方法时，方法不能被重写。 修饰字段/变量时，字段/变量必须被初始化。 static 可以修饰字段/方法/初始化块/内部类，它们在类加载时被创建。当 static 修饰方法时，该方法不能访问实例字段、不能使用 this 和 super 关键字。import static 表示静态导入。 abstract 可以使用 abstract 关键字来声明抽象类/方法。abstract 不能修饰私有/静态方法，以及 final 方法/类。包含抽象方法的类必须被声明为抽象类，但是抽象类可以不包含抽象方法。 常用类与接口 Object Object 类是 Java 中所有类的父类，可以使用 Object 类型的变量引用任何类型的对象。在 Java 中，只有基本类型不是对象，基本类型由于自动装箱可以赋值给 Object 类型的变量。数组类型没有重写 equals、hashcode 和 toString 方法，通常会借助 Arrays 工具类来执行这些操作。 equals 方法 Object 类中的 equals 方法比较两个对象的引用是否相等，源码如下： 123public boolean equals(Object obj) { return (this == obj);} 如果要比较两个对象的内容是否相等，需要覆盖 equals 方法，通用的实现如下。 1234567891011121314151617181920212223242526272829303132class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } @Override public boolean equals(Object otherObject) { // 1.判断对象的引用是否相等 if(this == otherObject) return true; // 2.判断 otherObject 是否为 null if(otherObject == null) return false; // 3.判断 this 与 otherObject 的类型是否相同 if(getClass() != otherObject.getClass()) return false; // 4.将 otherObject 强制类型转换为相应的类型 Employee other = (Employee) otherObject; // 5.使用 == 比较基本类型 // 使用 Object.equals 比较除数组之外的引用类型 // 使用 Arrays.equals 比较数组类型 // 不使用 name.equals(other.name) 比较是为了避免空指针异常 // 如果当前类的直接父类不是 Object，还需要调用 super.equals(other) 比较父类中的字段 return Objects.equals(name, other.name) &amp;&amp; salary == other.salary; }} hashCode 方法 Object 类中的 hashCode 方法是本地方法，它根据对象的存储地址计算得出散列码。如果重新定义 equals 方法，那么就要为可能插入散列表的对象重新定义 hashCode 方法。且 equals 与 hashCode 的定义必须相容：如果 x.equals(y) 返回 true，那么 x.hashCode() 就必须与 y.hashCode() 相等。 clone 方法 Object 类中的 clone 方法为 protected 修饰的本地方法，执行的是浅拷贝。如果要使用 clone 方法，需要在类上实现 Cloneable 标记接口，同时指定 public 修饰符。 String String 类对象是不可变的，我们只能改变 String 类型的对象变量的值（指针的指向），而不能改变对象本身。 字符串字面量是共享的，存储在常量池中。拼接两个非 final 的 String 对象变量以及执行 substring 操作得到的字符串不是共享的（存储在堆中）。拼接两个 final 的 String 对象变量，编译器会执行常量折叠优化，直接从常量池中获取字符串对象。 思考：为什么说 String 类对象是不可变的？ 因为 String 类被 final 修饰不可继承，String 类的 value 字段被 private final 修饰且没有逸出，也没有提供修改该字段的方法（不论方法被什么访问修饰符修饰），String 类对象的 this 引用不会在构造器中逸出。 思考：字符串拼接会有什么性能问题？编译器是如何优化字符串拼接 + 操作的？ 如果不优化，每次拼接都会创建一个新的 String 对象。在拼接多次的场景下，拼接产生的中间对象在拼接之后就不会使用，这会浪费创建对象的时间和空间。例如，在循环中拼接： 1234String s = &quot;7&quot;;for (int i = 0; i &lt; 10; i++) { s += s;} 如果优化，很容想到使用 StringBuilder 类，在 Java 8 中编译器也是这么做的。但是，不推荐在循环中使用 + 拼接，因为编译器会在循环中创建 StringBuilder 对象。而在 Java 9 之后编译器会使用 invokedynamic 指令，优点是可以动态地选择拼接策略。（或许可以看下这篇文章） 包装类 所有的基本类型都有一个对应的包装类（不可变的）。在使用包装类时，可以直接当作基本类型操作，编译器在编译时会自动地插入装箱和拆箱指令。例如： 1Integer x = 1, y = 2, z = x + y; 12345678910111213140: iconst_11: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;4: astore_15: iconst_26: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;9: astore_210: aload_111: invokevirtual #3 // Method java/lang/Integer.intValue:()I14: aload_215: invokevirtual #3 // Method java/lang/Integer.intValue:()I18: iadd19: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;22: astore_323: return 可以看到，编译器会调用 Integer.valueOf 装箱，调用 obj.intValue() 拆箱。似乎对包装类进行运算总是会拆箱转换为基本类型，然后将运算结果装箱，所以效率不是很高。为了提高性能，包装类会在静态初始化块中创建常用对象缓存池，缓存对象的范围如下：Boolean（true 和 false）、Byte | Short | Int | Long（-128 ~ 127）、Character（0 ~ 127），Float 和 Long 类不会缓存对象。 比较器 Comparable 接口 实现 Comparable 接口的类可以进行自然排序，该接口在 java.lang 包下。所谓自然排序，就是指排序时，默认会使用 Comparable 接口的 compareTo 方法排序，而定制排序需要在排序时需要显示传入实现 Comparator 接口的对象。 123public interface Comparable&lt;T&gt; { public int compareTo(T o);} 使用 compareTo 方法较当前对象与指定对象的大小关系，当前对象小于/等于/大于指定对象时，返回负整数/零/正整数。注意，返回值是 int 类型的整数。 文档建议 CompareTo 方法应当与 equals 方法兼容，即当 x.equals(y) == true 时，x.compareTo(y) == 0。特别的，BigDecimal 类不遵循该建议。 1234BigDecimal x = new BigDecimal(&quot;1.0&quot;);BigDecimal y = new BigDecimal(&quot;1.00&quot;);System.out.println(x.equals(y)); // falseSystem.out.println(x.compareTo(y)); // 0 Comparator 接口 如果类的自然排序与需求不匹配，可以定义Comparator 接口的实现类，然后将类对象作为参数传入排序方法中，执行定制排序。Comparator 接口在 java.util 包下。 123public interface Comparator&lt;T&gt; { int compare(T o1, T o2);} 枚举类 可以使用 enum 关键字创建枚举类，枚举类的构造器默认且必须是私有的，所以在比较时可以直接使用 == 运算符。枚举类实例的定义必须在字段/方法的定义之前。枚举类默认是 Enum 类的子类，所以枚举类型不能显示继承其他类。源代码和反编译得到的字节码如下所示。 12345678910111213enum Size { SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;); private String abbreviation; private Size(String abbreviation) { this.abbreviation = abbreviation; } public String getAbbreviation() { return abbreviation; }} 1234567891011final class Size extends java.lang.Enum&lt;Size&gt; { public static final Size SMALL; public static final Size MEDIUM; public static final Size LARGE; public static final Size EXTRA_LARGE; public java.lang.String abbreviation; public static Size[] values(); public static Size valueOf(java.lang.String); public java.lang.String getAbbreviation(); static {};} 异常 异常层次结构如下，异常被分为检查型异常和非检查型异常。非检查型异常：派生于 Error 类或 RuntimeException 类的所有异常。检查型异常：除非检查型异常以外的所有异常。 一个方法必须声明（throws）或捕获（catch）所有可能抛出的检查型异常，而非检查型异常要么在控制之外（Error），要么从一开始就应该避免（RuntimeException），所以不应该声明。 处理异常的一般经验是，捕获知道如何处理的异常，而继续传播（throw）不知道怎样处理的异常。 try-catch-finally 使用规则： 当 catch 捕获多个异常时，异常变量隐含为 final 变量。 可以在 catch 中使用 initCause 方法将原异常设置为新异常的原因，当捕获到新异常时，可以使用 getCause 方法获取原异常。 不论是否有异常被捕获，finally 中的代码都会在方法返回之前执行执行。 finally 用于清理资源，不要把改变控制流的语句（return，throw， break，continue）放在 finally 中。如果在 finally 中包含 return 语句，则 finally 中的 return 会在 try/catch 中的 return 或者 throw 之前执行，有可能会丢失异常。 思考：以下代码在未发生异常和发生异常情况下的返回值分别是多少？（示例源自《深入理解 Java 虚拟机》第 6 章） 123456789101112public int inc() { int x; try { x = 1; return x; } catch (Exception e) { x = 2; return x; } finally { x = 3; }} 如果未发生异常，由于 try 在 finally 之前执行，所以返回值已经确定是 1。如果在 try 中发生 Exception 及其子类的异常，由于 catch 也在 finally 之前执行，所以返回值已经确定是 2。如果在 try 中发生其他异常，或者在 catch/finally 中发生任意异常，则方法非正常退出，没有返回值。 try-with-resources 在 Java 7 中，如果资源实现了 AutoCloseable 接口，就可以使用 try-with-resources 语句处理资源。当 try 块退出时，会自动调用资源的 close 方法关闭资源。 使用规则： catch 和 finally 在资源关闭之后执行。 在 Java 9 中，允许在 try 首部中使用之前声明的 final 或 effective final 变量。 如果 try 和 close 都抛出异常，则 close 方法抛出的异常会被抑制，并由 addSuppressed 方法添加到 try 的抛出的异常对象中。如果想查看被抑制的异常，可以使用 getSuppressed 方法获取被抑制的异常数组。 泛型 基本概念 使用泛型的目的是什么？如果不使用泛型，可以向集合类中添加任何类型的对象，并且读取时需要类型判断和强制类型转换。所以，使用泛型的目的是允许编译器进行类型检查，以及避免频繁地强制类型转换。 定义泛型类 class C&lt;T&gt;，定义泛型方法 public static &lt;T&gt; void m(T x)。 Java 库使用参数 E 表示集合的元素类型，K 和 V 分别表示表的键和值的类型，T（或者 U 和 S）表示任意类型。 可以使用 extends 关键字对类型参数进行限定 &lt;T extends BoundingType&gt;，表示 T 是限定类型（bounding type）的子类型（subtype），T 和限定类型可以是类或接口。 一个类型参数或通配符可以有多个限定，限定类型用 &amp; 分隔，而类型参数用逗号分隔。如果有一个类作为限定，它必须是限定列表中的第一个限定。 类型擦除 在虚拟机中没有泛型类型，所有对象都属于普通类。无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，这个原始类型的名字就是去掉类型参数后的泛型类型名。类型参数会在编译时被擦除，替换为第一个限定类型，对于无限定的类型参数则替换为 Object 类型。 需要注意，如果将限定 &lt;T extends Comparable &amp; Serializable&gt; 换为 &lt;T extends Serializable &amp; Comparable&gt;，会用 Serializable 替换 T，而这会导致在调用 compareTo 方法时进行额外的强制类型转换。为了提高效率，应该将标记接口放在限定列表的末尾。 （1）当调用的泛型方法的返回类型被擦除，编译器会插入强制类型转换（checkcast 指令）。 （2）编译器会生成桥方法，来避免类型擦除和多态之间的冲突。假设泛型类 Class A&lt;T&gt; 有个方法 public void m(T x)，那么它的子类在继承时指定 Class B extends A&lt;Integer&gt;，对应的重写方法是 public void m(Integer x)。类型擦除之后，两个方法的签名不同不构成重写，所以编译器会在子类中生成 public void m(Object x) 方法作为代理（构成重写），从而解决冲突。 泛型的限制和继承规则 使用限制：Restrictions on Generics。 继承规则：无论 S 与 T 有什么关系，通常 Pair&lt;S&gt; 与 Pair&lt;T&gt; 都没有任何关系（偏序）。 通配符的限定 子类限定 &lt;? extends Type&gt;，将泛型对象的类型参数限制为 Type 类型或其子类型。此时，如果类型参数作为方法参数，只能传入 null，因为不知道该传入具体哪个子类。如果类型参数作为返回值，只能将返回值赋值给 Type 类型或其父类型的变量（向上转型）。 父类限定 &lt;? super Type&gt;，将泛型对象的类型参数限制为 Type 类型或其父类型。此时，如果类型参数作为方法参数，只能传入 Type 类型或其子类型的变量（向上转型）。如果类型参数作为返回值，只能将返回值赋值给 Object 类型的变量，因为只有 Object 必定是该类型参数的父类。 无限定 &lt;?&gt;，不限制泛型对象的类型参数。此时，如果类型参数作为方法参数，只能传入 null，因为不知道该传入具体哪个类。如果类型参数作为返回值，只能将返回值赋值给 Object 类型的变量，因为只有 Object 必定是该类型参数的父类。 PECS（Producer Extends，Consumer Super）原则：读取数据使用子类限定，写入数据使用父类限定。 自限定的类型 class SelfBound&lt;T extends SelfBound&lt;T&gt;&gt;，SelfBound 的类型参数 T 限定为 SelfBound&lt;T&gt; 的子类。示例如下： 123class A extends SelfBound&lt;A&gt; {...}class B extends SelfBound&lt;A&gt; {...}class C extends SelfBound&lt;B&gt; {...} // Error 以上代码中，A 继承 SelfBound&lt;A&gt; ，使得 A 可以作为 SelfBound 的类型参数。而 B 没有继承 SelfBound&lt;B&gt;，所以不能将 B 作为 SelfBound 的类型参数。使用自限定的类型，目的是保证 SelfBound 类的类型参数为当前定义的类（例如 A）。虽然 B 继承的 SelfBound 类的类型参数是 A 而不是当前定义的 B，但是一般情况下并不会这样使用。 如果看不懂，可以考虑没有自限定类型的情况： 123class SelfBound&lt;T&gt; {...}class A extends SelfBound&lt;Any-Type&gt; {...} 如果 SelfBound 没有自限定，A 类在继承 SelfBound 时，类型参数可以是任意类型。 反射 反射是 Java 中的一项功能，允许程序在运行时分析类，并且操纵其内部属性。（Using Java Reflection） 一个 Class 对象表示一个类型，包括类类型（包括数组类型）、接口类型、基本类型和 void。每个类型的 Class 对象是唯一的，所以可以直接使用 == 运算符比较。 获取 Class 对象的方式如下：使用 obj.getClass() 方法获取对象运行时类型的 Class 对象，使用 Class.forName(xxx) 方法获取指定类的 Class 对象。如果 T 是任意的 Java 类型或 void 关键字，T.class 将代表对应的 Class 对象。特别的，使用 .class 获取 Class 对象的引用时，不会初始化该 Class 对象表示的类，而前两种方式会进行初始化。（类加载的过程：加载、链接和初始化） 注解 可以使用注解（也被称为元数据）在代码中提供额外的信息，然后这些信息可以在编译时解析或运行时利用反射获取。 定义注解 注解的定义类似接口，区别在于需要再 interface 关键字之前加上 @ 符号。声明元素需要在元素名之后加上 ()，可以使用 default 关键字为元素指定默认值。注解元素的类型限制：基本类型、String、Class、枚举类型、注解类型，以及由这些类型组成的一维数组。 123@interface Demo { int num() default 1;} 所有的注解都隐式的继承自 java.lang.annotation.Annotation 接口。如果反编译上述注解的字节码： 123interface Demo extends java.lang.annotation.Annotation { public abstract int num();} 可以发现，注解就是接口，默认继承自 Annotation 接口。而且在其中定义的元素实际上是接口中的抽象方法，只是可以使用 default 指定默认值。 使用注解 在定义注解时，如果没有为元素指定默认值，则在使用时需要显示的赋值；否则，可以不显示赋值，自动使用默认值。注解元素的值必须是编译期常量，并且不能设置为 null。如果元素值是一个数组，那么要将它的值用 {} 括起来。 1@AnnotationName(elementName1 = value1, elementName2 = value2, ...) 标记注解：如果注解没有任何元素或者所有元素都提供了默认值，则在使用注解时可以不需要括号。 单值注解：如果注解只有一个名为 value 的元素，则在指定该元素的值时，可以忽略元素名以及赋值运算符。 内置注解 元注解 @Target：指定注解适用的上下文。@Retention：指示注解的保留时长，默认的保留策略为 CLASS。SOURCE 注解将被编译器丢弃。CLASS 注解将由编译器记录在类文件中，但会被 VM 丢弃。RUNTIME 注解将在运行时由 VM 保留，可以使用反射机制读取注解信息。 @Documented：指示将注解包含在 Java 文档中。@Inherited：允许子类继承父类中的注解，当被修饰的注解作用于类时，该元注解才有效。@repeatable：指示注解可以在同一上下文重复使用。 字段和方法上的注解只要没有被覆盖，就会被继承（前提是字段和方法会被继承）。 接口上的注解永远都不会被继承，类上的注解只有在使用 @Inherited 时才会被继承。 标准注解 @Overried：指示当前方法将覆盖父类中的方法或实现接口中的方法。@Deprecated：指示目标被弃用。@SuppressWarnings：抑制目标中给定类型的编译器警告。@SafeVarargs：指示将会安全地操作可变参数。@FunctionalInterface：指示接口为函数式接口。 I/O 流 字节流 所有字节流都继承自 InputStream/OutputStream 抽象类，FileInputStream/FileOutputStream 是基本的字节流。FilterInputStream/FilterOutputStream 内部使用其他字节流对象作为数据来源，没有提供额外的功能，但是其子类会通过重写方法来提供额外的功能。 BufferedInputStream/BufferedOutputStream 对流使用缓冲区技术，每次向流读取/写入时，不必每次都进行实际的物理读取/写入操作。DataInputStream/DataOutputStream 允许从流读取/写入基本数据类型。PrintStream 支持格式化输出。 ByteArrayInputStream/ByteArrayOutputStream 对字节数组进行读取/写入，由于没有使用到文件，所以不需要对该流执行关闭操作。ObjectInputStream/ObjectOutputStream 见序列化。 字符流 所有字符流都继承自 Reader/Writer 抽象类，字符流内部都是基于字节流的。在使用字符流时，注意保证字符的编码和解码方式的一致性。InputStreamReader/OutputStreamWriter 是字节流和字符流之间的桥梁。FileReader/FileWriter 内部使用 FileInputStream，是使用 InputStreamReader/OutputStreamWriter 的快捷方式。 BufferedReader/BufferedWriter 对流使用缓冲区技术，每次向流读取/写入时，不必每次都进行实际的物理读取/写入操作。PrintWriter 是使用 BufferedWriter 的快捷方式，并且支持格式化输出。 标准 I/O 和 NIO System.in 的类型是 InputStream，System.out 和 System.err 的类型是 PrintStream。可以使用 System 中的 setIn、setOut 和 setErr，对标准 I/O 进行重定向。 对象序列化 序列化就是将对象转换为字节序列的形式，在通过网络传输对象或者将对象存储到磁盘时会进行序列化操作，反序列化同理。需要实现 Serializable 接口以支持对象序列化，可以使用 transient 关键字关闭某个字段的序列化。 在序列化时，会生成对象的序列号和类的序列化版本号（serialVersionUID）。如果将一个对象序列化两次，那么反序列化将得到两个相同的对象。生成的序列化版本号是类的指纹，使用 SHA 计算结果的前 8 个字节表示。在反序列化时，会比较存储的指纹和当前指纹，如果不匹配就说明对象所属类的定义在序列化该对象后修改过，从而会产生 InvalidClassException 异常。此时，如果想要反序列化成功，就需要在类的定义中添加旧版本类的指纹，以此表明它对旧版本兼容。 使用 ObjectOutputStream 的 writeObject 方法将对象序列化，ObjectInputStream 的 readObject 方法将对象反序列化。反序列化时，要保证序列化对象所属的类在类路径中，否则在类型转换时会抛出 ClassNotFoundException 异常。 可以实现 Externalizable 接口对序列化的过程进行控制，该接口继承自 Serializable 接口。 Serializable：将对象完全序列化，并且反序列化时不会调用构造器。 Externalizable：序列化时调用 writeExternal 方法序列化字段，反序列化时首先调用公共的无参构造器，然后调用 readExternal 方法反序列化字段。 如果不想实现 Externalizable 接口，还可以在类中定义 writeObject/readObject 方法，方法会在序列化/反序列化时自动调用。方法需要按照如下格式定义： 123private void writeObject(ObjectOutputStream stream) throws IOException {...}private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {...} 如果想在 writeObject/readObject 方法中使用默认的序列化/反序列化机制，可以在其中调用 ObjectOutputStream/ObjectInputStream 的 defaultWriteObject/defaultReadObject 方法。 思考：序列化单例有什么问题？如何解决？ 如果将单例序列化，在反序列化时将得到不同的对象。解决方案是，在 readResolve 方法中返回单例对象，该方法会在反序列化时被调用。 123protected Object readResolve() { return xxx;} 容器 集合类会以内部类的形式实现 Iterator 接口。Collection 接口继承自 Iterable 接口，所以可以使用 Iterable 接口中的 iterator 方法获取 Iterator 对象来遍历集合。Map 接口的 entrySet 方法会返回 Collection 类型的对象，所以也支持迭代器遍历。 Collection List List 表示有序集合，可以存储重复的元素。 ArrayList ArrayList 是支持动态扩容的数组，它的底层是一个 Object 类型的数组，所以可以存放任何类型的元素。 虽然底层数组的默认初始容量是 10，但是如果在创建时没有指定容量，并不会立即创建容量为 10 的数组，而是将创建数组的操作延迟到添加元素时。 1234private static final Object[] EMPTY_ELEMENTDATA = {};public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;} 使用 transient 关键字修饰数组字段，表示不自动序列化，而是在 writeObject 方法中自定义序列化方式。因为数组元素数量小于等于数组容量，只序列化有效元素可以减少空间占用。 1transient Object[] elementData; LinkedList LinkedList 的底层是一个双向链表，实现自 List 和 Deque 接口。 使用 get 方法获取指定索引的值时，会根据索引是否小于链表长度的一半，来决定正序或倒序遍历。如果使用默认序列化，则会丢失头节点和尾节点之间的所有节点，所以使用 transient 修饰相关字段，然后手动序列化链表元素。 123transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; Set Set 表示没有重复元素的集合。HashSet 的底层是 HashMap，只是所有的 value 都是相同的单例对象。LinkedHashSet 的底层是 LinkedHashMap，TreeSet 的底层是 TreeMap。 12private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object(); Map HashMap HashMap 的底层是数组 + 链表/红黑树，不能保证迭代的顺序，遍历的时间与哈希表的容量和元素数量成正比。 默认容量是 16，负载因子是 0.75。在构造器中，不会创建底层数组，只会将负载因子和阈值初始化，数组的创建延迟到添加元素时。在源代码中，threshold 不只是存储阈值，在构造器中还会临时存储容量，该值会在初始扩容时使用。 当桶中的节点数量大于等于 8 时，如果哈希表的容量小于 64，会执行扩容操作，否则会将链表转为红黑树（树化）。当桶中的节点数量小于等于 6 时，会将红黑树转为链表（取消树化）。 123static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; 计算哈希值时会将高位和低位异或，因为哈希表的容量总是 2 的幂，计算索引值时高位变化不会引起索引变化，从而会产生严重的哈希冲突。 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 当元素数量大于扩容阈值时（容量和负载因子的乘积），会将容量扩容为原来的 2 倍。由于容量是 2 倍的关系，所以元素的索引值要么不变，要么加上旧容量的大小，取决于 e.hash &amp; oldCap 的值。 LinkedHashMap LinkedHashMap 具有确定的迭代顺序，默认是按插入顺序遍历。底层是哈希表 + 双向链表，遍历的时间只与元素数量成正比（通过双向链表遍历）。双向链表使用尾插法，头节点表示最早插入/访问的节点，尾节点表示最近插入/访问的节点。 1234// 双向链表的元素排列方式// false 按插入顺序排列（默认）// true 按访问顺序排列（实现 LRU 算法）final boolean accessOrder; LinkedHashMap 添加元素的方法继承自 HashMap，但是以下方法被重写，用于实现双向链表的排列和淘汰策略。 1234567// 如果是按访问顺序排列，则将访问的结点移动到链表尾部void afterNodeAccess(Node&lt;K,V&gt; e)// 在插入元素后调用，内部调用 removeEldestEntry 方法，用于实现淘汰策略// removeEldestEntry 方法默认返回 false，即不会进行淘汰// 可以重写该方法结合 accessOrder = true，来实现 LRU 淘汰策略void afterNodeInsertion(boolean evict)","link":"/2023/01/01/Java%20%E5%9F%BA%E7%A1%80/"},{"title":"Java 并发 &amp; 虚拟机","text":"基本概念 并发和并行：关于并发和并行的含义其实存在一些争议，但无非是定义不同。比较常见的说法，并发是指多个任务在单核 CPU 上分时执行，并行是指多个任务在多核 CPU 上同时执行。另一种说法，并发是指多个任务的执行在时间上重叠，在单核 CPU 上表现为分时执行，在多核 CPU 上表现为并行执行，并行是并发的子集。（当然还有其他说法，挺无聊的）另外，在单线程中也可以做到并发，例如 I/O 多路复用。 同步和异步：同步方法在方法执行完成之后才返回，异步方法可以在方法执行完成之前返回。异步方法只意味着非阻塞调用，并不一定是在另一个线程中执行。例如 C# 的 async 方法是在当前线程中执行，在遇到 await 时会将方法的剩余部分注册为延续（continuation），然后将控制权返回到方法的调用者，同时返回一个 Task 类型的对象，此时方法的调用者可以执行其他不依赖于方法结果的操作，从而避免阻塞。在 await 任务完成之后，延续会在线程池线程或者原始线程中执行。（参考 Task asynchronous programming model） 以上关于单线程中并发和异步的示例，在基于事件的系统中都有体现。事件循环在单个线程中接收和处理事件，通常使用 I/O 多路复用接收事件，使用异步 I/O 实现非阻塞。可以使用轮询判断异步 I/O 是否完成，更好的做法是使用 UNIX 信号在异步 I/O 完成时通知应用程序。如果要在异步 I/O 完成之后执行某些操作，通常会使用一种称为延续的数据结构，记录完成该事件需要的信息。（推荐阅读《OSTEP》第 33 章 基于事件的并发） 思考：什么是死锁？产生条件？如何预防（Prevention）、避免（Avoidance）和检测死锁？ 死锁简单来说就是 ABBA 问题，即持有资源 A 的线程要获取资源 B，而持有资源 B 的线程也要获取资源 A。产生死锁的条件：互斥，持有并等待，非抢占，循环等待。死锁避免要求知道全局信息，根据信息来判断分配资源是否会发生死锁，例如银行家算法。死锁检测可以通过构建等待图，然后判断图中是否有环来实现。 死锁预防：① 消除循环等待：使用一致的加锁顺序（全序/偏序），例如根据锁的地址获取锁，或者根据对象的哈希值获取锁。② 消除持有并等待：在执行操作之前原子地获取所有锁，但是很难做到且会有性能问题。③ 消除非抢占：使用 tryLock + unlock 的方式获取锁，但是会有活锁问题（可以通过随机化等待时间来避免），以及需要回滚中间执行的操作。④ 消除互斥：使用非阻塞算法（利用 CAS 原子指令）。 并发包 同步器 AbstractQueuedSynchronizer（AQS）为实现依赖 FIFO 等待队列（以链表形式实现）的同步器提供框架。AQS 使用 int 类型的整数表示状态，使用获取（acquire）和释放（release）操作修改状态。状态以及获取和释放的含义由同步器决定：在 ReentrantLock 中表示重入次数；在 Semaphore 中表示剩余的许可数量；在 ReentrantReadWriteLock 中，高 16 位表示读锁计数，低 16 位表示写锁计数。AQS 内部使用 LockSupport 实现线程的阻塞和唤醒，内部使用类似信号量的许可机制（最多一个许可），即使在 unpark 之后调用 park 也不会导致阻塞。 相比 synchronized 关键字，ReentrantLock 提供可中断锁、定时锁和公平锁，以及支持等待多个条件，但是需要在 finally 中显示地执行解锁操作。公平锁和非公平锁的区别是能否插队，当有其他线程在队列中等待时，公平锁总是会将当前加锁线程入队，而非公平锁会尝试加锁，从而避免更多的上下文切换。 Semaphore 提供指定数量的许可，允许多个线程访问资源。ReentrantReadWriteLock 提供可重入的读写锁，允许在持有写锁的情况下获取读锁，从而实现锁降级（写锁降级为读锁），不支持锁升级（读锁升级为写锁），适用于读多写少的场景。不支持锁升级是因为，如果两个读线程同时进行升级（由于读锁是共享锁），则会发生死锁。 CountDownLatch 允许一个或多个线程等待，直到一组操作完成，计数不能被重置。CyclicBarrier 允许一组线程等待彼此到达屏障，当所有线程到达屏障之后，会执行设置的 barrierAction 动作，然后唤醒所有线程，重置计数器。以上提到的同步器只有 CyclicBarrier 基于 ReentrantLock 实现，其他都是直接基于 AQS 实现的。 线程池 创建线程的方式有三种：继承 Thread 类 + 重写 run 方法；实现 Runnable 接口；实现 Callable 接口，然后构造 FutureTask 对象，FutureTask 实现自 RunnableFuture 接口，所以也可以看作 Runnable 对象。 使用线程池的目的是复用线程，避免创建/销毁线程的开销，以及控制线程的数量。过多的线程会占用大量内存，而且不一定能提高系统的性能，因为 CPU 核心数有限（对于 CPU 密集型负载来说）。Executors 工具类提供创建线程池的工厂方法，可以创建固定/动态大小（ThreadPoolExecutor）、支持计划任务（ScheduledThreadPoolExecutor）、支持工作窃取和分解任务（ForkJoinPool）的线程池。 线程池通常会使用队列存放任务（Runnable 类型），队列可以分为同步队列、有界队列和无界队列。当线程池的线程数量达到设置的最大值，且队列已满（不是无界队列），则会执行拒绝策略。JDK 内置的拒绝策略有：抛出异常、丢弃当前任务、丢弃最早的任务、在当前线程执行该任务。 当线程池的线程数量超过 corePoolSize 时，空闲线程在超时之后被销毁。如果使用 ExecutorService 的 submit 提交任务，需要注意异常会被捕获到返回的 Future 对象中。如果没有任务，在 corePoolSize 范围内的线程会在获取任务时被阻塞队列阻塞。如果要终止线程，可以调用 shutdown 方法，然后可以调用 awaitTermination 等待。 并发容器 可以使用 Collections.synchronizedxxx() 方法获取线程安全的容器，但是获取的容器只是简单地对所有方法使用 synchronized 关键字来实现线程安全。CopyOnWriteArrayList 读操作不需要加锁，写操作加锁且不会修改原数组，而是执行写时复制（COW）。ConcurrentLinkedQueue 是非阻塞的无界队列，没有使用锁而是只用 CAS 实现线程安全。 ArrayBlockingQueue 是有界阻塞队列，使用单个的 ReentrantLock 实现线程安全，使用两个 Condition（notEmpty 和 notFull）实现阻塞等待，不过也可以调用非阻塞的方法（在队列满/空时直接返回 false/null）。LinkedBlockingQueue 是无界阻塞队列，使用两个 ReentrantLock（putLock 和 takeLock）实现线程安全，同样使用两个 Condition 实现阻塞等待。 可以使用 Unsafe 或者 VarHandle 实现 CAS 操作。AtomicInteger 使用 CAS 保证原子性，AtomicStampedReference 使用版本号解决 CAS 的 ABA 问题，AtomicIntegerArray 提供原子修改数组的方法，AtomicIntegerFieldUpdater 使用反射和 Unsafe 提供对 volatile 字段原子更新的方法。 如果要设计线程安全的哈希表，最简单的方式是使用 synchronized 关键字修饰所有方法，但是并发性很差。首先，可以想到减少锁的粒度，将单个独占锁分解为每个桶一个锁（结合 CAS 提高性能）。但是，计数操作会修改共享变量，如果使用独占锁将成为性能瓶颈。如果使用原子变量进行计数，在高并发下性能不会更好，由于缓存失效以及频繁的重试。解决方案依然是减少锁的粒度，可以使用类似 LongAdder 的做法。接下来可以思考扩容问题，多个线程辅助扩容可以加快速度，基本上 ConcurrentHashMap 就是这样设计的。 锁优化 思考：减少锁竞争的方式有哪些？ 减小锁的范围，减小锁的粒度，读写锁/读写分离，线程私有。 ThreadLocal 的构造函数是空的，所以创建的对象没有和线程绑定，只有当调用 get/set 方法之后才会绑定。实际上，Thread 类有一个 ThreadLocalMap 类型的实例字段，set 方法会获取当前 ThreadLocal 对象的哈希值，使用 WeakReference 类型的数组存储 key/value（类似 WeakHashMap），key 就是 ThreadLocal 对象，value 就是 set 的参数。（该哈希表使用的是开放寻址法处理冲突） 通常所说的 ThreadLocal 存在内存泄露问题是指，当不再使用设置的 value 时（假设是很大的对象），如果存在该 ThreadLocal 的强引用，或者即使该 ThreadLocal 对象已经被回收，但是之后没有对 ThreadLocalMap 做操作，依然无法回收 value 对象。因为 ThreadLocalMap 的 Entry 对 value 有强引用，而只有在执行下一次 set/remove 操作时，该 Entry 以及 Entry 的 value 才会变为不可达的，所以最好在不使用时显式地执行 remove 操作。 思考：HotSpot 虚拟机对 synchronized 的优化有哪些？（详见《深入理解 Java 虚拟机》第 13 章） 自适应的自旋：动态调整自旋的时间，尽量避免重量级锁（互斥锁）的上下文切换开销，以及避免自旋过久占用 CPU 资源的开销。 锁消除：虚拟机在即时编译时，对不可能发生竞争的锁进行消除（依赖逃逸分析）。 锁粗化：如果连续地对相同对象加锁再解锁，会导致不必要的性能损耗，此时虚拟机会加大锁的范围（合并锁）。 轻量级锁：当目标对象没有被锁定，虚拟机会使用 CAS 获取对象的轻量级锁，目的是避免重量级锁的上下文切换开销。如果目标对象被轻量级锁定，那么自旋一段时间，超时之后升级为重量级锁。或者，如果有两个线程在等待获取轻量级锁，那么将锁升级为重量级锁。（轻量级锁本质上是复制对象的 Mark Word 到当前线程的栈帧中，然后使用 CAS 修改该对象的 Mark Word） 偏向锁：对象锁会偏向第一个加锁的线程，目的是减少无竞争情况下轻量级锁的 CAS 开销。即如果线程 A 对某个对象加锁（使用 CAS 修改 Mark Word），且该对象是第一次被加锁，那么线程 A 之后再次获取该对象锁时就不需要执行实际的加锁操作。但是，只要有其他线程尝试获取该对象的锁，那么偏向锁就会被撤销，变为未锁定或者轻量级锁定状态。（简单来说是这样，当然还有重偏向，以及如果调用过未重写的 Object::hashCode() 方法就不能偏向，之类的东西） 思考：轻量级锁和偏向锁优化什么情况下可以提升性能？什么情况下会降低性能？ 轻量级锁和偏向锁都假设锁竞争发生的概率很小，如果真的发生（激烈的）锁竞争，那么轻量级锁和偏向锁很快就会升级为重量级锁，“优化”反而会额外增加轻量级锁 CAS 操作的开销以及撤销偏向的开销。 在 Java 15 中，偏向锁已弃用，详见 JEP 374: Deprecate and Disable Biased Locking。主要原因是偏向锁的实现代码复杂且具有侵入性，妨碍 HotSpot 虚拟机中同步系统设计的更改，以及在当前环境下偏向锁的适用范围有限。 内存区域 简单来说：程序计数器存储当前执行的字节码指令的地址；栈存储方法级别的数据，方法调用会创建栈帧，存储局部变量、返回地址等数据，有虚拟机栈和本地方法栈两种；堆存储对象数据；方法区也被称为类区，存储类级别的数据，包括类的字节码、静态变量和常量（在运行时常量池中）等数据。 思考：HotSpot 虚拟机使用 new 关键字创建对象的过程？对象在堆中的内存布局？ 检查 new 指令的参数是否在运行时常量池中有对应的符号引用，然后检查该符号引用代表的类是否执行过类加载（区分类加载和加载，类加载包括加载、链接和初始化）。如果类加载完成，则为对象分配内存（使用 CAS + 重试保证原子性，或者使用线程私有内存），然后设置对象头。最后调用构造器执行初始化。 对象存储在堆中，由对象头、实例数据和对齐填充组成。对象头存储运行时数据（Mark Word）和指向类型元数据的指针。实例数据存储字段值，包括继承的字段，默认相同宽度的字段会被存放在一起，在该前提下父类字段会在子类之前。对齐填充的作用是内存对齐，HotSpot 虚拟机使用的是 8 字节对齐。 垃圾收集 基本概念 由于程序计数器、虚拟机栈和本地方法栈是线程私有的，占用的内存随方法返回或者线程结束而回收，所以不是垃圾收集器关注的重点。而堆和方法区是线程共享的，占用的内存何时回收是动态的，垃圾收集器会通过可达性分析判断什么对象可以回收。 最简单的想法是使用引用计数判断对象是否可以被回收，但是无法处理循环引用的问题。所以，通常是通过图的可达性分析来判断对象是否可以被回收，实际上就是维护一个可达的 GC Roots 的对象集，如果某个对象从 GC Roots 不可达，那么该对象就可以被回收。 引用类型：强引用、软引用、弱引用和虚引用。除强引用外的其他引用都对应一个继承自 Reference 抽象类的类，可以存储对其他对象的引用（称为 referent）。简单来说，强可达的对象不会被回收，软可达的对象会在内存溢出之前被回收，弱可达的对象会在下次垃圾收集时被回收，虚可达的对象已经是 finalized 的，不可达的对象可以被回收。（参考 java.lang.ref 文档） 思考：什么是 finalization 机制？finalize 方法为什么被弃用？ 当对象不可达时，如果对象没有重写 finalize 方法，则对象可以直接被回收。如果对象已重写 finalize 方法且该方法没有被调用过，则对象是 finalizable 的。虚拟机的 Finalizer 线程会将该对象加入队列排队，等待调用其 finalize 方法，调用之后对象是 finalized 的。如果对象是 finalized 且依然不可达，那么对象就会被回收变为 reclaimed。 垃圾收集器至少需要两个周期才能回收 finalizable 对象，并且被该对象引用的所有不可达对象会被保留，直到该对象被回收。此外，JVM 不保证会调用所有 finalizable 对象的 finalize 方法。（推荐阅读 How to Handle Java Finalization’s Memory-Retention Issues） finalization 机制存在问题，会导致性能问题、死锁和挂起。finalizer 的错误可能导致资源泄露；没有办法取消 finalization；不同对象的 finalize 方法调用之间没有指定的顺序。此外，无法保证 finalization 的完成时间。finalize 方法只能在 finalizable 对象上经过不确定的延迟之后调用。（参考 finalize 文档） 回收算法 分代收集理论：假设对象存活概率随对象年龄（经历垃圾收集的次数）的增加而增加，且跨代引用很少发生，则可以根据对象年龄，将堆划分成不同的区域（例如，新生代和老年代），然后使用不同的频率进行回收。相对于扫描所有对象而言，能够有效减少时间开销。 类加载机制 类的生命周期有 7 个阶段，各个阶段通常是交叉混合执行的，解析阶段可能在初始化之后开始。通常所说的类加载是指加载、连接和初始化。简单来说，加载阶段将类加载到方法区，验证阶段验证字节码是否符合规范，准备阶段执行静态字段的默认初始化（有例外情况），解析阶段将常量池的符号引用替换为直接引用。初始化阶段执行编译器生成的类构造器 &lt;clint&gt;() 方法（不是对象构造器），包括静态字段的显示初始化和静态初始化块。 类加载器用于实现加载阶段的“通过类的全限定名获取该类的二进制字节流”动作。在虚拟机中，类由类加载器和类的全限定名唯一确定。如果相同的类被不同类加载器加载，那么 instanceof 的判断结果就是 false。双亲委派机制是指，类加载器总是会将加载请求委派给父类加载器（父子类加载器是组合关系而不是继承关系），只有当父类加载器无法完成该加载请求时，子类加载器才会尝试加载，从而确保核心类（例如 Object）的唯一性。","link":"/2023/01/01/Java%20%E5%B9%B6%E5%8F%91%20&%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"title":"MySQL","text":"参考《高性能 MySQL》和官方文档。使用 MySQL 的 Sakila 示例数据库，使用 MySQL 版本 8.0.41 + InnoDB 存储引擎。各种术语的官方定义可以看 MySQL 术语表，锁相关的内容可以看 InnoDB Locking，更多数据库概念可以看 CUM 15-445 课程总结。任何描述都是简化的，不会涵盖所有情况，更多细节只能看文档。或者说没有必要去记细节，任何细节都取决于实现，而实现会随着版本更新而变化，需要学习的是整体的策略。 基本概念 快照（snapshot）：数据在特定时间的表示。一致性读（consistent read）：根据快照显示查询结果，也被称为一致性非锁定读。在读已提交和可重复读隔离级别下执行 SELECT 语句的默认模式是一致性读，也就是说会使用多版本并发控制（MVCC）读取数据。读已提交在每次执行一致性读时都会重置快照，而可重复读只在第一次一致性读时建立快照。锁定读（locking read）：使用 SELECT ... FOR SHARE 或者 SELECT ... FOR UPDATE 读取数据，会加读锁或者写锁，在事务提交或者回滚时释放（2PL）。 MVCC 是使用撤销日志（Undo Log）和读取视图（Read View）实现的。事务在修改记录之后会记录撤销日志，事务的回滚指针会指向该日志。读取视图包含一致性读不可见的事务 ID（事务 ID 不会在启动事务之后立即分配），读取记录时会比较记录的事务 ID 和读取视图，如果该记录对当前事务不可见，则执行撤销日志直到达到可见状态。删除操作被视为修改操作，通过修改删除标志位实现，只有当该版本记录对所有事务不可见时，才会被真正删除。撤销日志也会被记录到重做日志（Redo Log）中，实现崩溃恢复。 关于幻读的问题：DML 语句可以破坏快照，从而在可重复读隔离级别会出现幻读。（参考一致性读文档）如果将快照读和当前读混用，也会出现幻读。 1234567891011SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';-- Returns 0: no rows match.DELETE FROM t1 WHERE c1 = 'xyz';-- Deletes several rows recently committed by other transaction.SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';-- Returns 0: no rows match.UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';-- Affects 10 rows: another txn just committed 10 rows with 'abc' values.SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';-- Returns 10: this txn can now see the rows it just updated. 常用命令 12345678910SHOW FULL PROCESSLIST;SHOW ENGINE INNODB STATUS;SELECT * FROM performance_schema.data_locks\\GSHOW STATUS LIKE 'Last_query_cost';SHOW [GLOBAL | SESSION] VARIABLES [LIKE 'pattern' | WHERE expr];START TRANSACTION; BEGIN; COMMIT; ROLLBACK;[CREATE | ALTER | DROP | OPTIMIZE | ANALYZE | CHECK | REPAIR ] TABLE tbl_name;SHOW TABLE STATUS [LIKE 'pattern' | WHERE expr];SHOW INDEX FROM tbl_name;EXPLAIN [FORMAT=TREE | ANALYZE] select_statement; SHOW WARNINGS; 前缀索引 使用前缀索引可以减少索引的空间开销，内部节点的字符串比较会更高效，但是选择性会更低，那么匹配的主键会更多，从而需要更多次回表。所以需要选择合适的前缀长度，尽可能提高索引的选择性。索引的选择性是指不重复的索引值（基数，cardinality）和数据表的记录总数的比值。无法利用前缀索引执行分组、排序和覆盖索引扫描。 执行如下语句，city_demo 最终有 19200 条记录。 1234CREATE TABLE city_demo(city VARCHAR(50) NOT NULL);INSERT INTO city_demo(city) SELECT city FROM city;INSERT INTO city_demo(city) SELECT city FROM city_demo; -- 重复执行 5 次UPDATE city_demo SET city = (SELECT city FROM city ORDER BY RAND() LIMIT 1); -- 随机化数据 查询出现次数最多的前 10 个城市，然后使用各种前缀测试索引的选择性。前缀长度为 7 比较合适，因为统计数量的偏差不算很大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SELECT COUNT(*) AS c, cityFROM city_demo GROUP BY city ORDER BY c DESC LIMIT 10;+----+-----------------+| c | city |+----+-----------------+| 54 | Ondo || 51 | London || 49 | Olomouc || 49 | Pontianak || 47 | Kurgan || 46 | Almirante Brown || 46 | Changzhou || 46 | Funafuti || 46 | Jodhpur || 45 | Plock |+----+-----------------+SELECT COUNT(*) AS c, LEFT(city, 3) AS prefFROM city_demo GROUP BY pref ORDER BY c DESC LIMIT 10;+-----+------+| c | pref |+-----+------+| 477 | San || 197 | Cha || 171 | Tan || 157 | al- || 152 | Sou || 148 | Bat || 146 | Sal || 146 | Shi || 126 | Kam || 125 | Val |+-----+------+SELECT COUNT(*) AS c, LEFT(city, 7) AS prefFROM city_demo GROUP BY pref ORDER BY c DESC LIMIT 10;+----+---------+| c | pref |+----+---------+| 76 | San Fel || 66 | Valle d || 63 | Santiag || 54 | Ondo || 51 | London || 49 | Pontian || 49 | Olomouc || 47 | Kurgan || 46 | Jodhpur || 46 | Almiran |+----+---------+ 不能只根据前缀索引选择性的值确定前缀长度，例如前缀长度为 5 的选择性看上去很接近完整列的选择性，但是如果查看出现次数最多的前 10 个城市，和完整列的结果相比，会发现数据分布很不均匀。如果查询以 South 前缀的某个城市，那么回表的次数会更多。 12345678910111213141516171819202122232425262728SELECT COUNT(DISTINCT city) / COUNT(*) AS sel,COUNT(DISTINCT LEFT(city, 3)) / COUNT(*) AS sel3,COUNT(DISTINCT LEFT(city, 4)) / COUNT(*) AS sel4,COUNT(DISTINCT LEFT(city, 5)) / COUNT(*) AS sel5,COUNT(DISTINCT LEFT(city, 6)) / COUNT(*) AS sel6,COUNT(DISTINCT LEFT(city, 7)) / COUNT(*) AS sel7FROM city_demo;+--------+--------+--------+--------+--------+--------+| sel | sel3 | sel4 | sel5 | sel6 | sel7 |+--------+--------+--------+--------+--------+--------+| 0.0312 | 0.0236 | 0.0293 | 0.0305 | 0.0309 | 0.0310 |+--------+--------+--------+--------+--------+--------+SELECT COUNT(*) AS c, LEFT(city, 5) AS prefFROM city_demo GROUP BY pref ORDER BY c DESC LIMIT 10;+-----+--------+| c | pref |+-----+--------+| 118 | South || 104 | Santa || 78 | Chang || 76 | San F || 69 | Toulo || 68 | Xi´an || 66 | Valle || 64 | Saint || 64 | Shimo || 63 | Santi |+-----+--------+ 多列索引 在 film_actor 上有主键索引 PRIMARY KEY (actor_id,film_id)，有普通索引 KEY idx_fk_film_id (film_id)，以下查询计划表示合并两个索引的查询结果。索引合并策略有时效果不错，但更多时候表明表的索引建得很槽糕。如果优化器需要对多个索引做相交操作（由于多个 AND 条件），那么查看是否可以使用多列索引进行优化。 如果优化器需要对多个索引做联合操作（由于多个 OR 条件），且索引的选择性不高时，通常会在缓存、排序和合并上消耗大量 CPU 和内存资源。然而，优化器不会将这些操作计算到查询成本中，优化器只关心随机页面读取，所以有时索引合并的性能还不如全表扫描。这还会影响并发的查询，此时使用 UNION 改写，将单个查询拆分为多个查询，可以避免单个查询的执行时间过长，影响其他并发的查询（由于 2PL 协议，单个查询会在提交时才释放锁，当然不同隔离级别有细微差别）。 123456789101112131415EXPLAIN SELECT film_id, actor_id FROM film_actorWHERE actor_id = 1 OR film_id = 1\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: film_actor partitions: NULL type: index_mergepossible_keys: PRIMARY,idx_fk_film_id key: PRIMARY,idx_fk_film_id key_len: 2,2 ref: NULL rows: 29 filtered: 100.00 Extra: Using union(PRIMARY,idx_fk_film_id); Using where 聚簇索引 聚簇索引的每个叶子节点都包含主键值、事务 ID、用于事务和 MVCC 的回滚指针，以及所有的剩余列。二级索引的叶子节点存储主键值而不是物理指针，所以在移动主键索引中的记录时不需要修改二级索引。如果按照主键顺序插入行，聚簇索引不会发生页分裂，从而插入性能更高（减少磁盘 I/O）也不会产生内部碎片。不应该使用随机的主键（例如 UUID），如果没有按照主键顺序插入数据，可以使用 OPTIMIZE TABLE 命令重新组织表来消除内部碎片。 对于高并发负载，按主键顺序插入会产生较多竞争，可以通过更改 innodb_autoinc_lock_mode 配置来提升性能。简单来说，有传统、连续和交错三种锁定模式，不同模式会根据语句的不同使用互斥锁（Lock）或者轻量级锁（CAS）。 查询优化 可以根据慢查询日志来优化查询，使用 EXPLAIN 查看执行计划。基本准则：只选择需要的列，而不是使用 SELECT *，从而允许覆盖索引优化、减少时间（I/O）和空间开销。不要重复执行相同的查询，可以在应用层使用缓存。对于不是很重要的查询，可以将大查询分解为小查询，将查询的时间分散到一个时间段中，减少查询对服务器性能的影响（减少单次查询持有锁的时间，以及避免事务日志堆积）。例如：DELETE 大量数据，可以使用 LIMIT 分解执行；当中间查询结果能缓存和重用时，可以将连接查询分解，然后在应用层做连接。 应用 WHERE 条件的方式：① 将条件从服务器下推到存储引擎，直接在索引中使用条件过滤记录（索引条件下推，ICP），从而减少服务器访问存储引擎的次数，以及存储引擎访问基表的次数。② 使用覆盖索引获取记录（不需要回表），然后在服务器使用条件过滤记录。③ 回表之后，在服务器层使用条件。 MySQL 的局限性：无法将 UNION 外层的条件下推到内层。某些时候，等值传递会有问题（详细看书）。针对单个语句而言，无法利用多核并行执行查询，无法同时对某个表进行查询和更新（特指相关子查询）。 UNION 由于 UNION 查询无法使用到外层条件，所以需要手动将条件下推到 UNION 的各个子查询中。最好使用 UNION ALL 而不是 UNION，这样可以避免对临时表去重（UNION 查询总是会创建临时表）。 COUNT COUNT(*) 统计行数，COUNT(expr) 统计非 NULL 值的数量。性能 COUNT(*)=COUNT(1)&gt;COUNT(主键列)&gt;COUNT(普通列)，如下所示 COUNT(*) 实际上是 COUNT(0)。根据条件统计数量，可以使用 SUM(IF(expr, 1, 0)) 或者 COUNT(expr OR NULL)。如果允许使用近似值代替精确值，则可以去掉 WHERE 和 DISTINCT 之类的条件，优化查询性能。利用索引覆盖扫描优化性能，因为索引会比基表更小，减少 I/O 次数。 12345678910111213141516171819202122mysql&gt; EXPLAIN SELECT COUNT(*) FROM film\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: film partitions: NULL type: indexpossible_keys: NULL key: idx_fk_language_id key_len: 1 ref: NULL rows: 1000 filtered: 100.00 Extra: Using index1 row in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\\G*************************** 1. row *************************** Level: Note Code: 1003Message: /* select#1 */ select count(0) AS `COUNT(*)` from `sakila`.`film`1 row in set (0.00 sec) IN &amp; EXIST 常见的说法是，在子查询数据较少时使用 IN，而在子查询数据较大时使用 EXIST。因为使用 IN 是不相关子查询，会创建临时表，然后在临时表中查找匹配的数据。而使用 EXIST 是相关子查询，会直接在内表中查找匹配的数据（多次执行子查询）。但是，实际上优化器会做优化，使用 IN 并不意味着就会创建临时表。下面查询所有没有交易记录的顾客信息，执行计划显示该查询被转化为相关子查询，会使用覆盖索引查找匹配的数据。（推荐阅读 Optimizing Subqueries with the EXISTS Strategy） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; EXPLAIN SELECT * FROM customer WHERE customer_id IN ( -&gt; SELECT customer_id FROM payment -&gt; )\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: customer partitions: NULL type: ALLpossible_keys: PRIMARY key: NULL key_len: NULL ref: NULL rows: 599 filtered: 100.00 Extra: NULL*************************** 2. row *************************** id: 1 select_type: SIMPLE table: payment partitions: NULL type: refpossible_keys: idx_fk_customer_id key: idx_fk_customer_id key_len: 2 ref: sakila.customer.customer_id rows: 1 filtered: 100.00 Extra: Using index; FirstMatch(customer)2 rows in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\\G*************************** 1. row *************************** Level: Note Code: 1003Message: /* select#1 */ select `sakila`.`customer`.`customer_id` AS `customer_id`,`sakila`.`customer`.`store_id` AS `store_id`,`sakila`.`customer`.`first_name` AS `first_name`,`sakila`.`customer`.`last_name` AS `last_name`,`sakila`.`customer`.`email` AS `email`,`sakila`.`customer`.`address_id` AS `address_id`,`sakila`.`customer`.`active` AS `active`,`sakila`.`customer`.`create_date` AS `create_date`,`sakila`.`customer`.`last_update` AS `last_update` from `sakila`.`customer` semi join (`sakila`.`payment`) where (`sakila`.`payment`.`customer_id` = `sakila`.`customer`.`customer_id`)1 row in set (0.00 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM customer WHERE customer_id IN ( -&gt; SELECT customer_id FROM payment -&gt; )\\G*************************** 1. row ***************************EXPLAIN: -&gt; Nested loop semijoin (cost=271 rows=599) (actual time=0.0621..2.97 rows=599 loops=1) -&gt; Table scan on customer (cost=61.2 rows=599) (actual time=0.048..0.401 rows=599 loops=1) -&gt; Covering index lookup on payment using idx_fk_customer_id (customer_id=customer.customer_id) (cost=0.25 rows=1) (actual time=0.00418..0.00418 rows=1 loops=599)1 row in set (0.00 sec) 而使用 EXIST 也不意味着执行相关子查询，如果将 payment 中的索引 idx_fk_customer_id 删除，然后重新执行上述查询。执行计划显示，子查询会生成索引临时表，索引用于去重，然后外表使用该索引查找匹配的数据。如果临时表较小，则会使用 MEMORY 存储引擎创建内存临时表，否则使用 InnoDB 存储引擎创建磁盘临时表。（推荐阅读 Optimizing Subqueries with Materialization） 1ALTER TABLE payment DROP FOREIGN KEY fk_payment_customer, DROP INDEX idx_fk_customer_id; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566mysql&gt; EXPLAIN SELECT * FROM customer WHERE EXISTS ( -&gt; SELECT 1 FROM payment WHERE customer.customer_id = customer_id -&gt; )\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: customer partitions: NULL type: ALLpossible_keys: PRIMARY key: NULL key_len: NULL ref: NULL rows: 599 filtered: 100.00 Extra: NULL*************************** 2. row *************************** id: 1 select_type: SIMPLE table: &lt;subquery2&gt; partitions: NULL type: eq_refpossible_keys: &lt;auto_distinct_key&gt; key: &lt;auto_distinct_key&gt; key_len: 2 ref: sakila.customer.customer_id rows: 1 filtered: 100.00 Extra: NULL*************************** 3. row *************************** id: 2 select_type: MATERIALIZED table: payment partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 16086 filtered: 100.00 Extra: NULL3 rows in set, 2 warnings (0.00 sec)mysql&gt; SHOW WARNINGS\\G*************************** 1. row *************************** Level: Note Code: 1276Message: Field or reference 'sakila.customer.customer_id' of SELECT #2 was resolved in SELECT #1*************************** 2. row *************************** Level: Note Code: 1003Message: /* select#1 */ select `sakila`.`customer`.`customer_id` AS `customer_id`,`sakila`.`customer`.`store_id` AS `store_id`,`sakila`.`customer`.`first_name` AS `first_name`,`sakila`.`customer`.`last_name` AS `last_name`,`sakila`.`customer`.`email` AS `email`,`sakila`.`customer`.`address_id` AS `address_id`,`sakila`.`customer`.`active` AS `active`,`sakila`.`customer`.`create_date` AS `create_date`,`sakila`.`customer`.`last_update` AS `last_update` from `sakila`.`customer` semi join (`sakila`.`payment`) where (`&lt;subquery2&gt;`.`customer_id` = `sakila`.`customer`.`customer_id`)2 rows in set (0.00 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM customer WHERE EXISTS ( -&gt; SELECT 1 FROM payment WHERE customer.customer_id = customer_id -&gt; )\\G*************************** 1. row ***************************EXPLAIN: -&gt; Nested loop inner join (cost=963672 rows=9.64e+6) (actual time=6.27..6.92 rows=599 loops=1) -&gt; Table scan on customer (cost=61.2 rows=599) (actual time=0.0789..0.422 rows=599 loops=1) -&gt; Single-row index lookup on &lt;subquery2&gt; using &lt;auto_distinct_key&gt; (customer_id=customer.customer_id) (cost=3241..3241 rows=1) (actual time=0.0107..0.0107 rows=1 loops=599) -&gt; Materialize with deduplication (cost=3241..3241 rows=16086) (actual time=6.18..6.18 rows=599 loops=1) -&gt; Table scan on payment (cost=1633 rows=16086) (actual time=0.245..3.54 rows=16044 loops=1)1 row in set, 1 warning (0.01 sec) JOIN 确保 ON 或者 USING 的列上有索引。确保 GROUP BY 和 ORDER BY 只涉及一个表中的列，从而允许利用索引优化（松散/紧密索引扫描、利用索引排序）。如果需要对聚合的结果做超级聚合，可以使用 GROUP BY xxx WITH ROLLUP（注意查看查询计划，确定是否有性能问题），也可以使用其他等价语句或者在应用层聚合。 上面执行 SHOW WARNINGS\\G 都会显示半连接（semi join），所谓半连接就是从左表中查询和右表匹配的行。反连接（anti join）正好相反，从左表中查询和右表不匹配的行。下面的查询和上面的等价，但是更慢，没有使用半连接，在覆盖索引中使用 LIMIT 1 去重，在最后使用临时表去重（实际上没有必要，LIMIT 1 已经去重）。（推荐阅读 Optimizing IN and EXISTS Subquery Predicates with Semijoin and Antijoin Transformations） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; EXPLAIN SELECT DISTINCT customer.* FROM customer INNER JOIN payment USING(customer_id)\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: customer partitions: NULL type: ALLpossible_keys: PRIMARY key: NULL key_len: NULL ref: NULL rows: 599 filtered: 100.00 Extra: Using temporary*************************** 2. row *************************** id: 1 select_type: SIMPLE table: payment partitions: NULL type: refpossible_keys: idx_fk_customer_id key: idx_fk_customer_id key_len: 2 ref: sakila.customer.customer_id rows: 1 filtered: 100.00 Extra: Using index; Distinct2 rows in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\\G*************************** 1. row *************************** Level: Note Code: 1003Message: /* select#1 */ select distinct `sakila`.`customer`.`customer_id` AS `customer_id`,`sakila`.`customer`.`store_id` AS `store_id`,`sakila`.`customer`.`first_name` AS `first_name`,`sakila`.`customer`.`last_name` AS `last_name`,`sakila`.`customer`.`email` AS `email`,`sakila`.`customer`.`address_id` AS `address_id`,`sakila`.`customer`.`active` AS `active`,`sakila`.`customer`.`create_date` AS `create_date`,`sakila`.`customer`.`last_update` AS `last_update` from `sakila`.`customer` join `sakila`.`payment` where (`sakila`.`payment`.`customer_id` = `sakila`.`customer`.`customer_id`)1 row in set (0.00 sec)mysql&gt; EXPLAIN ANALYZE SELECT DISTINCT customer.* FROM customer INNER JOIN payment USING(customer_id)\\G*************************** 1. row ***************************EXPLAIN: -&gt; Table scan on &lt;temporary&gt; (cost=331..341 rows=599) (actual time=3.3..3.38 rows=599 loops=1) -&gt; Temporary table with deduplication (cost=331..331 rows=599) (actual time=3.3..3.3 rows=599 loops=1) -&gt; Nested loop inner join (cost=271 rows=599) (actual time=0.0668..2.13 rows=599 loops=1) -&gt; Table scan on customer (cost=61.2 rows=599) (actual time=0.0492..0.404 rows=599 loops=1) -&gt; Limit: 1 row(s) (cost=0.25 rows=1) (actual time=0.00271..0.00273 rows=1 loops=599) -&gt; Covering index lookup on payment using idx_fk_customer_id (customer_id=customer.customer_id) (cost=0.25 rows=1) (actual time=0.00262..0.00262 rows=1 loops=599)1 row in set (0.00 sec) LIMIT 如果偏移量很大，例如 LIMIT 10000, 20，那么会扫描 10020 条记录，而只有最后 20 条是有效的。如果行中有很多数据，那么 I/O 次数就会很多。MySQL 的 LIMIT OFFSET 似乎不会下推到索引，从而 10020 条记录都会回表查询。查询计划中确实没有下推，奇怪的是索引只会扫描 10020 条记录，说明索引是有 LIMIT OFFSET 信息的。（参考 Limit Offset 下推） 优化方式：① 使用覆盖索引执行 LIMIT，索引中只包含必要的列（如 ORDER BY 的列，当然默认包含主键），那么 LIMIT 扫描的数据会减少很多，最后使用主键做连接得到完整数据。（不能使用 IN，因为 ERROR 1235 (42000): This version of MySQL doesn't yet support 'LIMIT &amp; IN/ALL/ANY/SOME subquery'）② 如果只允许顺序翻页的话，通过记录上个页面的边界值，下次查询就可以使用该值定位到目标位置，而不会做无效的扫描。③ 一次性获取多页数据，在应用层缓存起来（类似缓存 I/O）。④ 其他方法，使用预先计算的汇总表，或者使用冗余表。 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment ORDER BY customer_id LIMIT 10000, 20\\G*************************** 1. row ***************************EXPLAIN: -&gt; Limit/Offset: 20/10000 row(s) (cost=1633 rows=20) (actual time=11.6..11.6 rows=20 loops=1) -&gt; Sort: payment.customer_id, limit input to 10020 row(s) per chunk (cost=1633 rows=16086) (actual time=10.6..11.4 rows=10020 loops=1) -&gt; Table scan on payment (cost=1633 rows=16086) (actual time=0.434..5.5 rows=16044 loops=1)1 row in set (0.01 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment FORCE INDEX (idx_fk_customer_id) ORDER BY customer_id LIMIT 10000, 20\\G*************************** 1. row ***************************EXPLAIN: -&gt; Limit/Offset: 20/10000 row(s) (cost=3129 rows=20) (actual time=11.1..11.1 rows=20 loops=1) -&gt; Index scan on payment using idx_fk_customer_id (cost=3129 rows=10020) (actual time=1.14..10.8 rows=10020 loops=1)1 row in set (0.01 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment INNER JOIN (SELECT payment_id FROM payment ORDER BY customer_id LIMIT 10000, 20) AS lim USING(payment_id)\\G*************************** 1. row ***************************EXPLAIN: -&gt; Nested loop inner join (cost=3151 rows=20) (actual time=2.29..2.32 rows=20 loops=1) -&gt; Table scan on lim (cost=641..644 rows=20) (actual time=2.27..2.28 rows=20 loops=1) -&gt; Materialize (cost=641..641 rows=20) (actual time=2.27..2.27 rows=20 loops=1) -&gt; Limit/Offset: 20/10000 row(s) (cost=639 rows=20) (actual time=2.12..2.12 rows=20 loops=1) -&gt; Covering index scan on payment using idx_fk_customer_id (cost=639 rows=10020) (actual time=0.178..1.89 rows=10020 loops=1) -&gt; Single-row index lookup on payment using PRIMARY (payment_id=lim.payment_id) (cost=0.25 rows=1) (actual time=0.00204..0.00207 rows=1 loops=20)1 row in set (0.00 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM payment WHERE payment_id IN (SELECT payment_id FROM (SELECT payment_id FROM payment ORDER BY customer_id LIMIT 10000, 20) AS lim)\\G*************************** 1. row ***************************EXPLAIN: -&gt; Nested loop inner join (cost=35413 rows=321720) (actual time=11.3..15.9 rows=20 loops=1) -&gt; Table scan on payment (cost=1633 rows=16086) (actual time=0.382..6.93 rows=16044 loops=1) -&gt; Single-row index lookup on &lt;subquery2&gt; using &lt;auto_distinct_key&gt; (payment_id=payment.payment_id) (cost=646..646 rows=1) (actual time=460e-6..460e-6 rows=0.00125 loops=16044) -&gt; Materialize with deduplication (cost=646..646 rows=20) (actual time=2.07..2.07 rows=20 loops=1) -&gt; Table scan on lim (cost=641..644 rows=20) (actual time=2.06..2.06 rows=20 loops=1) -&gt; Materialize (cost=641..641 rows=20) (actual time=2.06..2.06 rows=20 loops=1) -&gt; Limit/Offset: 20/10000 row(s) (cost=639 rows=20) (actual time=2.05..2.06 rows=20 loops=1) -&gt; Covering index scan on payment using idx_fk_customer_id (cost=639 rows=10020) (actual time=0.095..1.82 rows=10020 loops=1)1 row in set (0.02 sec) NOT IN 从文本文件读取数据，num 列有 100 万个 1、100 万个 2 和 1 个 3，测试一下 NOT IN (1, 2) 是否会使用索引。EXPLAIN ANALYZE 的结果显示，查询被分为三个区间，这样就可以利用索引范围扫描。（推荐阅读 Optimizing INSERT Statements，MySQL EXPLAIN ANALYZE，A must-know about NOT IN in SQL - more antijoin optimization）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263SET @@GLOBAL.local_infile = 1;CREATE TABLE test (num TINYINT NOT NULL, dummy TINYINT NOT NULL DEFAULT 0);LOAD DATA LOCAL INFILE 'data.txt' INTO TABLE test (num);ALTER TABLE test ADD INDEX idx_num (num);mysql&gt; EXPLAIN SELECT * FROM test WHERE num NOT IN (1, 2)\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: test partitions: NULL type: rangepossible_keys: idx_num key: idx_num key_len: 1 ref: NULL rows: 3 filtered: 100.00 Extra: Using index condition1 row in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\\G*************************** 1. row *************************** Level: Note Code: 1003Message: /* select#1 */ select `sakila`.`test`.`num` AS `num`,`sakila`.`test`.`dummy` AS `dummy` from `sakila`.`test` where (`sakila`.`test`.`num` not in (1,2))1 row in set (0.00 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM test WHERE num NOT IN (1, 2)\\G*************************** 1. row ***************************EXPLAIN: -&gt; Index range scan on test using idx_num over (num &lt; 1) OR (1 &lt; num &lt; 2) OR (2 &lt; num), with index condition: (test.num not in (1,2)) (cost=3.38 rows=3) (actual time=0.0355..0.0383 rows=1 loops=1)1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM test WHERE num NOT IN (3)\\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: test partitions: NULL type: ALLpossible_keys: idx_num key: NULL key_len: NULL ref: NULL rows: 1996905 filtered: 50.00 Extra: Using where1 row in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\\G*************************** 1. row *************************** Level: Note Code: 1003Message: /* select#1 */ select `sakila`.`test`.`num` AS `num`,`sakila`.`test`.`dummy` AS `dummy` from `sakila`.`test` where (`sakila`.`test`.`num` &lt;&gt; 3)1 row in set (0.00 sec)mysql&gt; EXPLAIN ANALYZE SELECT * FROM test WHERE num NOT IN (3)\\G*************************** 1. row ***************************EXPLAIN: -&gt; Filter: (test.num &lt;&gt; 3) (cost=201305 rows=998453) (actual time=0.0239..1133 rows=2e+6 loops=1) -&gt; Table scan on test (cost=201305 rows=2e+6) (actual time=0.0222..976 rows=2e+6 loops=1)1 row in set (1.26 sec)","link":"/2023/01/01/MySQL/"},{"title":"Redis","text":"参考 官方文档，对象编码，数据类型，命令列表，代码仓库（7.4.2），事务，可编程性，《Redis 设计与实现》。 基本概念 Redis 服务器是事件驱动程序，主要使用单线程 + I/O 多路复用处理客户端请求。不过也会使用后台线程，例如，使用 UNLINK 命令可以异步删除大键（Redis 4.0），以及将网络 I/O 委托给其他线程来提高性能（Redis 6.0）。Redis 的瓶颈在内存和网络，CPU 很少成为 Redis 的瓶颈，而且由于多线程的复杂性，Redis 核心逻辑没有使用多线程设计。如果要提高 CPU 的利用率，可以在同一个机器中启动多个 Redis 实例，并将它们视为不同的服务器。 过期删除策略：定时删除会将 CPU 时间用在和当前任务无关的过期键上，影响服务器的响应时间。惰性删除检查当前处理的键是否过期，如果不对过期键执行命令就会导致内存泄露。定期删除结合前两种策略的优点，是时间和空间的折中。Redis 使用惰性删除 + 定期删除的策略，定期删除从一定数量的数据库中随机检查一定数量的键，如果过期就删除。 Key 淘汰策略：配置 maxmemory 来指定使用内存的上限，当超过该限制时会执行淘汰策略。概括一下：① 不淘汰键，此时只支持读命令，写命令会报错。② 使用 LRU、LFU 或者随机淘汰键。③ 使用 LRU、LFU 或者随机淘汰有过期时间的键，或者淘汰 TTL 最短的键。 Redis 使用的是近似 LRU，随机抽取少量的键，然后淘汰其中最久未被访问的键（Redis 3.0 会跟踪候选键来提高性能），不使用标准 LRU 的原因是会消耗更多内存（因为需要维护访问链表）。LFU 使用概率计数器（Morris 计数器）估计键的访问频率，结合衰减期以便计数器随时间减少，也使用上述采样方式淘汰访问频率最小的键。 通用命令 12345678SELECT indexINFO [section [section ...]]DEL key [key ...] | UNLINK key [key ...]EXPIRE key seconds [NX | XX | GT | LT] | TTL key | TIME | PERSIST keyTYPE key | OBJECT ENCODING key | OBJECT IDLETIME key | OBJECT REFCOUNT keySAVE | BGSAVE [SCHEDULE] | BGREWRITEAOFWATCH key [key ...] | UNWATCH | MULTI | DISCARD | EXECEVAL script numkeys [key [key ...]] [arg [arg ...]] 数据结构 SDS 在 Redis 中，当无需修改字符串时，使用的是 C 字符串。否则，使用简单动态字符串（simple dynamic string，SDS）。相比 C 字符串有如下优点：① 获取长度的时间复杂度为 \\(O(1)\\)。② 自动扩容，空间预分配，不会自动缩容，但支持手动缩容。③ 二进制安全，不根据 \\0 空字符判断字符串结束。 123456struct __attribute__ ((__packed__)) hisdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];}; ziplist ziplist 是特殊编码的双向链表，非常节省内存。它存储字符串和整数值，其中整数被编码为实际整数，而不是一系列的字符。它允许在列表的任意一侧进行 push 和 pop 操作，该操作需要重新分配内存（realloc + memmove），时间复杂度和列表使用的内存量相关。 ziplist 的布局如下，&lt;uint32_t zlbytes&gt; 表示列表占用的字节数，&lt;uint32_t zltail&gt; 表示列表最后一个节点的偏移量，&lt;uint16_t zllen&gt; 表示列表中的节点数量（当节点数量超过 \\(2^{16}-2\\) 时，该值被设置为 \\(2^{16}-1\\)，此时需要遍历整个列表才能知道有多少节点），&lt;uint8_t zlend&gt; 是列表的结束标识（被设置为 0xFF）。 1&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt; entry 的布局如下，&lt;prevlen&gt; 表示前一个节点的长度（如果小于 254 字节，则占用单个字节，否则占用 5 个字节，第一个字节被设置为 0xFE，后四个字节表示长度），&lt;encoding&gt; 和 &lt;entry-data&gt; 的编码方式取决于节点的内容。添加/删除节点可能引发级联更新（Cascade Update），不过新版 Redis 会提前计算所需空间，时间复杂度是 \\(O(n)\\)。 123&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt; listpack 由于经常发生和 ziplist 的代码相关的崩溃报告，而 ziplist 实现复杂（主要源于级联更新）难以审计，所以对 ziplist 进行改进。listpack 的实现更紧凑、解析速度更快以及更易于审计和理解。listpack 的布局如下，由于没有使用偏移量，头部只占用 6 字节（ziplist 头部占用 10 字节）。依然使用 0xFF 单个字节作为结束标识，原因是这样可以很容易地识别列表的结束，而不需要额外保存末尾地址。由于没有使用偏移量，要快速定位最后一个元素实现反向遍历，很容易想到倒着存储元素的长度信息，element 的布局如下。 12&lt;tot-bytes&gt; &lt;num-elements&gt; &lt;element-1&gt; ... &lt;element-N&gt; &lt;listpack-end-byte&gt;&lt;encoding-type&gt;&lt;element-data&gt;&lt;element-tot-len&gt; quicklist quicklist 是以 ziplist 或者 listpack 为节点的双向链表，结合 linkedlist 插入/删除快速以及 ziplist/listpack 节省空间的特点。 intset inset 存储整数集合（不包含重复项），按照从小到大的顺序存储在 contents 数组中。所有元素的编码方式取决于 encoding 字段，可以将元素编码为 16、32 和 64 字节。如果当前编码方式无法存储新元素，则会将所有元素的编码方式都升级为更大的类型（不会自动降级）。因为引发升级的元素总是比现有元素都小/大，所以该新元素会存放到列表开头/结尾。 12345typedef struct intset { uint32_t encoding; uint32_t length; int8_t contents[];} intset; hashtable ht_table 表示两个哈希表，一般只使用 ht_table[0]，而 ht_table[1] 在扩容/缩容时使用。哈希表的大小是 2 的幂，扩容的大小为第一个大于等于 ht_used[0] * 2 的 \\(2^{n}\\)，缩容的大小为第一个大于等于 ht_used[0] 的 \\(2^{n}\\)。扩容/缩容是渐进式的，在每次对哈希表执行操作时，会 rehash 一个桶（由 rehashidx 标识）。 扩容的时机：当没有在执行 BGSAVE 或者 BGREWRITEAOF 命令且负载因子大于等于 1，当在执行 BGSAVE 或者 BGREWRITEAOF 命令且负载因子大于等于 5。因为在持久化时会创建子进程，操作系统使用写时复制（COW）优化子进程的使用，所以如果存在子进程，服务器会尽可能避免扩容（避免修改共享的页面），从而避免写时复制的开销。缩容的时机：当负载因子小于 0.1 时自动缩容。 123456789101112131415161718192021222324252627struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; /* Next entry in the same hash bucket. */};struct dict { dictType *type; dictEntry **ht_table[2]; unsigned long ht_used[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ /* Keep small vars at end for optimal (minimal) struct padding */ unsigned pauserehash : 15; /* If &gt;0 rehashing is paused */ unsigned useStoredKeyApi : 1; /* See comment of storedHashFunction above */ signed char ht_size_exp[2]; /* exponent of size. (size = 1&lt;&lt;exp) */ int16_t pauseAutoResize; /* If &gt;0 automatic resizing is disallowed (&lt;0 indicates coding error) */ void *metadata[];}; skiplist skiplist 使用 zset 结构作为底层实现，由跳表和哈希表组成。跳表维护多层链表，支持正序/倒序遍历，节点负责存储字符串元素 ele 和浮点数分值 score，同时会维护该节点在各层中的下一个节点的跨度 span（用于快速计算排名）。程序根据幂次定律生成节点的层数，节点层高为 k 层的概率是 (1 - ZSKIPLIST_P) * (ZSKIPLIST_P) ^ (k - 1)（其中 ZSKIPLIST_P = 0.25）。 使用跳表可以提高 ZRANGE 和 ZRANK 的效率，使用哈希表可以提高根据字符串查找分值的效率。 123456789101112131415161718192021/* ZSETs use a specialized version of Skiplists */typedef struct zskiplistNode { sds ele; double score; struct zskiplistNode *backward; struct zskiplistLevel { struct zskiplistNode *forward; unsigned long span; } level[];} zskiplistNode;typedef struct zskiplist { struct zskiplistNode *header, *tail; unsigned long length; int level;} zskiplist;typedef struct zset { dict *dict; zskiplist *zsl;} zset; 数据类型 123456789struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr;}; String 使用场景：存储字节序列（文本、序列化对象和二进制数组）或者充当计数器。默认最大可以存储 512 MB 的字符串。编码方式：① int，在保存 64 位有符号整数时使用，可以看作 Java 中的 long 类型。② embstr（embedded string），默认在字符串长度小于等于 44 字节时使用，该编码将 redisObject 和 sdshdr 存储在单个内存块中，不可修改。③ raw，该编码将 redisObject 和 sdshdr 存储在不同内存块中。 123SET key value [NX | XX] [EX seconds | PX milliseconds]GET key | MGET key [key ...]INCR key | INCRBY key increment | INCRBYFLOAT key increment List 使用场景：实现栈和队列。最多可以存储 \\(2^{32}-1\\) 个元素。编码方式：ziplist | listpack，linkedlist，quicklist。 12345[LPUSH | RPUSH] key element [element ...][LPOP | RPOP] key [count]LREM key count elementLRANGE key start stopLLEN key Set 使用场景：存储唯一值，计算交集、并集和差集。最多可以存储 \\(2^{32}-1\\) 个元素。编码方式：intset，listpack，hashtable（值被设置为 NULL）。 123456SADD key member [member ...]SREM key member [member ...]SISMEMBER key memberSMEMBERS key | SSCAN key cursor [MATCH pattern] [COUNT count][SINTER | SUNION | SDIFF] key [key ...]SCARD key Hash 使用场景：存储键值对（对象）。最多可以存储 \\(2^{32}-1\\) 个键值对。编码方式：ziplist | listpack，hashtable。 1234HSET key field value [field value ...] | HSETNX key field valueHDEL key field [field ...]HGET key field | HGETALL key | HSCAN key cursor [MATCH pattern] [COUNT count] [NOVALUES]HLEN key Sorted set（ZSet） 使用场景：排行榜、速率限制器。首先按照分数排序（浮点数），然后按照字典序排序（元素都是字符串）。编码方式：ziplist | listpack，skiplist。 12345ZADD key [NX | XX] [GT | LT] score member [score member ...]ZREM key member [member ...]ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES][ZRANK | ZREVRANK] key member [WITHSCORE]ZCARD key | ZCOUNT key min max 持久化机制 持久化机制：① RDB（Redis Database），以指定的时间间隔创建数据的快照。② AOF（Append Only File），记录所有写命令。（不建议单独使用 AOF）③ No persistence，不持久化。④ RDB + AOF：组合使用 RDB 和 AOF。 相比 AOF，RDB 文件表示更紧凑，允许更快地重启（就是使用快照恢复数据）。而 AOF 文件会更大，Redis 会自动重写 AOF 来减少文件大小。在发生故障时 RDB 会丢失更多数据（因为是指定时间间隔持久化），而 AOF 默认每秒执行 fsync（也可以配置为不执行 fsync，让操作系统决定何时刷盘，或者每次查询都执行，但是会很慢），最多丢失一秒的数据。如果数据很大 fork 会占用 CPU 从而阻塞客户端命令，RDB 相比 AOF 执行 fork 的频率更高（RDB 必然会执行 fork，AOF 只有在重写时执行 fork）。 重写是根据当前数据记录写命令，而不是根据旧的 AOF 文件。在 Reids 7.0 之前，重写期间到达的所有写命令最终会写入磁盘两次，因为重写 AOF 的同时 AOF 操作也依然在执行（保证数据安全），所以写命令会写入旧文件，然后还会使用缓冲区记录写命令，等待 AOF 重写完成之后将其追加到新文件。在 Redis 7.0 之后，使用 Multi Part AOF 机制，AOF 文件被分为基本文件（最多一个）和增量文件（可能有多个）。基本文件表示重写 AOF 时的数据快照（RDB 或 AOF 格式），增量文件记录创建基本文件之后的增量更改。Redis 使用临时清单文件跟踪基本文件和增量文件，当 AOF 重写完成，Redis 执行原子切换使改临时清单文件生效。 应用场景 缓存数据 缓存穿透：频繁请求数据库中不存在的数据。解决方案：① 用户权限和参数校验，提前过滤无效请求。② 将无效键加入缓存同时设置较短的过期时间（区分无效值和正常空值），如果之后数据库中有相关数据，会导致短时间的不一致。或者可以在更新数据时删除缓存，从而保证一致性。③ 使用布隆过滤器（定期重建），一种概率数据结构，由一个位数组和多个哈希函数组成。插入元素会将所有哈希函数计算的索引位置置为 1。查询元素只要有一个计算出的索引位置不为 1，那么该元素就必定不在集合中。否则，有可能在集合中（由于哈希冲突，存在误报）。 缓存击穿：热点数据过期。解决方案：① 访问热点数据的同时重置过期时间。② 发现缓存失效时，加锁重建缓存，避免所有请求都查询数据库。其他线程会尝试加锁（使用 trylock，因为缓存重建完成之后就不需要互斥），失败之后休眠一段时间再查询缓存。③ 逻辑过期，不设置 TTL，而是在值中增加过期时间字段。如果查询缓存发现已经逻辑过期，依然加锁重建缓存，但是加锁失败的线程直接返回过期数据。 缓存雪崩：大量数据过期。解决方案：① 设计随机的过期时间（类似 Raft 里的随机选举超时），避免同时过期。 通用方案：① 缓存预热、多级缓存。② 为缓存业务添加限流（可以整体限流也可以根据用户 ID 限流）、降级（简化响应，保证核心功能稳定）和熔断（拒绝请求，防止故障扩散）策略。限流策略：固定窗口，对时间窗口内的请求计数，但是窗口切换时存在双倍流量的问题；滑动窗口，将窗口分为细粒度的时间片做计数，通过计算窗口内所有时间片计数的和来判断是否达到流量阈值，内存开销较大；漏桶算法，将请求放入桶中（排队），以恒定速率处理请求，不能处理突发流量；令牌桶算法，将令牌放入桶中（计数），以恒定的速率生成令牌，允许突发流量。③ 使用 Redis 集群提高服务可用性。 缓存一致性问题：① 更新数据不处理缓存，存在不一致的问题。② 更新数据时删除缓存。如果事务提交之后删除缓存，假设另一个请求已经读取到旧数据，但直到很久之后才设置缓存，也会存在不一致（可以延迟双删）。之所以删除缓存而不是更新缓存，是因为如果同时有多个请求更新相同的数据，更新缓存会有时序问题。③ 订阅 MySQL binlog（阿里 canal 组件，利用主从节点的日志复制），解析日志然后利用消息队列更新缓存（适合数据不过期的场景）。 分布式锁 使用 SET 命令获取分布式锁：① 设置过期时间，避免客户端宕机导致锁无法被释放。② 设置锁的持有者，在释放锁（删除键）时检查当前客户端是否持有锁，如果持有才执行释放操作（使用 Lua 脚本保证原子性）。避免客户端 A 持有的锁过期之后，释放客户端 B 持有的锁。③ 使用 Lua 脚本原子地执行 CAS 操作来解锁。 12SET lock owner NX EX max-lock-timeEVAL ...script... 1 lock owner 123456if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1]then return redis.call(&quot;del&quot;,KEYS[1])else return 0end 严格来说，这是只是近似的分布式锁，当锁过期时，存在两个客户端同时执行操作的情况。如果只是将锁用于提升效率（例如缓存重建），那么也不会有什么问题。如果是用于互斥操作共享数据，则会有正确性问题。Redlock 算法的基本想法是利用多数原则来选举，减少锁失效的可能性以及提高容错性，但是成本更大而且并不能保证互斥，由于存在进程暂停、网络延迟和时钟同步问题。（推荐阅读 How to do distributed locking） 要实现严格互斥的分布式锁可以使用 ZooKeeper + Fencing 令牌来实现，ZooKeeper 用于实现无羊群效应的简单锁，而 Fencing 令牌用于标记锁和存储服务的版本，从而解决进程暂停导致的问题。也可以使用单机 MySQL 实现分布式锁，例如在事务中使用 FOR UPDATE 当前读来锁定行或者使用 GET_LOCK() 函数，从而允许客户端宕机时自动释放锁，又或者使用插入指定主键记录 + 过期时间字段来确保不会一直持有锁。","link":"/2023/01/01/Redis/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Debugging","slug":"Debugging","link":"/tags/Debugging/"},{"name":"Draft","slug":"Draft","link":"/tags/Draft/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"AtCoder","slug":"算法/AtCoder","link":"/categories/%E7%AE%97%E6%B3%95/AtCoder/"},{"name":"Codeforces","slug":"算法/Codeforces","link":"/categories/%E7%AE%97%E6%B3%95/Codeforces/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"语言/Java","link":"/categories/%E8%AF%AD%E8%A8%80/Java/"},{"name":"C++","slug":"语言/C","link":"/categories/%E8%AF%AD%E8%A8%80/C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"CMU 15-445","slug":"课程/CMU-15-445","link":"/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"OceanBase","slug":"数据库/OceanBase","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"},{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"书籍","slug":"书籍","link":"/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"DDIA","slug":"书籍/DDIA","link":"/categories/%E4%B9%A6%E7%B1%8D/DDIA/"},{"name":"模板","slug":"基础/模板","link":"/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"},{"name":"MIT 6.824","slug":"课程/MIT-6-824","link":"/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"NJU Static Analysis","slug":"课程/NJU-Static-Analysis","link":"/categories/%E8%AF%BE%E7%A8%8B/NJU-Static-Analysis/"},{"name":"UCB CS61A","slug":"课程/UCB-CS61A","link":"/categories/%E8%AF%BE%E7%A8%8B/UCB-CS61A/"},{"name":"NJU ICS&#x2F;OS","slug":"课程/NJU-ICS-OS","link":"/categories/%E8%AF%BE%E7%A8%8B/NJU-ICS-OS/"},{"name":"CSAPP&#x2F;OSTEP","slug":"书籍/CSAPP-OSTEP","link":"/categories/%E4%B9%A6%E7%B1%8D/CSAPP-OSTEP/"},{"name":"GAMES101","slug":"课程/GAMES101","link":"/categories/%E8%AF%BE%E7%A8%8B/GAMES101/"},{"name":"Go","slug":"语言/Go","link":"/categories/%E8%AF%AD%E8%A8%80/Go/"},{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"MySQL","slug":"数据库/MySQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"}],"pages":[{"title":"Links","text":"数学 GILBERT STRANG，3Blue1Brown。 物理 feynmanlectures。 语言 refactoringguru，MDN，Java SE。 算法 oi-wiki，clist。 课程 csdiy，mit ocw。 博客 美团技术团队，阮一峰的网络日志，小林coding，JavaGuide，阿秀的学习笔记。 research!rsc，1024cores，Paul E. McKenney，Brendan Gregg。 Bjarne Stroustrup，Modernes C++，W. Richard Stevens。 工具 poe，pythontutor，Z-Library，Anna’s Archive。","link":"/links/index.html"},{"title":"About","text":"","link":"/about/index.html"}]}