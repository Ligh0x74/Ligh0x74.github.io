<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Ligh0x74&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ligh0x74&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ligh0x74&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Ligh0x74&#039;s Blog"><meta property="og:url" content="https://ligh0x74.github.io/"><meta property="og:site_name" content="Ligh0x74&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ligh0x74.github.io/img/og_image.png"><meta property="article:author" content="Ligh0x74"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ligh0x74.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ligh0x74.github.io"},"headline":"Ligh0x74's Blog","image":["https://ligh0x74.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Ligh0x74"},"publisher":{"@type":"Organization","name":"Ligh0x74's Blog","logo":{"@type":"ImageObject","url":"https://ligh0x74.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-08T09:08:52.308Z" title="2024/8/8 下午5:08:52">2024-08-08</time>发表</span><span class="level-item"><time dateTime="2024-08-08T09:14:37.480Z" title="2024/8/8 下午5:14:37">2024-08-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a><span> / </span><a class="link-muted" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP/">CSAPP</a></span><span class="level-item">1 小时读完 (大约11333个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/08/CSAPP%20%E6%80%BB%E7%BB%93/">CSAPP 总结</a></p><div class="content"><p>推荐：<a target="_blank" rel="noopener" href="https://csapp.cs.cmu.edu/">官方网站</a>，<a target="_blank" rel="noopener" href="https://dreamanddead.github.io/CSAPP-3e-Solutions/">习题答案</a>。</p>
<h2 id="计算机系统漫游">计算机系统漫游</h2>
<h3 id="编译系统">编译系统</h3>
<p><img src="/img/CSAPP.assets/1723106784635.png" alt=""></p>
<h3 id="系统抽象">系统抽象</h3>
<p><img src="/img/CSAPP.assets/1723107838196.png" alt=""></p>
<h2 id="信息的表示和处理">信息的表示和处理</h2>
<h3 id="信息存储">信息存储</h3>
<p>大多数计算机使用 8 位的块，或者<strong>字节</strong>（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址</strong>（address），所有可能地址的集合就称为<strong>虚拟地址空间</strong>（virtual address space）。</p>
<p>每台计算机都有一个<strong>字长</strong>（word size），指明指针数据的<strong>标称大小</strong>（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 \(w\) 位的机器而言，虚拟地址的范围为 0 ~ \(2^{w}\)-1，程序最多访问 \(2^{w}\) 个字节。</p>
<p>我们将程序称为“32 位程序”或“64 位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。</p>
<h4 id="字节顺序">字节顺序</h4>
<p>对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。</p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为 int 的变量 × 的地址为 0x100，也就是说，地址表达式 &amp;× 的值为 0x100。那么，（假设数据类型 int 为 32 位表示）x 的 4 个字节将被存储在内存的 0x100、0x101、0x102 和 0x103 位置。</p>
<p>在内存中按照从最低有效字节到最高有效字节的顺序存储对象的方式，称为<strong>小端法</strong>（little endian）。按照从最高有效字节到最低有效字节的顺序存储对象的方式，称为<strong>大端法</strong>（big endian）。假设变量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围 0x100 ~ 0x103 的字节顺序依赖于机器的类型：</p>
<p><img src="/img/CSAPP.assets/1722937251924.png" alt=""></p>
<h3 id="整数">整数</h3>
<h4 id="编码方式">编码方式</h4>
<p>对向量 \(\vec{x}=[x_{w-1},x_{w-2},\cdots,x_{0}]\)，各编码方式的定义如下：</p>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>无符号数</td>
<td>\(B2U_{w}(\vec{x})\dot =\sum_{i=0}^{w-1}x_{i}2^{i}\)</td>
</tr>
<tr>
<td>补码</td>
<td>\(B2T_{w}(\vec{x})\dot =-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}\)</td>
</tr>
<tr>
<td>反码</td>
<td>\(B2O_{w}(\vec{x})\dot =-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^{i}\)</td>
</tr>
<tr>
<td>原码</td>
<td>\(B2S_{w}(\vec{x})\dot =(-1)^{x_{w-1}}\cdot(\sum_{i=0}^{w-2}x_{i}2^{i})\)</td>
</tr>
</tbody>
</table>
<h4 id="转换规则">转换规则</h4>
<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。转换关系如下：</p>
<ul>
<li>补码转换为无符号数，\(T2U_{w}(x)=x+x_{w-1}2^{w}\)。</li>
<li>无符号数转换为补码，\(U2T_{w}(u)=u-u_{w-1}2^{w}\)。</li>
</ul>
<p>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。</p>
<h4 id="扩展规则">扩展规则</h4>
<p>要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0，这种运算被称为零扩展（zero extension）。要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展（sign extension），在表示中添加最高有效位的值。对于扩展大小和转换符号的顺序，C 语言标准要求，先扩展大小，再转换符号。</p>
<h4 id="运算规则">运算规则</h4>
<ul>
<li>检测无符号数加法中的溢出：对满足 \(0\leq x,y\leq UMax_{w}\) 的 \(x\) 和 \(y\)，令 \(s\dot=x+_{w}^{u}y\)。当且仅当 \(s&lt;x\)（或者等价地 \(s&lt;y\)）时，计算 \(s\) 发生溢出。</li>
<li>检测补码数字加法中的溢出：对满足 \(TMin_{w}\leq x,y\leq TMax_{w}\) 的 \(x\) 和 \(y\)，令 \(s\dot=x+_{w}^{t}y\)。当且仅当 \(x&gt;0\)，\(y&gt;0\)，但 \(s\leq 0\) 时，计算 \(s\) 发生正溢出。当且仅当 \(x&lt;0\)，\(y&lt;0\)，但 \(s\geq 0\) 时，计算 \(s\) 发生负溢出。</li>
</ul>
<p>计算一个位级表示的值的在补码加法下的逆元：第一种方法是对每一位取反，再对结果加 1，即 <code>-x == ~x + 1</code>；第二种方法是将最低位的 1 左侧的所有位取反。</p>
<p>无符号乘法和补码乘法在截断之后的位级表示是相同的，该结论可以通过公式推导得出。</p>
<p>整数乘法运算指令比其他整数运算（例如加法、减法、移位）更慢，因此编译器会尝试使用移位和加减法的组合来代替乘以常数因子的乘法。是否实际替换，取决于两种方案的相对速度。</p>
<p>整数除法总是向零取整，即对于正数向下取整，对于负数向上取整。当使用移位运算替换除以 2 的幂的除法时，需要注意补码移位是向下取整。也就是说，对于负数需要添加“偏置（biasing）”值，从而使得其向零取整。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x / (<span class="number">1</span> &lt;&lt; k) == (x &lt; <span class="number">0</span> ? x + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure>
<h3 id="浮点数">浮点数</h3>
<p>IEEE 浮点标准用 \(V=(-1)^{s}\times M\times 2^{E}\) 的形式来表示一个数：</p>
<ul>
<li>
<p>符号（sign） \(s\) 决定这数是负数（\(s=1\)）还是正数（\(s=0\)），而对于数值 0 的符号位解释作为特殊情况处理。</p>
</li>
<li>
<p>尾数（significand） \(M\) 是一个二进制小数，它的范围是1 ~ \(2-\varepsilon\)，或者是 0 ~ \(1-\varepsilon\)。</p>
</li>
<li>
<p>阶码（exponent） \(E\) 的作用是对浮点数加权，这个权重是 2 的 \(E\) 次幂（可能是负数）。</p>
</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位 \(s\) 直接编码符号 \(s\)。</li>
<li>\(k\) 位的阶码字段 \(exp=e_{k-1}\cdots e_{1}e_{0}\) 编码阶码 \(E\)。</li>
<li>\(n\) 位小数字段 \(frac=f_{n-1}\cdots f_{1}f_{0}\)，编码尾数 \(M\)，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li>
</ul>
<p>图 2-32 给出了将这三个字段装进字中两种最常见的格式。在单精度浮点格式中，s、exp 和 frac 字段分别为 1 位、k = 8 位和 n = 23 位，得到一个 32 位的表示。在双精度浮点格式中，s、exp 和 frac 字段分别为 1 位、k = 11 位和 n = 52 位，得到一个 64 位的表示。</p>
<p><img src="/img/CSAPP.assets/1722992357904.png" alt=""></p>
<p>给定位表示，根据 exp 的值，被编码的值可以分成三种不同的情况。</p>
<p><img src="/img/CSAPP.assets/1722992781731.png" alt=""></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>阶码</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td>规格化的值</td>
<td>\(E=e-Bias\)，\(Bias=2^{k-1}-1\)</td>
<td>\(M=1+f\)</td>
</tr>
<tr>
<td>非规格化的值</td>
<td>\(E=1-Bias\)</td>
<td>\(M=f\)</td>
</tr>
</tbody>
</table>
<p><img src="/img/CSAPP.assets/1722994306389.png" alt=""></p>
<p>这种表示具有一个有趣的属性，假如我们将图 2-35 中的值的位表达式解释为无符号整数，它们就是按升序排列的，就像它们表示的浮点数一样。IEEE 格式如此设计就是为了浮点数能够使用整数排序函数来进行排序。当处理负数时，有一个小的难点，因为它们有开头的 1，并且它们是按照降序出现的，但是不需要浮点运算来进行比较也能解决这个问题。</p>
<p>IEEE 浮点格式定义了四种不同的舍入方式：向偶数舍入（默认），向零舍入，向下舍入，向上舍入。向偶数舍入指的是，将正中间的值向偶数舍入。IEEE 标准中的浮点加法和乘法是可交换的，具有单调性，但是不可结合，不具有分配性。</p>
<h2 id="存储器的层次结构">存储器的层次结构</h2>
<h3 id="存储技术">存储技术</h3>
<h4 id="随机访问存储器">随机访问存储器</h4>
<p>随机访问存储器（Random-Access Memory，RAM）分为两类：静态的和动态的。静态 RAM（SRAM）比动态 RAM（DRAM）更快，但也更贵。SRAM 通常用来作为高速缓存存储器，DRAM 通常用来作为主存以及图形系统的帧缓冲区。</p>
<h5 id="静态-RAM">静态 RAM</h5>
<p>SRAM 将每个位存储在一个双稳态的（bistable）存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压配置（configuration）或状态（state）之一。由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除时，电路就会恢复到稳定值。</p>
<h5 id="动态-RAM">动态 RAM</h5>
<p>DRAM 将每个位存储为对一个电容的充电。这个电容非常小，通常只有大约 \(30\times 10^{-15}\) 法拉（femtofarad）。DRAM 存储器单元对干扰非常敏感，当电容的电压被扰乱之后，它永远都不会恢复。内存系统必须周期性地通过读出，然后重写来刷新内存每一位。有些系统也使用纠错码，其中计算机的字会被多编码几位（例如 64 位的字可能用 72 位来编码），这样一来，电路可以发现并纠正一个字中任何单个的错误位。</p>
<p><img src="/img/CSAPP.assets/1723018724301.png" alt=""></p>
<h4 id="非易失性存储器">非易失性存储器</h4>
<p>如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是易失的（volatile）。另一方面，非易失性存储器（nonvolatile memory）即使是在关电后，仍然保存着它们的信息。现在有很多种非易失性存储器。由于历史原因，虽然 ROM 中有的类型既可以读也可以写，但是它们整体上都被称为只读存储器（Read-Only Memory，ROM）。ROM 是以它们能够被重编程（写）的次数和对它们进行重编程所用的机制来区分的。</p>
<p>存储在 ROM 设备中的程序通常被称为固件（firmware）。当一个计算机系统通电以后，它会运行存储在 ROM 中的固件。一些系统在固件中提供了少量基本的输入和输出函数，例如 PC 的 BIOS（基本输入/输出系统）例程。复杂的设备，像图形卡和磁盘驱动控制器，也依赖固件翻译来自 CPU 的 I/O（输入/输出）请求。</p>
<h4 id="总线事务">总线事务</h4>
<p>数据流通过称为总线（bus）的共享电子电路在处理器和 DRAM 主存之间来来回回。每次 CPU 和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为<strong>总线事务</strong>（bus transaction）。<strong>读事务</strong>（read transaction）从主存传送数据到 CPU。<strong>写事务</strong>（write transaction）从 CPU 传送数据到主存。</p>
<p>总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。例如，当前事务是到主存还是到诸如磁盘控制器这样的其他 I/O 设备，事务是读还是写，总线上的信息是地址还是数据项。</p>
<p><img src="/img/CSAPP.assets/1723020094053.png" alt=""></p>
<p>图 6-6 展示了一个示例计算机系统的配置。主要部件是 CPU 芯片、我们将称为 I/O 桥接器（I/O bridge）的芯片组（其中包括内存控制器），以及组成主存的 DRAM 内存模块。这些部件由一对总线连接起来，其中一条总线是<strong>系统总线</strong>（system bus），它连接 CPU 和 I/O 桥接器，另一条总线是<strong>内存总线</strong>（memory bus），它连接 I/O 桥接器和主存。I/O 桥接器将系统总线的电子信号翻译成内存总线的电子信号。I/O 桥也将系统总线和内存总线连接到 I/O 总线，像磁盘和图形卡这样的 I/O 设备共享 I/O 总线。</p>
<h4 id="磁盘存储">磁盘存储</h4>
<h5 id="磁盘构造">磁盘构造</h5>
<p>磁盘是由<strong>盘片</strong>（platter）构成的。每个盘片有两面或者称为<strong>表面</strong>（surface），表面覆盖着磁性记录材料。盘片中央有一个可以旋转的<strong>主轴</strong>（spindle），它使得盘片以固定的<strong>旋转速率</strong>（rotational rate）旋转，通常是 5400 ~ 15000 <strong>转每分钟</strong>（Revolution Per Minute，RPM）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。</p>
<p>图 6-9a 展示了一个典型的磁盘表面的结构。每个表面是由一组称为磁道（track）的同心圆组成的。每个磁道被划分为一组<strong>扇区</strong>（sector）。每个扇区包含相等数量的数据位（通常是 512 字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些<strong>间隙</strong>（gap）分隔开，这些间隙中不存储数据位。间隙存储用来标识扇区的格式化位。</p>
<p><img src="/img/CSAPP.assets/1723021002985.png" alt=""></p>
<p>磁盘是由一个或多个叠放在一起的盘片组成的，它们被封装在一个密封的包装里，如图 6-9b 所示。整个装置通常被称为<strong>磁盘驱动器</strong>（disk drive），我们通常简称为<strong>磁盘</strong>（disk）。有时，我们会称磁盘为<strong>旋转磁盘</strong>（rotating disk），以使之区别于基于闪存的固态硬盘（SSD），SSD 是没有移动部分的。</p>
<p>磁盘制造商通常用术语<strong>柱面</strong>（cylinder）来描述多个盘片驱动器的构造，这里，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。例如，如果一个驱动器有三个盘片和六个面，每个表面上的磁道的编号都是一致的，那么柱面 k 就是 6 个磁道 k 的集合。</p>
<h5 id="磁盘操作">磁盘操作</h5>
<p>磁盘用<strong>读/写头</strong>（read/write head）来读写存储在磁性表面的位，而读写头连接到一个<strong>传动臂</strong>（actuator arm）一端，如图 6-10a 所示。通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为<strong>寻道</strong>（seek）。一旦读/写头定位到了期望的磁道上，那么当磁道上的每个位通过它的下面时，读/写头可以感知到这个位的值（读该位），也可以修改这个位的值（写该位）。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头，如图 6-10b 所示。读/写头垂直排列，一致行动。在任何时刻，所有的读/写头都位于同一个柱面上。</p>
<p><img src="/img/CSAPP.assets/1723021907724.png" alt=""></p>
<p>磁盘以扇区大小的块来读写数据。对扇区的<strong>访问时间</strong>（access time）有三个主要的部分：<strong>寻道时间</strong>（seek time）、<strong>旋转时间</strong>（rotational latency）和<strong>传送时间</strong>（transfer time）。</p>
<h5 id="逻辑磁盘块">逻辑磁盘块</h5>
<p>正如我们看到的那样，现代磁盘构造复杂，有多个盘面，这些盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，现代磁盘将它们的构造呈现为一个简单的视图，一个 B 个扇区大小的<strong>逻辑块</strong>的序列。磁盘封装中有一个小的硬件/固件设备，称为<strong>磁盘控制器</strong>，维护着逻辑块号和实际（物理）磁盘扇区之间的映射关系。当操作系统想要执行一个 I/O 操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个（盘面，磁道，扇区）的三元组，这个三元组唯一地标识了对应的物理扇区。控制器上的硬件会解释这个三元组，将读/写头移动到适当的柱面，等待扇区移动到读/写头下，将读/写头感知到的位放到控制器上的一个小缓冲区中，然后将它们复制到主存中。</p>
<h3 id="局部性原理">局部性原理</h3>
<p>局部性通常有两种不同的形式：<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）。在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</p>
<h3 id="存储器层次结构">存储器层次结构</h3>
<p>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k + 1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。数据总是以块大小为<strong>传送单元</strong>（transfer unit）在第 k 层和第 k + 1 层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。</p>
<p><img src="/img/CSAPP.assets/1723023834271.png" alt=""></p>
<p><img src="/img/CSAPP.assets/1723026787216.png" alt=""></p>
<h3 id="高速缓存存储器">高速缓存存储器</h3>
<p>早期计算机系统的存储器层次结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入 SRAM 高速缓存存储器。</p>
<p>缓存不命中的种类：强制性不命中/冷不命中、冲突不命中和容量不命中。</p>
<p>高速缓存的种类：直接映射高速缓存、组相联高速缓存和全相联高速缓存。</p>
<p>写的策略：直写 + 非写分配、写回 + 写分配。</p>
<h4 id="组织结构">组织结构</h4>
<p>考虑一个计算机系统，其中每个存储器地址有 \(m\) 位，形成 \(M=2^{m}\) 个不同的地址。如图 6-25a 所示，这样一个机器的高速缓存被组织成一个有 \(S=2^{s}\) 个高速缓存组（cache set）的数组。每个组包含 \(E\) 个高速缓存行（cache line）。每个行是由一个 \(B=2^{b}\) 字节的数据块（block）组成的，一个有效位（valid bit）指明这个行是否包含有意义的信息，还有 \(t=m-(b+s)\) 个标记位（tag bit）（是当前块的内存地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。</p>
<p><img src="/img/CSAPP.assets/1723027569074.png" alt=""></p>
<h2 id="链接">链接</h2>
<h3 id="加载可执行目标文件">加载可执行目标文件</h3>
<p>要运行可执行目标文件 <code>prog</code>，我们可以在 Linux shell 的命令行中输入它的名字 <code>./prog</code>。因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 <code>prog</code> 是一个可执行目标文件，shell 进程会生成一个子进程，它是父进程的一个复制。子进程通过 <code>execve</code> 系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和推段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的内容。</p>
<p>最后，加载器跳转到程序的入口点，也就是 <code>_start</code> 函数的地址。这个函数是在系统目标文件 <code>ctrl.o</code> 中定义的，对所有的 C 程序都是一样的。<code>_start</code> 函数调用系统启动函数 <code>__libc_start_main</code>，该函数定义在 <code>libc.so</code> 中。它初始化执行环境，调用用户层的 <code>main</code> 函数，处理 <code>main</code> 函数的返回值，并且在需要的时候把控制返回给内核。</p>
<p>除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制，直到 CPU 引用一个被映射的虚拟页时才会进行复制。此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p>
<p><img src="/img/CSAPP.assets/1723030191357.png" alt=""></p>
<p>Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间，类似于图 7-15 中所示。在 Linux x86-64 系统中，代码段总是从地址 0×400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址（\(2^{48}-1\)）开始，向较小内存地址增长。栈上的区域，从地址 \(2^{48}\) 开始，是为内核（kernel）中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。</p>
<p>为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于<code>.data</code> 段有对齐要求，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR）。虽然每次程序运行时这些区域的地址都会改变，但它们的相对位置是不变的。</p>
<h2 id="异常控制流">异常控制流</h2>
<p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列 \(a_{0},a_{1},\cdots,a_{n-1}\) 其中，每个 \(a_{k}\) 是某个相应的指令 \(I_{k}\) 的地址。每次从 \(a_{k}\) 到 \(a_{k+1}\) 的过渡称为<strong>控制转移</strong>（control transfer）。这样的控制转移序列叫做处理器的<strong>控制流</strong>（flow of control，control flow）。</p>
<p>最简单的一种控制流是一个“平滑的”序列，其中每个 \(I_{k}\) 和 \(I_{k+1}\) 在内存中都是相邻的。这种平滑流的突变（也就是 \(I_{k+1}\) 与 \(I_{k}\) 不相邻）通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。</p>
<p>但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流</strong>（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<h3 id="异常">异常</h3>
<p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。</p>
<p><strong>异常</strong>（exception）就是控制流中的突变，用来响应处理器状态中的某些变化。图 8-1 展示了基本的思想。在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 \(I_{curr}\)。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件</strong>（event）。事件可能和当前指令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。</p>
<p><img src="/img/CSAPP.assets/1723078899085.png" alt=""></p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>（exception table）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的<strong>异常处理程序</strong>（exception handler）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令 \(I_{curr}\)，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 \(I_{next}\)，如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ul>
<h3 id="异常处理">异常处理</h3>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>（exception number）。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p><img src="/img/CSAPP.assets/1723079742524.png" alt=""></p>
<p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为异常表的跳转表，使得表目 k 包含异常 k 的处理程序的地址。图 8-2 展示了异常表的格式。在运行时（当系统在执行某个程序时），处理器检测到发生了一个事件，并且确定了相应的异常号。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k，转到相应的处理程序。图 8-3 展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>（exception table base register）的特殊 CPU 寄存器里。</p>
<p><img src="/img/CSAPP.assets/1723079814153.png" alt=""></p>
<h3 id="异常分类">异常分类</h3>
<h4 id="中断">中断</h4>
<p>中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为<strong>中断处理程序</strong>（interrupt handler）。</p>
<h4 id="陷阱和系统调用">陷阱和系统调用</h4>
<p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p><img src="/img/CSAPP.assets/1723079926034.png" alt=""></p>
<h4 id="故障">故障</h4>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。</p>
<h4 id="终止">终止</h4>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。</p>
<h3 id="进程">进程</h3>
<p>异常是允许操作系统内核提供<strong>进程</strong>（process）概念的基本构造块。进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的<strong>上下文</strong>（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。每次用户通过向 shell 输人一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。进程提供给程序的关键抽象：程序好像独占地使用处理器（<strong>时分共享</strong>）和内存（<strong>虚拟内存</strong>）。</p>
<h4 id="用户模式和内核模式">用户模式和内核模式</h4>
<p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在<strong>内核模式</strong>中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>
<p>没有设置模式位时，进程就运行在<strong>用户模式</strong>中。用户模式中的进程不允许执行<strong>特权指令</strong>（privileged instruction），比如停止处理器、改变模式位，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p>
<h4 id="上下文切换">上下文切换</h4>
<p>操作系统内核使用一种称为<strong>上下文切换</strong>（context switch）的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在较低层异常机制之上的。在进程执行的某些时刻，内核可以决定抢占当前进程，并使用上下文切换来将控制转移到新的进程。这种决策就叫做<strong>调度</strong>（scheduling），是由内核中称为<strong>调度器</strong>（scheduler）的代码处理的。上下文切换的步骤：① 保存当前进程的上下文，② 恢复某个先前被抢占的进程被保存的上下文，③ 将控制传递给这个新恢复的进程。</p>
<p><img src="/img/CSAPP.assets/1723083860508.png" alt=""></p>
<p>图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。在这个例子中，进程 A 初始运行在用户模式中，直到它通过执行系统调用 read 陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。</p>
<h2 id="虚拟内存">虚拟内存</h2>
<h3 id="虚拟寻址">虚拟寻址</h3>
<p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址</strong>（Physical Address，PA）。使用虚拟寻址时，CPU 通过生成一个<strong>虚拟地址</strong>（Virtual Address，VA）来访问主存。之后 CPU 上被称为<strong>内存管理单元</strong>（Memory Management Unit，MMU）的专用硬件，利用存放在主存中的查询表来动态的将虚拟地址翻译为物理地址，该表的内容由操作系统管理。</p>
<p><img src="/img/CSAPP.assets/1723089151589.png" alt=""></p>
<h3 id="页面缓存">页面缓存</h3>
<p>概念上而言，虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。VM 系统通过将虚拟内存分割为固定大小的<strong>虚拟页</strong>（Virtual Page，VP），每个虚拟页的大小为 \(P=2^{p}\) 字节。类似地，物理内存被分割为<strong>物理页</strong>（Physical Page，PP），大小也为 \(P\) 字节。</p>
<p>虚拟页面的集合被分为三个不相交的子集：</p>
<ul>
<li>
<p>未分配的：VM 系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</p>
</li>
<li>
<p>已缓存的：已缓存在物理内存中的已分配页。</p>
</li>
<li>
<p>未缓存的：未缓存在物理内存中的已分配页。</p>
</li>
</ul>
<p><img src="/img/CSAPP.assets/1723090092259.png" alt=""></p>
<p>图 9-3 的示例展示了一个有 8 个虚拟页的小虚拟内存。虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。页 2、5 和 7 已被分配，但是当前并未缓存在主存中。</p>
<h4 id="页表">页表</h4>
<p>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和存放在物理内存中被称为<strong>页表</strong>（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p><img src="/img/CSAPP.assets/1723098406460.png" alt=""></p>
<p>图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。目前，我们将假设每个 PTE 是由一个有效位（valid bit）和一个 n 位地址字段组成的。有效位表明该虚拟页当前是否被缓存在 DRAM 中。如果设置了有效位，那么地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个 null 地址表示这个虚拟页还未被分配，否则这个地址就指向该虚拟页在磁盘上的起始位置（即已分配但未缓存）。</p>
<h4 id="缺页">缺页</h4>
<p><img src="/img/CSAPP.assets/1723103059482.png" alt=""></p>
<p>在虚拟内存的习惯说法中，DRAM 缓存不命中称为<strong>缺页</strong>（page fault）。图 9-6 展示了在缺页之前我们的示例页表的状态。CPU 引用了 VP3 中的一个字，VP3 并未缓存在 DRAM 中。地址翻译硬件将虚拟地址作为索引来定位 PTE3，并从内存中读取它。从有效位推断出 VP3 未被缓存，从而触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在 PP3 中的 VP4。如果 VP4 已被修改，那么内核会将它复制回磁盘。无论哪种情况，内核都会修改 VP4 的页表条目，反映出 VP4 不再缓存在主存中这一事实。</p>
<p><img src="/img/CSAPP.assets/1723099103451.png" alt=""></p>
<p>之后，内核从磁盘复制 VP3 到内存中的 PP3，更新 PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP3 已被缓存在主存中，那么页命中也能由地址翻译硬件正常处理。图 9-7 展示了在缺页之后我们的示例页表的状态。</p>
<p><img src="/img/CSAPP.assets/1723099598262.png" alt=""></p>
<h3 id="内存管理">内存管理</h3>
<p>到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。图 9-9 展示了基本思想。注意，多个虚拟页面可以映射到同一个物理页面上（页面共享）。</p>
<p><img src="/img/CSAPP.assets/1723100192553.png" alt=""></p>
<h3 id="内存保护">内存保护</h3>
<p>任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。不应该允许一个用户进程修改它的只读代码段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写其他进程的私有内存，并且不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做（通过调用明确的进程间通信系统调用）。</p>
<p><img src="/img/CSAPP.assets/1723101059965.png" alt=""></p>
<p>每次 CPU 生成一个虚拟地址时，地址翻译硬件都会读一个 PTE，所以可以在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问。图 9-10 展示了基本思想。在这个示例中，每个 PTE 中添加了三个许可位。SUP 位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。READ 位和 WRITE 位控制对页面的读写访问。如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般将这种异常报告为“段错误（segmentation fault）”。</p>
<h3 id="地址翻译">地址翻译</h3>
<p>CPU 中的一个控制寄存器，页表基址寄存器（Page Table Base Register，PTBR）指向当前页表。\(n\) 位的虚拟地址包含两个部分：一个 \(p\) 位的虚拟页面偏移（Virtual Page Offset，VPO）和一个 \((n - p)\) 位的虚拟页号（Virtual Page Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。将页表条目中物理页号（Physical Page Number，PPN）和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。</p>
<p><img src="/img/CSAPP.assets/1723102631207.png" alt=""></p>
<h4 id="快表">快表</h4>
<p>每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2 个周期。然而，许多系统都试图消除即使是这样的开销，它们在 MMU 中包括了一个关于 PTE 的小缓存，称为快表（Translation Lookaside Buffer，TLB）。</p>
<p><img src="/img/CSAPP.assets/1723103916101.png" alt=""></p>
<h4 id="多级页表">多级页表</h4>
<p>到目前为止，我们一直假设系统只用一个单独的页表来进行地址翻译。但是如果我们有一个 32 位的地址空间、4KB 的页面和一个 4 字节的 PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。对于地址空间为 64 位的系统来说，问题将变得更复杂。使用多级页表，时间换空间。</p>
<p><img src="/img/CSAPP.assets/1723104790652.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-05T13:35:47.814Z" title="2024/8/5 下午9:35:47">2024-08-05</time>发表</span><span class="level-item"><time dateTime="2024-08-06T03:08:10.924Z" title="2024/8/6 上午11:08:10">2024-08-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><span> / </span><a class="link-muted" href="/categories/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span><span class="level-item">5 分钟读完 (大约746个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><div class="content"><p>推荐网站 <a target="_blank" rel="noopener" href="https://refactoringguru.cn/%EF%BC%8Chttps://sourcemaking.com/%E3%80%82">https://refactoringguru.cn/，https://sourcemaking.com/。</a></p>
<h2 id="创建型模式">创建型模式</h2>
<h3 id="单例模式"><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/singleton">单例模式</a></h3>
<h4 id="定义">定义</h4>
<p>单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<h4 id="结构">结构</h4>
<p><img src="/img/Design_Patterns.assets/1722905875878.png" alt=""></p>
<h4 id="应用">应用</h4>
<p>程序中的某个类对于所有客户端只有一个可用的实例时，需要更加严格地控制全局变量时。</p>
<h4 id="实现">实现</h4>
<ul>
<li>提前创建单例：适用于频繁使用，或者单例占用资源较少的情况。最简单创建单例的方式是使用枚举类。</li>
<li>延迟创建单例：存在多线程问题，可以直接使用 <code>synchronized</code> 对整个方法进行同步。但实际上只有在第一次调用时才需要同步，所以更优的实现是使用<strong>双重检查加锁</strong>（双检锁）以及 <code>volatile</code> 关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">public</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题">问题</h4>
<p>当使用多个类加载器、反射和序列化/反序列化时，要注意避免创建多个单例实例。</p>
<h2 id="结构型模式">结构型模式</h2>
<h3 id="代理模式"><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/proxy">代理模式</a></h3>
<h4 id="定义-2">定义</h4>
<p>代理模式是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p>
<h4 id="结构-2">结构</h4>
<p><img src="/img/Design_Patterns.assets/1722846590984.png" alt=""></p>
<h4 id="应用-2">应用</h4>
<p>远程代理（本地执行远程服务），虚拟代理（延迟初始化），保护代理（访问控制），缓存代理（缓存请求结果），日志记录代理（记录日志请求），智能引用代理，等等。</p>
<h4 id="实现-2">实现</h4>
<p>Java 在 java.lang.reflect 包中有自己的代理支持，利用该包可以动态地创建代理类，所以该技术被称为<strong>动态代理</strong>。</p>
<p>使用步骤：</p>
<ul>
<li>实现 <code>InvocationHandler</code> 接口。</li>
<li>以指定的对象和 <code>InvocationHandler</code> 实现类为参数，调用 <code>Proxy.newProxyInstance</code> 方法，创建代理对象。</li>
<li>将代理对象强制类型转换为指定的对象所实现的某个接口类型，然后调用方法。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 逻辑处理</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(person, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getProxyInstance</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) Proxy.newProxyInstance(</span><br><span class="line">                person.getClass().getClassLoader(),</span><br><span class="line">                person.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(person));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getProxyInstance</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) Proxy.newProxyInstance(</span><br><span class="line">                person.getClass().getClassLoader(),</span><br><span class="line">                person.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(person));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonImpl</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> getProxyInstance(person);</span><br><span class="line">        proxyInstance.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-05T03:58:17.939Z" title="2024/8/5 上午11:58:17">2024-08-05</time>发表</span><span class="level-item"><time dateTime="2024-08-05T07:34:55.326Z" title="2024/8/5 下午3:34:55">2024-08-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></span><span class="level-item">2 小时读完 (大约18208个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/05/Java%20%E5%9F%BA%E7%A1%80/">Java 基础</a></p><div class="content"><h2 id="术语">术语</h2>
<table>
<thead>
<tr>
<th>术语名</th>
<th style="text-align:center">缩写</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java Development Kit（Java 开发工具包）</td>
<td style="text-align:center">JDK</td>
<td>编写 Java 程序的程序员使用的软件</td>
</tr>
<tr>
<td>Java Runtime Environment（Java 运行时环境）</td>
<td style="text-align:center">JRE</td>
<td>运行 Java 程序的用户使用的软件</td>
</tr>
<tr>
<td>Standard Edition（标准版）</td>
<td style="text-align:center">SE</td>
<td>用于桌面或简单服务器应用的 Java 平台</td>
</tr>
<tr>
<td>Enterprise Edition（企业版）</td>
<td style="text-align:center">EE</td>
<td>用于复杂服务器应用的 Java 平台</td>
</tr>
<tr>
<td>Micro Edition（微型版）</td>
<td style="text-align:center">ME</td>
<td>用于小型设备的 Java 平台</td>
</tr>
<tr>
<td>OpenJDK</td>
<td style="text-align:center">—</td>
<td>Java SE 的一个免费开源实现</td>
</tr>
</tbody>
</table>
<h2 id="命名规则">命名规则</h2>
<p>变量名必须是<strong>一个以字母开头并由字母或数字构成的序列</strong>。字母包括英文字母、下划线、$，或在某种语言中表示字母的任何 Unicode 字符。数字包括 0~9 和在某种语言中表示数字的任何 Unicode 字符。</p>
<p>如果想要知道哪些 Unicode 字符属于 Java 中的“字母”，可以使用 Character 类的 <code>isJavaIdentifierStart</code> 和 <code>isJavaIdentifierPart</code> 方法来检查。</p>
<p>不要在自己的代码中使用 $ 字符，它只用在 Java 编译器或其他工具生成的名字中。</p>
<h2 id="数据类型">数据类型</h2>
<h3 id="1-基本类型">1. 基本类型</h3>
<h4 id="1-1-整型">1.1 整型</h4>
<p>Java 整型的范围与运行 Java 代码的机器无关。</p>
<p>长整型数值有一个后缀 L 或 l，十六进制数值前有一个前缀 0x 或 0X，八进制有一个前缀 0。</p>
<p>从 Java 7 开始，可以加上前缀 0b 或 0B 表示二进制数，还可以为数字字面量加下划线（如 1_000_000 表示 100 万）。下划线只是为了让数字更易读，Java 编译器在编译时会去除这些下划线。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>4 字节</td>
<td>-2,147,483,648 ~ 2,147,483,647（刚刚超过 20 亿）</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-32,768 ~ 32,767</td>
</tr>
<tr>
<td>long</td>
<td>8 字节</td>
<td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>byte</td>
<td>1 字节</td>
<td>-128 ~ 127</td>
</tr>
</tbody>
</table>
<h4 id="1-2-浮点类型">1.2 浮点类型</h4>
<p>float 类型的数值有一个后缀 F 或 f，没有后缀 F 的浮点数值默认为 double 类型。</p>
<p>由于浮点数值采用二进制系统表示，而二进制系统无法精确表示分数 1/10，所以浮点数值存在<strong>舍入误差</strong>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4 字节</td>
<td>大约 ± 3.40282347E+38F（有效位数为 6 ~ 7 位）</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
<td>大约 ± 1.79769313486231570E+308（有效位数为 15 位）</td>
</tr>
</tbody>
</table>
<p>浮点数值计算遵循 IEEE 754 规范。<strong>一个正数除以 0 的结果为无穷大，0 除以 0 的结果为 NaN。</strong></p>
<table>
<thead>
<tr>
<th>特殊的浮点数值</th>
<th>表示方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>正无穷大</td>
<td><code>Double.POSITIVE_INFINITY</code></td>
</tr>
<tr>
<td>负无穷大</td>
<td><code>Double.POSITIVE_INFINITY</code></td>
</tr>
<tr>
<td>NaN（不是一个数字）</td>
<td><code>Double.NaN</code></td>
</tr>
</tbody>
</table>
<p>要判断一个特定值是否等于 <code>Double.NaN</code>，不能使用 == 判断，需要使用 <code>Double.isNaN</code> 方法来判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == Double.NaN) <span class="comment">// is never true</span></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(x)) <span class="comment">// check whether x is &quot;not a number&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-char-类型">1.3 char 类型</h4>
<p>Java 的 char 类型占用两个字节，使用 Unicode 字符集，并且采用 UTF-16 编码方式。</p>
<p>一个 Unicode 字符在 UTF-16 编码中由 1 ~ 2 个代码单元组成，一个 char 值表示 UTF-16 编码中的一个代码单元。（看不懂可忽略，只要知道一个 Unicode 字符由 1 ~ 2 个 char 值描述就行）</p>
<p>char 类型可以使用转义序列 \u 表示，例如 \u0061 表示字符 a。</p>
<p>\u 转义序列与其他转义序列不同，它可以出现在加引号的字符常量或字符串之外。如下所示，第一行代码中的 \u005B 和 \u005D 分别是 [ 和 ] 的编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String\u005B\u005D args)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是 Unicode 转义序列会在解析代码前进行处理。例如，下面的代码看上去是一个注释，但是会产生一个语法错误，因为<code>\u000A</code>会被替换为一个换行符。（还有一个错误，能看出来么）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \u000A is a newline</span></span><br><span class="line"><span class="comment">// look inside c:\user</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\u0022+\u0022&quot;</span>; <span class="comment">// 表示一个空串</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-boolean-类型">1.4 boolean 类型</h4>
<p>与 C++ 不同，Java 中的整型值和布尔值之间不能进行相互转换。</p>
<h3 id="2-类型转换">2. 类型转换</h3>
<h4 id="2-1-自动类型转换">2.1 自动类型转换</h4>
<p>在进行运算时，我们经常需要将一种数值类型转换为另一种数值类型，图 2-1 给出了数值类型之间的合法转换。</p>
<p><img src="/img/Java.assets/1665313955255.png" alt=""></p>
<p><strong>在图 2-1 中，6 个实线箭头，表示无信息丢失的转换；另外 3 个虚线箭头，表示可能有精度损失的转换。可以用箭头推出的转换会在运算时自动进行；否则，需要进行强制类型转换。</strong></p>
<h4 id="2-2-强制类型转换">2.2 强制类型转换</h4>
<p><strong>可能损失信息（不是损失精度）的转换，需要通过强制类型转换来完成，如下所示。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">9.997</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> (<span class="type">int</span>)x; <span class="comment">// double -&gt; int</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">9.997</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> (<span class="type">int</span>)Math.round(x); <span class="comment">// long -&gt; int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">x += <span class="number">3.5</span>; <span class="comment">// long -&gt; int（隐式的强制类型转换）</span></span><br></pre></td></tr></table></figure>
<h3 id="3-数组类型">3. 数组类型</h3>
<h4 id="3-1-声明数组">3.1 声明数组</h4>
<p>Java 中数组长度不要求是常量，并且可以为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] c = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;; <span class="comment">//简写形式</span></span><br><span class="line"><span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]; <span class="comment">//长度为 0 的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="2-访问数组">2. 访问数组</h4>
<p>数字数组默认初始化为 0，boolean 数组默认初始化为 false，对象数组默认初始化为 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// for each 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> element : array) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>
<h4 id="3-拷贝数组">3. 拷贝数组</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] smallPrimes = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// 引用数组</span></span><br><span class="line"><span class="type">int</span>[] luckyNumbers = smallPrimes;</span><br><span class="line"><span class="comment">// 拷贝数组</span></span><br><span class="line">luckyNumbers = Arrays.copyOf(smallPrimes, smallPrimes.length);</span><br></pre></td></tr></table></figure>
<h4 id="4-多维数组">4. 多维数组</h4>
<p>可以构造不规则数组，即数组的每一行有不同的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造不规则数组</span></span><br><span class="line"><span class="type">int</span>[][] odds = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; odds.length; i++) &#123;</span><br><span class="line">    odds[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印多维数组</span></span><br><span class="line">System.out.println(Arrays.deepToString(odds));</span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<h3 id="1-算术运算符">1. 算术运算符</h3>
<p><strong>整数进行除法运算，商向零取整。</strong></p>
<p><strong>整数被 0 除将会产生一个异常，而浮点数被 0 除将会得到无穷大或 NaN。</strong></p>
<p>进行取模运算时，数值的正负对结果有什么影响？代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span> % <span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">3</span> % <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span> % -<span class="number">2</span>; <span class="comment">// 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">3</span> % -<span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d %d %d %d&quot;</span>,a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先抛出取模的定义：(a / b) * b + a % b = a。</p>
<p>根据定义算就可以得出正确的结果，或者记住取模的结果和左边的数（被除数）符号相同就行。</p>
<p>取模运算和 <code>floorMod</code> 方法的区别是什么？先看看 <code>floorMod</code> 方法的运行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Math.floorMod(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Math.floorMod(-<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Math.floorMod(<span class="number">3</span>, -<span class="number">2</span>); <span class="comment">// -1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Math.floorMod(-<span class="number">3</span>, -<span class="number">2</span>); <span class="comment">// -1</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;%d %d %d %d&quot;</span>,a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据结果我们可以得出结论，<code>floorMod</code> 方法的结果和右边的数（除数）符号相同。</p>
<p>但为什么会是这个结果呢？让我们来看下 <code>floorMod</code> 的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">floorMod</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> x % y;</span><br><span class="line">    <span class="comment">// if the signs are different and modulo not zero, adjust result</span></span><br><span class="line">    <span class="keyword">if</span> ((mod ^ y) &lt; <span class="number">0</span> &amp;&amp; mod != <span class="number">0</span>) &#123;</span><br><span class="line">            mod += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上源代码可知，<code>floorMod</code> 方法先进行取模运算得到 <code>mod</code>，如果 <code>mod</code> 与除数异号，则将取模的结果加上除数再返回。</p>
<h3 id="2-复合赋值运算符">2. 复合赋值运算符</h3>
<p><strong>如果运算符得到的值，其类型与左侧操作数的类型不同，就会发生强制类型转换，如下所示。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">x += <span class="number">3.5</span>; <span class="comment">// double -&gt; int</span></span><br><span class="line">x = (<span class="type">int</span>)(x + <span class="number">3.5</span>); <span class="comment">//double -&gt; int</span></span><br></pre></td></tr></table></figure>
<h3 id="3-自增与自减运算符">3. 自增与自减运算符</h3>
<p>自增和自减运算符分为前缀和后缀两种形式。<code>++n</code> 为前缀形式，会先加一再参与运算；<code>n++</code> 为后缀形式，先参与运算再加一，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">7</span>, n = <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> * ++m; <span class="comment">// now a is 16, m is 8</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span> * n++; <span class="comment">// now b is 14, n is 8</span></span><br><span class="line">        System.out.println(a + <span class="string">&quot; &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-关系和-boolean-运算符">4. 关系和 boolean 运算符</h3>
<p>注意逻辑运算的<strong>短路求值</strong>，其他的不多说。</p>
<h3 id="5-位运算符">5. 位运算符</h3>
<p><strong>Java 的右移运算符有两种，<code>&gt;&gt;</code> 运算符使用符号位填充高位，<code>&gt;&gt;&gt;</code> 运算符使用 0 填充高位</strong>。C++ 只有 <code>&gt;&gt;</code> 运算符，其结果依赖于具体的实现。</p>
<h3 id="6-运算符的优先级">6. 运算符的优先级</h3>
<p>注意运算符的优先级和结合性！</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]</code>  <code>.()</code> （方法调用）</td>
<td>从左向右</td>
</tr>
<tr>
<td><code>!</code>  <code>~</code>  <code>++</code>  <code>--</code>  <code>+</code>（一元运算）  <code>-</code>（一元运算）  <code>()</code>（强制类型转换）  <code>new</code></td>
<td>从右向左</td>
</tr>
<tr>
<td><code>*</code>  <code>/</code>  <code>%</code></td>
<td>从左向右</td>
</tr>
<tr>
<td><code>+</code>  <code>-</code></td>
<td>从左向右</td>
</tr>
<tr>
<td><code>&lt;&lt;</code>  <code>&gt;&gt;</code>  <code>&gt;&gt;&gt;</code></td>
<td>从左向右</td>
</tr>
<tr>
<td><code>&lt;</code>  <code>&lt;=</code>  <code>&gt;</code>  <code>&gt;=</code>  <code>instanceof</code></td>
<td>从左向右</td>
</tr>
<tr>
<td><code>==</code>  <code>!=</code></td>
<td>从左向右</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>从左向右</td>
</tr>
<tr>
<td><code>^</code></td>
<td>从左向右</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>从左向右</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
<tr>
<td><code>?:</code></td>
<td>从右向左</td>
</tr>
<tr>
<td><code>=</code>  <code>+=</code>  <code>-=</code>  <code>*=</code>  <code>/=</code>  <code>%=</code>  <code>&amp;=</code>  `</td>
<td>=<code>  </code>^=<code>  </code>&lt;&lt;=<code>  </code>&gt;&gt;=<code>  </code>&gt;&gt;&gt;=`</td>
</tr>
</tbody>
</table>
<h2 id="控制流程">控制流程</h2>
<h3 id="1-switch-语句">1. switch 语句</h3>
<p>case 标签可以是：</p>
<ul>
<li>类型为 char、byte、short、int 的常量表达式</li>
<li>枚举常量</li>
<li>从 Java 7 开始，case 标签还可以是字符串字面量</li>
</ul>
<h3 id="2-中断控制流程">2. 中断控制流程</h3>
<p>break 跳出当前循环，continue 跳过本次循环。</p>
<p>带标签的 break 和 continue：将标签放在希望跳出的循环之前，并且必须跟一个冒号。（一般不使用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line"><span class="keyword">while</span>(...) &#123; <span class="comment">// this loop statement is tagged with the lable</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(...) &#123; <span class="comment">// this inner loop is not labeled</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(...)<span class="keyword">break</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jumps here when the break statement executes</span></span><br></pre></td></tr></table></figure>
<p>可以将标签应用到任何语句，甚至是 if 语句或者块语句，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(condition) <span class="keyword">break</span> lable; <span class="comment">//exits block</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jumps here when the break statement executes</span></span><br></pre></td></tr></table></figure>
<h2 id="对象与类">对象与类</h2>
<h3 id="1-对象与对象变量">1. 对象与对象变量</h3>
<p><strong>对象变量</strong>和<strong>对象</strong>的区别是什么？我们看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">deadline</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码中，我们构造了一个 Date 类型的对象，并将这个对象的引用（地址）赋值给了 <code>deadline</code>，这个 <code>deadline</code> 即是对象变量。（Java 中的对象变量可以看作 C++ 中的对象指针）</p>
<h3 id="2、访问修饰符">2、访问修饰符</h3>
<p>常规类（非内部类）的访问修饰符：</p>
<ul>
<li>public：被修饰的类可以被任意类访问。在一个源文件中，只能有一个public修饰的类，并且源文件名必须与public类的名字相同。</li>
<li>缺省：默认的访问修饰符，被修饰的类只能被同一个包中的类访问。</li>
</ul>
<p>字段和方法的访问修饰符：</p>
<ul>
<li>public：被修饰的字段和方法可以被任意类访问。</li>
<li>protected：<strong>被修饰的字段和方法可以被所有子类和同一个包中的类访问。需要注意的是，在不同包中，子类可以访问的是继承的受保护字段及方法，而不能访问父类对象的受保护字段及方法。</strong>（避免滥用保护机制，不能通过派生子类来访问超类对象受保护的字段）</li>
<li>缺省：默认的访问修饰符，被修饰的字段和方法只能被同一个包中的类访问。</li>
<li>private：被修饰的字段和方法只能被所属的类访问。</li>
</ul>
<p>可能 protected 有点难理解，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在不同包中，子类可以访问继承的 protected 字段和方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;salary=&quot;</span> + salary);</span><br><span class="line">        setSalary(<span class="number">1800.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">        <span class="comment">// 在不同包中，子类不能访问父类对象的 protected 字段和方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;salary=&quot;</span> + e.salary);</span><br><span class="line">        e.setSalary(<span class="number">1800.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，Manager 继承 Employee 类，这两个类在不同包中。在 Manager 类中 <code>test1</code> 方法可以正确执行，而 <code>test2</code> 方法会报错。</p>
<h3 id="3-类">3. 类</h3>
<h4 id="3-1-字段">3.1 字段</h4>
<p><strong>实例字段的初始化顺序：</strong></p>
<ul>
<li>如果构造器的第一行调用了另一个构造器，则执行第二个构造器。</li>
<li>执行默认初始化。</li>
<li>按照在类声明中出现的顺序，执行显式初始化、初始化块。</li>
<li>执行构造器主体代码。</li>
</ul>
<p><strong>静态字段的初始化顺序：</strong></p>
<ul>
<li>在类第一次加载的时候，按照类声明中出现的顺序执行显式初始化、静态初始化块。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; staticFoo(); &#125; <span class="comment">// 2.第一个静态初始化块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;nextId=&quot;</span> + nextId); &#125; <span class="comment">// 3.第二个静态初始化块</span></span><br><span class="line"></span><br><span class="line">    &#123; foo(); &#125; <span class="comment">// 6.第一个初始化块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticFoo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;nextId=&quot;</span> + nextId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 7.第二个初始化块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,salary=&quot;</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">double</span> s)</span> &#123;</span><br><span class="line">        <span class="comment">// 8.执行构造器主体代码</span></span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(n, <span class="number">1800.0</span>); <span class="comment">// 5.调用另一个构造函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,salary=&quot;</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,salary=&quot;</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.company.Employee&quot;</span>); <span class="comment">// 1.类加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 4.创建实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nextId=<span class="number">0</span></span><br><span class="line">nextId=<span class="number">7</span></span><br><span class="line">----------</span><br><span class="line">id=<span class="number">0</span>,name=<span class="literal">null</span>,salary=<span class="number">0.0</span></span><br><span class="line">id=<span class="number">0</span>,name=L,salary=<span class="number">0.0</span></span><br><span class="line">id=<span class="number">0</span>,name=张三,salary=<span class="number">1800.0</span></span><br></pre></td></tr></table></figure>
<p>通过上述测试，表明初始化顺序确实如此。注意看代码注释标出的顺序，可以打断点调试看看。</p>
<h4 id="3-2-方法">3.2 方法</h4>
<p>构造器：</p>
<p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时如果不提供参数就是不合法的。</p>
<p>更改器方法和访问器方法：</p>
<p>更改器方法会改变对象的状态，而访问器方法只访问对象而不修改对象。<strong>注意不要编写返回可变对象引用的访问器方法，这会破坏类的封装性！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay; <span class="comment">// BAD</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，如果 Employee 类型的对象调用 <code>getHireDay</code> 方法，将会返回私有的对象引用，这时我们就可以通过这个引用修改对象的值！建议使用克隆返回一个副本。</p>
<p><strong>重载方法：方法的名字相同，参数类型不同。</strong></p>
<p><strong>要完整地描述一个方法，需要指定方法名以及参数类型，这叫做方法的签名。返回类型不是方法签名的一部分，即不能有两个名字相同、参数类型也相同却有不同返回类型的方法。</strong></p>
<p>在进行方法调用时，如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报告一个错误。</p>
<p>参数数量可变的方法：使用 <code>...</code> 可以表示参数数量可变的方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span>... values)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">largest</span> <span class="operator">=</span> Double.NEGATIVE_INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> v : values) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; largest) largest = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> largest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> max(<span class="number">3.1</span>, <span class="number">40.4</span>, -<span class="number">5</span>); <span class="comment">// 编译器将 new double[]&#123;3.1, 40.4, -5&#125; 传递给 max 方法</span></span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他知识点：</p>
<ul>
<li>一个方法可以访问所属类的所有对象的私有数据。</li>
<li>每一个类都可以有一个 main 方法，常用于对类进行单元测试。</li>
<li>Java 中所有方法都必须在类的内部定义，但并不表示它们是内联方法。</li>
<li><strong>Java 程序设计语言总是按值调用，即方法得到的是所有参数值的一个副本。</strong></li>
</ul>
<h4 id="3-3-初始化块">3.3 初始化块</h4>
<p>可以将初始化块放在字段定义之前，这时只能在块中对字段进行赋值，而不能读取字段的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(id); <span class="comment">// 非法</span></span><br><span class="line">        id = <span class="number">7</span>; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-包">4. 包</h3>
<p>一般使用因特网域名以逆序的形式作为包名，然后对不同工程使用不同的子包，以防止相同名字的类产生冲突。</p>
<p>一个类可以使用所属包的所有类，以及其他包中的公共类。我们可以使用<strong>完全限定名</strong>来访问其他包中的公共类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.time.<span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> java.time.LocalDate.now();</span><br></pre></td></tr></table></figure>
<p>也可以使用 import 语句，导入一个特定类或者整个包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.*;</span><br></pre></td></tr></table></figure>
<p>导入后就可以直接使用类名，而不用写出类所属的包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，import 语句应该位于 package 语句的后面，并且只能使用星号（*）导入一个包，而不能一次导入多个包。例如 <code>import java.*</code> 或 <code>import java.*.*</code>。</strong></p>
<p><strong>嵌套的包之间没有任何关系，每一个包都是独立的类集合。用星号导入一个包中的所有类后，使用其子包仍需要显示导入。例如 java.util 包和 java.util.jar 包。</strong></p>
<p>当导入的包存在命名冲突时，例如 java.util 和 java.sql 包都有 Date 类，此时编译器无法确定使用哪一个 Date 类，会出现编译错误。这时需要在类名之前加上完整的包名来解决此问题。</p>
<p>编译器将 java 文件编译为 .class 文件后，.class 文件中的字节码使用的都是完全限定名。我不信，怎么办？尝试分析一下字节码文件吧，我们对如下代码进行编译后，对生成的字节码文件进行反编译试试看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 javap 命令反编译看看。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.company.Main &#123;</span><br><span class="line">  <span class="keyword">public</span> com.company.Main();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">7</span>                  <span class="comment">// class java/util/Date</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">9</span>                  <span class="comment">// Method java/util/Date.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然看不太懂，但看到的确实都是完全限定名诶。。（以后再看看）</p>
<p>之前说的 import 导入都是导入类，而还有一种导入可以导入静态方法和静态字段，我们称之为静态导入，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        out.println(PI);</span><br><span class="line">        out.println(sqrt(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用 import static 导入了 System 类和 Math 类的静态方法和静态字段。</p>
<h3 id="5-内部类">5. 内部类</h3>
<p>使用内部类的主要原因：</p>
<ul>
<li>内部类可以对同一个包中的其它类隐藏。</li>
<li>内部类的方法可以访问外围类的所有数据，包括私有数据。</li>
</ul>
<h4 id="5-1-成员内部类">5.1 成员内部类</h4>
<ul>
<li>可以被所有的访问修饰符修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> outerField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OuterMethod</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> InnerField;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(outerField);</span><br><span class="line">            System.out.println(OuterClass.<span class="built_in">this</span>.outerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-局部内部类">5.2 局部内部类</h4>
<ul>
<li>不能有访问修饰符。</li>
<li>可以访问外部类的字段和方法中的 final 或 effectively final 的局部变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> outerClass.OuterMethod();</span><br><span class="line">        demo.InnerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">InnerMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> outerField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">OuterClass</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OuterClass</span><span class="params">(<span class="type">int</span> outerField)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.outerField = outerField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Demo <span class="title function_">OuterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span> <span class="keyword">implements</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> InnerField;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println(outerField);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，编译器会检测内部类对局部变量的访问，为每一个变量建立相应的实例字段，我们反编译内部类看看结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.company.OuterClass$1InnerClass <span class="keyword">implements</span> <span class="title class_">com</span>.company.Demo &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> InnerField;</span><br><span class="line">  <span class="keyword">final</span> java.lang.String val$s;</span><br><span class="line">  <span class="keyword">final</span> com.company.OuterClass <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">  com.company.OuterClass$1InnerClass();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InnerMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实多出一个 String 类型的字段，还有一个<code>this$0</code>字段指示外围类的引用。</p>
<h4 id="5-3-匿名内部类">5.3 匿名内部类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Demo <span class="title function_">OuterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Demo</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            System.out.println(outerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-4-静态内部类">5.4 静态内部类</h4>
<p><s>为什么内部类中声明的所有静态字段都必须是 final 的？（书上说的）</s></p>
<p><s>为什么常规内部类不能有静态字段和方法，只有静态内部类可以有静态字段和方法？</s></p>
<p>在 Java 8 中，常规内部类如果有静态字段和方法将会报错，如图所示：</p>
<p><img src="/img/Java.assets/1665753547865.png" alt=""></p>
<p>网上很多解释都是说违背了 static 语义，但是感觉解释得不是很让人信服。而且，我在高版本的 JDK 中测试，已经不会报错了。所以，这个规定到底要不要遵守呢？（<em>TODO</em>）以下代码在高版本 JDK 时，不会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        OuterClass.InnerClass.k = <span class="number">100</span>;</span><br><span class="line">        System.out.println(OuterClass.InnerClass.k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<h3 id="1-超类和子类">1. 超类和子类</h3>
<p>关键字 extends 表明正在构造的新类派生于一个已存在的类。这个已存在的类称为超类、基类或父类；新类称为子类、派生类或孩子类。<strong>Java 中的类之间只支持单继承，而接口之间支持多继承。</strong></p>
<p>在子类的构造器中，我们可以使用 super 语句调用超类的构造器（该语句必须是子类构造器的第一条语句），来初始化超类的字段。如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java 编译器就会报告一个错误。</p>
<h3 id="2-初始化顺序">2. 初始化顺序</h3>
<p>继承中的初始化顺序，与普通类的初始化顺序相差不大，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Employee 静态初始化块&quot;</span>); &#125; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> -<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 7</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Employee 非静态初始化块 &quot;</span>);</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Employee 无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">double</span> e)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">// 6</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee 有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;e=&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Manager 静态初始化块&quot;</span>); &#125; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 8</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Manager 非静态初始化块 &quot;</span>);</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">7</span>); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manager 无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(<span class="type">double</span> m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manager 有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m=&quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="number">100.0</span>); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Employee 静态初始化块</span><br><span class="line">Manager 静态初始化块</span><br><span class="line">Employee 非静态初始化块 m=<span class="number">0</span></span><br><span class="line">Employee 无参构造器</span><br><span class="line">Employee 有参构造器</span><br><span class="line">Manager 非静态初始化块 m=<span class="number">100</span></span><br><span class="line">Manager 无参构造器</span><br><span class="line">Manager 有参构造器</span><br></pre></td></tr></table></figure>
<p>不做过多解释，可以参考一下对象与类中描述的初始化顺序。注意看代码注释标出的顺序，可以打断点调试看看。</p>
<h3 id="3-覆盖方法（方法重写）">3. 覆盖方法（方法重写）</h3>
<p><strong>覆盖方法（一般加上 @Override 注解，表示当前方法是覆盖方法）：</strong></p>
<ul>
<li>子类方法的可见性不能低于超类方法。</li>
<li>子类的返回值类型可以改为原返回类型的子类型，此时称这两个方法有可协变的返回类型。</li>
<li>子类方法中声明的异常不能比超类方法中声明的异常更通用。</li>
<li>超类中的 static 方法不能被子类覆盖，但是可以被子类中相同签名的 static 方法隐藏。</li>
<li>参数数量可变的形参换成数组类型构成重写。</li>
</ul>
<p>当子类的返回值类型改为原返回类型的子类型时，编译器会在子类中合成一个桥方法，该方法会调用覆盖的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> package2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package1.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们编译上述代码后，使用 javap -v Manager.class 命令反编译看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">package2</span>.Manager <span class="keyword">extends</span> <span class="title class_">package1</span>.Employee &#123;</span><br><span class="line">  <span class="keyword">public</span> package2.Manager();</span><br><span class="line">  <span class="keyword">public</span> java.lang.Integer <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.Object <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Manager 类中确实合成了桥方法 <code>public java.lang.Object foo()</code>，在该桥方法中会调用覆盖的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.Object <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()Ljava/lang/Object;</span><br><span class="line">    flags: (<span class="number">0x1041</span>) ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokevirtual #<span class="number">13</span>                 <span class="comment">// Method foo:()Ljava/lang/Integer;</span></span><br><span class="line">         <span class="number">4</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lpackage2/Manager;</span><br></pre></td></tr></table></figure>
<h3 id="4-多态（向上转型）">4. 多态（向上转型）</h3>
<p><strong>一个对象变量可以指示多种实际类型的现象称为多态，在运行时能够自动地选择适当的方法，称为动态绑定。</strong></p>
<p>在将超类强制类型转换成子类之前，应该使用 instanceof 进行检查；否则，如果类型不符，将会产生类型转换异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">m</span> <span class="operator">=</span> (Manager) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-抽象类">5. 抽象类</h3>
<p>我们可以使用 abstract 关键字来声明抽象类和抽象方法。<strong>abstract 不能修饰私有方法、静态方法、final 方法/类。</strong></p>
<p>包含抽象方法的类必须被声明为抽象类，但是抽象类可以不包含抽象方法。</p>
<h3 id="6-静态绑定和动态绑定">6. 静态绑定和动态绑定</h3>
<ul>
<li><strong>静态绑定：调用的方法在编译期间就可以确定。private 方法、static 方法、final 方法和构造器是静态绑定的。</strong></li>
<li><strong>动态绑定：在运行时根据对象的实际类型选择调用的方法。</strong></li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">field1</span> <span class="operator">=</span> <span class="string">&quot;Employee Field1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method1</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Employee Method1&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">field2</span> <span class="operator">=</span> <span class="string">&quot;Employee Field2&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method2</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Employee Method2&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">field1</span> <span class="operator">=</span> <span class="string">&quot;Manager Field1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method1</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Manager Method1&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">field2</span> <span class="operator">=</span> <span class="string">&quot;Manager Field2&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method2</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Manager Method2&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        System.out.println(e.field1 + <span class="string">&quot;\n&quot;</span> + e.field2 +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> + e.method1() + <span class="string">&quot;\n&quot;</span> + e.method2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee Field1</span><br><span class="line">Employee Field2</span><br><span class="line">Employee Method1</span><br><span class="line">Manager Method2</span><br></pre></td></tr></table></figure>
<p><strong>可以发现，字段不论静态与否，都是由编译器解析的，因此不是多态的；静态方法也是由编译器解析的（静态绑定），而普通方法是在运行时确定的（动态绑定）。</strong></p>
<h2 id="接口">接口</h2>
<h3 id="1-接口的特点">1. 接口的特点</h3>
<ul>
<li>接口的方法默认是 public abstract 的。</li>
<li>接口的字段必须是 public static final 的。</li>
<li>一个类可以用 extends 扩展多个接口。</li>
</ul>
<h3 id="2-接口中的方法">2. 接口中的方法</h3>
<ul>
<li>可以在接口中添加默认方法，用 default 修饰符标记。</li>
<li>在 Java 8 中，可以在接口中添加静态方法。该方法只能通过接口调用，不能通过实现类及其对象调用。</li>
<li>在 Java 9 中，可以在接口中添加私有方法，私有方法可以是静态方法或默认方法。</li>
</ul>
<h3 id="3-默认方法的冲突">3. 默认方法的冲突</h3>
<p>解决冲突的规则：</p>
<ul>
<li><strong>超类与接口冲突，超类优先</strong>。如果超类提供了一个具体方法，则接口中同名且有相同参数类型的默认方法会被忽略。</li>
<li><strong>接口与接口冲突，覆盖方法</strong>。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法（不论是否是默认方法），则必须覆盖这个方法来解决冲突。</li>
</ul>
<p>下面演示如何解决接口与接口的冲突：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">inter1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">foo</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">inter2</span> &#123;</span><br><span class="line">    String <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> <span class="keyword">implements</span> <span class="title class_">inter1</span>, inter2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inter1.<span class="built_in">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们需要覆盖 <code>foo</code> 方法以解决冲突。在覆盖的方法中，我们可以调用接口中的默认方法，调用格式如上所示。</p>
<h3 id="4-特殊的接口">4. 特殊的接口</h3>
<p>标记接口（tagging interface）：不包含任何方法的接口。作用：可以使用 instanceof 进行类型检查。例如：Cloneable。</p>
<p>函数式接口（functional interface）：只有一个抽象方法的接口。例如：Predicate，Supplier。</p>
<h2 id="lambda-表达式">lambda 表达式</h2>
<h3 id="1-语法">1. 语法</h3>
<p>参数、箭头和表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strs, (String s1, String s2) -&gt; s1.length() - s2.length());</span><br></pre></td></tr></table></figure>
<p>如果代码的计算无法放在一个表达式中，则可以放在<code>&#123;&#125;</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strs, (String s1, String s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果可以推导出参数类型，则可以忽略其类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (s1, s2) -&gt; s1.length() - s2.length();</span><br></pre></td></tr></table></figure>
<p>即使没有参数，仍需要提供空括号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123; <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">0</span>; i--) System.out.println(i); &#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个参数，并且可以推导出类型，这时可以省略小括号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; System.out.println(<span class="string">&quot;...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>lambda 表达式是<strong>延迟执行</strong>的。</li>
<li>lambda 表达式可以捕获外围方法或类中的 final 变量或事实最终变量（effectively final）。</li>
<li>lambda 表达式的体与嵌套块有相同的作用域，在表达式中声明与局部变量同名的参数或局部变量是不合法的。</li>
</ul>
<p>解释一下第二点，事实最终变量，即初始化后不会再赋新值的变量，如下代码中变量 <code>s</code> 就是事实最终变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;Light&quot;</span>, <span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;Alex&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(strs, (String s1, String s2) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在定义变量 <code>s</code> 的语句后添加一个修改语句，lambda 表达式将会报错：</p>
<p><img src="/img/Java.assets/1665740703647.png" alt=""></p>
<h3 id="2-函数式接口">2. 函数式接口</h3>
<p>我们可以把 lambda 表达式赋值给函数式接口类型的对象。注意 Object 类型不是函数式接口类型。</p>
<p>Java API 在 java.util.function 包中定义了很多通用的函数式接口，下面进行简单的介绍。（<em>TODO</em>）</p>
<h3 id="3-方法引用">3. 方法引用</h3>
<p>当 lambda 表达式只调用一个方法，而不做其他操作时，我们可以把 lambda 表达式重写为方法引用。</p>
<p>例如，我们需要对字符串数组排序，而不考虑字母的大小写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strs, (s1, s2) -&gt; s1.compareToIgnoreCase(s2)); <span class="comment">// lambda 表达式</span></span><br><span class="line">Arrays.sort(strs, String::compareToIgnoreCase); <span class="comment">// 方法引用</span></span><br></pre></td></tr></table></figure>
<p><strong>表达式 <code>String::compareToIgnoreCase</code> 是一个方法引用，它指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法</strong>。在这个例子中，会生成一个 Comparator 实例，它的 <code>compare(T o1, T o2)</code> 方法会调用 <code>o1.compareToIgnoreCase(o2)</code> 方法。</p>
<p>使用方法引用的情况主要有三种：</p>
<ul>
<li><code>object::instanceMethod</code>：方法引用等价于向方法传递参数的 lambda 表达式，如 <code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code>。</li>
<li><code>Class::instanceMethod</code>：第一个参数会成为方法的隐式参数，如 <code>String::compareToIgnoreCase</code> 等价于 <code>(x, y) -&gt; x.compareToIgnoreCase(y)</code>。</li>
<li><code>Class::staticMethod</code>：所有的参数都传递到静态方法，如 <code>Math::pow</code> 等价于 <code>(x, y) -&gt; Math.pow(x, y)</code>。</li>
</ul>
<p>可以在方法引用中使用 this 和 super，如 <code>this::instanceMethod</code> 或 <code>super::instanceMethod</code>。</p>
<p>包含对象的方法引用与等价的 lambda 表达式的细微差别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Predicate&lt;String&gt; a = s::equals;</span><br><span class="line">Predicate&lt;String&gt; b = x -&gt; s.equals(x);</span><br></pre></td></tr></table></figure>
<p>在这段代码中，构造方法引用时会立即抛出异常，而 lambda 表达式只在调用时抛出异常。</p>
<h3 id="4-构造器引用">4. 构造器引用</h3>
<p>使用方式为 <code>Class::new</code>，如 <code>int[]::new</code> 或 <code>String::new</code> 等。（<em>TODO</em>）</p>
<h2 id="常用关键字">常用关键字</h2>
<h3 id="1-final">1. final</h3>
<ul>
<li>修饰字段（成员变量）时，该字段不支持默认初始化，必须在构造对象时初始化。静态字段则需要显示初始化或在静态初始化块中初始化。</li>
<li>修饰方法时，该方法不允许覆盖。</li>
<li>修饰类时，该类不允许被继承，且类中的所有方法自动地成为 final 方法。</li>
</ul>
<h3 id="2-this">2. this</h3>
<ul>
<li>指示隐式参数的引用。特别的，在内部类中使用 <code>OuterClass.this</code> 指示外围类的引用；在 lambda 表达式中，指示创建这个表达式的方法的 this 参数。</li>
<li>调用该类的其他构造器。</li>
</ul>
<h3 id="3-super">3. super</h3>
<ul>
<li>调用接口的默认方法，<code>接口名.super.xxx()</code>。</li>
<li>调用超类的方法或字段。</li>
<li>调用超类的构造器。</li>
</ul>
<p>与 this 不同，super 不是对象的引用，不能将 super 赋给另一个对象变量。</p>
<h3 id="4-static">4. static</h3>
<p>可以修饰字段、方法、初始化块、内部类，它们随着类的加载而加载；可以和 import 组合成 import static 静态导入。</p>
<p>需要注意的是，当 static 修饰方法时，该方法不能访问实例字段、不能使用 this 和 super 关键字。</p>
<h3 id="5-instanceof">5. instanceof</h3>
<ul>
<li>可以用来判断 a 是否为类 A 或其子类的实例。</li>
<li>可以用来判断 a 是否实现了 A 接口。</li>
</ul>
<h3 id="6-var（java-10）">6. var（java 10）</h3>
<p>只能用于方法中的局部变量，方法的参数和字段的类型必须显示声明。</p>
<h3 id="7-assert">7. assert</h3>
<p>形式：<code>assert condition</code> 或 <code>assert condition : expression</code>。</p>
<p>这两个语句都会计算条件，如果条件为 false，则抛出 AssertionException 异常。在第二个语句中，expression 将传入 AssertionError 对象的构造器，并转换成一个消息字符串。</p>
<p>在默认情况下，断言是禁用的。我们可以在运行程序时，用如下选项启用或禁用断言。启用断言，-ea/-ea:Class/-ea:Package；禁用断言，-da/-da:Class/-da:Package。选项 -ea 将打开无名包中所有类的断言。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea:MyClass -ea:com.mycompany.mylib MyApp</span><br></pre></td></tr></table></figure>
<p>以上命令将为 MyClass 类以及 com.mycompany.mylib 包和它的子包中的所有类打开断言。</p>
<p>看不懂，待解决（<em>TODO</em>）：{</p>
<p>需要注意的是，不必重新编译程序来启用或禁用断言，因为启用或禁用断言是类加载器的功能。</p>
<p>启用和禁用所有断言的 -ea 和 -da 选项不能应用到没有类加载器的“系统类”上，此时需要使用 -esa 和 -dsa 选项。</p>
<p>}</p>
<h2 id="常用类和接口">常用类和接口</h2>
<h3 id="Object">Object</h3>
<p>Object 类是 Java 中所有类的始祖，我们可以使用 Object 类型的变量引用任何类型的对象。在 Java 中，只有基本类型不是对象，基本类型由于自动装箱可以赋值给 Object 类型的变量。注意：数组也是对象，我们可以把它赋值给 Object 类型的变量，也可以通过数组调用 Object 类中的方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> arr;</span><br><span class="line">        System.out.println(arr.equals(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-equals-方法">1. equals 方法</h4>
<p>Object 类中的 <code>equals</code> 方法比较两个对象的引用是否相等，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们通常需要比较两个对象的状态是否相等，这就需要我们覆盖 Object 类中的 <code>equals</code> 方法。</p>
<p>下面使用 Employee 类举例，给出比较通用的覆盖方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.判断对象的引用是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断 otherObject 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.判断 this 与 otherObject 的类型是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.将 otherObject 强制类型转换为相应的类型</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) otherObject;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.使用 == 比较基本类型，使用 Object.equals 比较引用类型</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, other.name)</span><br><span class="line">                &amp;&amp; salary == other.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意：</strong></p>
<ul>
<li>在第三个判断语句中，两个对象如果类型不同就会返回 false。但是，是否这样实现取决于具体的情况。如果子类判断相等的方式和父类一致，我们可以不强求类型相同，这时使用 <code>if(!(otherObject instanceof Employee)) return false;</code> 语句替换。</li>
<li>在最后的 return 语句中，我们比较 <code>name</code> 对象需要使用<code>Objects.equals</code>，而不能使用<code>name.equals(other.name)</code>。这是因为当 <code>name</code> 为 null 时，使用后一种方式会导致空指针异常。</li>
<li>如果在子类中重新定义 <code>equals</code> 方法，我们需要在 return 语句中包含 <code>super.equals(other)</code> 调用，来判断父类中的字段是否相同。</li>
</ul>
<p>对于数组类型的字段，可以使用静态的 <code>Arrays.equals</code> 方法判断对应的数组元素是否相等。</p>
<h4 id="2-hashCode-方法">2. hashCode 方法</h4>
<p>Object 类中的 <code>hashCode</code> 方法是本地方法，它根据对象的存储地址计算得出散列码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>如果我们重新定义了 <code>equals</code> 方法，那么就要为可能插入散列表的对象重新定义 <code>hashCode</code> 方法。且 <code>equals</code> 与 <code>hashCode</code> 的定义必须相容：如果 <code>x.equals(y)</code> 返回 true，那么 <code>x.hashCode()</code> 就必须与 <code>y.hashCode()</code> 相等。</strong></p>
<p>我们可以使用 <code>Objects.hashCode</code> 或 <code>Objects.hash</code> 方法为自定义类计算散列码。</p>
<p>对于数组类型的字段，可以使用静态的 <code>Arrays.hashCode</code> 方法计算散列码，这个散列码由数组元素的散列码组成。</p>
<h4 id="3-toString-方法">3. toString 方法</h4>
<p>Object 类中的 <code>toString</code> 方法返回的是对象的类名和散列码组成的字符串，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，我们应该为每个自定义的类覆盖 <code>toString</code> 方法，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()</span><br><span class="line">            + <span class="string">&quot;[name=&quot;</span> + name</span><br><span class="line">            + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">            + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好通过调用 <code>getClass().getName()</code> 获取类名字符串，而不要将类名硬编码到 <code>toString</code> 方法中。这样子类调用父类的 <code>toString</code> 方法时，将会获取子类的类型。</p>
<p>打印一维数组可以使用静态的 <code>Arrays.toString</code> 方法，多维数组使用 <code>Arrays.deepToString</code> 方法。</p>
<h4 id="4-clone-方法">4. clone 方法</h4>
<p>Object 类中的 <code>clone</code> 方法为 protected 修饰的本地方法，执行的是浅拷贝，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>如果我们想要使用 <code>clone</code> 方法，需要在类上实现 Cloneable 接口（该接口是标记接口），并指定 public 修饰符。在方法内部，可以调用 Object 类的 <code>clone</code> 方法执行浅拷贝，也可以自己编写执行深拷贝的代码。</p>
<h3 id="字符串">字符串</h3>
<h4 id="1-字符串的共享与常量折叠">1. 字符串的共享与常量折叠</h4>
<p>String 类的对象是不可变的，我们只能改变 String 类型的对象变量的值（即指针的指向），而不能改变对象本身。</p>
<p>字符串字面量是共享的，而用 <code>+</code> 拼接 String 对象变量或执行 <code>substring</code> 等操作得到的字符串不共享，验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;He&quot;</span>, s2 = <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;He&quot;</span> &amp;&amp; s2 == <span class="string">&quot;llo&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;He&quot;</span> + <span class="string">&quot;llo&quot;</span> == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        System.out.println(s1 + <span class="string">&quot;llo&quot;</span> == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s1 + s2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>.substring(<span class="number">0</span>, <span class="number">5</span>) == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果为 <code>s1</code> 和 <code>s2</code> 加上 final 修饰符，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;He&quot;</span>,  s2 = <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">        System.out.println(s1 == <span class="string">&quot;He&quot;</span> &amp;&amp; s2 == <span class="string">&quot;llo&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;He&quot;</span> + <span class="string">&quot;llo&quot;</span> == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        System.out.println(s1 + <span class="string">&quot;llo&quot;</span> == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s1 + s2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>.substring(<span class="number">0</span>, <span class="number">5</span>) == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，第三和第四个判断语句的结果与之前不同，结果为 true。因为编译器有一种称为<strong>常量折叠</strong>的优化技术：它会在编译期间，完成常量之间的计算，而不需要等到运行时计算。我们简化一下上述代码，再使用反编译命令 <code>javap -v Main.class</code>，验证一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;He&quot;</span>,  s2 = <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> s1 + <span class="string">&quot;llo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String He</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">9</span>                  <span class="comment">// String llo</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: ldc           #<span class="number">11</span>                 <span class="comment">// String Hello</span></span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         <span class="number">9</span>: ldc           #<span class="number">11</span>                 <span class="comment">// String Hello</span></span><br><span class="line">        <span class="number">11</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">13</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>根据 ldc 指令可以知道，字符串 Hello 都是从常量池中取的，没有进行 <code>+</code> 拼接操作，这就验证了编译器的常量折叠。</p>
<h4 id="2-码点与代码单元">2. 码点与代码单元</h4>
<p><strong>区分码点与代码单元：一个 UTF-16 编码的 Unicode 字符对应一个码点，对应 1 ~ 2 个 char 值；一个 char 值对应一个代码单元。</strong></p>
<p>如下所示，Unicode 字符 🍺（啤酒杯）的码点为 U+1F37A；它对应两个代码单元，分别是 U+D83C 和 U+DF7A。它也对应两个 char 值，分别是 \uD83C 和 \uDF7A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\uD83C\uDF7A&quot;</span>; <span class="comment">// 🍺（啤酒杯）</span></span><br><span class="line">        System.out.println(s); <span class="comment">// 🍺</span></span><br><span class="line">        System.out.println(Arrays.toString(s.toCharArray())); <span class="comment">// [?, ?]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平时我们都是对代码单元进行遍历，下面是对码点进行遍历的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;I Love \uD83C\uDF7A!&quot;</span>;</span><br><span class="line">        <span class="type">int</span>[] codePoints = str.codePoints().toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : codePoints) &#123;</span><br><span class="line">            System.out.print(v + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(codePoints, <span class="number">0</span>, codePoints.length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-构建字符串">3. 构建字符串</h4>
<p>我们之前说过，用 + 拼接 String 对象变量或执行 <code>substring</code> 等操作得到的字符串不共享。当需要频繁地拼接字符串时，每次执行 <code>+</code> 操作都会构建一个新的 String 对象，既耗时又浪费空间。</p>
<p>这时，我们可以使用 StringBuffer（线程安全）或者 StringBuilder（线程不安全）类，来避免这个问题发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            builder.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装器">包装器</h3>
<p>所有的基本类型都有一个对应的类，这些类被称为包装器。包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值。同时，包装器类还是 final 的，因此不能派生它们的子类。</p>
<h4 id="1-自动装箱与自动拆箱">1. 自动装箱与自动拆箱</h4>
<p>在需要包装器类型时，我们可以直接传递基本数据类型，编译器在编译时，会自动地插入装箱和拆箱的指令。</p>
<p>我们验证一下，先准备如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译代码后，反编译看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: bipush        7</span><br><span class="line">         2: invokestatic  #7                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">         5: astore_1</span><br><span class="line">         6: aload_1</span><br><span class="line">         7: astore_2</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: invokevirtual #13                 // Method java/lang/Integer.intValue:()I</span><br><span class="line">        12: iconst_1</span><br><span class="line">        13: iadd</span><br><span class="line">        14: invokestatic  #7                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">        17: astore_1</span><br><span class="line">        18: aload_2</span><br><span class="line">        19: pop</span><br><span class="line">        20: return</span><br></pre></td></tr></table></figure>
<p>可以看到，编译器会将 7 变换成 <code>Integer.valueOf(7)</code>，然后调用 <code>n.intValue()</code> 拆箱，自增之后再调用 <code>Integer.valueOf</code> 方法装箱。特别注意，自动装箱规范要求 boolean、byte、char ≤ 127，以及在 -128 和 127 之间的 short 和 int 被包装到固定的对象中。</p>
<h4 id="2-类型之间的转换">2. 类型之间的转换</h4>
<p>基本数据类型转换为 String 类型，有以下两种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span> + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> String.valueOf(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>
<p>反编译看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">7</span>                  <span class="comment">// String 7</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">7</span></span><br><span class="line">         <span class="number">5</span>: invokestatic  #<span class="number">9</span>                  <span class="comment">// Method java/lang/String.valueOf:(I)Ljava/lang/String;</span></span><br><span class="line">         <span class="number">8</span>: astore_2</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>可以看到，第一种方法直接从常量池中取字符 7，而没有进行连接。（常量折叠）</p>
<p>包装器装换为 String 类型：先进行拆箱转换为基本数据类型，然后再将基本数据类型转换为 String 类型。</p>
<p>String 转换为基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;7&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>String 转换为包装器类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;7&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="比较器">比较器</h3>
<h4 id="1-Comparable-接口">1. Comparable 接口</h4>
<p>实现了 Comparable 接口的类可以进行自然排序，该接口在 java.lang 包下，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，实现 Comparable 接口需要覆盖 <code>compareTo</code> 方法，该方法比较当前对象与指定对象的顺序：当前对象小于、等于或大于指定对象时，返回负整数、零或正整数。</p>
<p><strong>Comparable 接口的文档建议 <code>CompareTo</code> 方法应当与 <code>equals</code> 方法兼容，即当 <code>x.equals(y) == true</code> 时，<code>x.compareTo(y)  ==  0</code></strong>。特别的，BigDecimal 类不遵从这个建议，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">        System.out.println(x.equals(y)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(x.compareTo(y)); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Comparator-接口">2. Comparator 接口</h4>
<p>如果类的自然排序与需求不匹配，我们可以定义一个实现了 Comparator 接口的类，并将类对象作为参数传入排序方法中，来完成定制排序。</p>
<p>Comparator 接口在 java.util 包下，要实现 Comparator 接口需要覆盖它的 <code>compare</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 Arrays 类的 <code>sort</code> 方法进行演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;Light&quot;</span>, <span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;Alex&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br><span class="line">        System.out.println(Arrays.toString(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Alex, Light, Zero]</span><br><span class="line">----------</span><br><span class="line">[Alex, Zero, Light]</span><br></pre></td></tr></table></figure>
<p>我们还可以利用 lambda 表达式，简化 Comparator 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strs, (s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.length() - s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者调用 Comparator 中的静态方法，并传入一个方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strs, Comparator.comparingInt(String::length));</span><br></pre></td></tr></table></figure>
<h3 id="枚举类">枚举类</h3>
<h4 id="1-定义枚举类">1. 定义枚举类</h4>
<p>我们可以为枚举类添加构造器、方法和字段，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中，<code>SMALL</code>、<code>MEDIUM</code>、<code>LARGE</code>、<code>EXTRA_LARGE</code> 是 Size 类的四个实例，这些实例的定义必须先于方法和字段。并且，Size 类有且仅有这四个实例，因为枚举类的构造器总是私有的，不能再构造其他实例。由于枚举类不可能构造新的对象，在比较两个枚举类型的值时可以直接使用 <code>==</code> 判断。</strong></p>
<h4 id="2-枚举类的超类">2. 枚举类的超类</h4>
<p>所有的枚举类型都是 Enum 类的子类，我们将上述代码编译后，进行反编译看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.company.Size <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.company.Size&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size SMALL;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size MEDIUM;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size LARGE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size EXTRA_LARGE;</span><br><span class="line">  <span class="keyword">private</span> java.lang.String abbreviation;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size[] $VALUES;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.company.Size[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.company.Size <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">private</span> com.company.Size(java.lang.String);</span><br><span class="line">  <span class="keyword">public</span> java.lang.String <span class="title function_">getAbbreviation</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> com.company.Size[] $values();</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，编译器生成的 Size 类是由 final 修饰的，并且继承自 Enum 类。其中的实例字段都被声明为公有的静态常量，这些字段应该是在静态初始化块中完成初始化的。仔细看一下上述结果，我们还可以发现多出了两个方法：<code>values</code> 和 <code>valueOf</code> 方法，这两个方法都是由编译器添加的。</p>
<p>我们简单演示一下比较常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Size.SMALL.toString(); <span class="comment">// 返回枚举常量名</span></span><br><span class="line">        <span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> Enum.valueOf(Size.class, str); <span class="comment">// 常量名转枚举常量</span></span><br><span class="line">        Size[] values = Size.values(); <span class="comment">// 返回一个包含全部枚举常量的数组</span></span><br><span class="line">        <span class="keyword">for</span>(Size v : values) &#123;</span><br><span class="line">            <span class="comment">// 返回枚举常量在类中声明的位置（从零开始）</span></span><br><span class="line">            System.out.println(v.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个与 <code>values</code> 方法类似的方法，即 Class 类中的 <code>getEnumConstants</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.SMALL;</span><br><span class="line">        Size[] enumConstants = s.getClass().getEnumConstants();</span><br><span class="line">        System.out.println(Arrays.toString(enumConstants));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-抽象的枚举类">3. 抽象的枚举类</h4>
<p>如果枚举类中包含抽象方法，或者枚举类实现了某个接口，但没有覆盖其中的抽象方法，这个枚举类将被声明为抽象的。这时，我们必须以内部类的形式对枚举类中的实例完成初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> <span class="keyword">implements</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SMALL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, MEDIUM(<span class="string">&quot;M&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MEDIUM&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们反编译看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">com</span>.company.Size <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.company.Size&gt; <span class="keyword">implements</span> <span class="title class_">com</span>.company.demo &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size SMALL;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size MEDIUM;</span><br><span class="line">  <span class="keyword">private</span> java.lang.String abbreviation;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> com.company.Size[] $VALUES;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.company.Size[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.company.Size <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">private</span> com.company.Size(java.lang.String);</span><br><span class="line">  <span class="keyword">public</span> java.lang.String <span class="title function_">getAbbreviation</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> com.company.Size[] $values();</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类被声明为抽象类！看下文件夹中的文件！</p>
<p><img src="/img/Java.assets/1665715078699.png" alt=""></p>
<p>确实有两个内部类。</p>
<h2 id="异常">异常</h2>
<h3 id="1-Throwable-类">1. Throwable 类</h3>
<p>Java 异常层次结构：</p>
<p><img src="/img/Java.assets/1665803216018.png" alt=""></p>
<p><strong>异常分类：</strong></p>
<ul>
<li>检查型异常：除非检查型异常以外的所有异常。</li>
<li>非检查型异常：派生于 Error 类或 RuntimeException 类的所有异常。</li>
</ul>
<p><strong>一个方法必须声明或捕获所有可能抛出的检查型异常，而非检查型异常要么在控制之外（Error），要么从一开始就应该避免（RuntimeException）。</strong></p>
<h3 id="2-处理异常">2. 处理异常</h3>
<p>一般经验是，要捕获那些你知道如何处理的异常，而继续传播那些你不知道怎样处理的异常。</p>
<h4 id="2-1-抛出异常">2.1 抛出异常</h4>
<p>抛出 EOFException 异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br></pre></td></tr></table></figure>
<h4 id="2-2-声明异常">2.2 声明异常</h4>
<p>在方法的首部声明这个方法可能抛出一个异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<p>如果一个方法可能抛出多个检查型异常，那么需要在方法的首部列出所有的异常类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundException, EOFException</span><br></pre></td></tr></table></figure>
<p>不应该声明从 Error 和 RuntimeException 继承的非检查型异常。</p>
<h4 id="2-3-捕获异常">2.3 捕获异常</h4>
<h5 id="2-3-1-try-catch-finally-语句">2.3.1 try/catch/finally 语句</h5>
<p>下面是关闭输入流的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用规则：</p>
<ul>
<li>一个 catch 可以捕获多个异常，不过需要注意此时异常变量隐含为 final 变量，例如在以下子句体中不能为 <code>e</code> 赋其他值：<code>catch (FileNotFoundException | UnknownHostException e) &#123;...&#125;</code>。</li>
<li>可以在 catch 中将捕获的异常抛出，或者抛出一个新的异常，并使用 <code>initCause</code> 方法将原始异常设置为新异常的“原因”，当捕获到这个新异常时，我们可以使用 <code>getCause</code> 方法获取原始异常。</li>
<li>不管是否有异常被捕获，finally 子句中的代码都会在方法返回之前执行执行。</li>
<li>finally 用于清理资源，不要把改变控制流的语句（return，throw， break，continue）放在 finally 子句中。</li>
</ul>
<p>下面演示在 finally 中使用 return 存在的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;try!!!&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;finally!!!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为 finally!!!，即 finally 中的 return 将会先于 try 中的 return 执行。</p>
<h5 id="2-3-2-try-with-resources-语句">2.3.2 try-with-resources 语句</h5>
<p>在 Java 7 中，如果资源实现了 AutoCloseable 接口，我们可以使用 try-with-resources 语句处理资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try 块退出时，会自动的调用资源的 close 方法，关闭资源。close 是 AutoCloseable 接口中的方法。</p>
<p>使用规则：</p>
<ul>
<li>try-with-resources 语句可以有 catch 和 finally 子句，这些子句在关闭资源之后执行。</li>
<li>在 Java 9 中，可以在 try 首部中提供之前声明的 final 或 effective final 变量。</li>
<li>如果 try 和 close 都抛出异常，则 close 方法抛出的异常会被抑制，并由 <code>addSuppressed</code> 方法增加到 try 中的异常。如果想查看被抑制的异常，我们可以使用 <code>getSuppressed</code> 方法获取被抑制的异常数组。</li>
</ul>
<p>我们对最后一点进行演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(Arrays.toString(e.getSuppressed()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/img/Java.assets/1665820395758.png" alt=""></p>
<h5 id="2-3-3-异常丢失">2.3.3 异常丢失</h5>
<p>Java 的异常实现存在异常丢失的问题，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，我们会发现：在 try 中抛出了异常，它却没有产生任何输出。</p>
<p>这就是异常丢失，如果我们在 finally 中也使用 throw 抛出一个异常，结果只会输出新抛出的异常， try 中的异常同样会丢失。</p>
<h3 id="3-创建异常类">3. 创建异常类</h3>
<p>当遇到标准的异常类无法描述清楚问题时，我们可以创建自己的异常类。自定义的异常类需要派生于 Exception 类或其子类，并且应该包含一个默认构造器和一个包含详细描述信息的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型">泛型</h2>
<h3 id="1-为什么使用泛型">1. 为什么使用泛型</h3>
<p>泛型之前 ArrayList 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)list.get(<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;...&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们希望 list 只存储 String 类型的对象时，原始的 ArrayList 存在两个问题：</p>
<ul>
<li>当获取一个值时，必须进行强制类型转换。</li>
<li>编译器不能进行类型检查，可以向数组列表中添加任何类的值。</li>
</ul>
<h3 id="2-泛型类和泛型方法">2. 泛型类和泛型方法</h3>
<h4 id="2-1-泛型类">2.1 泛型类</h4>
<p>定义泛型类，类型参数用尖括号括起来，放在类名之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象时，可以使用菱形语法省略构造器中的类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="2-2-泛型方法">2.2. 泛型方法</h4>
<p>定义泛型方法，类型参数放在修饰符之后，返回类型之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用一个泛型方法时，可以把具体类型包围在尖括号中，放在方法名之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> Main.&lt;String&gt;getMiddle(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Q.&quot;</span>, <span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>不过，在大多数情况下，方法调用可以省略类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> Main.getMiddle(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Q.&quot;</span>, <span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-类型参数的限定">3. 类型参数的限定</h3>
<p>Java 库使用参数 E 表示集合的元素类型，K 和 V 分别表示表的键和值的类型，T（或者 U 和 S）表示&quot;任意类型&quot;。</p>
<p>我们可以使用 extends 关键字对类型参数进行限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">BoundingType</span>&gt;</span><br></pre></td></tr></table></figure>
<p>以上写法，表示 T 应该是限定类型（bounding type）的子类型（subtype），T 和限定类型可以是类或接口。</p>
<p>一个类型参数或通配符可以有多个限定，限定类型用 &amp; 分隔，而类型参数用逗号分隔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果有一个类作为限定，它必须是限定列表中的第一个限定。</p>
<h3 id="4-类型擦除">4. 类型擦除</h3>
<p>在虚拟机中没有泛型类型对象，所有对象都属于普通类。无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，这个原始类型的名字就是去掉类型参数后的泛型类型名。<strong>类型参数会在编译时被擦除，并替换为其第一个限定类型，对于无限定的类型参数则替换为 Object。</strong></p>
<h4 id="4-1-擦除泛型类">4.1 擦除泛型类</h4>
<p>下面我们定义一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interval</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Interval</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first;upper = second; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second;upper = first; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该泛型类的原始类型如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Interval</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Interval</span><span class="params">(Comparable first, Comparable second)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，如果将限定换为 &lt;T extends Serializable &amp; Comparable&gt;，会用 Serializable 替换 T，而这可能导致在调用 <code>compareTo</code> 方法时需要进行强制类型转换。为了提高效率，应该将标签接口放在限定列表的末尾。</p>
<h4 id="4-2-编译器的工作">4.2 编译器的工作</h4>
<p>① 当调用一个泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(...);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">first</span> <span class="operator">=</span> pair.getFirst();</span><br></pre></td></tr></table></figure>
<p>对字节码文件进行反编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      ...</span><br><span class="line">        <span class="number">32</span>: invokespecial #<span class="number">22</span>                 <span class="comment">// Method com/company/Pair.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;Ljava/lang/Object;)V</span></span><br><span class="line">        <span class="number">35</span>: astore_3</span><br><span class="line">        <span class="number">36</span>: aload_3</span><br><span class="line">        <span class="number">37</span>: invokevirtual #<span class="number">25</span>                 <span class="comment">// Method com/company/Pair.getFirst:()Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">40</span>: checkcast     #<span class="number">7</span>                  <span class="comment">// class com/company/Employee</span></span><br><span class="line">        <span class="number">43</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">45</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>可以看到在调用 <code>getFirst</code> 方法后，进行了 <code>checkcast</code> 强制类型转换的检查。</p>
<p>② 类型擦除与多态存在冲突，为了解决这个问题，编译器会生成桥方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123; <span class="built_in">this</span>.first = first; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T second)</span> &#123; <span class="built_in">this</span>.second = second; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateInterval</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DateInterval</span><span class="params">(LocalDate first, LocalDate second)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(second.compareTo(getFirst()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.setSecond(second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DateInterval 类描述一个日期区间，我们覆盖了 Pair 类的 <code>setSecond</code> 方法来确保第二个值不小于第一个值。</p>
<p>类型擦除后变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span> &#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span> &#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(Object first)</span> &#123; <span class="built_in">this</span>.first = first; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span> &#123; <span class="built_in">this</span>.second = second; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateInterval</span> <span class="keyword">extends</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DateInterval</span><span class="params">(LocalDate first, LocalDate second)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(second.compareTo((LocalDate)getFirst()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.setSecond(second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，我们发现 DateInterval 类中 <code>setSecond</code> 方法的签名为 <code>setSecond(LocalDate second)</code>，而 Pair 类中的签名为 <code>setSecond(Object second)</code>，不构成覆盖方法。</p>
<p>但是，考虑以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInterval</span>(...);</span><br><span class="line">pair.setSecond(...);</span><br></pre></td></tr></table></figure>
<p>setSecond 的调用应该具有多态性，<code>pair.setSecond</code> 应该调用 DateInterval 的 <code>setSecond</code> 方法。但是，类型擦除与多态产生了冲突，实际上会调用 Pair 的 <code>setSecond</code> 方法。 为了解决这个问题，编译器在 DateInterval 类中生成了一个桥方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span> &#123; setSecond((LocalDate) second);&#125;</span><br></pre></td></tr></table></figure>
<p>这时，桥方法覆盖了 Pair 类中的 <code>setSecond</code> 方法，并且会调用 DateInterval 的 <code>setSecond(LocalDate)</code> 方法，保证了 Java 的多态。我们对 DateInterval 类文件进行反编译，进行验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.company.DateInterval <span class="keyword">extends</span> <span class="title class_">com</span>.company.Pair&lt;java.time.LocalDate&gt; &#123;</span><br><span class="line">  com.company.DateInterval();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(java.time.LocalDate)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，确实多出了一个 <code>setSecond(Object)</code> 方法。</p>
<h3 id="5-泛型的限制">5. 泛型的限制</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html">Restrictions on Generics</a>（<em>TODO</em>）</p>
<h3 id="6-泛型类型的继承规则">6. 泛型类型的继承规则</h3>
<p><strong>继承规则：无论 S 与 T 有什么关系，通常 Pair&lt;S&gt; 与 Pair&lt;T&gt; 都没有任何关系。</strong></p>
<p><img src="/img/Java.assets/1665996674774.png" alt=""></p>
<p>如上所示，Manager 是 Employee 的子类，但是 ArrayList&lt;Manager&gt; 和 ArrayList&lt;Employee&gt; 没有任何关系。</p>
<h3 id="7-通配符的限定">7. 通配符的限定</h3>
<h4 id="7-1-子类限定">7.1 子类限定</h4>
<p>子类限定 &lt;? extends Type&gt;，表示将泛型对象的类型参数限制为 Type 类型或其子类型。类型参数为子类限定的泛型对象引用，可以读取，但不能写入。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Manager&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(m1, m2);</span><br><span class="line">Pair&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; p2 = p1;</span><br></pre></td></tr></table></figure>
<p>对象变量 <code>p2</code> 引用的对象的类型为 Pair&lt;Manager&gt;，但是 <code>p2</code> 本身被声明为 Pair&lt;? extends Employee&gt; 类型。从 <code>p2</code> 角度看，我们只知道 <code>p2</code> 引用的 Pair 类型的对象存储的是 Employee 类或其子类的对象，可以读取这个对象并向上转型为 Employee 类型；但是不能进行写入，因为不知道子类的具体类型。</p>
<h4 id="7-2-超类限定">7.2 超类限定</h4>
<p>超类限定 &lt;? super Type&gt;，表示将泛型对象的类型参数限制为 Type 类型或其超类型。类型参数为超类限定的泛型对象引用，可以写入，但只能读取为 Object。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(e1, e2);</span><br><span class="line">Pair&lt;? <span class="built_in">super</span> Manager&gt; p2 = p1;</span><br></pre></td></tr></table></figure>
<p>对象变量 <code>p2</code> 引用的对象的类型为 Pair&lt;Manager&gt;，但是 <code>p2</code> 本身被声明为 Pair&lt;? super Manager&gt; 类型。从 <code>p2</code> 角度看，我们只知道 <code>p2</code> 引用的 Pair 类型的对象存储的是 Manager 类或其超类的对象，可以写入 Manager 类型或其子类的对象，它会自动向上转型为特定的超类类型；但是因为不知道读取到的超类的具体类型，只能将读取结果赋值为 Object。</p>
<h4 id="7-3-无限定">7.3 无限定</h4>
<p>无限定 &lt;?&gt;，表示不限定泛型对象的类型参数。类型参数为无限定的泛型对象引用，只能读取为 Object，不能写入除 null 以外的值。PECS（Producer Extends, Consumer Super）原则，即读取数据使用子类限定，写入数据使用超类限定。</p>
<h3 id="8-自限定的类型">8. 自限定的类型</h3>
<p>在 Java 泛型中，有一种经常出现的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfBound</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;T&gt;&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>我们称这种类型为自限定的类型，selfBound 接收类型参数 T，而 T 限定为 selfBound&lt;T&gt; 的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;A&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;A&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;B&gt; &#123;...&#125; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，A 继承 selfBound&lt;A&gt; ，使得 A 可以作为 selfBound 的类型参数；而 B 没有继承 selfBound&lt;B&gt;，所以不能将 B 作为 selfBound 的类型参数。</p>
<p>自限定类型的主要使用方式为 <code>class A extends SelfBound&lt;A&gt; &#123;...&#125;</code>，它的目的是保证 SelfBound 类的类型参数为当前定义的类。你可能会说，B 继承的 SelfBound 类的类型参数是 A 而不是当前定义的 B 类，但是一般情况下并不会这样使用。</p>
<p>如果看不懂，可以考虑没有自限定类型的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfBound</span>&lt;T&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;Any-Type&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>如果 selfBound 没有自限定，A 类在继承 selfBound 时，类型参数可以是任意类型。</p>
<h2 id="反射">反射</h2>
<h3 id="1-获取-Class-对象">1. 获取 Class 对象</h3>
<p>一个 Class 对象可以表示一个类型，可能是类类型（包括数组类型）、接口类型，或者是基本数据类型和 void。</p>
<p>① 使用 Object 类中的 <code>getClass</code> 方法获取对应的 Class 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; cl = e.getClass();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cl.getName();</span><br><span class="line">        System.out.println(name); <span class="comment">// com.company.Manager</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，因为 e 引用的对象的类型是 Manager ，所以获取的 Class 对象保存了 Manager 类的信息。我们使用 <code>getName</code> 输出 cl 保存的类型名称，得到 com.company.Manager。</p>
<p>需要注意，虚拟机为每一个类型管理一个唯一的 Class 对象，我们可以利用 <code>==</code> 运算符实现两个 Class 对象的比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        System.out.println(m1.getClass() == m2.getClass()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② 使用静态方法 <code>forName</code> 获得类名对应的 Class 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cl = Class.forName(<span class="string">&quot;com.company.Manager&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们需要传入一个类名或接口名的完全限定名，否则将抛出一个检查型异常。</p>
<p>③ 如果 T 是任意的 Java 类型或 void 关键字，<code>T.class</code> 将代表对应的 Class 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; cl1 = Integer.class;</span><br><span class="line">Class&lt;Integer&gt; cl2 = <span class="type">int</span>.class;</span><br><span class="line">Class&lt;Void&gt; cl3 = <span class="keyword">void</span>.class;</span><br></pre></td></tr></table></figure>
<p>如上所示，它们对应的类型名分别是 java.lang.Integer、int 和 void。</p>
<p>需要注意的是，使用 <code>.class</code> 获取 Class 对象的引用时，不会自动初始化该 Class 对象表示的类，而前两个方法会进行初始化。类加载的步骤：加载、链接和初始化。</p>
<p>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Init1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Initializing Init1&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Initializing Init2&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">&quot;Initializing Init3&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Init1</span> <span class="variable">init1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Init1</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Init1</span>&gt; cl1 = init1.getClass();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cl2 = Class.forName(<span class="string">&quot;com.company.Init2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;Init3&gt; cl3 = Init3.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Initializing Init1</span><br><span class="line">Initializing Init2</span><br></pre></td></tr></table></figure>
<p>可以发现，输出结果中并没有 Initializing Init3，说明 Init3 类并没有初始化。</p>
<h3 id="2-利用反射分析类">2. 利用反射分析类</h3>
<p>主要使用 java.lang.reflect 包下的 Field、Method、Constructor 和 Modifier 类。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cl = Class.forName(<span class="string">&quot;com.company.Employee&quot;</span>);</span><br><span class="line">        <span class="comment">// Field</span></span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f : fields) &#123;</span><br><span class="line">            System.out.println(f.getType().getName() + <span class="string">&quot; &quot;</span> + f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = cl.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor&lt;?&gt; c : constructors) &#123;</span><br><span class="line">            Class&lt;?&gt;[] types = c.getParameterTypes();</span><br><span class="line">            System.out.println(c.getName() + <span class="string">&quot; &quot;</span> + Arrays.toString(types));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Method</span></span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : methods) &#123;</span><br><span class="line">            Class&lt;?&gt;[] types = m.getParameterTypes();</span><br><span class="line">            System.out.println(m.getReturnType().getName() + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                               m.getName() + <span class="string">&quot; &quot;</span> + Arrays.toString(types));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Modifier</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> fields[<span class="number">0</span>].getModifiers();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">aPrivate</span> <span class="operator">=</span> Modifier.isPrivate(modifiers);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">aStatic</span> <span class="operator">=</span> Modifier.isStatic(modifiers);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">aFinal</span> <span class="operator">=</span> Modifier.isFinal(modifiers);</span><br><span class="line">        System.out.println(aPrivate + <span class="string">&quot; &quot;</span> + aStatic + <span class="string">&quot; &quot;</span> + aFinal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String name</span><br><span class="line"><span class="type">double</span> salary</span><br><span class="line">com.company.Employee []</span><br><span class="line">com.company.Employee [<span class="keyword">class</span> <span class="title class_">java</span>.lang.String, <span class="type">double</span>]</span><br><span class="line"><span class="keyword">void</span> foo [<span class="keyword">class</span> <span class="title class_">java</span>.lang.String]</span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-利用反射分析对象">3. 利用反射分析对象</h3>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">1800.0</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; cl = e.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f1</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line">        <span class="comment">// 将private字段设置为可访问</span></span><br><span class="line">        f1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取对象e的字段值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) f1.get(e);</span><br><span class="line">        <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> (<span class="type">double</span>) f2.get(e);</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>setAccessible</code> 方法是 AccessibleObject 类中的一个方法，它是 Field、Method 和 Constructor 类的公共超类。</p>
<h3 id="4-利用反射动态创建泛型数组">4. 利用反射动态创建泛型数组</h3>
<p>java.lang.reflect 包中的 Array 类允许动态地创建数组，Arrays 类中的 <code>copyOf</code> 方法就使用了这个类，我们分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝数组，并指定长度，可能截断或者用null填充</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 如果是原数组是Object数组，则创建Object数组</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>copyOf</code> 方法先使用了 Class 类的 <code>getComponentType</code> 方法获取数组的元素类型，然后使用 Array 类的 <code>newInstance</code> 方法创建数组。</p>
<h3 id="5-利用反射调用方法和构造器">5. 利用反射调用方法和构造器</h3>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">1800</span>);</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; cl = e1.getClass();</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;foo&quot;</span>, String.class);</span><br><span class="line">        foo.invoke(e1, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用构造器</span></span><br><span class="line">        Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt; constructor = cl.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;李四&quot;</span>, <span class="number">20000.0</span>);</span><br><span class="line">        e2.foo(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解">注解</h2>
<p><strong>注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。</strong></p>
<h3 id="1-注解的语法">1. 注解的语法</h3>
<h4 id="1-1-定义注解">1.1 定义注解</h4>
<p>注解是由<strong>注解接口</strong>定义的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modifiers <span class="meta">@interface</span> AnnotationName &#123;</span><br><span class="line">    elementDeclaration1</span><br><span class="line">    elementDeclaration2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比常规接口的定义，interface 之前需要加上 @ 符号，可以在注解接口中声明元素，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">elementName</span><span class="params">()</span>;</span><br><span class="line">type <span class="title function_">elementName</span><span class="params">()</span> <span class="keyword">default</span> value;</span><br></pre></td></tr></table></figure>
<p>声明元素需要在元素名之后加上 ()，可以使用 default 关键字为元素指定默认值。</p>
<p>注解元素的类型限制：基本数据类型、String、Class、枚举类型、注解类型，以及由这些类型组成的一维数组。</p>
<p>所有的注解接口都隐式的继承自 java.lang.annotation.Annotation 接口，这是一个常规接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们验证一下注解接口是否继承自 Annotation 接口，示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Demo &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">str</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译 Demo.class 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">com</span>.company.Demo <span class="keyword">extends</span> <span class="title class_">java</span>.lang.annotation.Annotation &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">num</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String <span class="title function_">str</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Demo 注解接口确实扩展自 Annotation 接口，并且发现其中的元素实际上是接口中的抽象方法。注解接口的元素与常规接口的方法唯一的区别是可以使用 default 指定默认返回值。</p>
<h4 id="1-2-使用注解">1.2 使用注解</h4>
<p>注解的使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationName(elementName1 = value1, elementName2 = value2, ...)</span></span><br></pre></td></tr></table></figure>
<p>在注解接口中，如果没有为元素指定默认值，则在注解中需要显示的赋值；否则，可以不显示赋值，自动使用默认值。</p>
<p>特殊的注解形式：</p>
<ul>
<li>标记注解：如果注解接口没有任何元素或者所有元素都提供了默认值，则在使用注解时可以不需要括号。</li>
<li>单值注解：如果注解接口只有一个名为 <code>value</code> 的元素，则在指定该元素的值时，可以忽略元素名以及等号。</li>
</ul>
<p>注解元素的值必须是编译期常量，并且不能设置为 null。如果元素值是一个数组，那么要将它的值用 {} 括起来。</p>
<h3 id="2-Java-中的注解">2. Java 中的注解</h3>
<h4 id="2-1-元注解">2.1 元注解</h4>
<h5 id="2-1-1-Target">2.1.1 @Target</h5>
<p>指定注解适用的上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    <span class="comment">/** 类、接口(包括注解接口)、枚举声明 */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 字段声明（包括enum常量） */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 方法声明 */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 参数声明 */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造器声明 */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 局部变量声明 */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注解接口声明 */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 包声明 */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型参数声明</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个类型的使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-2-Retention">2.1.2 @Retention</h5>
<p>指示注解保留的时长，默认的保留策略为 <code>CLASS</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将被编译器丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将由编译器记录在类文件中，但会被VM丢弃（默认）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解将在运行时由VM保留，可以通过反射机制读取注解信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-3-Documented">2.1.3 @Documented</h5>
<p>指示将注解包含在 Javadoc 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-4-Inherited">2.1.4 @Inherited</h5>
<p>允许子类继承父类中的注解，当被修饰的注解作用于类时，该元注解才有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1-5-repeatable">2.1.5 @repeatable</h5>
<p>指示注解可以在同一上下文重复使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-标准注解">2.2 标准注解</h4>
<h5 id="2-2-1-Overried">2.2.1 @Overried</h5>
<p>指示当前方法将覆盖超类中的方法或实现接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-2-Deprecated">2.2.2 @Deprecated</h5>
<p>指示目标被弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-3-SuppressWarnings">2.2.3 @SuppressWarnings</h5>
<p>抑制目标中给定类型的编译器警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-SafeVarargs">2.2.4 @SafeVarargs</h5>
<p>指示将会安全的操作可变参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SafeVarargs &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-5-FunctionalInterface">2.2.5 @FunctionalInterface</h5>
<p>指示接口为函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-注解的继承">3. 注解的继承</h3>
<ul>
<li>字段和方法上的注解只要没有被覆盖，就会被继承（前提是字段和方法会被继承）。</li>
<li>接口上的注解永远都不会被继承，类上的注解只有在使用 @Inherited 时才会被继承。</li>
</ul>
<h3 id="4-利用反射处理注解">4. 利用反射处理注解</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Demo &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Demo(&quot;Hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Demo(&quot;World&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        Class&lt;Main&gt; cl = Main.class;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> cl.getAnnotation(Demo.class);</span><br><span class="line">        System.out.println(demo.value());</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cl.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">        demo = method.getAnnotation(Demo.class);</span><br><span class="line">        System.out.println(demo.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式">正则表达式</h2>
<h3 id="1-匹配字符串">1. 匹配字符串</h3>
<p>要求字符串全部匹配时，使用 <code>matcher.matches()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 将给定的正则表达式编译为模式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([1-9]|1[0-2]):([0-5][0-9]))[ap]m&quot;</span></span><br><span class="line">                , Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="comment">// 创建一个将根据此模式匹配给定输入的匹配器</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;11:59AM&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否全部匹配</span></span><br><span class="line">        <span class="keyword">if</span>(matcher.matches()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个匹配字符的偏移量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> matcher.start();</span><br><span class="line">            <span class="comment">// 获取最后一个匹配字符之后的偏移量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> matcher.end();</span><br><span class="line">            System.out.println(start + <span class="string">&quot; &quot;</span> + end);</span><br><span class="line">            <span class="comment">// 返回捕获的群组数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> matcher.groupCount();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">                <span class="comment">// 输出捕获的群组</span></span><br><span class="line">                System.out.print(matcher.group(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">11</span>:59AM <span class="number">11</span>:<span class="number">59</span> <span class="number">11</span> <span class="number">59</span> </span><br></pre></td></tr></table></figure>
<p>获取匹配的子字符串时，使用 <code>matcher.find()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 将给定的正则表达式编译为模式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(([1-9]|1[0-2]):([0-5][0-9]))[ap]m&quot;</span></span><br><span class="line">                , Pattern.CASE_INSENSITIVE);</span><br><span class="line">        <span class="comment">// 创建一个将根据此模式匹配给定输入的匹配器</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;--11:59am--5:30PM--&quot;</span>);</span><br><span class="line">        <span class="comment">// 查找部分匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个匹配字符的偏移量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> matcher.start();</span><br><span class="line">            <span class="comment">// 获取最后一个匹配字符之后的偏移量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> matcher.end();</span><br><span class="line">            System.out.print(start + <span class="string">&quot; &quot;</span> + end + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 输出匹配的字符串</span></span><br><span class="line">            System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">9</span> <span class="number">11</span>:59am</span><br><span class="line"><span class="number">11</span> <span class="number">17</span> <span class="number">5</span>:30PM</span><br></pre></td></tr></table></figure>
<h3 id="2-分割字符串">2. 分割字符串</h3>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1, 2,  3 ,4 , 5&quot;</span>;</span><br><span class="line">        String[] split = str.split(<span class="string">&quot;\\s*,\\s*&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(split));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3-替换字符串">3. 替换字符串</h3>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;[0-9]+&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;192.168.167.14&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#.#.#.#</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-14T07:56:20.438Z" title="2024/5/14 下午3:56:20">2024-05-14</time>发表</span><span class="level-item"><time dateTime="2024-05-14T08:05:34.472Z" title="2024/5/14 下午4:05:34">2024-05-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">3 分钟读完 (大约486个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/14/%E7%AC%AC%20130%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B%EF%BC%88VP%EF%BC%89/">第 130 场力扣夜喵双周赛（VP）</a></p><div class="content"><h2 id="正方形中的最多点数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-points-inside-the-square/">正方形中的最多点数</a></h2>
<h3 id="题目">题目</h3>
<p>输入长度为 \(n\) 的二维数组 \(points\) 和字符串 \(s\)，\(points[i]\) 表示第 \(i\) 个点的坐标，\(s[i]\) 表示第 \(i\) 个点的标签。如果以 \((0,0)\) 为中心且边平行于坐标轴的正方形内（包括边上的点，且边长可以为 \(0\)），不包含标签相同的两个点，则该正方形是合法的。输出合法正方形可以包含的最多点数。其中 \(points\) 中的点互不相同，\(s\) 只包含小写英文字母。</p>
<p>数据范围：\(1\leq n\leq 10^{5}\)，\(-10^{9}\leq points[i][0],points[i][1]\leq 10^{9}\)。</p>
<h3 id="思路">思路</h3>
<p>首先可以想到，正方形的边长越长，包含的点就越多，越可能不合法。具有单调性，可以使用二分求解。在二分的过程中，判断正方形是否合法，如果合法则更新答案。时间复杂度为 \(O(n\log{U})\)，其中 \(U=\max_{i=0}^{n-1}(|x_{i}|,|y_{i}|)\)。更好的做法是观察到，如果正方形包含某个点 \((x,y)\)，则正方形的边长 \(len\) 必须满足 \(len\geq 2\times\max(|x|,|y|)\)。其中，\(\max(|x|,|y|)\) 是点 \((x,y)\) 到点 \((0,0)\) 的切比雪夫距离。实际上，我们只需要维护每种标签点的最小切比雪夫距离 \(min_{i}\)，以及除此之外所有点的最小切比雪夫距离 \(k\)。因为，如果正方形包含某个标签 \(i\)，必定是包含具有该标签的切比雪夫距离最小的那个点，而这个点需要满足 \(min_{i}&lt;k\)。详情见代码，时间复杂度为 \(O(n)\)。优化思路参考<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-points-inside-the-square/solutions/2775310/er-fen-bian-chang-tong-shi-ji-lu-da-an-z-92w5/">灵神题解</a>。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPointsInsideSquare</span><span class="params">(<span class="type">int</span>[][] points, String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(min, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> Math.max(Math.abs(x), Math.abs(y));</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (z &lt; min[c]) &#123;</span><br><span class="line">                k = Math.min(k, min[c]);</span><br><span class="line">                min[c] = z;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = Math.min(k, z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : min) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分割字符频率相等的最少子字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/">分割字符频率相等的最少子字符串</a></h2>
<h3 id="题目-2">题目</h3>
<p>输入长度为 \(n\) 的字符串 \(s\)（只包含小写英文字母），输出 \(s\) 最少能被分割为多少个平衡子字符串。平衡字符串就是字符串中不同字符出现频次都相同的字符串。</p>
<p>数据范围：\(1\leq n\leq 1000\)。</p>
<h3 id="思路-2">思路</h3>
<p>定义 \(dp[i+1]\) 表示字符串 \([0,i]\) 最少能被分割的平衡子字符串数目，则转移方程为 \(dp[i+1]=\min(dp[j]+1)\)，其中 \(0\leq j\leq i\) 且字符串 \([j,i]\) 必须是平衡字符串。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSubstringsInPartition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                k += cnt[s.charAt(j) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                max = Math.max(max, ++cnt[s.charAt(j) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * max) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数组元素的乘积"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-products-of-elements-of-big-array/">大数组元素的乘积</a></h2>
<p>不会。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-13T11:03:22.872Z" title="2024/5/13 下午7:03:22">2024-05-13</time>发表</span><span class="level-item"><time dateTime="2024-05-13T11:20:12.867Z" title="2024/5/13 下午7:20:12">2024-05-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">6 分钟读完 (大约857个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/13/%E7%AC%AC%20397%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 397 场力扣周赛</a></p><div class="content"><h2 id="矩阵中的最大得分"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid/">矩阵中的最大得分</a></h2>
<h3 id="题目">题目</h3>
<p>输入一个 \(m\times n\) 的矩阵 \(grid\)，输出选择任意单元格作为起点，至少移动一次能够得到的最大得分。每次移动只能向正右方和正下方的单元格移动，不必相邻。假设从单元格 \((x_{1},y_{1})\) 移动到 \((x_{2},y_{2})\)，则本次移动的得分为 \(grid[x_{2}][y_{2}]-grid[x_{1}][y_{1}]\)。</p>
<p>数据范围：\(2\leq m,n\leq 1000\)，\(4\leq m\times n\leq 10^{5}\)，\(1\leq grid[i][j]\le 10^{5}\)。</p>
<h3 id="思路">思路</h3>
<p>比赛时想到计算过程存在重叠子问题，可以使用记忆化搜索。定义 \(f[i][j]\) 表示以 \((i,j)\) 为起点能够得到的最大得分，初始化 \(f[i][j]\) 为负无穷。当 \(i&lt;m-1\) 且 \(j&lt;n-1\) 时，状态转移方程为 \(f[i][j]=\max{(f[i+1][j]+grid[i+1][j]-grid[i][j],f[i][j+1])+grid[i][j+1]-grid[i][j]}\)。也可以将记忆化搜索转化为自底向上的形式，或者定义 \(f[i][j]\) 表示以 \((i,j)\) 为终点能够得到的最大得分。</p>
<p>通过观察可以发现，对于某个移动路径，得分只和起点和终点有关，中间的值都被抵消了。也就是说，某个起点能够得到的最大得分，是其右下角的最大值减去起点的值，反之亦然。所以也可以定义 \(f[i][j]\) 表示 \((i,j)\) 右下角的最大值或者左上角的最小值，然后进行递推。</p>
<p>时间复杂度为 \(O(mn)\)，空间复杂度为 \(O(mn)\)。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid/solutions/2774823/nao-jin-ji-zhuan-wan-dppythonjavacgo-by-swux7/">灵神题解</a>有个空间复杂度为 \(O(n)\) 的做法，思路是维护每列的最小值。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.size(), n = grid.get(<span class="number">0</span>).size();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, grid, dp);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans = Math.max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, List&lt;List&lt;Integer&gt;&gt; grid, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.size(), n = grid.get(<span class="number">0</span>).size();</span><br><span class="line">        <span class="keyword">if</span> (dp[x][y] == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> grid.get(x + <span class="number">1</span>).get(y) - grid.get(x).get(y);</span><br><span class="line">                dp[x][y] = Math.max(dp[x][y], diff + dfs(x + <span class="number">1</span>, y, grid, dp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> grid.get(x).get(y + <span class="number">1</span>) - grid.get(x).get(y);</span><br><span class="line">                dp[x][y] = Math.max(dp[x][y], diff + dfs(x, y + <span class="number">1</span>, grid, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, dp[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找出分数最低的排列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/">找出分数最低的排列</a></h2>
<h3 id="题目-2">题目</h3>
<p>输入从 \(0\) 到 \(n-1\) 的一个排列 \(nums\)，输出从 \(0\) 到 \(n-1\) 的排列 \(perm\)，使得 \(score(perm)=\sum_{i=0}^{n-1}{|perm[i]-nums[perm[(i+1)\bmod n|}\) 的值最小。如果有多个满足条件的排列，则返回字典序最小的那个。</p>
<p>数据范围：\(2\leq n\leq 14\)。</p>
<h3 id="思路-2">思路</h3>
<p>通过观察可以发现，对于一个给定的排列 \(perm\)，将其循环移动不会改变 \(score(perm)\) 的值。要使满足条件的 \(perm\) 字典序最小，那么必然有 \(perm[0]=0\)。暴力的想法是枚举所有排列，但是时间复杂度为 \(n!\times n\)。由于枚举过程中，存在重复子问题，可以使用记忆化搜索来降低时间复杂度到 \(O(2^{n}n^{2})\)。定义 \(f[mask][pre]\) 表示已经选择集合 \(mask\) 中的数，上一个选择的数是 \(pre\)，剩余的数排列能够得到的最小分数。同理，定义 \(g[mask][pre]\) 表示下一个选择什么数能够使得分数最小，以及相同分数的排列字典序最小。可以看下<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/solutions/2775272/zhuang-ya-dpcong-ji-yi-hua-sou-suo-dao-d-s9t5/">灵神题解</a>，不使用记忆化搜索，自底向上的解法也是非常经典的。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findPermutation(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n][n];</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(f[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] = Math.abs(i - nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>, nums, f, g);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, mask = <span class="number">0</span>, cur = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = cur;</span><br><span class="line">            mask |= <span class="number">1</span> &lt;&lt; cur;</span><br><span class="line">            cur = g[mask][cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> mask, <span class="type">int</span> pre, <span class="type">int</span>[] nums, <span class="type">int</span>[][] f, <span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (mask == (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> || f[mask][pre] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[mask][pre];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mask &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dfs(mask | <span class="number">1</span> &lt;&lt; i, i, nums, f, g) + Math.abs(pre - nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (cur &lt; res) &#123;</span><br><span class="line">                    res = cur;</span><br><span class="line">                    g[mask][pre] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[mask][pre] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-13T11:02:05.914Z" title="2024/5/13 下午7:02:05">2024-05-13</time>发表</span><span class="level-item"><time dateTime="2024-05-13T11:03:06.563Z" title="2024/5/13 下午7:03:06">2024-05-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/">AtCoder</a></span><span class="level-item">1 分钟读完 (大约119个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/13/AtCoder%20Beginner%20Contest%20350/">AtCoder Beginner Contest 350</a></p><div class="content"><h2 id="Sort"><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc350/tasks/abc350_c">Sort</a></h2>
<h3 id="题目">题目</h3>
<p>输入长度为 \(n\) 的数组 \(a\)，表示从 \(1\) 到 \(n\) 的排列。输出操作的次数和过程，使得排列有序。每次操作可以交换 \(a_{i}\) 和 \(a_{j}\)，其中 \(1\leq i&lt;j\leq n\)。</p>
<p>数据范围：\(2\leq n\leq 2\times 10^{5}\)。</p>
<h3 id="思路">思路</h3>
<p>如果 \(a_{i}=i\)，则说明 \(a_{i}\) 在正确的位置上。否则，\(a_{i}\) 应该移动到位置 \(a_{i}\) 上，即交换下标 \(i\) 和 \(a_{i}\) 的值。这样每次交换都至少使得一个数在正确的位置上，最多交换 \(n-1\) 次，时间复杂度为 \(O(n)\)。PS：太久没做题，竟然没有做出来。比赛时多此一举，使用的是下标数组 + 排序做的，其实也没问题，就是最后没有按照大小顺序输出。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = io.nextInt() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] != i) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Math.min(i, a[i]), Math.max(i, a[i])&#125;);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[a[i]]; a[a[i]] = a[i]; a[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.println(ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> t : ans) &#123;</span><br><span class="line">        io.println((t[<span class="number">0</span>] + <span class="number">1</span>) + <span class="string">&quot; &quot;</span> + (t[<span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-13T10:59:29.137Z" title="2024/5/13 下午6:59:29">2024-05-13</time>发表</span><span class="level-item"><time dateTime="2024-05-13T11:09:22.984Z" title="2024/5/13 下午7:09:22">2024-05-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">6 分钟读完 (大约934个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/05/13/%E7%AC%AC%20394%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 394 场力扣周赛</a></p><div class="content"><h2 id="使矩阵满足条件的最少操作次数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-operations-to-satisfy-conditions/">使矩阵满足条件的最少操作次数</a></h2>
<h3 id="题目">题目</h3>
<p>输入 \(m\times n\) 的矩阵 \(grid\)，输出需要的最少操作次数，使得每列的值相等，且相邻两列的值不相等。每次操作可以将任意单元格的值修改为任意非负整数。</p>
<p>数据范围：\(1\leq n,m\leq 1000\)，\(0\leq grid[i][j]\leq 9\)。</p>
<h3 id="思路">思路</h3>
<p>首先，每列的值肯定是修改为 \([0,9]\) 之间更优，因为操作次数可能更少。我们可以从前往后枚举每列修改为什么值，可以发现存在重叠子问题。定义 \(dp[i][j]\) 表示将第 \(i\) 列修改为 \(j\)，使得 \([0,i]\) 列满足条件所需的最少操作次数。有状态转移方程 \(dp[i][j]=\min{(dp[i-1][k])}+cnt_{i,j}\)，其中 \(0\leq k\leq 9\) 且 \(k\neq j\)，\(cnt_{i,j}\) 表示将第 \(i\) 列修改为 \(j\) 所需的操作次数。时间复杂度为 \(O(mn+nU^{2})\)，空间复杂度为 \(O(nU)\)，其中 \(U\) 表示 \(grid[i][j]\) 的值域大小。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-operations-to-satisfy-conditions/solutions/2749283/ji-yi-hua-sou-suo-pythonjavacgo-by-endle-8i0e/">灵神题解</a>提到一个优化方式，状态转移只会从前面所有列操作的最优值或者次优值转移过来，利用这个特性可以降低时间和空间复杂度。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                cnt[j][grid[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k != j) &#123;</span><br><span class="line">                        dp[i + <span class="number">1</span>][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][k] + (m - cnt[i][j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ans = Math.min(ans, dp[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径中的边"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-edges-in-shortest-paths/">最短路径中的边</a></h2>
<h3 id="题目-2">题目</h3>
<p>输入整数 \(n\) 和长度为 \(m\) 的数组 \(edges\)，表示包含 \(n\) 个节点和 \(m\) 条边的无向带权图（无重边和自环）。输出长度为 \(m\) 的布尔数组 \(ans\)，如果从节点 \(0\) 到节点 \(n-1\) 的所有最短路中包含 \(edges[i]\)，则 \(ans[i]=true\)。</p>
<p>数据范围：\(2\leq n\leq 5\times 10^{4}\)，\(1\leq m\leq\min{(5\times 10^{4},\frac{n(n-1)}{2})}\)，\(1\leq w_{i}\leq 10^{5}\)。</p>
<h3 id="思路-2">思路</h3>
<p>首先使用 Dijkstra 算法求出从节点 \(0\) 到所有其他节点的最短路，然后暴力的想法是以节点 \(0\) 为起点使用 DFS 回溯来遍历图，遍历的同时存储路径上的边，当到达节点 \(n-1\) 的路径长度等于最短路时，则将该路径上的边都置为 \(true\)。回溯理论上最坏情况下的时间复杂度为 \(O(n\times n!)\)，但是可以通过力扣的测试，因为可以利用最短路的限制进行剪枝，至于能否构造出 Hack 回溯的测试用例，我不太清楚。</p>
<p>正确的解法是使用两次 Dijkstra 算法，分别求出从节点 \(0\) 到所有其他节点的最短路，和从节点 \(n-1\) 到所有其他节点的最短路。然后枚举每一条边，判断路径长度 \(d_{0,u}+w_{u,v}+d_{v,n-1}\) 或者 \(d_{0,v}+w_{u,v}+d_{u,n-1}\) 是否等于最短路，从而可以得出该边是否在某个最短路中。</p>
<p>另一种做法是只对起点使用一次 Dijkstra 算法，然后从终点反向 DFS，经过的边如果满足 \(d_{0,v}+w_{u,v}=d_{0,u}\)，则说明该边在某个最短路上。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-10T11:14:50.503Z" title="2024/3/10 下午7:14:50">2024-03-10</time>发表</span><span class="level-item"><time dateTime="2024-03-10T11:16:45.497Z" title="2024/3/10 下午7:16:45">2024-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></span><span class="level-item">3 分钟读完 (大约472个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/10/%E7%AC%AC%20388%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 388 场力扣周赛</a></p><div class="content"><h2 id="K-个不相交子数组的最大能量值"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/">K 个不相交子数组的最大能量值</a></h2>
<h3 id="题目">题目</h3>
<p>输入长度为 \(n\) 的整数数组 \(nums\) 和正奇数 \(k\)，输出从数组中选择 \(k\) 个不相交的子数组，能够得到的最大得分。\(k\) 个子数组的得分为 \(\sum_{i=1}^{k}(-1)^{i+1}\times sum[i]\times (k-i+1)\)，其中 \(sum[i]\) 表示第 \(i\) 个子数组中元素之和。</p>
<p>数据范围：\(1\leq n\leq 10^{4}\)，\(-10^{9}\leq nums[i]\leq 10^{9}\)，\(1\leq k\leq n\)，\(1\leq n\times k\leq 10^{6}\)。</p>
<h3 id="思路">思路</h3>
<p>定义 \(dp[i][r]\) 表示从区间 \([0,r-1]\) 选择 \(i\) 个不相交子数组，能够得到的最大得分。对于元素 \(nums[r-1]\)，我们有选或者不选两种情况，状态转移方程如下：</p>
<div>
$$
dp[i][r]=\max(dp[i][r-1],\max_{l=i-1}^{r-1}(dp[i-1][l]+(sum[r]-sum[l])\times (-1)^{i+1}\times (k-i+1)))
$$
</div>
<p>初始时，对于所有 \(0\leq i\leq n\)，有 \(dp[0][i]=0\)，其他值初始化为负无穷。使用上述转移方程，时间复杂度为 \(O(kn^{2})\)。可以对其变形，将时间复杂度优化为 \(O(kn)\)，详细参见<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/solutions/2678061/qian-zhui-he-hua-fen-xing-dpshi-zi-bian-ap5z5/">灵神的题解</a>。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strength-of-k-disjoint-subarrays/solutions/2678091/xiao-yang-xiao-en-xian-duan-shang-de-zhu-ea5g/">小羊的题解</a>使用的是另一种做法，似乎更简洁，但是看不太懂啊。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumStrength</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[] sum = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[k + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Long.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> (<span class="number">2</span> * (i &amp; <span class="number">1</span>) - <span class="number">1</span>) * -<span class="number">1</span> * (k - i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i; r &lt; n - (k - i - <span class="number">1</span>); r++) &#123;</span><br><span class="line">                max = Math.max(max, dp[i][r] - sum[r] * w);</span><br><span class="line">                dp[i + <span class="number">1</span>][r + <span class="number">1</span>] = Math.max(dp[i + <span class="number">1</span>][r], sum[r + <span class="number">1</span>] * w + max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-10T11:13:00.612Z" title="2024/3/10 下午7:13:00">2024-03-10</time>发表</span><span class="level-item"><time dateTime="2024-03-10T11:14:26.473Z" title="2024/3/10 下午7:14:26">2024-03-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/">AtCoder</a></span><span class="level-item">2 分钟读完 (大约362个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/03/10/AtCoder%20Beginner%20Contest%20344/">AtCoder Beginner Contest 344</a></p><div class="content"><h2 id="String-Bags"><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc344/tasks/abc344_d">String Bags</a></h2>
<h3 id="题目">题目</h3>
<p>输入字符串 \(T\) 和整数 \(N\)，表示有 \(N\) 个袋子。然后对每个袋子，输入其包含的字符串个数 \(A_{i}\)，以及 \(A_{i}\) 个字符串 \(S_{i,1},S_{i,2},\dots,S_{i,A_{i}}\)。对于每个袋子，我们只能从中选择一个字符串或者不选。输出选择袋子的最少个数，使得按照袋子的编号顺序拼接字符串，能够得到字符串 \(T\)。如果无法得到字符串 \(T\)，则输出 \(-1\)。</p>
<p>数据范围：\(1\leq \operatorname{len}(T)\leq 100\)，\(1\leq N\leq 100\)，\(1\leq A_{i}\leq 10\)，\(1\leq \operatorname{len}(S_{i,j})\leq 10\)。</p>
<h3 id="思路">思路</h3>
<p>定义 \(dp[i][j]\) 表示从袋子 \([1,i]\) 中选择袋子的最少个数，使得拼接得到的字符串和 \(T\) 的前缀 \([1,j]\) 相同（下标从 \(1\) 开始）。初始状态和转移方程见代码，算是基本的动态规划，太久没做题加上原题表述有歧义，竟然没做出来。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> io.next();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, m + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> io.nextInt();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; z; j++) &#123;</span><br><span class="line">            set.add(io.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">10</span> &amp;&amp; k &lt;= j + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(t.substring(j - k + <span class="number">1</span>, j + <span class="number">1</span>))) &#123;</span><br><span class="line">                    dp[j + <span class="number">1</span>] = Math.min(dp[j + <span class="number">1</span>], dp[j + <span class="number">1</span> - k] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io.println(dp[m] == m + <span class="number">1</span> ? -<span class="number">1</span> : dp[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-02-28T05:01:59.396Z" title="2024/2/28 下午1:01:59">2024-02-28</time>发表</span><span class="level-item"><time dateTime="2024-02-28T05:09:33.609Z" title="2024/2/28 下午1:09:33">2024-02-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a><span> / </span><a class="link-muted" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/">DDIA</a></span><span class="level-item">17 分钟读完 (大约2564个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%91%E6%88%98/">分布式系统的挑战</a></p><div class="content"><h2 id="不可靠的网络">不可靠的网络</h2>
<p>网络分区故障，指网络的一部分由于网络故障而与其他部分断开，其实可以直接称为网络故障。作者推荐，可以通过故意触发网络问题，来测试系统的反应。</p>
<p>在分布式系统中，需要设置响应的超时时间，从而判断节点是否失效。如果时间设置得太长，则需要等待更长的时间。如果时间设置得太短，可能节点只是负载过高而响应缓慢，此时判断节点失效并将负载转移到其他节点会进一步增加系统负载，从而可能导致失效扩散（还可能会导致其他异常）。比较好的做法是，持续测量响应时间及其变化，然后根据测量结果自动调整超时时间。</p>
<p>从广义上讲，网络延迟的波动可以视为资源动态分配的结果。传统的电话网络（非 VoIP）使用电路交换技术，为每个通话分配一条固定带宽的通信链路，网络的延迟是确定的；而互联网使用分组交换技术，所有用户共享网络带宽，用户之间的数据存在排队的情况，该方法可以增加带宽的利用率，但是理论上的延迟是无限大的。</p>
<h2 id="不可靠的时钟">不可靠的时钟</h2>
<p>网络上的每台机器都有独立的时钟硬件设备，通常是石英晶体振荡器，用于维护机器的本地时间，该时间可能与其他机器上的时间不同。通常使用网络时间协议（Network Time Protocol，NTP）来同步机器之间的时间，该协议根据一组专门的时间服务器来调整本地时间（调整石英的振动频率），时间服务器则从精确度更高的时间源（例如 GPS 接收器）获取高精度时间。</p>
<h3 id="墙上时钟和单调时钟">墙上时钟和单调时钟</h3>
<p>现代计算机内部至少有两种时钟：墙上时钟和单调时钟。</p>
<p><strong>墙上时钟</strong></p>
<p>墙上时钟根据某个日期返回当前的日期与时间，例如 Linux 的 <code>clock_gettime(CLOCK_REALTIME)</code> 和 Java 的 <code>System.currentTimeMillis()</code> 会返回自 1970 年 1月 1 日（UTC）以来的秒数和毫秒数，不含润秒。有些系统则使用其他日期作为参考点。</p>
<p>墙上时钟需要使用 NTP 进行同步，但是存在很多问题。特别是，如果本地时钟远远快于 NTP 服务器，则同步之后会发生时间倒退的现象，以及墙上时钟经常忽略润秒，导致其不太适合用于测量时间间隔。</p>
<p><strong>单调时钟</strong></p>
<p>单调时钟不需要和 NTP 服务器时钟进行同步，适合测量时间间隔。例如 Linux 的 <code>clock_gettime(CLOCK_MONOTONIC)</code> 和 Java 中的 <code>System.nanoTime()</code> 返回的都是单调时钟。单调时钟的单个值没有任何意义，它可能是电脑启动后经过的纳秒数或者其他含义，不同节点上的单调时钟没有相同的基准，不能相互比较。</p>
<h3 id="时钟同步和准确性">时钟同步和准确性</h3>
<p>硬件时钟和 NTP 服务器可能会出现各种问题，例如：计算机中的石英钟存在漂移现象（运行速度会加快或减慢，取决于机器的温度）；如果本地时钟和 NTP 服务器时钟相差太大，应用程序可能会看到时间倒退或跳跃的现象；同步的准确性受限于网络延迟，以及 NTP 服务器是否正常工作；各种其他情况，包括下面提到的润秒。</p>
<p>润秒（Leap second）就是对协调世界时（Coordinated Universal Time，UTC）增加或减少 1 秒，以使协调世界时和世界时（UT，通常指 UT1）之间的差异不超过 0.9 秒。2022 年 11 月，国际计量大会决定在 2035 年之前取消润秒。润秒曾经使许多大型系统崩溃，根本原因是许多系统没有正确适配润秒，软件存在 BUG 从而引发各种问题。可以看下 <a target="_blank" rel="noopener" href="https://www.wired.com/2012/07/leap-second-glitch-explained/">The Inside Story of the Extra Second That Crashed the Web</a> 这篇文章，讲述了现实中发生过的问题。Google 处理润秒方式是，在一天内逐步调整时间，而不是在一天结束时直接改变 1 秒。PS：一个显示各个时钟目前时间的<a target="_blank" rel="noopener" href="http://leapsecond.com/java/gpsclock.htm">网站</a>。</p>
<p>如果投入大量资源，可以达到非常高的时钟精度，例如交易系统的时钟就要求很小的时钟误差。高精度的时钟可以使用 GPS 接收器，精确时间协议（PTP）并辅以细致的部署和监测来实现。</p>
<h3 id="依赖同步的时钟">依赖同步的时钟</h3>
<p>如果应用需要精确同步的时钟，最好仔细监控所有节点上的时钟偏差。如果某个节点的时钟漂移超出上限，则将其视为失效节点并从集群中移除。这样监控的目的是确保在造成重大影响（例如隐式的数据丢失）之前尽早发现并处理问题。</p>
<p><strong>时间戳和事件顺序</strong></p>
<p>在无主复制的检测并发写中提到过，最后写入者获胜（LWW）冲突解决策略由于时钟偏差，可能会覆盖非并发写入。</p>
<p><img src="/img/DDIA.assets/1704193039170.jpg" alt=""></p>
<p>在上述例子中，时钟同步机制稳定工作，节点 1 和节点 3 之间的时钟偏差小于 3ms，但是时间戳却不能正确排序事件，从而导致客户端 B 的增量操作被覆盖。解决方案就是之前提到过的，使用版本向量技术跟踪因果关系。PS：因果关系其实就是非并发写操作的前后关系，版本向量不仅可以跟踪因果关系，还可以判断写操作是否并发。</p>
<p><strong>时钟的置信区间</strong></p>
<p>或许墙上时钟会返回微秒甚至纳秒级别的信息，但是这种精度的测量值其实并不可信，因为存在石英漂移和网络延迟等不确定性因素。所以，我们不应该将时钟读数视为一个精确的时间点，而应该视为带有置信区间的时间范围。例如，系统可能有 95% 的置信度认为目前时间介于 10.3~10.5 秒之间。</p>
<p>可以根据具体的时间源来推算出时钟误差的上限。如果节点上直接装有 GPS 接收器或原子（铯）时钟，那它的误差范围通常可查询制造商的手册。如果节点是从服务器获取时间，则不确定性取决于上次同步以来的石英漂移范围，加上 NTP 服务器的不确定性，再加上节点和服务器之间的往返时间。</p>
<p>但是，大多数系统并不提供这种误差查询接口，通常只会返回某个确定的时间，而没有任何误差信息。Google Spanner 中的 TrueTime API 提供误差查询，它会返回时间的上下界。</p>
<p><strong>全局快照的同步时钟</strong></p>
<p>该节主要是讲如何在分布式场景下，生成全局单调递增的事务 ID，有点不明白这个标题是什么意思。如果是单节点数据库，使用一个计数器就可以实现正确的事务 ID。但是，如果是多节点数据库，则更加复杂并且开销更大。</p>
<p>Twitter 使用雪花（Snowflake）算法来生成近似单调递增的唯一 ID。如果节点之间的墙上时钟完全同步，则也可以将其作为事务 ID，但是实际上是不可能的。Google Spanner 使用 TrueTime API 返回的时钟置信区间作为事务 ID，如果两个置信区间没有重叠，则可以知道两个事务的先后顺序。</p>
<h3 id="进程暂停">进程暂停</h3>
<p>在使用主从复制的数据库中，只有主节点可以接受写入，如果主节点失效则需要将某个从节点提升为主节点。判断节点是否失效可以使用租约来实现：如果某个节点持有租约，那么它就是主节点；如果租约过期，则该节点失效。我们可以使用单调时钟来判断租约是否过期，但是可能由于垃圾收集、上下文切换或磁盘 I/O 等原因导致进程暂停，从而使得暂停之前判断租约没有过期，暂停之后发送请求时租约已经过期。</p>
<p><img src="/img/DDIA.assets/1709093091191.png" alt=""></p>
<p>上图是 HBase 曾经遇到的问题，不正确的分布式锁实现，导致未持有锁的客户端修改数据。解决方案是，锁服务为每个锁维护一个单调递增的 fencing 令牌（实际上就是版本号），在锁服务授予客户端租约和客户端向存储服务发送写请求时会包含该令牌，存储服务也会维护数据最后一次修改对应的令牌。如果存储服务收到的写请求包含旧令牌，则会拒绝该请求。如果使用 ZooKeeper 作为锁服务，则事务标识 zxid 或节点版本 cversion 可以充当 fencing 令牌。</p>
<p><img src="/img/DDIA.assets/1709093912140.png" alt=""></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/13/">13</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/dark_souls.jpg" alt="Ligh0x74"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Ligh0x74</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">122</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Ligh0x74" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Ligh0x74"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">ICARUS</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://waline.js.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Waline</span></span><span class="level-right"><span class="level-item tag">waline.js.org</span></span></a></li><li><a class="level is-mobile" href="https://vercel.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Vercel</span></span><span class="level-right"><span class="level-item tag">vercel.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/"><span class="level-start"><span class="level-item">书籍</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP/"><span class="level-start"><span class="level-item">CSAPP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B9%A6%E7%B1%8D/DDIA/"><span class="level-start"><span class="level-item">DDIA</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E6%A8%A1%E6%9D%BF/"><span class="level-start"><span class="level-item">模板</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase/"><span class="level-start"><span class="level-item">OceanBase</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">88</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/AtCoder/"><span class="level-start"><span class="level-item">AtCoder</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Codeforces/"><span class="level-start"><span class="level-item">Codeforces</span></span><span class="level-end"><span class="level-item tag">34</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/"><span class="level-start"><span class="level-item">课程</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/CMU-15-445/"><span class="level-start"><span class="level-item">CMU 15-445</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BE%E7%A8%8B/MIT-6-824/"><span class="level-start"><span class="level-item">MIT 6.824</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-08T09:08:52.308Z">2024-08-08</time></p><p class="title"><a href="/2024/08/08/CSAPP%20%E6%80%BB%E7%BB%93/">CSAPP 总结</a></p><p class="categories"><a href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a> / <a href="/categories/%E4%B9%A6%E7%B1%8D/CSAPP/">CSAPP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-05T13:35:47.814Z">2024-08-05</time></p><p class="title"><a href="/2024/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a> / <a href="/categories/%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-05T03:58:17.939Z">2024-08-05</time></p><p class="title"><a href="/2024/08/05/Java%20%E5%9F%BA%E7%A1%80/">Java 基础</a></p><p class="categories"><a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a> / <a href="/categories/%E8%AF%AD%E8%A8%80/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-14T07:56:20.438Z">2024-05-14</time></p><p class="title"><a href="/2024/05/14/%E7%AC%AC%20130%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%A4%9C%E5%96%B5%E5%8F%8C%E5%91%A8%E8%B5%9B%EF%BC%88VP%EF%BC%89/">第 130 场力扣夜喵双周赛（VP）</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-05-13T11:03:22.872Z">2024-05-13</time></p><p class="title"><a href="/2024/05/13/%E7%AC%AC%20397%20%E5%9C%BA%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/">第 397 场力扣周赛</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">95</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/I-O/"><span class="tag">I/O</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://clist.by/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CLIST</span></span><span class="level-right"><span class="level-item tag">clist.by</span></span></a></li><li><a class="level is-mobile" href="https://tech.meituan.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">美团技术团队</span></span><span class="level-right"><span class="level-item tag">tech.meituan.com</span></span></a></li><li><a class="level is-mobile" href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">阮一峰的网络日志</span></span><span class="level-right"><span class="level-item tag">www.ruanyifeng.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ligh0x74&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Ligh0x74</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>